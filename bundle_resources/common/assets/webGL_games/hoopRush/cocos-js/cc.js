System.register(['./instantiated-15eecf6d.js'], function (exports) {
  'use strict';
  var bits, Vec2, v2, Vec3, v3, Vec4, v4, Quat, quat, Mat3, Mat4, mat4, AffineTransform, Size, size, Rect, rect, Color, color, EPSILON$2, equals$1, approx, clamp$1, clamp01, lerp, toRadian, toDegree, random, randomRange, randomRangeInt, pseudoRandom, pseudoRandomRange, pseudoRandomRangeInt, nextPow2, repeat$1, pingPong, inverseLerp, absMaxComponent, absMax, enumerableProps, MATH_FLOAT_ARRAY, MathBase, Pool, RecyclePool, CachedArray, DescriptorSet, Buffer, CommandBuffer, ObjectType, Status, API, SurfaceTransform, Feature, Format, FormatType, Type$1, BufferUsageBit, BufferFlagBit, MemoryAccessBit, MemoryUsageBit, TextureType, TextureUsageBit, TextureFlagBit, FormatFeatureBit, SampleCount, VsyncMode, Filter, Address, ComparisonFunc, StencilOp, BlendFactor, BlendOp, ColorMask, ShaderStageFlagBit, LoadOp, StoreOp, AccessFlagBit, ResolveMode, PipelineBindPoint, PrimitiveMode, PolygonMode, ShadeModel, CullMode, DynamicStateFlagBit, StencilFace, DescriptorType, QueueType, QueryType, CommandBufferType, ClearFlagBit, BarrierType, PassType, Size$1, DeviceCaps, DeviceOptions, Offset, Rect$1, Extent, TextureSubresLayers, TextureSubresRange, TextureCopy, TextureBlit, BufferTextureCopy, Viewport, Color$1, BindingMappingInfo, SwapchainInfo, DeviceInfo, BufferInfo, BufferViewInfo, DrawInfo, DispatchInfo, IndirectBuffer, TextureInfo, TextureViewInfo, SamplerInfo, Uniform, UniformBlock, UniformSamplerTexture, UniformSampler, UniformTexture, UniformStorageImage, UniformStorageBuffer, UniformInputAttachment, ShaderStage, Attribute, ShaderInfo, InputAssemblerInfo, ColorAttachment, DepthStencilAttachment, SubpassInfo, SubpassDependency, RenderPassInfo, GeneralBarrierInfo, TextureBarrierInfo, BufferBarrierInfo, FramebufferInfo, DescriptorSetLayoutBinding, DescriptorSetLayoutInfo, DescriptorSetInfo, PipelineLayoutInfo, InputState, CommandBufferInfo, QueueInfo, QueryPoolInfo, FormatInfo, MemoryStatus, DynamicStencilStates, DynamicStates, GFXObject, AttributeName, FormatInfos, DESCRIPTOR_BUFFER_TYPE, DESCRIPTOR_SAMPLER_TYPE, DESCRIPTOR_DYNAMIC_TYPE, DRAW_INFO_SIZE, IsPowerOf2, FormatSize, FormatSurfaceSize, GetTypeSize, getTypedArrayConstructor, formatAlignment, alignTo, Device, Swapchain, Framebuffer, InputAssembler, DescriptorSetLayout, PipelineLayout, RasterizerState, DepthStencilState, BlendTarget, BlendState, PipelineStateInfo, PipelineState, Queue, RenderPass, Sampler, Shader, Texture, GeneralBarrier, TextureBarrier, LegacyRenderMode, RenderType, DeviceManager, deviceManager, distance, enums, intersect, Line$1, Plane, Ray, Triangle, Sphere, AABB, OBB, Capsule, Frustum, Keyframe, AnimationCurve, SplineMode, Spline, ERaycastMode, line, plane, ray, triangle, sphere, aabb, obb, capsule, frustum, CameraFOVAxis, CameraProjection, CameraAperture, CameraISO, CameraShutter, CameraType, TrackingType, SKYBOX_FLAG, Camera, ModelType, Model, SubModel, Ambient, EnvironmentLightingType, Skybox, ShadowSize, ShadowType, PCFType, CSMLevel, CSMOptimizationMode, Shadows, FogType, Fog, Octree, ColorTemperatureToRGB, LightType, nt2lm, Light$1, DirectionalLight$1, SphereLight$1, SpotLight$1, replaceProperty, legacyCC, Scheduler, System, removeProperty, Root, markAsWarning, game, Director, assetManager, extname, resources, assets, dependUtil, downloader, parser, _createClass, BuiltinBundleName, transform, changeExtname, AssetManager, getError, macro, director, releaseManager, parseLoadResArgs, Asset, factory, setDefaultProgressCallback, Cache, getUuidFromURL, bundles, dirname, basename, _inheritsLoose, supportsR32FloatTexture, _createForOfIteratorHelperLoose, SRGBToLinear, Material, PixelFormat, Texture2D, Filter$1, js, readBuffer, assertIsTrue, UBOMorph, assertIsNonNullable, ImageAsset, warn, nextPow2$1, log2, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, ccclass, RenderingSubMesh, warnID, _applyDecoratedDescriptor, _initializerDefineProperty, _assertThisInitialized, murmurhash2_32_gc, serializable, sys, writeBuffer, find, mapBuffer, errorID, createMap, getClassId, editable, override, string, type, mixin, Pool$1, assertID, disallowMultiple, executeInEditMode, NodeEventType, help, executionOrder, menu, displayOrder, tooltip, visibleRect, Component, ccenum, uiRendererManager, assert, builtinResMgr, Renderer, disallowAnimation, requireComponent, visible, displayName, TextureBase, multiline, debug, RenderScene, Layers, Pass, genHandle, getTypeFromHandle, getBindingFromHandle, getCountFromHandle, getOffsetFromHandle, customizeType, type2reader, type2writer, getDefaultFromType, getStringFromType, overrideMacros, BatchingSchemes, getDeviceShaderVersion, programLib, MaterialInstance, PassInstance, RenderTexture, _extends, range, slide, NodeEventProcessor, deprecateModuleExportedName, Enum, Camera$1, view, screen, TransformBit, ModelLocalBindings, ModelRenderer, Node, CCObject, RenderPriority, clampf, addon, WrapMode, logID, Input, EventDispatcherPriority, input, DispatcherEventType, InputEventType, UBOLocal, CCFloat, property, formerlySerializedAs, CCString, CCBoolean, UBOSkinning, UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, UBOSkinningTexture, UNIFORM_JOINT_TEXTURE_BINDING, UBOSkinningAnimation, INST_JOINT_ANIM_INFO, EditorExtendable, WrapModeMask, WrappedInfo, WrapMode$1, getClassByName, uniquelyReferenced, RealCurve, _float, QuatCurve, ObjectCurve, easing, bezierByTime, binarySearchEpsilon, ValueType, isLerpable, EasingMethod, RealInterpolationMode, TangentWeightMode, QuatInterpolationMode, array, MutableForwardIterator, remove, contains$1, Eventify, log, error, _throw, debug$1, join, mainFileName, changeBasename, _normalize, stripSep, getSeperator, systemInfo, OS, BrowserType, WECHAT, EDITOR, BufferBarrier, CCClass, constructLegacyCurveAndConvert, sign$1, radian, INT_MAX, CCInteger, rangeStep, instantiate, bt, settings, Settings, readOnly, fastRemoveAt, Game, preTransforms, Event, EventHandler, rangeMin, rangeMax, contains$2, screenAdapter, KeyCode, MINIGAME, JSB, RUNTIME_BASED, EventTouch, SystemEventType, EventGamepad, EventHandle, Scene, editorOnly, View;
  return {
    setters: [function (module) {
      bits = module.b;
      Vec2 = module.V;
      v2 = module.v;
      Vec3 = module.a;
      v3 = module.c;
      Vec4 = module.d;
      v4 = module.e;
      Quat = module.Q;
      quat = module.q;
      Mat3 = module.M;
      Mat4 = module.f;
      mat4 = module.m;
      AffineTransform = module.A;
      Size = module.S;
      size = module.s;
      Rect = module.R;
      rect = module.r;
      Color = module.C;
      color = module.g;
      EPSILON$2 = module.E;
      equals$1 = module.h;
      approx = module.i;
      clamp$1 = module.j;
      clamp01 = module.k;
      lerp = module.l;
      toRadian = module.t;
      toDegree = module.n;
      random = module.o;
      randomRange = module.p;
      randomRangeInt = module.u;
      pseudoRandom = module.w;
      pseudoRandomRange = module.x;
      pseudoRandomRangeInt = module.y;
      nextPow2 = module.z;
      repeat$1 = module.B;
      pingPong = module.D;
      inverseLerp = module.F;
      absMaxComponent = module.G;
      absMax = module.H;
      enumerableProps = module.I;
      MATH_FLOAT_ARRAY = module.J;
      MathBase = module.K;
      Pool = module.P;
      RecyclePool = module.L;
      CachedArray = module.N;
      DescriptorSet = module.O;
      Buffer = module.T;
      CommandBuffer = module.U;
      ObjectType = module.W;
      Status = module.X;
      API = module.Y;
      SurfaceTransform = module.Z;
      Feature = module._;
      Format = module.$;
      FormatType = module.a0;
      Type$1 = module.a1;
      BufferUsageBit = module.a2;
      BufferFlagBit = module.a3;
      MemoryAccessBit = module.a4;
      MemoryUsageBit = module.a5;
      TextureType = module.a6;
      TextureUsageBit = module.a7;
      TextureFlagBit = module.a8;
      FormatFeatureBit = module.a9;
      SampleCount = module.aa;
      VsyncMode = module.ab;
      Filter = module.ac;
      Address = module.ad;
      ComparisonFunc = module.ae;
      StencilOp = module.af;
      BlendFactor = module.ag;
      BlendOp = module.ah;
      ColorMask = module.ai;
      ShaderStageFlagBit = module.aj;
      LoadOp = module.ak;
      StoreOp = module.al;
      AccessFlagBit = module.am;
      ResolveMode = module.an;
      PipelineBindPoint = module.ao;
      PrimitiveMode = module.ap;
      PolygonMode = module.aq;
      ShadeModel = module.ar;
      CullMode = module.as;
      DynamicStateFlagBit = module.at;
      StencilFace = module.au;
      DescriptorType = module.av;
      QueueType = module.aw;
      QueryType = module.ax;
      CommandBufferType = module.ay;
      ClearFlagBit = module.az;
      BarrierType = module.aA;
      PassType = module.aB;
      Size$1 = module.aC;
      DeviceCaps = module.aD;
      DeviceOptions = module.aE;
      Offset = module.aF;
      Rect$1 = module.aG;
      Extent = module.aH;
      TextureSubresLayers = module.aI;
      TextureSubresRange = module.aJ;
      TextureCopy = module.aK;
      TextureBlit = module.aL;
      BufferTextureCopy = module.aM;
      Viewport = module.aN;
      Color$1 = module.aO;
      BindingMappingInfo = module.aP;
      SwapchainInfo = module.aQ;
      DeviceInfo = module.aR;
      BufferInfo = module.aS;
      BufferViewInfo = module.aT;
      DrawInfo = module.aU;
      DispatchInfo = module.aV;
      IndirectBuffer = module.aW;
      TextureInfo = module.aX;
      TextureViewInfo = module.aY;
      SamplerInfo = module.aZ;
      Uniform = module.a_;
      UniformBlock = module.a$;
      UniformSamplerTexture = module.b0;
      UniformSampler = module.b1;
      UniformTexture = module.b2;
      UniformStorageImage = module.b3;
      UniformStorageBuffer = module.b4;
      UniformInputAttachment = module.b5;
      ShaderStage = module.b6;
      Attribute = module.b7;
      ShaderInfo = module.b8;
      InputAssemblerInfo = module.b9;
      ColorAttachment = module.ba;
      DepthStencilAttachment = module.bb;
      SubpassInfo = module.bc;
      SubpassDependency = module.bd;
      RenderPassInfo = module.be;
      GeneralBarrierInfo = module.bf;
      TextureBarrierInfo = module.bg;
      BufferBarrierInfo = module.bh;
      FramebufferInfo = module.bi;
      DescriptorSetLayoutBinding = module.bj;
      DescriptorSetLayoutInfo = module.bk;
      DescriptorSetInfo = module.bl;
      PipelineLayoutInfo = module.bm;
      InputState = module.bn;
      CommandBufferInfo = module.bo;
      QueueInfo = module.bp;
      QueryPoolInfo = module.bq;
      FormatInfo = module.br;
      MemoryStatus = module.bs;
      DynamicStencilStates = module.bt;
      DynamicStates = module.bu;
      GFXObject = module.bv;
      AttributeName = module.bw;
      FormatInfos = module.bx;
      DESCRIPTOR_BUFFER_TYPE = module.by;
      DESCRIPTOR_SAMPLER_TYPE = module.bz;
      DESCRIPTOR_DYNAMIC_TYPE = module.bA;
      DRAW_INFO_SIZE = module.bB;
      IsPowerOf2 = module.bC;
      FormatSize = module.bD;
      FormatSurfaceSize = module.bE;
      GetTypeSize = module.bF;
      getTypedArrayConstructor = module.bG;
      formatAlignment = module.bH;
      alignTo = module.bI;
      Device = module.bJ;
      Swapchain = module.bK;
      Framebuffer = module.bL;
      InputAssembler = module.bM;
      DescriptorSetLayout = module.bN;
      PipelineLayout = module.bO;
      RasterizerState = module.bP;
      DepthStencilState = module.bQ;
      BlendTarget = module.bR;
      BlendState = module.bS;
      PipelineStateInfo = module.bT;
      PipelineState = module.bU;
      Queue = module.bV;
      RenderPass = module.bW;
      Sampler = module.bX;
      Shader = module.bY;
      Texture = module.bZ;
      GeneralBarrier = module.b_;
      TextureBarrier = module.b$;
      LegacyRenderMode = module.c0;
      RenderType = module.c1;
      DeviceManager = module.c2;
      deviceManager = module.c3;
      distance = module.c4;
      enums = module.c5;
      intersect = module.c6;
      Line$1 = module.c7;
      Plane = module.c8;
      Ray = module.c9;
      Triangle = module.ca;
      Sphere = module.cb;
      AABB = module.cc;
      OBB = module.cd;
      Capsule = module.ce;
      Frustum = module.cf;
      Keyframe = module.cg;
      AnimationCurve = module.ch;
      SplineMode = module.ci;
      Spline = module.cj;
      ERaycastMode = module.ck;
      line = module.cl;
      plane = module.cm;
      ray = module.cn;
      triangle = module.co;
      sphere = module.cp;
      aabb = module.cq;
      obb = module.cr;
      capsule = module.cs;
      frustum = module.ct;
      CameraFOVAxis = module.cu;
      CameraProjection = module.cv;
      CameraAperture = module.cw;
      CameraISO = module.cx;
      CameraShutter = module.cy;
      CameraType = module.cz;
      TrackingType = module.cA;
      SKYBOX_FLAG = module.cB;
      Camera = module.cC;
      ModelType = module.cD;
      Model = module.cE;
      SubModel = module.cF;
      Ambient = module.cG;
      EnvironmentLightingType = module.cH;
      Skybox = module.cI;
      ShadowSize = module.cJ;
      ShadowType = module.cK;
      PCFType = module.cL;
      CSMLevel = module.cM;
      CSMOptimizationMode = module.cN;
      Shadows = module.cO;
      FogType = module.cP;
      Fog = module.cQ;
      Octree = module.cR;
      ColorTemperatureToRGB = module.cS;
      LightType = module.cT;
      nt2lm = module.cU;
      Light$1 = module.cV;
      DirectionalLight$1 = module.cW;
      SphereLight$1 = module.cX;
      SpotLight$1 = module.cY;
      replaceProperty = module.cZ;
      legacyCC = module.c_;
      Scheduler = module.c$;
      System = module.d0;
      removeProperty = module.d1;
      Root = module.d2;
      markAsWarning = module.d3;
      game = module.d4;
      Director = module.d5;
      assetManager = module.d6;
      extname = module.d7;
      resources = module.d8;
      assets = module.d9;
      dependUtil = module.da;
      downloader = module.db;
      parser = module.dc;
      _createClass = module.dd;
      BuiltinBundleName = module.de;
      transform = module.df;
      changeExtname = module.dg;
      AssetManager = module.dh;
      getError = module.di;
      macro = module.dj;
      director = module.dk;
      releaseManager = module.dl;
      parseLoadResArgs = module.dm;
      Asset = module.dn;
      factory = module.dp;
      setDefaultProgressCallback = module.dq;
      Cache = module.dr;
      getUuidFromURL = module.ds;
      bundles = module.dt;
      dirname = module.du;
      basename = module.dv;
      _inheritsLoose = module.dw;
      supportsR32FloatTexture = module.dx;
      _createForOfIteratorHelperLoose = module.dy;
      SRGBToLinear = module.dz;
      Material = module.dA;
      PixelFormat = module.dB;
      Texture2D = module.dC;
      Filter$1 = module.dD;
      js = module.dE;
      readBuffer = module.dF;
      assertIsTrue = module.dG;
      UBOMorph = module.dH;
      assertIsNonNullable = module.dI;
      ImageAsset = module.dJ;
      warn = module.dK;
      nextPow2$1 = module.dL;
      log2 = module.dM;
      UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = module.dN;
      UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = module.dO;
      UNIFORM_POSITION_MORPH_TEXTURE_BINDING = module.dP;
      ccclass = module.dQ;
      RenderingSubMesh = module.dR;
      warnID = module.dS;
      _applyDecoratedDescriptor = module.dT;
      _initializerDefineProperty = module.dU;
      _assertThisInitialized = module.dV;
      murmurhash2_32_gc = module.dW;
      serializable = module.dX;
      sys = module.dY;
      writeBuffer = module.dZ;
      find = module.d_;
      mapBuffer = module.d$;
      errorID = module.e0;
      createMap = module.e1;
      getClassId = module.e2;
      editable = module.e3;
      override = module.e4;
      string = module.e5;
      type = module.e6;
      mixin = module.e7;
      Pool$1 = module.e8;
      assertID = module.e9;
      disallowMultiple = module.ea;
      executeInEditMode = module.eb;
      NodeEventType = module.ec;
      help = module.ed;
      executionOrder = module.ee;
      menu = module.ef;
      displayOrder = module.eg;
      tooltip = module.eh;
      visibleRect = module.ei;
      Component = module.ej;
      ccenum = module.ek;
      uiRendererManager = module.el;
      assert = module.em;
      builtinResMgr = module.en;
      Renderer = module.eo;
      disallowAnimation = module.ep;
      requireComponent = module.eq;
      visible = module.er;
      displayName = module.es;
      TextureBase = module.et;
      multiline = module.eu;
      debug = module.ev;
      RenderScene = module.ew;
      Layers = module.ex;
      Pass = module.ey;
      genHandle = module.ez;
      getTypeFromHandle = module.eA;
      getBindingFromHandle = module.eB;
      getCountFromHandle = module.eC;
      getOffsetFromHandle = module.eD;
      customizeType = module.eE;
      type2reader = module.eF;
      type2writer = module.eG;
      getDefaultFromType = module.eH;
      getStringFromType = module.eI;
      overrideMacros = module.eJ;
      BatchingSchemes = module.eK;
      getDeviceShaderVersion = module.eL;
      programLib = module.eM;
      MaterialInstance = module.eN;
      PassInstance = module.eO;
      RenderTexture = module.eP;
      _extends = module.eQ;
      range = module.eR;
      slide = module.eS;
      NodeEventProcessor = module.eT;
      deprecateModuleExportedName = module.eU;
      Enum = module.eV;
      Camera$1 = module.eW;
      view = module.eX;
      screen = module.eY;
      TransformBit = module.eZ;
      ModelLocalBindings = module.e_;
      ModelRenderer = module.e$;
      Node = module.f0;
      CCObject = module.f1;
      RenderPriority = module.f2;
      clampf = module.f3;
      addon = module.f4;
      WrapMode = module.f5;
      logID = module.f6;
      Input = module.f7;
      EventDispatcherPriority = module.f8;
      input = module.f9;
      DispatcherEventType = module.fa;
      InputEventType = module.fb;
      UBOLocal = module.fc;
      CCFloat = module.fd;
      property = module.fe;
      formerlySerializedAs = module.ff;
      CCString = module.fg;
      CCBoolean = module.fh;
      UBOSkinning = module.fi;
      UNIFORM_REALTIME_JOINT_TEXTURE_BINDING = module.fj;
      UBOSkinningTexture = module.fk;
      UNIFORM_JOINT_TEXTURE_BINDING = module.fl;
      UBOSkinningAnimation = module.fm;
      INST_JOINT_ANIM_INFO = module.fn;
      EditorExtendable = module.fo;
      WrapModeMask = module.fp;
      WrappedInfo = module.fq;
      WrapMode$1 = module.fr;
      getClassByName = module.fs;
      uniquelyReferenced = module.ft;
      RealCurve = module.fu;
      _float = module.fv;
      QuatCurve = module.fw;
      ObjectCurve = module.fx;
      easing = module.fy;
      bezierByTime = module.fz;
      binarySearchEpsilon = module.fA;
      ValueType = module.fB;
      isLerpable = module.fC;
      EasingMethod = module.fD;
      RealInterpolationMode = module.fE;
      TangentWeightMode = module.fF;
      QuatInterpolationMode = module.fG;
      array = module.fH;
      MutableForwardIterator = module.fI;
      remove = module.fJ;
      contains$1 = module.fK;
      Eventify = module.fL;
      log = module.fM;
      error = module.fN;
      _throw = module.fO;
      debug$1 = module.fP;
      join = module.fQ;
      mainFileName = module.fR;
      changeBasename = module.fS;
      _normalize = module.fT;
      stripSep = module.fU;
      getSeperator = module.fV;
      systemInfo = module.fW;
      OS = module.fX;
      BrowserType = module.fY;
      WECHAT = module.fZ;
      EDITOR = module.f_;
      BufferBarrier = module.f$;
      CCClass = module.g0;
      constructLegacyCurveAndConvert = module.g1;
      sign$1 = module.g2;
      radian = module.g3;
      INT_MAX = module.g4;
      CCInteger = module.g5;
      rangeStep = module.g6;
      instantiate = module.g7;
      bt = module.g8;
      settings = module.g9;
      Settings = module.ga;
      readOnly = module.gb;
      fastRemoveAt = module.gc;
      Game = module.gd;
      preTransforms = module.ge;
      Event = module.gf;
      EventHandler = module.gg;
      rangeMin = module.gh;
      rangeMax = module.gi;
      contains$2 = module.gj;
      screenAdapter = module.gk;
      KeyCode = module.gl;
      MINIGAME = module.gm;
      JSB = module.gn;
      RUNTIME_BASED = module.go;
      EventTouch = module.gp;
      SystemEventType = module.gq;
      EventGamepad = module.gr;
      EventHandle = module.gs;
      Scene = module.gt;
      editorOnly = module.gu;
      View = module.gv;
      var _setter = {};
      _setter.Acceleration = module.hM;
      _setter.AffineTransform = module.A;
      _setter.AmbientInfo = module.hw;
      _setter.Asset = module.dn;
      _setter.AssetManager = module.dh;
      _setter.AsyncDelegate = module.gT;
      _setter.BaseNode = module.ht;
      _setter.BitMask = module.gy;
      _setter.BloomStage = module.hj;
      _setter.BufferAsset = module.gU;
      _setter.CCBoolean = module.fh;
      _setter.CCClass = module.g0;
      _setter.CCFloat = module.fd;
      _setter.CCInteger = module.g5;
      _setter.CCObject = module.f1;
      _setter.CCString = module.fg;
      _setter.CachedArray = module.N;
      _setter.Camera = module.eW;
      _setter.CameraComponent = module.eW;
      _setter.Color = module.C;
      _setter.CompactValueTypeArray = module.gO;
      _setter.Component = module.ej;
      _setter.DEFAULT_OCTREE_DEPTH = module.hC;
      _setter.DEFAULT_WORLD_MAX_POS = module.hB;
      _setter.DEFAULT_WORLD_MIN_POS = module.hA;
      _setter.DebugMode = module.h4;
      _setter.DebugView = module.hr;
      _setter.DeferredPipeline = module.hf;
      _setter.Details = module.gM;
      _setter.Director = module.d5;
      _setter.EPSILON = module.E;
      _setter.EffectAsset = module.g_;
      _setter.Enum = module.eV;
      _setter.Event = module.gf;
      _setter.EventAcceleration = module.hI;
      _setter.EventGamepad = module.gr;
      _setter.EventHMD = module.hL;
      _setter.EventHandle = module.gs;
      _setter.EventHandler = module.gg;
      _setter.EventKeyboard = module.hJ;
      _setter.EventMouse = module.hK;
      _setter.EventTarget = module.gS;
      _setter.EventTouch = module.gp;
      _setter.Eventify = module.fL;
      _setter.ExtrapolationMode = module.hH;
      _setter.FogInfo = module.hy;
      _setter.ForwardFlow = module.hd;
      _setter.ForwardPipeline = module.hc;
      _setter.ForwardStage = module.he;
      _setter.Game = module.gd;
      _setter.GbufferStage = module.hh;
      _setter.ImageAsset = module.dJ;
      _setter.Input = module.f7;
      _setter.InstancedBuffer = module.hn;
      _setter.JavaScript = module.h0;
      _setter.JsonAsset = module.gY;
      _setter.KeyCode = module.gl;
      _setter.Layers = module.ex;
      _setter.LightingStage = module.hi;
      _setter.MATH_FLOAT_ARRAY = module.J;
      _setter.MainFlow = module.hg;
      _setter.Mat3 = module.M;
      _setter.Mat4 = module.f;
      _setter.Material = module.dA;
      _setter.MathBase = module.K;
      _setter.MissingScript = module.hG;
      _setter.ModelRenderer = module.e$;
      _setter.Node = module.f0;
      _setter.NodeActivator = module.hu;
      _setter.NodeEventType = module.ec;
      _setter.NodeSpace = module.hv;
      _setter.ObjectCurve = module.fx;
      _setter.OctreeInfo = module.hD;
      _setter.PipelineEventProcessor = module.hp;
      _setter.PipelineEventType = module.hq;
      _setter.PipelineSceneData = module.hb;
      _setter.PipelineStateManager = module.ho;
      _setter.Pool = module.P;
      _setter.PostProcessStage = module.hk;
      _setter.Prefab = module.gV;
      _setter.PrefabLink = module.gC;
      _setter.PrivateNode = module.hF;
      _setter.Quat = module.Q;
      _setter.QuatCurve = module.fw;
      _setter.QuatInterpolationMode = module.fG;
      _setter.RealCurve = module.fu;
      _setter.RealInterpolationMode = module.fE;
      _setter.Rect = module.R;
      _setter.RecyclePool = module.L;
      _setter.RenderFlow = module.h9;
      _setter.RenderPipeline = module.h8;
      _setter.RenderStage = module.ha;
      _setter.RenderTexture = module.eP;
      _setter.RenderableComponent = module.e$;
      _setter.Renderer = module.eo;
      _setter.RenderingSubMesh = module.dR;
      _setter.ResolutionPolicy = module.h5;
      _setter.Root = module.d2;
      _setter.Scene = module.gt;
      _setter.SceneAsset = module.gW;
      _setter.SceneGlobals = module.hE;
      _setter.Scheduler = module.c$;
      _setter.Script = module.g$;
      _setter.Settings = module.ga;
      _setter.ShadowFlow = module.hl;
      _setter.ShadowStage = module.hm;
      _setter.ShadowsInfo = module.hz;
      _setter.Size = module.S;
      _setter.SkyboxInfo = module.hx;
      _setter.System = module.d0;
      _setter.SystemEvent = module.hP;
      _setter.SystemEventType = module.gq;
      _setter.TangentWeightMode = module.fF;
      _setter.TextAsset = module.gX;
      _setter.Texture2D = module.dC;
      _setter.TextureCube = module.gZ;
      _setter.Touch = module.hN;
      _setter.TransformBit = module.eZ;
      _setter.TypeScript = module.h1;
      _setter.VERSION = module.gx;
      _setter.ValueType = module.fB;
      _setter.Vec2 = module.V;
      _setter.Vec3 = module.a;
      _setter.Vec4 = module.d;
      _setter.View = module.gv;
      _setter.WorldNode3DToLocalNodeUI = module.gG;
      _setter.WorldNode3DToWorldNodeUI = module.gH;
      _setter.__checkObsoleteInNamespace__ = module.gF;
      _setter.__checkObsolete__ = module.gE;
      _setter._decorator = module.gJ;
      _setter.absMax = module.H;
      _setter.absMaxComponent = module.G;
      _setter.approx = module.i;
      _setter.assert = module.em;
      _setter.assertID = module.e9;
      _setter.assetManager = module.d6;
      _setter.bezier = module.gw;
      _setter.bezierByTime = module.fz;
      _setter.bits = module.b;
      _setter.builtinResMgr = module.en;
      _setter.ccenum = module.ek;
      _setter.cclegacy = module.c_;
      _setter.clamp = module.j;
      _setter.clamp01 = module.k;
      _setter.color = module.g;
      _setter.convertUtils = module.gI;
      _setter.createDefaultPipeline = module.h7;
      _setter.debug = module.ev;
      _setter.deprecateModuleExportedName = module.eU;
      _setter.deserialize = module.gL;
      _setter.deserializeTag = module.gQ;
      _setter.director = module.dk;
      _setter.easing = module.fy;
      _setter.editorExtrasTag = module.gP;
      _setter.enumerableProps = module.I;
      _setter.equals = module.h;
      _setter.error = module.fN;
      _setter.errorID = module.e0;
      _setter.find = module.d_;
      _setter.game = module.d4;
      _setter.getError = module.di;
      _setter.getPhaseID = module.hs;
      _setter.getSerializationMetadata = module.gN;
      _setter.input = module.f9;
      _setter.instantiate = module.g7;
      _setter.inverseLerp = module.F;
      _setter.isDisplayStats = module.h2;
      _setter.isValid = module.gK;
      _setter.js = module.gz;
      _setter.lerp = module.l;
      _setter.log = module.fM;
      _setter.logID = module.f6;
      _setter.macro = module.dj;
      _setter.markAsWarning = module.d3;
      _setter.mat4 = module.m;
      _setter.misc = module.gA;
      _setter.murmurhash2_32_gc = module.dW;
      _setter.nextPow2 = module.z;
      _setter.path = module.gB;
      _setter.pingPong = module.D;
      _setter.pipeline = module.h6;
      _setter.pseudoRandom = module.w;
      _setter.pseudoRandomRange = module.x;
      _setter.pseudoRandomRangeInt = module.y;
      _setter.quat = module.q;
      _setter.random = module.o;
      _setter.randomRange = module.p;
      _setter.randomRangeInt = module.u;
      _setter.rect = module.r;
      _setter.removeProperty = module.d1;
      _setter.repeat = module.B;
      _setter.replaceProperty = module.cZ;
      _setter.resources = module.d8;
      _setter.screen = module.eY;
      _setter.serializeTag = module.gR;
      _setter.setDefaultLogTimes = module.gD;
      _setter.setDisplayStats = module.h3;
      _setter.settings = module.g9;
      _setter.size = module.s;
      _setter.sys = module.dY;
      _setter.systemEvent = module.hO;
      _setter.toDegree = module.n;
      _setter.toRadian = module.t;
      _setter.v2 = module.v;
      _setter.v3 = module.c;
      _setter.v4 = module.e;
      _setter.view = module.eX;
      _setter.warn = module.dK;
      _setter.warnID = module.dS;
      exports(_setter);
    }],
    execute: function () {

      exports({
        AntiAliasing: void 0,
        CacheMode: void 0,
        EAxisDirection: void 0,
        ERigidBodyType: void 0,
        HorizontalTextAlignment: void 0,
        InstanceMaterialType: void 0,
        Overflow: void 0,
        VerticalTextAlignment: void 0,
        buildShadowPass: buildShadowPass,
        buildShadowPasses: buildShadowPasses,
        computeRatioByType: computeRatioByType,
        earcut: earcut,
        fragmentText: fragmentText,
        getBaselineOffset: getBaselineOffset,
        getCameraUniqueID: getCameraUniqueID,
        getEnglishWordPartAtFirst: getEnglishWordPartAtFirst,
        getEnglishWordPartAtLast: getEnglishWordPartAtLast,
        getLoadOpOfClearFlag: getLoadOpOfClearFlag,
        getPathFromRoot: getPathFromRoot,
        getRenderArea: getRenderArea,
        getWorldTransformUntilRoot: getWorldTransformUntilRoot,
        isEnglishWordPartAtFirst: isEnglishWordPartAtFirst,
        isEnglishWordPartAtLast: isEnglishWordPartAtLast,
        isUnicodeCJK: isUnicodeCJK,
        isUnicodeSpace: isUnicodeSpace,
        safeMeasureText: safeMeasureText,
        sampleAnimationCurve: sampleAnimationCurve,
        validPunctualLightsCulling: validPunctualLightsCulling
      });

      var math = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bits: bits,
        Vec2: Vec2,
        v2: v2,
        Vec3: Vec3,
        v3: v3,
        Vec4: Vec4,
        v4: v4,
        Quat: Quat,
        quat: quat,
        Mat3: Mat3,
        Mat4: Mat4,
        mat4: mat4,
        AffineTransform: AffineTransform,
        Size: Size,
        size: size,
        Rect: Rect,
        rect: rect,
        Color: Color,
        color: color,
        EPSILON: EPSILON$2,
        equals: equals$1,
        approx: approx,
        clamp: clamp$1,
        clamp01: clamp01,
        lerp: lerp,
        toRadian: toRadian,
        toDegree: toDegree,
        random: random,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: pseudoRandomRangeInt,
        nextPow2: nextPow2,
        repeat: repeat$1,
        pingPong: pingPong,
        inverseLerp: inverseLerp,
        absMaxComponent: absMaxComponent,
        absMax: absMax,
        enumerableProps: enumerableProps,
        MATH_FLOAT_ARRAY: MATH_FLOAT_ARRAY,
        MathBase: MathBase
      });
      exports('math', math);

      var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Pool: Pool,
        RecyclePool: RecyclePool,
        CachedArray: CachedArray
      });
      exports('memop', index);

      var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DescriptorSet: DescriptorSet,
        Buffer: Buffer,
        CommandBuffer: CommandBuffer,
        get ObjectType () { return ObjectType; },
        get Status () { return Status; },
        get API () { return API; },
        get SurfaceTransform () { return SurfaceTransform; },
        get Feature () { return Feature; },
        get Format () { return Format; },
        get FormatType () { return FormatType; },
        get Type () { return Type$1; },
        get BufferUsageBit () { return BufferUsageBit; },
        get BufferFlagBit () { return BufferFlagBit; },
        get MemoryAccessBit () { return MemoryAccessBit; },
        get MemoryUsageBit () { return MemoryUsageBit; },
        get TextureType () { return TextureType; },
        get TextureUsageBit () { return TextureUsageBit; },
        get TextureFlagBit () { return TextureFlagBit; },
        get FormatFeatureBit () { return FormatFeatureBit; },
        get SampleCount () { return SampleCount; },
        get VsyncMode () { return VsyncMode; },
        get Filter () { return Filter; },
        get Address () { return Address; },
        get ComparisonFunc () { return ComparisonFunc; },
        get StencilOp () { return StencilOp; },
        get BlendFactor () { return BlendFactor; },
        get BlendOp () { return BlendOp; },
        get ColorMask () { return ColorMask; },
        get ShaderStageFlagBit () { return ShaderStageFlagBit; },
        get LoadOp () { return LoadOp; },
        get StoreOp () { return StoreOp; },
        get AccessFlagBit () { return AccessFlagBit; },
        get ResolveMode () { return ResolveMode; },
        get PipelineBindPoint () { return PipelineBindPoint; },
        get PrimitiveMode () { return PrimitiveMode; },
        get PolygonMode () { return PolygonMode; },
        get ShadeModel () { return ShadeModel; },
        get CullMode () { return CullMode; },
        get DynamicStateFlagBit () { return DynamicStateFlagBit; },
        get StencilFace () { return StencilFace; },
        get DescriptorType () { return DescriptorType; },
        get QueueType () { return QueueType; },
        get QueryType () { return QueryType; },
        get CommandBufferType () { return CommandBufferType; },
        get ClearFlagBit () { return ClearFlagBit; },
        get BarrierType () { return BarrierType; },
        get PassType () { return PassType; },
        Size: Size$1,
        DeviceCaps: DeviceCaps,
        DeviceOptions: DeviceOptions,
        Offset: Offset,
        Rect: Rect$1,
        Extent: Extent,
        TextureSubresLayers: TextureSubresLayers,
        TextureSubresRange: TextureSubresRange,
        TextureCopy: TextureCopy,
        TextureBlit: TextureBlit,
        BufferTextureCopy: BufferTextureCopy,
        Viewport: Viewport,
        Color: Color$1,
        BindingMappingInfo: BindingMappingInfo,
        SwapchainInfo: SwapchainInfo,
        DeviceInfo: DeviceInfo,
        BufferInfo: BufferInfo,
        BufferViewInfo: BufferViewInfo,
        DrawInfo: DrawInfo,
        DispatchInfo: DispatchInfo,
        IndirectBuffer: IndirectBuffer,
        TextureInfo: TextureInfo,
        TextureViewInfo: TextureViewInfo,
        SamplerInfo: SamplerInfo,
        Uniform: Uniform,
        UniformBlock: UniformBlock,
        UniformSamplerTexture: UniformSamplerTexture,
        UniformSampler: UniformSampler,
        UniformTexture: UniformTexture,
        UniformStorageImage: UniformStorageImage,
        UniformStorageBuffer: UniformStorageBuffer,
        UniformInputAttachment: UniformInputAttachment,
        ShaderStage: ShaderStage,
        Attribute: Attribute,
        ShaderInfo: ShaderInfo,
        InputAssemblerInfo: InputAssemblerInfo,
        ColorAttachment: ColorAttachment,
        DepthStencilAttachment: DepthStencilAttachment,
        SubpassInfo: SubpassInfo,
        SubpassDependency: SubpassDependency,
        RenderPassInfo: RenderPassInfo,
        GeneralBarrierInfo: GeneralBarrierInfo,
        TextureBarrierInfo: TextureBarrierInfo,
        BufferBarrierInfo: BufferBarrierInfo,
        FramebufferInfo: FramebufferInfo,
        DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
        DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
        DescriptorSetInfo: DescriptorSetInfo,
        PipelineLayoutInfo: PipelineLayoutInfo,
        InputState: InputState,
        CommandBufferInfo: CommandBufferInfo,
        QueueInfo: QueueInfo,
        QueryPoolInfo: QueryPoolInfo,
        FormatInfo: FormatInfo,
        MemoryStatus: MemoryStatus,
        DynamicStencilStates: DynamicStencilStates,
        DynamicStates: DynamicStates,
        GFXObject: GFXObject,
        get AttributeName () { return AttributeName; },
        FormatInfos: FormatInfos,
        DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
        DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
        DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
        DRAW_INFO_SIZE: DRAW_INFO_SIZE,
        IsPowerOf2: IsPowerOf2,
        FormatSize: FormatSize,
        FormatSurfaceSize: FormatSurfaceSize,
        GetTypeSize: GetTypeSize,
        getTypedArrayConstructor: getTypedArrayConstructor,
        formatAlignment: formatAlignment,
        alignTo: alignTo,
        Device: Device,
        Swapchain: Swapchain,
        Framebuffer: Framebuffer,
        InputAssembler: InputAssembler,
        DescriptorSetLayout: DescriptorSetLayout,
        PipelineLayout: PipelineLayout,
        RasterizerState: RasterizerState,
        DepthStencilState: DepthStencilState,
        BlendTarget: BlendTarget,
        BlendState: BlendState,
        PipelineStateInfo: PipelineStateInfo,
        PipelineState: PipelineState,
        Queue: Queue,
        RenderPass: RenderPass,
        Sampler: Sampler,
        Shader: Shader,
        Texture: Texture,
        GeneralBarrier: GeneralBarrier,
        TextureBarrier: TextureBarrier,
        get LegacyRenderMode () { return LegacyRenderMode; },
        get RenderType () { return RenderType; },
        DeviceManager: DeviceManager,
        deviceManager: deviceManager
      });
      exports('gfx', index$1);

      var geometry = /*#__PURE__*/Object.freeze({
        __proto__: null,
        distance: distance,
        enums: enums,
        intersect: intersect,
        Line: Line$1,
        Plane: Plane,
        Ray: Ray,
        Triangle: Triangle,
        Sphere: Sphere,
        AABB: AABB,
        OBB: OBB,
        Capsule: Capsule,
        Frustum: Frustum,
        Keyframe: Keyframe,
        AnimationCurve: AnimationCurve,
        get SplineMode () { return SplineMode; },
        Spline: Spline,
        get ERaycastMode () { return ERaycastMode; },
        line: line,
        plane: plane,
        ray: ray,
        triangle: triangle,
        sphere: sphere,
        aabb: aabb,
        obb: obb,
        capsule: capsule,
        frustum: frustum
      });
      exports('geometry', geometry);

      var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get CameraFOVAxis () { return CameraFOVAxis; },
        get CameraProjection () { return CameraProjection; },
        get CameraAperture () { return CameraAperture; },
        get CameraISO () { return CameraISO; },
        get CameraShutter () { return CameraShutter; },
        get CameraType () { return CameraType; },
        get TrackingType () { return TrackingType; },
        SKYBOX_FLAG: SKYBOX_FLAG,
        Camera: Camera,
        get ModelType () { return ModelType; },
        Model: Model,
        SubModel: SubModel,
        Ambient: Ambient,
        EnvironmentLightingType: EnvironmentLightingType,
        Skybox: Skybox,
        ShadowSize: ShadowSize,
        ShadowType: ShadowType,
        PCFType: PCFType,
        CSMLevel: CSMLevel,
        CSMOptimizationMode: CSMOptimizationMode,
        Shadows: Shadows,
        FogType: FogType,
        Fog: Fog,
        Octree: Octree,
        ColorTemperatureToRGB: ColorTemperatureToRGB,
        get LightType () { return LightType; },
        nt2lm: nt2lm,
        Light: Light$1,
        DirectionalLight: DirectionalLight$1,
        SphereLight: SphereLight$1,
        SpotLight: SpotLight$1
      });

      var vmath = {};
      replaceProperty(vmath, 'vmath', [{
        name: 'vec2',
        newName: 'Vec2',
        target: math,
        targetName: 'math'
      }, {
        name: 'vec3',
        newName: 'Vec3',
        target: math,
        targetName: 'math'
      }, {
        name: 'vec4',
        newName: 'Vec4',
        target: math,
        targetName: 'math'
      }, {
        name: 'quat',
        newName: 'Quat',
        target: math,
        targetName: 'math'
      }, {
        name: 'mat3',
        newName: 'Mat3',
        target: math,
        targetName: 'math'
      }, {
        name: 'mat4',
        newName: 'Mat4',
        target: math,
        targetName: 'math'
      }, {
        name: 'color4',
        newName: 'Color',
        target: math,
        targetName: 'math'
      }, {
        name: 'rect',
        newName: 'Rect',
        target: math,
        targetName: 'math'
      }, {
        name: 'approx',
        newName: 'approx',
        target: math,
        targetName: 'math'
      }, {
        name: 'EPSILON',
        newName: 'EPSILON',
        target: math,
        targetName: 'math'
      }, {
        name: 'equals',
        newName: 'equals',
        target: math,
        targetName: 'math'
      }, {
        name: 'clamp',
        newName: 'clamp',
        target: math,
        targetName: 'math'
      }, {
        name: 'clamp01',
        newName: 'clamp01',
        target: math,
        targetName: 'math'
      }, {
        name: 'lerp',
        newName: 'lerp',
        target: math,
        targetName: 'math'
      }, {
        name: 'toRadian',
        newName: 'toRadian',
        target: math,
        targetName: 'math'
      }, {
        name: 'toDegree',
        newName: 'toDegree',
        target: math,
        targetName: 'math'
      }, {
        name: 'random',
        newName: 'random',
        target: math,
        targetName: 'math'
      }, {
        name: 'randomRange',
        newName: 'randomRange',
        target: math,
        targetName: 'math'
      }, {
        name: 'randomRangeInt',
        newName: 'randomRangeInt',
        target: math,
        targetName: 'math'
      }, {
        name: 'pseudoRandom',
        newName: 'pseudoRandom',
        target: math,
        targetName: 'math'
      }, {
        name: 'pseudoRandomRangeInt',
        newName: 'pseudoRandomRangeInt',
        target: math,
        targetName: 'math'
      }, {
        name: 'nextPow2',
        newName: 'nextPow2',
        target: math,
        targetName: 'math'
      }, {
        name: 'repeat',
        newName: 'repeat',
        target: math,
        targetName: 'math'
      }, {
        name: 'pingPong',
        newName: 'pingPong',
        target: math,
        targetName: 'math'
      }, {
        name: 'inverseLerp',
        newName: 'inverseLerp',
        target: math,
        targetName: 'math'
      }]);
      legacyCC.vmath = vmath;
      replaceProperty(Scheduler.prototype, 'Scheduler.prototype', [{
        name: 'enableForTarget',
        newName: 'enableForTarget',
        target: Scheduler,
        targetName: 'Scheduler'
      }]);
      replaceProperty(Scheduler, 'Scheduler', [{
        name: 'PRIORITY_SYSTEM',
        newName: 'System.Priority.SCHEDULER',
        customGetter: function customGetter() {
          return System.Priority.SCHEDULER;
        }
      }]);
      removeProperty(Scheduler, 'Scheduler', [{
        name: 'PRIORITY_NON_SYSTEM',
        suggest: 'Use enum` System.Priority` instead'
      }]);
      replaceProperty(SubModel.prototype, 'SubModel.prototype', [{
        name: 'subMeshData',
        newName: 'subMesh'
      }]);
      removeProperty(SubModel.prototype, 'SubModel.prototype', [{
        name: 'getSubModel',
        suggest: 'Use `subModels[i]` instead'
      }, {
        name: 'subModelNum',
        suggest: 'Use `subModels.length` instead'
      }]);
      replaceProperty(Root.prototype, 'Root.prototype', [{
        name: 'ui',
        newName: 'batcher2D'
      }]);
      markAsWarning(game, 'game', [{
        name: 'collisionMatrix'
      }, {
        name: 'groupList'
      }]);
      markAsWarning(Director.prototype, 'director', [{
        name: 'calculateDeltaTime'
      }, {
        name: 'getDeltaTime',
        suggest: 'Use game.deltaTime instead'
      }, {
        name: 'getTotalTime',
        suggest: 'Use game.totalTime instead'
      }, {
        name: 'getCurrentTime',
        suggest: 'Use game.frameStartTime instead'
      }]);
      removeProperty(Director.prototype, 'director', [{
        name: 'setAnimationInterval',
        suggest: 'please use game.frameRate instead'
      }, {
        name: 'getAnimationInterval',
        suggest: 'please use game.frameRate instead'
      }, {
        name: 'getRunningScene',
        suggest: 'please use getScene instead'
      }, {
        name: 'setDepthTest',
        suggest: 'please use camera API instead'
      }, {
        name: 'setClearColor',
        suggest: 'please use camera API instead'
      }, {
        name: 'getWinSize',
        suggest: 'please use view.getVisibleSize instead'
      }, {
        name: 'getWinSizeInPixels'
      }, {
        name: 'purgeCachedData',
        suggest: 'please use assetManager.releaseAll instead'
      }, {
        name: 'convertToGL'
      }, {
        name: 'convertToUI'
      }]);

      var ImageFmts = ['.png', '.jpg', '.bmp', '.jpeg', '.gif', '.ico', '.tiff', '.webp', '.image', '.pvr', '.pkm', '.astc'];
      var AudioFmts = ['.mp3', '.ogg', '.wav', '.m4a'];

      function GetTrue() {
        return true;
      }

      var md5Pipe = {
        transformURL: function transformURL(url) {
          var uuid = getUuidFromURL(url);

          if (!uuid) {
            return url;
          }

          var bundle = bundles.find(function (b) {
            return !!b.getAssetInfo(uuid);
          });

          if (!bundle) {
            return url;
          }

          var hashValue = '';
          var info = bundle.getAssetInfo(uuid);

          if (url.startsWith(bundle.base + bundle.config.nativeBase)) {
            hashValue = info.nativeVer || '';
          } else {
            hashValue = info.ver || '';
          }

          if (!hashValue || url.indexOf(hashValue) !== -1) {
            return url;
          }

          var hashPatchInFolder = false;

          if (extname(url) === '.ttf') {
            hashPatchInFolder = true;
          }

          if (hashPatchInFolder) {
            var dirname$1 = dirname(url);
            var basename$1 = basename(url);
            url = dirname$1 + "." + hashValue + "/" + basename$1;
          } else {
            url = url.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,})/, function (match, uuid) {
              return match + "." + hashValue;
            });
          }

          return url;
        }
      };
      var CCLoader = exports('CCLoader', function () {
        function CCLoader() {
          this._autoReleaseSetting = Object.create(null);
          this._parseLoadResArgs = parseLoadResArgs;
        }

        var _proto = CCLoader.prototype;

        _proto.load = function load(res, progressCallback, completeCallback) {
          if (completeCallback === undefined) {
            if (progressCallback !== undefined) {
              completeCallback = progressCallback;
              progressCallback = null;
            }
          }

          var requests = Array.isArray(res) ? res : [res];

          for (var i = 0; i < requests.length; i++) {
            var _item = requests[i];

            if (typeof _item === 'string') {
              requests[i] = {
                url: _item,
                __isNative__: true
              };
            } else {
              if (_item.type) {
                _item.ext = "." + _item.type;
                _item.type = undefined;
              }

              if (_item.url) {
                _item.__isNative__ = true;
              }
            }
          }

          var images = [];
          var audios = [];
          assetManager.loadAny(requests, null, function (finish, total, item) {
            if (item.content) {
              if (ImageFmts.includes(item.ext)) {
                images.push(item.content);
              } else if (AudioFmts.includes(item.ext)) {
                audios.push(item.content);
              }
            }

            if (progressCallback) {
              progressCallback(finish, total, item);
            }
          }, function (err, _native) {
            var out = null;

            if (!err) {
              _native = Array.isArray(_native) ? _native : [_native];

              var _loop = function _loop(_i) {
                var item = _native[_i];

                if (!(item instanceof Asset)) {
                  var _asset = item;
                  var _url = requests[_i].url;

                  if (images.includes(_asset)) {
                    factory.create(_url, item, '.png', {}, function (err, image) {
                      _asset = _native[_i] = image;
                    });
                  } else if (audios.includes(_asset)) {
                    factory.create(_url, item, '.mp3', {}, function (err, audio) {
                      _asset = _native[_i] = audio;
                    });
                  }

                  assets.add(_url, _asset);
                }
              };

              for (var _i = 0; _i < _native.length; _i++) {
                _loop(_i);
              }

              if (_native.length > 1) {
                var map = Object.create(null);

                _native.forEach(function (asset) {
                  map[asset._uuid] = asset;
                });

                out = {
                  isCompleted: GetTrue,
                  _map: map
                };
              } else {
                out = _native[0];
              }
            }

            if (completeCallback) {
              completeCallback(err, out);
            }
          });
        };

        _proto.getXMLHttpRequest = function getXMLHttpRequest() {
          return new XMLHttpRequest();
        };

        _proto.getItem = function getItem(id) {
          return assetManager.assets.has(id) ? {
            content: assetManager.assets.get(id)
          } : null;
        };

        _proto.loadRes = function loadRes(url, type, progressCallback, completeCallback) {
          var _this$_parseLoadResAr = this._parseLoadResArgs(type, progressCallback, completeCallback),
              _type = _this$_parseLoadResAr.type,
              onProgress = _this$_parseLoadResAr.onProgress,
              onComplete = _this$_parseLoadResAr.onComplete;

          var extname$1 = extname(url);

          if (extname$1 && !resources.getInfoWithPath(url, _type)) {
            url = url.slice(0, -extname$1.length);
          }

          resources.load(url, _type, onProgress, onComplete);
        };

        _proto.loadResArray = function loadResArray(urls, type, progressCallback, completeCallback) {
          var _this$_parseLoadResAr2 = this._parseLoadResArgs(type, progressCallback, completeCallback),
              _type = _this$_parseLoadResAr2.type,
              onProgress = _this$_parseLoadResAr2.onProgress,
              onComplete = _this$_parseLoadResAr2.onComplete;

          urls.forEach(function (url, i) {
            var extname$1 = extname(url);

            if (extname$1 && !resources.getInfoWithPath(url, _type)) {
              urls[i] = url.slice(0, -extname$1.length);
            }
          });
          resources.load(urls, _type, onProgress, onComplete);
        };

        _proto.loadResDir = function loadResDir(url, type, progressCallback, completeCallback) {
          var _this$_parseLoadResAr3 = this._parseLoadResArgs(type, progressCallback, completeCallback),
              _type = _this$_parseLoadResAr3.type,
              onProgress = _this$_parseLoadResAr3.onProgress,
              onComplete = _this$_parseLoadResAr3.onComplete;

          resources.loadDir(url, _type, onProgress, function (err, out) {
            var urls = [];

            if (!err) {
              var infos = resources.getDirWithPath(url, _type);
              urls = infos.map(function (info) {
                return info.path;
              });
            }

            if (onComplete) {
              onComplete(err, out, urls);
            }
          });
        };

        _proto.getRes = function getRes(url, type) {
          return assets.has(url) ? assets.get(url) : resources.get(url, type);
        };

        _proto.getResCount = function getResCount() {
          return assets.count;
        };

        _proto.getDependsRecursively = function getDependsRecursively(owner) {
          if (!owner) {
            return [];
          }

          var uuid = typeof owner === 'string' ? owner : owner._uuid;
          return dependUtil.getDepsRecursively(uuid).concat([uuid]);
        };

        _proto.addDownloadHandlers = function addDownloadHandlers(extMap) {
          var handler = Object.create(null);

          var _loop2 = function _loop2(_type2) {
            var func = extMap[_type2];

            handler["." + _type2] = function (url, options, onComplete) {
              func({
                url: url
              }, onComplete);
            };
          };

          for (var _type2 in extMap) {
            _loop2(_type2);
          }

          downloader.register(handler);
        };

        _proto.addLoadHandlers = function addLoadHandlers(extMap) {
          var handler = Object.create(null);

          var _loop3 = function _loop3(_type3) {
            var func = extMap[_type3];

            handler["." + _type3] = function (file, options, onComplete) {
              func({
                content: file
              }, onComplete);
            };
          };

          for (var _type3 in extMap) {
            _loop3(_type3);
          }

          parser.register(handler);
        };

        _proto.release = function release(asset) {
          if (Array.isArray(asset)) {
            for (var i = 0; i < asset.length; i++) {
              var key = asset[i];

              if (typeof key === 'string') {
                key = assets.get(key);
              }

              assetManager.releaseAsset(key);
            }
          } else if (asset) {
            if (typeof asset === 'string') {
              asset = assets.get(asset);
            }

            assetManager.releaseAsset(asset);
          }
        };

        _proto.releaseAsset = function releaseAsset(asset) {
          assetManager.releaseAsset(asset);
        };

        _proto.releaseRes = function releaseRes(res, type) {
          resources.release(res, type);
        };

        _proto.releaseAll = function releaseAll() {
          assetManager.releaseAll();
          assets.clear();
        };

        _proto.removeItem = function removeItem(id) {
          return !!assets.remove(id);
        };

        _proto.setAutoRelease = function setAutoRelease(asset, autoRelease) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }

          this._autoReleaseSetting[asset] = !!autoRelease;
        };

        _proto.setAutoReleaseRecursively = function setAutoReleaseRecursively(asset, autoRelease) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }

          autoRelease = !!autoRelease;
          this._autoReleaseSetting[asset] = autoRelease;
          var depends = dependUtil.getDepsRecursively(asset);

          for (var i = 0; i < depends.length; i++) {
            this._autoReleaseSetting[depends[i]] = autoRelease;
          }
        };

        _proto.isAutoRelease = function isAutoRelease(asset) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }

          return !!this._autoReleaseSetting[asset];
        };

        _createClass(CCLoader, [{
          key: "onProgress",
          set: function set(val) {
            setDefaultProgressCallback(val);
          }
        }, {
          key: "_cache",
          get: function get() {
            if (assets instanceof Cache) {
              return assets._map;
            } else {
              var map = {};
              assets.forEach(function (val, key) {
                map[key] = val;
              });
              return map;
            }
          }
        }, {
          key: "md5Pipe",
          get: function get() {
            return md5Pipe;
          }
        }, {
          key: "downloader",
          get: function get() {
            return downloader;
          }
        }, {
          key: "loader",
          get: function get() {
            return assetManager.parser;
          }
        }]);

        return CCLoader;
      }());
      var loader = exports('loader', new CCLoader());
      var AssetLibrary = exports('AssetLibrary', {
        init: function init(options) {
          options.importBase = options.libraryPath;
          options.nativeBase =  options.rawAssetsBase ;
          assetManager.init(options);

          if (options.rawAssets) {
            resources.init({
              base: '',
              deps: [],
              scenes: {},
              redirect: [],
              debug: true,
              packs: {},
              types: [],
              versions: {
                "import": [],
                "native": []
              },
              name: BuiltinBundleName.RESOURCES,
              importBase: options.importBase,
              nativeBase: options.nativeBase,
              paths: options.rawAssets.assets,
              uuids: Object.keys(options.rawAssets.assets),
              extensionMap: {}
            });
          }
        },
        loadAsset: function loadAsset(uuid, callback, options) {
          assetManager.loadAny(uuid, callback);
        }
      });
      var url = exports('url', {});
      replaceProperty(url, 'url', [{
        name: 'normalize',
        target: assetManager.utils,
        targetName: 'assetManager.utils',
        newName: 'normalize'
      }, {
        name: 'raw',
        targetName: 'Asset.prototype',
        newName: 'nativeUrl',
        customFunction: function customFunction(url) {
          if (url.startsWith('resources/')) {
            return transform({
              path: changeExtname(url.substr(10)),
              bundle: BuiltinBundleName.RESOURCES,
              __isNative__: true,
              ext: extname(url)
            });
          }

          return '';
        }
      }]);
      removeProperty(AssetLibrary, 'AssetLibrary', [{
        name: 'getLibUrlNoExt',
        suggest: 'AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use assetManager.utils.getUrlWithUuid instead'
      }, {
        name: 'queryAssetInfo',
        suggest: 'AssetLibrary.queryAssetInfo was removed'
      }]);
      removeProperty(loader, 'loader', [{
        name: 'releaseResDir',
        suggest: 'loader.releaseResDir was removed, please use assetManager.releaseAsset instead'
      }, {
        name: 'flowInDeps',
        suggest: 'loader.flowInDeps was removed'
      }, {
        name: 'assetLoader',
        suggest: 'loader.assetLoader was removed, assetLoader and md5Pipe were merged into assetManager.transformPipeline'
      }]);
      replaceProperty(legacyCC, 'cc', [{
        name: 'loader',
        newName: 'assetManager',
        logTimes: 1,
        customGetter: function customGetter() {
          return loader;
        }
      }, {
        name: 'AssetLibrary',
        newName: 'assetManager',
        logTimes: 1,
        customGetter: function customGetter() {
          return AssetLibrary;
        }
      }, {
        name: 'Pipeline',
        target: AssetManager,
        targetName: 'AssetManager',
        newName: 'Pipeline',
        logTimes: 1
      }, {
        name: 'url',
        targetName: 'assetManager',
        newName: 'utils',
        logTimes: 1,
        customGetter: function customGetter() {
          return url;
        }
      }]);
      removeProperty(legacyCC, 'cc', [{
        name: 'LoadingItems',
        suggest: getError(1400, 'LoadingItems', 'AssetManager.Task')
      }]);
      replaceProperty(macro, 'macro', [{
        name: 'DOWNLOAD_MAX_CONCURRENT',
        target: downloader,
        targetName: 'assetManager.downloader',
        newName: 'maxConcurrency'
      }]);
      replaceProperty(director, 'director', [{
        name: '_getSceneUuid',
        targetName: 'assetManager.main',
        newName: 'getSceneInfo',
        customFunction: function customFunction(sceneName) {
          if (assetManager.main) {
            var _assetManager$main$ge;

            return (_assetManager$main$ge = assetManager.main.getSceneInfo(sceneName)) === null || _assetManager$main$ge === void 0 ? void 0 : _assetManager$main$ge.uuid;
          }

          return '';
        }
      }]);
      replaceProperty(game, 'game', [{
        name: '_sceneInfos',
        targetName: 'assetManager.main',
        newName: 'getSceneInfo',
        customGetter: function customGetter() {
          var scenes = [];

          if (assetManager.main) {
            assetManager.main.config.scenes.forEach(function (val) {
              scenes.push(val);
            });
          }

          return scenes;
        }
      }]);
      var _autoRelease = releaseManager._autoRelease;

      releaseManager._autoRelease = function (oldScene, newScene, persistNodes) {
        _autoRelease.call(releaseManager, oldScene, newScene, persistNodes);

        var releaseSettings = loader._autoReleaseSetting;
        var keys = Object.keys(releaseSettings);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (releaseSettings[key] === true) {
            var _asset2 = assets.get(key);

            if (_asset2) {
              releaseManager.tryRelease(_asset2);
            }
          }
        }
      };

      var ResourceResidency = {
        MANAGED: 0,
        MEMORYLESS: 1,
        PERSISTENT: 2,
        EXTERNAL: 3,
        BACKBUFFER: 4
      };
      var QueueHint = {
        NONE: 0,
        RENDER_OPAQUE: 1,
        RENDER_CUTOUT: 2,
        RENDER_TRANSPARENT: 3
      };
      var SceneFlags = {
        NONE: 0,
        OPAQUE_OBJECT: 1,
        CUTOUT_OBJECT: 2,
        TRANSPARENT_OBJECT: 4,
        SHADOW_CASTER: 8,
        UI: 16,
        DEFAULT_LIGHTING: 32,
        VOLUMETRIC_LIGHTING: 64,
        CLUSTERED_LIGHTING: 128,
        PLANAR_SHADOW: 256,
        GEOMETRY: 512,
        PROFILER: 1024,
        ALL: 4294967295
      };
      var AttachmentType = {
        RENDER_TARGET: 0,
        DEPTH_STENCIL: 1
      };
      var AccessType = {
        READ: 0,
        READ_WRITE: 1,
        WRITE: 2
      };
      var RasterView = function RasterView(slotName, accessType, attachmentType, loadOp, storeOp, clearFlags, clearColor) {
        if (slotName === void 0) {
          slotName = '';
        }

        if (accessType === void 0) {
          accessType = AccessType.WRITE;
        }

        if (attachmentType === void 0) {
          attachmentType = AttachmentType.RENDER_TARGET;
        }

        if (loadOp === void 0) {
          loadOp = LoadOp.LOAD;
        }

        if (storeOp === void 0) {
          storeOp = StoreOp.STORE;
        }

        if (clearFlags === void 0) {
          clearFlags = ClearFlagBit.ALL;
        }

        if (clearColor === void 0) {
          clearColor = new Color$1();
        }

        this.slotName = void 0;
        this.accessType = void 0;
        this.attachmentType = void 0;
        this.loadOp = void 0;
        this.storeOp = void 0;
        this.clearFlags = void 0;
        this.clearColor = void 0;
        this.slotName = slotName;
        this.accessType = accessType;
        this.attachmentType = attachmentType;
        this.loadOp = loadOp;
        this.storeOp = storeOp;
        this.clearFlags = clearFlags;
        this.clearColor = clearColor;
      };
      var ClearValueType = {
        FLOAT_TYPE: 0,
        INT_TYPE: 1
      };
      var ComputeView = function ComputeView() {
        this.name = '';
        this.accessType = AccessType.READ;
        this.clearFlags = ClearFlagBit.NONE;
        this.clearColor = new Color$1();
        this.clearValueType = ClearValueType.FLOAT_TYPE;
      };
      var LightInfo = function LightInfo(light, level) {
        if (light === void 0) {
          light = null;
        }

        if (level === void 0) {
          level = 0;
        }

        this.light = void 0;
        this.level = void 0;
        this.light = light;
        this.level = level;
      };

      var PipelineRuntime = function PipelineRuntime() {};
      var Setter = function Setter() {};
      var RasterQueueBuilder = function (_Setter) {
        _inheritsLoose(RasterQueueBuilder, _Setter);

        function RasterQueueBuilder() {
          return _Setter.apply(this, arguments) || this;
        }

        return RasterQueueBuilder;
      }(Setter);
      var RasterPassBuilder = function (_Setter2) {
        _inheritsLoose(RasterPassBuilder, _Setter2);

        function RasterPassBuilder() {
          return _Setter2.apply(this, arguments) || this;
        }

        return RasterPassBuilder;
      }(Setter);
      var ComputeQueueBuilder = function (_Setter3) {
        _inheritsLoose(ComputeQueueBuilder, _Setter3);

        function ComputeQueueBuilder() {
          return _Setter3.apply(this, arguments) || this;
        }

        return ComputeQueueBuilder;
      }(Setter);
      var ComputePassBuilder = function (_Setter4) {
        _inheritsLoose(ComputePassBuilder, _Setter4);

        function ComputePassBuilder() {
          return _Setter4.apply(this, arguments) || this;
        }

        return ComputePassBuilder;
      }(Setter);
      var Pipeline = function (_PipelineRuntime) {
        _inheritsLoose(Pipeline, _PipelineRuntime);

        function Pipeline() {
          return _PipelineRuntime.apply(this, arguments) || this;
        }

        return Pipeline;
      }(PipelineRuntime);
      var PipelineBuilder = function PipelineBuilder() {};

      function getRenderArea(camera, width, height, light, level) {
        if (light === void 0) {
          light = null;
        }

        if (level === void 0) {
          level = 0;
        }

        var out = new Rect$1();
        var vp = camera.viewport;
        var w = width;
        var h = height;
        out.x = vp.x * w;
        out.y = vp.y * h;
        out.width = vp.width * w;
        out.height = vp.height * h;

        if (light) {
          switch (light.type) {
            case LightType.DIRECTIONAL:
              {
                var mainLight = light;

                if (mainLight.shadowFixedArea || mainLight.csmLevel === CSMLevel.LEVEL_1) {
                  out.x = 0;
                  out.y = 0;
                  out.width = w;
                  out.height = h;
                } else {
                  out.x = level % 2 * 0.5 * w;
                  out.y = (1 - Math.floor(level / 2)) * 0.5 * h;
                  out.width = 0.5 * w;
                  out.height = 0.5 * h;
                }

                break;
              }

            case LightType.SPOT:
              {
                out.x = 0;
                out.y = 0;
                out.width = w;
                out.height = h;
                break;
              }
          }
        }

        return out;
      }
      function buildShadowPass(passName, ppl, camera, light, level, width, height) {
        var device = ppl.device;
        var shadowMapName = passName;

        if (!ppl.containsResource(shadowMapName)) {
          var format = supportsR32FloatTexture(device) ? Format.R32F : Format.RGBA8;
          ppl.addRenderTarget(shadowMapName, format, width, height, ResourceResidency.MANAGED);
          ppl.addDepthStencil(shadowMapName + "Depth", Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
        }

        var pass = ppl.addRasterPass(width, height, 'default', passName);
        pass.addRasterView(shadowMapName, new RasterView('_', AccessType.WRITE, AttachmentType.RENDER_TARGET, LoadOp.CLEAR, StoreOp.STORE, ClearFlagBit.COLOR, new Color$1(1, 1, 1, camera.clearColor.w)));
        pass.addRasterView(shadowMapName + "Depth", new RasterView('_', AccessType.WRITE, AttachmentType.DEPTH_STENCIL, LoadOp.CLEAR, StoreOp.DISCARD, ClearFlagBit.DEPTH_STENCIL, new Color$1(camera.clearDepth, camera.clearStencil, 0, 0)));
        var rect = getRenderArea(camera, width, height, light, level);
        pass.setViewport(new Viewport(rect.x, rect.y, rect.width, rect.height));
        var queue = pass.addQueue(QueueHint.RENDER_OPAQUE);
        queue.addSceneOfCamera(camera, new LightInfo(light, level), SceneFlags.SHADOW_CASTER);
      }

      var CameraInfo = function CameraInfo() {
        this.shadowEnabled = false;
        this.mainLightShadowNames = new Array();
        this.spotLightShadowNames = new Array();
      };

      function buildShadowPasses(cameraName, camera, ppl) {
        var pipeline = ppl;
        var shadowInfo = pipeline.pipelineSceneData.shadows;
        var validPunctualLights = ppl.pipelineSceneData.validPunctualLights;
        var cameraInfo = new CameraInfo();
        var shadows = ppl.pipelineSceneData.shadows;

        if (!shadowInfo.enabled || shadowInfo.type !== ShadowType.ShadowMap) {
          return cameraInfo;
        }

        cameraInfo.shadowEnabled = true;
        var _validLights = [];
        var n = 0;
        var m = 0;

        for (; n < shadowInfo.maxReceived && m < validPunctualLights.length;) {
          var light = validPunctualLights[m];

          if (light.type === LightType.SPOT) {
            var spotLight = light;

            if (spotLight.shadowEnabled) {
              _validLights.push(light);

              n++;
            }
          }

          m++;
        }

        var _ref = camera.scene,
            mainLight = _ref.mainLight;
        var mapWidth = shadows.size.x;
        var mapHeight = shadows.size.y;

        if (mainLight && mainLight.shadowEnabled) {
          cameraInfo.mainLightShadowNames[0] = "MainLightShadow" + cameraName;

          if (mainLight.shadowFixedArea) {
            buildShadowPass(cameraInfo.mainLightShadowNames[0], ppl, camera, mainLight, 0, mapWidth, mapHeight);
          } else {
            var csmLevel = pipeline.pipelineSceneData.csmSupported ? mainLight.csmLevel : 1;

            for (var i = 0; i < csmLevel; i++) {
              cameraInfo.mainLightShadowNames[i] = "MainLightShadow" + cameraName;
              buildShadowPass(cameraInfo.mainLightShadowNames[i], ppl, camera, mainLight, i, mapWidth, mapHeight);
            }
          }
        }

        for (var l = 0; l < _validLights.length; l++) {
          var _light = _validLights[l];
          var passName = "SpotLightShadow" + l.toString() + cameraName;
          cameraInfo.spotLightShadowNames[l] = passName;
          buildShadowPass(passName, ppl, camera, _light, 0, mapWidth, mapHeight);
        }

        return cameraInfo;
      }
      var _cameras = [];
      function getCameraUniqueID(camera) {
        if (!_cameras.includes(camera)) {
          _cameras.push(camera);
        }

        return _cameras.indexOf(camera);
      }
      function getLoadOpOfClearFlag(clearFlag, attachment) {
        var loadOp = LoadOp.CLEAR;

        if (!(clearFlag & ClearFlagBit.COLOR) && attachment === AttachmentType.RENDER_TARGET) {
          if (clearFlag & SKYBOX_FLAG) {
            loadOp = LoadOp.DISCARD;
          } else {
            loadOp = LoadOp.LOAD;
          }
        }

        if ((clearFlag & ClearFlagBit.DEPTH_STENCIL) !== ClearFlagBit.DEPTH_STENCIL && attachment === AttachmentType.DEPTH_STENCIL) {
          if (!(clearFlag & ClearFlagBit.DEPTH)) loadOp = LoadOp.LOAD;
          if (!(clearFlag & ClearFlagBit.STENCIL)) loadOp = LoadOp.LOAD;
        }

        return loadOp;
      }
      var ForwardPipelineBuilder = exports('ForwardPipelineBuilder', function (_PipelineBuilder) {
        _inheritsLoose(ForwardPipelineBuilder, _PipelineBuilder);

        function ForwardPipelineBuilder() {
          return _PipelineBuilder.apply(this, arguments) || this;
        }

        var _proto = ForwardPipelineBuilder.prototype;

        _proto.setup = function setup(cameras, ppl) {
          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];

            if (camera.scene === null) {
              continue;
            }

            validPunctualLightsCulling(ppl, camera);
            var cameraID = getCameraUniqueID(camera);
            var cameraName = "Camera" + cameraID;
            var cameraInfo = buildShadowPasses(cameraName, camera, ppl);
            var width = camera.window.width;
            var height = camera.window.height;
            var forwardPassRTName = "dsForwardPassColor" + cameraName;
            var forwardPassDSName = "dsForwardPassDS" + cameraName;

            if (!ppl.containsResource(forwardPassRTName)) {
              ppl.addRenderTexture(forwardPassRTName, Format.RGBA8, width, height, camera.window);
              ppl.addDepthStencil(forwardPassDSName, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
            }

            var forwardPass = ppl.addRasterPass(width, height, 'default', "CameraForwardPass" + cameraID);

            for (var _iterator = _createForOfIteratorHelperLoose(cameraInfo.mainLightShadowNames), _step; !(_step = _iterator()).done;) {
              var dirShadowName = _step.value;

              if (ppl.containsResource(dirShadowName)) {
                var computeView = new ComputeView();
                forwardPass.addComputeView(dirShadowName, computeView);
              }
            }

            for (var _iterator2 = _createForOfIteratorHelperLoose(cameraInfo.spotLightShadowNames), _step2; !(_step2 = _iterator2()).done;) {
              var spotShadowName = _step2.value;

              if (ppl.containsResource(spotShadowName)) {
                var _computeView = new ComputeView();

                forwardPass.addComputeView(spotShadowName, _computeView);
              }
            }

            var passView = new RasterView('_', AccessType.WRITE, AttachmentType.RENDER_TARGET, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.RENDER_TARGET), StoreOp.STORE, camera.clearFlag, new Color$1(camera.clearColor.x, camera.clearColor.y, camera.clearColor.z, camera.clearColor.w));
            var passDSView = new RasterView('_', AccessType.WRITE, AttachmentType.DEPTH_STENCIL, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.DEPTH_STENCIL), StoreOp.STORE, camera.clearFlag, new Color$1(camera.clearDepth, camera.clearStencil, 0, 0));
            forwardPass.addRasterView(forwardPassRTName, passView);
            forwardPass.addRasterView(forwardPassDSName, passDSView);
            forwardPass.addQueue(QueueHint.RENDER_OPAQUE).addSceneOfCamera(camera, new LightInfo(), SceneFlags.OPAQUE_OBJECT | SceneFlags.PLANAR_SHADOW | SceneFlags.CUTOUT_OBJECT | SceneFlags.PLANAR_SHADOW | SceneFlags.DEFAULT_LIGHTING);
            forwardPass.addQueue(QueueHint.RENDER_TRANSPARENT).addSceneOfCamera(camera, new LightInfo(), SceneFlags.TRANSPARENT_OBJECT | SceneFlags.UI | SceneFlags.GEOMETRY | SceneFlags.PROFILER);
          }
        };

        return ForwardPipelineBuilder;
      }(PipelineBuilder));
      var AntiAliasing;

      (function (AntiAliasing) {
        AntiAliasing[AntiAliasing["NONE"] = 0] = "NONE";
        AntiAliasing[AntiAliasing["FXAA"] = 1] = "FXAA";
      })(AntiAliasing || (AntiAliasing = exports('AntiAliasing', {})));

      var DeferredData = function DeferredData() {
        this._deferredLightingMaterial = void 0;
        this._deferredPostMaterial = void 0;
        this._antiAliasing = AntiAliasing.NONE;
        this._deferredLightingMaterial = new Material();
        this._deferredLightingMaterial.name = 'builtin-deferred-material';

        this._deferredLightingMaterial.initialize({
          effectName: 'pipeline/deferred-lighting',
          defines: {
            CC_RECEIVE_SHADOW: 1
          }
        });

        for (var i = 0; i < this._deferredLightingMaterial.passes.length; ++i) {
          this._deferredLightingMaterial.passes[i].tryCompile();
        }

        this._deferredPostMaterial = new Material();
        this._deferredPostMaterial.name = 'builtin-post-process-material';

        if (macro.ENABLE_ANTIALIAS_FXAA) {
          this._antiAliasing = AntiAliasing.FXAA;
        }

        this._deferredPostMaterial.initialize({
          effectName: 'pipeline/post-process',
          defines: {
            ANTIALIAS_TYPE: this._antiAliasing
          }
        });

        for (var _i = 0; _i < this._deferredPostMaterial.passes.length; ++_i) {
          this._deferredPostMaterial.passes[_i].tryCompile();
        }
      };

      function validPunctualLightsCulling(pipeline, camera) {
        var sceneData = pipeline.pipelineSceneData;
        var validPunctualLights = sceneData.validPunctualLights;
        validPunctualLights.length = 0;

        var _sphere = Sphere.create(0, 0, 0, 1);

        var _ref2 = camera.scene,
            spotLights = _ref2.spotLights;

        for (var i = 0; i < spotLights.length; i++) {
          var light = spotLights[i];

          if (light.baked) {
            continue;
          }

          Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);

          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }

        var _ref3 = camera.scene,
            sphereLights = _ref3.sphereLights;

        for (var _i2 = 0; _i2 < sphereLights.length; _i2++) {
          var _light2 = sphereLights[_i2];

          if (_light2.baked) {
            continue;
          }

          Sphere.set(_sphere, _light2.position.x, _light2.position.y, _light2.position.z, _light2.range);

          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(_light2);
          }
        }
      }
      var DeferredPipelineBuilder = exports('DeferredPipelineBuilder', function (_PipelineBuilder2) {
        _inheritsLoose(DeferredPipelineBuilder, _PipelineBuilder2);

        function DeferredPipelineBuilder() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineBuilder2.call.apply(_PipelineBuilder2, [this].concat(args)) || this;
          _this._deferredData = new DeferredData();
          return _this;
        }

        var _proto2 = DeferredPipelineBuilder.prototype;

        _proto2.setup = function setup(cameras, ppl) {
          for (var i = 0; i < cameras.length; ++i) {
            var camera = cameras[i];

            if (!camera.scene) {
              continue;
            }

            validPunctualLightsCulling(ppl, camera);
            var cameraID = getCameraUniqueID(camera);
            var cameraName = "Camera" + cameraID;
            var cameraInfo = buildShadowPasses(cameraName, camera, ppl);
            var width = camera.window.width;
            var height = camera.window.height;
            var deferredGbufferPassRTName = "dsDeferredPassColorCamera";
            var deferredGbufferPassNormal = "deferredGbufferPassNormal";
            var deferredGbufferPassEmissive = "deferredGbufferPassEmissive";
            var deferredGbufferPassDSName = "dsDeferredPassDSCamera";

            if (!ppl.containsResource(deferredGbufferPassRTName)) {
              var colFormat = Format.RGBA16F;
              ppl.addRenderTarget(deferredGbufferPassRTName, colFormat, width, height, ResourceResidency.MANAGED);
              ppl.addRenderTarget(deferredGbufferPassNormal, colFormat, width, height, ResourceResidency.MANAGED);
              ppl.addRenderTarget(deferredGbufferPassEmissive, colFormat, width, height, ResourceResidency.MANAGED);
              ppl.addDepthStencil(deferredGbufferPassDSName, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
            }

            var gbufferPass = ppl.addRasterPass(width, height, 'Geometry', "CameraGbufferPass" + cameraID);
            var rtColor = new Color$1(0, 0, 0, 0);

            if (camera.clearFlag & ClearFlagBit.COLOR) {
              if (ppl.pipelineSceneData.isHDR) {
                SRGBToLinear(rtColor, camera.clearColor);
              } else {
                rtColor.x = camera.clearColor.x;
                rtColor.y = camera.clearColor.y;
                rtColor.z = camera.clearColor.z;
              }
            }

            var passColorView = new RasterView('_', AccessType.WRITE, AttachmentType.RENDER_TARGET, LoadOp.CLEAR, StoreOp.STORE, camera.clearFlag, rtColor);
            var passNormalView = new RasterView('_', AccessType.WRITE, AttachmentType.RENDER_TARGET, LoadOp.CLEAR, StoreOp.STORE, camera.clearFlag, new Color$1(0, 0, 0, 0));
            var passEmissiveView = new RasterView('_', AccessType.WRITE, AttachmentType.RENDER_TARGET, LoadOp.CLEAR, StoreOp.STORE, camera.clearFlag, new Color$1(0, 0, 0, 0));
            var passDSView = new RasterView('_', AccessType.WRITE, AttachmentType.DEPTH_STENCIL, LoadOp.CLEAR, StoreOp.STORE, camera.clearFlag, new Color$1(camera.clearDepth, camera.clearStencil, 0, 0));
            gbufferPass.addRasterView(deferredGbufferPassRTName, passColorView);
            gbufferPass.addRasterView(deferredGbufferPassNormal, passNormalView);
            gbufferPass.addRasterView(deferredGbufferPassEmissive, passEmissiveView);
            gbufferPass.addRasterView(deferredGbufferPassDSName, passDSView);
            gbufferPass.addQueue(QueueHint.RENDER_OPAQUE).addSceneOfCamera(camera, new LightInfo(), SceneFlags.OPAQUE_OBJECT | SceneFlags.CUTOUT_OBJECT);
            var deferredLightingPassRTName = "deferredLightingPassRTName";
            var deferredLightingPassDS = "deferredLightingPassDS";

            if (!ppl.containsResource(deferredLightingPassRTName)) {
              ppl.addRenderTarget(deferredLightingPassRTName, Format.RGBA8, width, height, ResourceResidency.MANAGED);
              ppl.addDepthStencil(deferredLightingPassDS, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
            }

            var lightingPass = ppl.addRasterPass(width, height, 'Lighting', "CameraLightingPass" + cameraID);

            for (var _iterator3 = _createForOfIteratorHelperLoose(cameraInfo.mainLightShadowNames), _step3; !(_step3 = _iterator3()).done;) {
              var dirShadowName = _step3.value;

              if (ppl.containsResource(dirShadowName)) {
                var _computeView3 = new ComputeView();

                lightingPass.addComputeView(dirShadowName, _computeView3);
              }
            }

            for (var _iterator4 = _createForOfIteratorHelperLoose(cameraInfo.spotLightShadowNames), _step4; !(_step4 = _iterator4()).done;) {
              var spotShadowName = _step4.value;

              if (ppl.containsResource(spotShadowName)) {
                var _computeView4 = new ComputeView();

                lightingPass.addComputeView(spotShadowName, _computeView4);
              }
            }

            if (ppl.containsResource(deferredGbufferPassRTName)) {
              var computeView = new ComputeView();
              computeView.name = 'gbuffer_albedoMap';
              lightingPass.addComputeView(deferredGbufferPassRTName, computeView);
              var computeNormalView = new ComputeView();
              computeNormalView.name = 'gbuffer_normalMap';
              lightingPass.addComputeView(deferredGbufferPassNormal, computeNormalView);
              var computeEmissiveView = new ComputeView();
              computeEmissiveView.name = 'gbuffer_emissiveMap';
              lightingPass.addComputeView(deferredGbufferPassEmissive, computeEmissiveView);
              var computeDepthView = new ComputeView();
              computeDepthView.name = 'depth_stencil';
              lightingPass.addComputeView(deferredGbufferPassDSName, computeDepthView);
            }

            var lightingClearColor = new Color$1(0, 0, 0, 0);

            if (camera.clearFlag & ClearFlagBit.COLOR) {
              lightingClearColor.x = camera.clearColor.x;
              lightingClearColor.y = camera.clearColor.y;
              lightingClearColor.z = camera.clearColor.z;
            }

            lightingClearColor.w = 0;
            var lightingPassView = new RasterView('_', AccessType.WRITE, AttachmentType.RENDER_TARGET, LoadOp.CLEAR, StoreOp.STORE, camera.clearFlag, lightingClearColor);
            lightingPass.addRasterView(deferredLightingPassRTName, lightingPassView);
            lightingPass.addQueue(QueueHint.RENDER_TRANSPARENT).addCameraQuad(camera, this._deferredData._deferredLightingMaterial, SceneFlags.VOLUMETRIC_LIGHTING);
            lightingPass.addQueue(QueueHint.RENDER_TRANSPARENT).addSceneOfCamera(camera, new LightInfo(), SceneFlags.TRANSPARENT_OBJECT | SceneFlags.PLANAR_SHADOW | SceneFlags.GEOMETRY);
            var postprocessPassRTName = "postprocessPassRTName" + cameraID;
            var postprocessPassDS = "postprocessPassDS" + cameraID;

            if (!ppl.containsResource(postprocessPassRTName)) {
              ppl.addRenderTexture(postprocessPassRTName, Format.RGBA8, width, height, camera.window);
              ppl.addDepthStencil(postprocessPassDS, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
            }

            var postprocessPass = ppl.addRasterPass(width, height, 'Postprocess', "CameraPostprocessPass" + cameraID);

            if (ppl.containsResource(deferredLightingPassRTName)) {
              var _computeView2 = new ComputeView();

              _computeView2.name = 'outputResultMap';
              postprocessPass.addComputeView(deferredLightingPassRTName, _computeView2);
            }

            var postClearColor = new Color$1(0, 0, 0, camera.clearColor.w);

            if (camera.clearFlag & ClearFlagBit.COLOR) {
              postClearColor.x = camera.clearColor.x;
              postClearColor.y = camera.clearColor.y;
              postClearColor.z = camera.clearColor.z;
            }

            var postprocessPassView = new RasterView('_', AccessType.WRITE, AttachmentType.RENDER_TARGET, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.RENDER_TARGET), StoreOp.STORE, camera.clearFlag, postClearColor);
            var postprocessPassDSView = new RasterView('_', AccessType.WRITE, AttachmentType.DEPTH_STENCIL, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.DEPTH_STENCIL), StoreOp.STORE, camera.clearFlag, new Color$1(camera.clearDepth, camera.clearStencil, 0, 0));
            postprocessPass.addRasterView(postprocessPassRTName, postprocessPassView);
            postprocessPass.addRasterView(postprocessPassDS, postprocessPassDSView);
            postprocessPass.addQueue(QueueHint.NONE).addFullscreenQuad(this._deferredData._deferredPostMaterial, SceneFlags.NONE);
            postprocessPass.addQueue(QueueHint.RENDER_TRANSPARENT).addSceneOfCamera(camera, new LightInfo(), SceneFlags.UI | SceneFlags.PROFILER);
          }
        };

        return DeferredPipelineBuilder;
      }(PipelineBuilder));

      legacyCC.math = math;
      legacyCC.geometry = geometry;

      var m = new Mat4();
      function fillMeshVertices3D(node, renderer, renderData, color) {
        var chunk = renderData.chunk;
        var dataList = renderData.data;
        var vData = chunk.vb;
        var vertexCount = renderData.vertexCount;
        node.getWorldMatrix(m);
        var vertexOffset = 0;

        for (var i = 0; i < vertexCount; i++) {
          var vert = dataList[i];
          var x = vert.x;
          var y = vert.y;
          var rhw = m.m03 * x + m.m07 * y + m.m15;
          rhw = rhw ? Math.abs(1 / rhw) : 1;
          vData[vertexOffset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
          vData[vertexOffset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
          vData[vertexOffset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
          Color.toArray(vData, color, vertexOffset + 5);
          vertexOffset += 9;
        }

        var bid = chunk.bufferId;
        var vid = chunk.vertexOffset;
        var meshBuffer = chunk.meshBuffer;
        var ib = chunk.meshBuffer.iData;
        var indexOffset = meshBuffer.indexOffset;

        for (var _i = 0, count = vertexCount / 4; _i < count; _i++) {
          var start = vid + _i * 4;
          ib[indexOffset++] = start;
          ib[indexOffset++] = start + 1;
          ib[indexOffset++] = start + 2;
          ib[indexOffset++] = start + 1;
          ib[indexOffset++] = start + 3;
          ib[indexOffset++] = start + 2;
        }

        meshBuffer.indexOffset += renderData.indexCount;
        meshBuffer.setDirty();
      }
      function updateOpacity(renderData, opacity) {
        var vfmt = renderData.vertexFormat;
        var vb = renderData.chunk.vb;
        var attr;
        var format;
        var stride;
        var offset = 0;

        for (var i = 0; i < vfmt.length; ++i) {
          attr = vfmt[i];
          format = FormatInfos[attr.format];

          if (format.hasAlpha) {
            stride = renderData.floatStride;

            if (format.size / format.count === 1) {
              var alpha = ~~clamp$1(Math.round(opacity * 255), 0, 255);

              for (var color = offset; color < vb.length; color += stride) {
                vb[color] = (vb[color] & 0xffffff00 | alpha) >>> 0;
              }
            } else if (format.size / format.count === 4) {
              for (var _alpha = offset + 3; _alpha < vb.length; _alpha += stride) {
                vb[_alpha] = opacity;
              }
            }
          }

          offset += format.size >> 2;
        }
      }

      var minigame = {};

      var space = 2;
      var Atlas = function () {
        function Atlas(width, height) {
          this._texture = void 0;
          this._width = void 0;
          this._height = void 0;
          this._x = void 0;
          this._y = void 0;
          this._nexty = void 0;
          this._innerTextureInfos = {};
          this._innerSpriteFrames = void 0;
          this._count = void 0;
          var texture = new DynamicAtlasTexture();
          texture.initWithSize(width, height);
          this._texture = texture;
          this._width = width;
          this._height = height;
          this._x = space;
          this._y = space;
          this._nexty = space;
          this._innerTextureInfos = {};
          this._innerSpriteFrames = [];
          this._count = 0;
        }

        var _proto = Atlas.prototype;

        _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
          var rect = spriteFrame.rect;
          var texture = spriteFrame.texture;

          var info = this._innerTextureInfos[texture.getId()];

          var sx = rect.x;
          var sy = rect.y;

          if (info) {
            sx += info.x;
            sy += info.y;
          } else {
            var width = texture.width;
            var height = texture.height;

            if (this._x + width + space > this._width) {
              this._x = space;
              this._y = this._nexty;
            }

            if (this._y + height + space > this._nexty) {
              this._nexty = this._y + height + space;
            }

            if (this._nexty > this._height) {
              return null;
            }

            if (legacyCC.internal.dynamicAtlasManager.textureBleeding) {
              if (width <= 8 || height <= 8) {
                this._texture.drawTextureAt(texture.image, this._x - 1, this._y - 1);

                this._texture.drawTextureAt(texture.image, this._x - 1, this._y + 1);

                this._texture.drawTextureAt(texture.image, this._x + 1, this._y - 1);

                this._texture.drawTextureAt(texture.image, this._x + 1, this._y + 1);
              }

              this._texture.drawTextureAt(texture.image, this._x - 1, this._y);

              this._texture.drawTextureAt(texture.image, this._x + 1, this._y);

              this._texture.drawTextureAt(texture.image, this._x, this._y - 1);

              this._texture.drawTextureAt(texture.image, this._x, this._y + 1);
            }

            this._texture.drawTextureAt(texture.image, this._x, this._y);

            this._innerTextureInfos[texture.getId()] = {
              x: this._x,
              y: this._y,
              texture: texture
            };
            this._count++;
            sx += this._x;
            sy += this._y;
            this._x += width + space;
          }

          var frame = {
            x: sx,
            y: sy,
            texture: this._texture
          };

          this._innerSpriteFrames.push(spriteFrame);

          return frame;
        };

        _proto.deleteInnerTexture = function deleteInnerTexture(texture) {
          if (texture && this._innerTextureInfos[texture.getId()]) {
            delete this._innerTextureInfos[texture.getId()];
            this._count--;
          }
        };

        _proto.isEmpty = function isEmpty() {
          return this._count <= 0;
        };

        _proto.reset = function reset() {
          this._x = space;
          this._y = space;
          this._nexty = space;
          var frames = this._innerSpriteFrames;

          for (var i = 0, l = frames.length; i < l; i++) {
            var frame = frames[i];

            if (!frame.isValid) {
              continue;
            }

            frame._resetDynamicAtlasFrame();
          }

          this._innerSpriteFrames.length = 0;
          this._innerTextureInfos = {};
        };

        _proto.destroy = function destroy() {
          this.reset();

          this._texture.destroy();
        };

        return Atlas;
      }();
      var DynamicAtlasTexture = function (_Texture2D) {
        _inheritsLoose(DynamicAtlasTexture, _Texture2D);

        function DynamicAtlasTexture() {
          return _Texture2D.apply(this, arguments) || this;
        }

        var _proto2 = DynamicAtlasTexture.prototype;

        _proto2.initWithSize = function initWithSize(width, height, format) {
          if (format === void 0) {
            format = PixelFormat.RGBA8888;
          }

          this.reset({
            width: width,
            height: height,
            format: format
          });
        };

        _proto2.drawTextureAt = function drawTextureAt(image, x, y) {
          var gfxTexture = this.getGFXTexture();

          if (!image || !gfxTexture) {
            return;
          }

          var gfxDevice = this._getGFXDevice();

          if (!gfxDevice) {
            console.warn('Unable to get device');
            return;
          }

          var region = new BufferTextureCopy();
          region.texOffset.x = x;
          region.texOffset.y = y;
          region.texExtent.width = image.width;
          region.texExtent.height = image.height;
          gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
        };

        return DynamicAtlasTexture;
      }(Texture2D);

      var DynamicAtlasManager = function (_System) {
        _inheritsLoose(DynamicAtlasManager, _System);

        function DynamicAtlasManager() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _System.call.apply(_System, [this].concat(args)) || this;
          _this._atlases = [];
          _this._atlasIndex = -1;
          _this._maxAtlasCount = 5;
          _this._textureSize = 2048;
          _this._maxFrameSize = 512;
          _this._textureBleeding = true;
          _this._enabled = false;
          return _this;
        }

        var _proto = DynamicAtlasManager.prototype;

        _proto.newAtlas = function newAtlas() {
          var atlas = this._atlases[++this._atlasIndex];

          if (!atlas) {
            atlas = new Atlas(this._textureSize, this._textureSize);

            this._atlases.push(atlas);
          }

          return atlas;
        };

        _proto.beforeSceneLoad = function beforeSceneLoad() {
          this.reset();
        };

        _proto.init = function init() {
          this.enabled = !macro.CLEANUP_IMAGE_CACHE;
        };

        _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
          if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !spriteFrame || spriteFrame._original) return null;
          if (!spriteFrame.packable) return null;
          var sampler = spriteFrame.texture.getSamplerInfo();

          if (sampler.minFilter !== Filter$1.LINEAR || sampler.magFilter !== Filter$1.LINEAR || sampler.mipFilter !== Filter$1.NONE) {
            return null;
          }

          var atlas = this._atlases[this._atlasIndex];

          if (!atlas) {
            atlas = this.newAtlas();
          }

          var frame = atlas.insertSpriteFrame(spriteFrame);

          if (!frame && this._atlasIndex !== this._maxAtlasCount) {
            atlas = this.newAtlas();
            return atlas.insertSpriteFrame(spriteFrame);
          }

          return frame;
        };

        _proto.reset = function reset() {
          for (var i = 0, l = this._atlases.length; i < l; i++) {
            this._atlases[i].destroy();
          }

          this._atlases.length = 0;
          this._atlasIndex = -1;
        };

        _proto.deleteAtlasSpriteFrame = function deleteAtlasSpriteFrame(spriteFrame) {
          if (!spriteFrame._original) return;
          var atlas;

          for (var i = this._atlases.length - 1; i >= 0; i--) {
            atlas = this._atlases[i];
            js.array.fastRemove(atlas._innerSpriteFrames, spriteFrame);
          }

          var texture = spriteFrame._original._texture;
          this.deleteAtlasTexture(texture);
        };

        _proto.deleteAtlasTexture = function deleteAtlasTexture(texture) {
          if (texture) {
            for (var i = this._atlases.length - 1; i >= 0; i--) {
              this._atlases[i].deleteInnerTexture(texture);

              if (this._atlases[i].isEmpty()) {
                this._atlases[i].destroy();

                this._atlases.splice(i, 1);

                this._atlasIndex--;
              }
            }
          }
        };

        _proto.packToDynamicAtlas = function packToDynamicAtlas(comp, frame) {
          if ( !this._enabled) return;

          if (frame && !frame._original && frame.packable && frame.texture && frame.texture.width > 0 && frame.texture.height > 0) {
            var packedFrame = this.insertSpriteFrame(frame);

            if (packedFrame) {
              frame._setDynamicAtlasFrame(packedFrame);
            }
          }
        };

        _createClass(DynamicAtlasManager, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(value) {
            if (this._enabled === value) return;

            if (value) {
              this.reset();
              legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
            } else {
              this.reset();
              legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
            }

            this._enabled = value;
          }
        }, {
          key: "maxAtlasCount",
          get: function get() {
            return this._maxAtlasCount;
          },
          set: function set(value) {
            this._maxAtlasCount = value;
          }
        }, {
          key: "atlasCount",
          get: function get() {
            return this._atlases.length;
          }
        }, {
          key: "textureBleeding",
          get: function get() {
            return this._textureBleeding;
          },
          set: function set(enable) {
            this._textureBleeding = enable;
          }
        }, {
          key: "textureSize",
          get: function get() {
            return this._textureSize;
          },
          set: function set(value) {
            this._textureSize = value;
          }
        }, {
          key: "maxFrameSize",
          get: function get() {
            return this._maxFrameSize;
          },
          set: function set(value) {
            this._maxFrameSize = value;
          }
        }]);

        return DynamicAtlasManager;
      }(System);
      DynamicAtlasManager.instance = void 0;
      var dynamicAtlasManager = exports('dynamicAtlasManager', DynamicAtlasManager.instance = new DynamicAtlasManager());
      director.registerSystem('dynamicAtlasManager', dynamicAtlasManager, 0);
      legacyCC.internal.dynamicAtlasManager = dynamicAtlasManager;

      function toPPM(buffer, w, h) {
        return "P3 " + w + " " + h + " 255\n" + buffer.filter(function (e, i) {
          return i % 4 < 3;
        }).toString() + "\n";
      }

      var _keyMap;

      (function (_keyMap) {
        _keyMap[_keyMap["positions"] = AttributeName.ATTR_POSITION] = "positions";
        _keyMap[_keyMap["normals"] = AttributeName.ATTR_NORMAL] = "normals";
        _keyMap[_keyMap["uvs"] = AttributeName.ATTR_TEX_COORD] = "uvs";
        _keyMap[_keyMap["colors"] = AttributeName.ATTR_COLOR] = "colors";
      })(_keyMap || (_keyMap = {}));

      function readMesh(mesh, iPrimitive) {
        if (iPrimitive === void 0) {
          iPrimitive = 0;
        }

        var out = {
          positions: []
        };
        var dataView = new DataView(mesh.data.buffer, mesh.data.byteOffset, mesh.data.byteLength);
        var struct = mesh.struct;
        var primitive = struct.primitives[iPrimitive];

        for (var _iterator = _createForOfIteratorHelperLoose(primitive.vertexBundelIndices), _step; !(_step = _iterator()).done;) {
          var idx = _step.value;
          var bundle = struct.vertexBundles[idx];
          var offset = bundle.view.offset;
          var _bundle$view = bundle.view,
              length = _bundle$view.length,
              stride = _bundle$view.stride;

          for (var _iterator2 = _createForOfIteratorHelperLoose(bundle.attributes), _step2; !(_step2 = _iterator2()).done;) {
            var attr = _step2.value;
            var name = _keyMap[attr.name];

            if (name) {
              out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride));
            }

            offset += FormatInfos[attr.format].size;
          }
        }

        var view = primitive.indexView;
        out.indices = readBuffer(dataView, Format["R" + view.stride * 8 + "UI"], view.offset, view.length);
        return out;
      }

      var BufferBlob = function () {
        function BufferBlob() {
          this._arrayBufferOrPaddings = [];
          this._length = 0;
        }

        var _proto = BufferBlob.prototype;

        _proto.setNextAlignment = function setNextAlignment(align) {
          if (align !== 0) {
            var remainder = this._length % align;

            if (remainder !== 0) {
              var padding = align - remainder;

              this._arrayBufferOrPaddings.push(padding);

              this._length += padding;
            }
          }
        };

        _proto.addBuffer = function addBuffer(arrayBuffer) {
          var result = this._length;

          this._arrayBufferOrPaddings.push(arrayBuffer);

          this._length += arrayBuffer.byteLength;
          return result;
        };

        _proto.getLength = function getLength() {
          return this._length;
        };

        _proto.getCombined = function getCombined() {
          var result = new Uint8Array(this._length);
          var counter = 0;

          this._arrayBufferOrPaddings.forEach(function (arrayBufferOrPadding) {
            if (typeof arrayBufferOrPadding === 'number') {
              counter += arrayBufferOrPadding;
            } else {
              result.set(new Uint8Array(arrayBufferOrPadding), counter);
              counter += arrayBufferOrPadding.byteLength;
            }
          });

          return result.buffer;
        };

        return BufferBlob;
      }();

      function createMorphRendering(mesh, gfxDevice) {
        return new StdMorphRendering(mesh, gfxDevice);
      }
      var StdMorphRendering = function () {
        function StdMorphRendering(mesh, gfxDevice) {
          this._mesh = void 0;
          this._subMeshRenderings = [];
          this._mesh = mesh;

          if (!this._mesh.struct.morph) {
            return;
          }

          var nSubMeshes = this._mesh.struct.primitives.length;
          this._subMeshRenderings = new Array(nSubMeshes).fill(null);

          for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
            var subMeshMorph = this._mesh.struct.morph.subMeshMorphs[iSubMesh];

            if (!subMeshMorph) {
              continue;
            }

            if ( subMeshMorph.targets.length > UBOMorph.MAX_MORPH_TARGET_COUNT) {
              this._subMeshRenderings[iSubMesh] = new CpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
            } else {
              this._subMeshRenderings[iSubMesh] = new GpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
            }
          }
        }

        var _proto = StdMorphRendering.prototype;

        _proto.createInstance = function createInstance() {
          var _this = this;

          var nSubMeshes = this._mesh.struct.primitives.length;
          var subMeshInstances = new Array(nSubMeshes);

          for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
            var _this$_subMeshRenderi, _this$_subMeshRenderi2;

            subMeshInstances[iSubMesh] = (_this$_subMeshRenderi = (_this$_subMeshRenderi2 = this._subMeshRenderings[iSubMesh]) === null || _this$_subMeshRenderi2 === void 0 ? void 0 : _this$_subMeshRenderi2.createInstance()) !== null && _this$_subMeshRenderi !== void 0 ? _this$_subMeshRenderi : null;
          }

          return {
            setWeights: function setWeights(subMeshIndex, weights) {
              var _subMeshInstances$sub;

              (_subMeshInstances$sub = subMeshInstances[subMeshIndex]) === null || _subMeshInstances$sub === void 0 ? void 0 : _subMeshInstances$sub.setWeights(weights);
            },
            requiredPatches: function requiredPatches(subMeshIndex) {
              assertIsNonNullable(_this._mesh.struct.morph);
              var subMeshMorph = _this._mesh.struct.morph.subMeshMorphs[subMeshIndex];
              var subMeshRenderingInstance = subMeshInstances[subMeshIndex];

              if (subMeshRenderingInstance === null) {
                return null;
              }

              assertIsNonNullable(subMeshMorph);
              var patches = [{
                name: 'CC_USE_MORPH',
                value: true
              }, {
                name: 'CC_MORPH_TARGET_COUNT',
                value: subMeshMorph.targets.length
              }];

              if (subMeshMorph.attributes.includes(AttributeName.ATTR_POSITION)) {
                patches.push({
                  name: 'CC_MORPH_TARGET_HAS_POSITION',
                  value: true
                });
              }

              if (subMeshMorph.attributes.includes(AttributeName.ATTR_NORMAL)) {
                patches.push({
                  name: 'CC_MORPH_TARGET_HAS_NORMAL',
                  value: true
                });
              }

              if (subMeshMorph.attributes.includes(AttributeName.ATTR_TANGENT)) {
                patches.push({
                  name: 'CC_MORPH_TARGET_HAS_TANGENT',
                  value: true
                });
              }

              patches.push.apply(patches, subMeshRenderingInstance.requiredPatches());
              return patches;
            },
            adaptPipelineState: function adaptPipelineState(subMeshIndex, descriptorSet) {
              var _subMeshInstances$sub2;

              (_subMeshInstances$sub2 = subMeshInstances[subMeshIndex]) === null || _subMeshInstances$sub2 === void 0 ? void 0 : _subMeshInstances$sub2.adaptPipelineState(descriptorSet);
            },
            destroy: function destroy() {
              for (var _iterator = _createForOfIteratorHelperLoose(subMeshInstances), _step; !(_step = _iterator()).done;) {
                var subMeshInstance = _step.value;
                subMeshInstance === null || subMeshInstance === void 0 ? void 0 : subMeshInstance.destroy();
              }
            }
          };
        };

        return StdMorphRendering;
      }();

      var GpuComputing = function () {
        function GpuComputing(mesh, subMeshIndex, morph, gfxDevice) {
          this._gfxDevice = void 0;
          this._subMeshMorph = void 0;
          this._textureInfo = void 0;
          this._attributes = void 0;
          this._verticesCount = void 0;
          this._gfxDevice = gfxDevice;
          var subMeshMorph = morph.subMeshMorphs[subMeshIndex];
          assertIsNonNullable(subMeshMorph);
          this._subMeshMorph = subMeshMorph;
          enableVertexId(mesh, subMeshIndex, gfxDevice);
          var nVertices = mesh.struct.vertexBundles[mesh.struct.primitives[subMeshIndex].vertexBundelIndices[0]].view.count;
          this._verticesCount = nVertices;
          var nTargets = subMeshMorph.targets.length;
          var vec4Required = nVertices * nTargets;
          var vec4TextureFactory = createVec4TextureFactory(gfxDevice, vec4Required);
          this._textureInfo = {
            width: vec4TextureFactory.width,
            height: vec4TextureFactory.height
          };
          this._attributes = subMeshMorph.attributes.map(function (attributeName, attributeIndex) {
            var vec4Tex = vec4TextureFactory.create();
            var valueView = vec4Tex.valueView;
            subMeshMorph.targets.forEach(function (morphTarget, morphTargetIndex) {
              var displacementsView = morphTarget.displacements[attributeIndex];
              var displacements = new Float32Array(mesh.data.buffer, mesh.data.byteOffset + displacementsView.offset, displacementsView.count);
              var displacementsOffset = nVertices * morphTargetIndex * 4;

              for (var iVertex = 0; iVertex < nVertices; ++iVertex) {
                valueView[displacementsOffset + 4 * iVertex + 0] = displacements[3 * iVertex + 0];
                valueView[displacementsOffset + 4 * iVertex + 1] = displacements[3 * iVertex + 1];
                valueView[displacementsOffset + 4 * iVertex + 2] = displacements[3 * iVertex + 2];
              }
            });
            vec4Tex.updatePixels();
            return {
              name: attributeName,
              morphTexture: vec4Tex
            };
          });
        }

        var _proto2 = GpuComputing.prototype;

        _proto2.destroy = function destroy() {
          for (var _iterator2 = _createForOfIteratorHelperLoose(this._attributes), _step2; !(_step2 = _iterator2()).done;) {
            var attribute = _step2.value;
            attribute.morphTexture.destroy();
          }
        };

        _proto2.createInstance = function createInstance() {
          var _this2 = this;

          var morphUniforms = new MorphUniforms(this._gfxDevice, this._subMeshMorph.targets.length);
          morphUniforms.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height);
          morphUniforms.setVerticesCount(this._verticesCount);
          morphUniforms.commit();
          return {
            setWeights: function setWeights(weights) {
              morphUniforms.setWeights(weights);
              morphUniforms.commit();
            },
            requiredPatches: function requiredPatches() {
              return [{
                name: 'CC_MORPH_TARGET_USE_TEXTURE',
                value: true
              }];
            },
            adaptPipelineState: function adaptPipelineState(descriptorSet) {
              for (var _iterator3 = _createForOfIteratorHelperLoose(_this2._attributes), _step3; !(_step3 = _iterator3()).done;) {
                var attribute = _step3.value;
                var binding = void 0;

                switch (attribute.name) {
                  case AttributeName.ATTR_POSITION:
                    binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
                    break;

                  case AttributeName.ATTR_NORMAL:
                    binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
                    break;

                  case AttributeName.ATTR_TANGENT:
                    binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
                    break;

                  default:
                    warn('Unexpected attribute!');
                    break;
                }

                if (binding !== undefined) {
                  descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
                  descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
                }
              }

              descriptorSet.bindBuffer(UBOMorph.BINDING, morphUniforms.buffer);
              descriptorSet.update();
            },
            destroy: function destroy() {}
          };
        };

        return GpuComputing;
      }();

      var CpuComputing = function () {
        function CpuComputing(mesh, subMeshIndex, morph, gfxDevice) {
          this._gfxDevice = void 0;
          this._attributes = [];
          this._gfxDevice = gfxDevice;
          var subMeshMorph = morph.subMeshMorphs[subMeshIndex];
          assertIsNonNullable(subMeshMorph);
          enableVertexId(mesh, subMeshIndex, gfxDevice);
          this._attributes = subMeshMorph.attributes.map(function (attributeName, attributeIndex) {
            return {
              name: attributeName,
              targets: subMeshMorph.targets.map(function (attributeDisplacement) {
                return {
                  displacements: new Float32Array(mesh.data.buffer, mesh.data.byteOffset + attributeDisplacement.displacements[attributeIndex].offset, attributeDisplacement.displacements[attributeIndex].count)
                };
              })
            };
          });
        }

        var _proto3 = CpuComputing.prototype;

        _proto3.createInstance = function createInstance() {
          return new CpuComputingRenderingInstance(this, this._attributes[0].targets[0].displacements.length / 3, this._gfxDevice);
        };

        _createClass(CpuComputing, [{
          key: "data",
          get: function get() {
            return this._attributes;
          }
        }]);

        return CpuComputing;
      }();

      var CpuComputingRenderingInstance = function () {
        function CpuComputingRenderingInstance(owner, nVertices, gfxDevice) {
          this._attributes = void 0;
          this._owner = void 0;
          this._morphUniforms = void 0;
          this._owner = owner;
          this._morphUniforms = new MorphUniforms(gfxDevice, 0);
          var vec4TextureFactory = createVec4TextureFactory(gfxDevice, nVertices);

          this._morphUniforms.setMorphTextureInfo(vec4TextureFactory.width, vec4TextureFactory.height);

          this._morphUniforms.commit();

          this._attributes = this._owner.data.map(function (attributeMorph, attributeIndex) {
            var morphTexture = vec4TextureFactory.create();
            return {
              attributeName: attributeMorph.name,
              morphTexture: morphTexture
            };
          });
        }

        var _proto4 = CpuComputingRenderingInstance.prototype;

        _proto4.setWeights = function setWeights(weights) {
          for (var iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {
            var myAttribute = this._attributes[iAttribute];
            var valueView = myAttribute.morphTexture.valueView;
            var attributeMorph = this._owner.data[iAttribute];
            assertIsTrue(weights.length === attributeMorph.targets.length);

            for (var iTarget = 0; iTarget < attributeMorph.targets.length; ++iTarget) {
              var targetDisplacements = attributeMorph.targets[iTarget].displacements;
              var weight = weights[iTarget];
              var nVertices = targetDisplacements.length / 3;

              if (iTarget === 0) {
                for (var iVertex = 0; iVertex < nVertices; ++iVertex) {
                  valueView[4 * iVertex + 0] = targetDisplacements[3 * iVertex + 0] * weight;
                  valueView[4 * iVertex + 1] = targetDisplacements[3 * iVertex + 1] * weight;
                  valueView[4 * iVertex + 2] = targetDisplacements[3 * iVertex + 2] * weight;
                }
              } else if (weight !== 0.0) {
                for (var _iVertex = 0; _iVertex < nVertices; ++_iVertex) {
                  valueView[4 * _iVertex + 0] += targetDisplacements[3 * _iVertex + 0] * weight;
                  valueView[4 * _iVertex + 1] += targetDisplacements[3 * _iVertex + 1] * weight;
                  valueView[4 * _iVertex + 2] += targetDisplacements[3 * _iVertex + 2] * weight;
                }
              }
            }

            myAttribute.morphTexture.updatePixels();
          }
        };

        _proto4.requiredPatches = function requiredPatches() {
          return [{
            name: 'CC_MORPH_TARGET_USE_TEXTURE',
            value: true
          }, {
            name: 'CC_MORPH_PRECOMPUTED',
            value: true
          }];
        };

        _proto4.adaptPipelineState = function adaptPipelineState(descriptorSet) {
          for (var _iterator4 = _createForOfIteratorHelperLoose(this._attributes), _step4; !(_step4 = _iterator4()).done;) {
            var attribute = _step4.value;
            var attributeName = attribute.attributeName;
            var binding = void 0;

            switch (attributeName) {
              case AttributeName.ATTR_POSITION:
                binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
                break;

              case AttributeName.ATTR_NORMAL:
                binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
                break;

              case AttributeName.ATTR_TANGENT:
                binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
                break;

              default:
                warn('Unexpected attribute!');
                break;
            }

            if (binding !== undefined) {
              descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
              descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
            }
          }

          descriptorSet.bindBuffer(UBOMorph.BINDING, this._morphUniforms.buffer);
          descriptorSet.update();
        };

        _proto4.destroy = function destroy() {
          this._morphUniforms.destroy();

          for (var iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {
            var myAttribute = this._attributes[iAttribute];
            myAttribute.morphTexture.destroy();
          }
        };

        return CpuComputingRenderingInstance;
      }();

      var MorphUniforms = function () {
        function MorphUniforms(gfxDevice, targetCount) {
          this._targetCount = void 0;
          this._localBuffer = void 0;
          this._remoteBuffer = void 0;
          this._targetCount = targetCount;
          this._localBuffer = new DataView(new ArrayBuffer(UBOMorph.SIZE));
          this._remoteBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOMorph.SIZE, UBOMorph.SIZE));
        }

        var _proto5 = MorphUniforms.prototype;

        _proto5.destroy = function destroy() {
          this._remoteBuffer.destroy();
        };

        _proto5.setWeights = function setWeights(weights) {
          assertIsTrue(weights.length === this._targetCount);

          for (var iWeight = 0; iWeight < weights.length; ++iWeight) {
            this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_WEIGHTS + 4 * iWeight, weights[iWeight], legacyCC.sys.isLittleEndian);
          }
        };

        _proto5.setMorphTextureInfo = function setMorphTextureInfo(width, height) {
          this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH, width, legacyCC.sys.isLittleEndian);

          this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT, height, legacyCC.sys.isLittleEndian);
        };

        _proto5.setVerticesCount = function setVerticesCount(count) {
          this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_VERTICES_COUNT, count, legacyCC.sys.isLittleEndian);
        };

        _proto5.commit = function commit() {
          this._remoteBuffer.update(this._localBuffer.buffer);
        };

        _createClass(MorphUniforms, [{
          key: "buffer",
          get: function get() {
            return this._remoteBuffer;
          }
        }]);

        return MorphUniforms;
      }();

      function createVec4TextureFactory(gfxDevice, vec4Capacity) {
        var hasFeatureFloatTexture = gfxDevice.getFormatFeatures(Format.RGBA32F) & FormatFeatureBit.SAMPLED_TEXTURE;
        var pixelRequired;
        var pixelFormat;
        var pixelBytes;
        var UpdateViewConstructor;

        if (hasFeatureFloatTexture) {
          pixelRequired = vec4Capacity;
          pixelBytes = 16;
          pixelFormat = Texture2D.PixelFormat.RGBA32F;
          UpdateViewConstructor = Float32Array;
        } else {
          pixelRequired = 4 * vec4Capacity;
          pixelBytes = 4;
          pixelFormat = Texture2D.PixelFormat.RGBA8888;
          UpdateViewConstructor = Uint8Array;
        }

        var _bestSizeToHavePixels = bestSizeToHavePixels(pixelRequired),
            width = _bestSizeToHavePixels.width,
            height = _bestSizeToHavePixels.height;

        assertIsTrue(width * height >= pixelRequired);
        return {
          width: width,
          height: height,
          create: function create() {
            var arrayBuffer = new ArrayBuffer(width * height * pixelBytes);
            var valueView = new Float32Array(arrayBuffer);
            var updateView = UpdateViewConstructor === Float32Array ? valueView : new UpdateViewConstructor(arrayBuffer);
            var image = new ImageAsset({
              width: width,
              height: height,
              _data: updateView,
              _compressed: false,
              format: pixelFormat
            });
            var textureAsset = new Texture2D();
            textureAsset.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST);
            textureAsset.setMipFilter(Texture2D.Filter.NONE);
            textureAsset.setWrapMode(Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE);
            textureAsset.image = image;

            if (!textureAsset.getGFXTexture()) {
              warn('Unexpected: failed to create morph texture?');
            }

            var sampler = gfxDevice.getSampler(textureAsset.getSamplerInfo());
            return {
              get texture() {
                return textureAsset.getGFXTexture();
              },

              get sampler() {
                return sampler;
              },

              get valueView() {
                return valueView;
              },

              destroy: function destroy() {
                textureAsset.destroy();
              },
              updatePixels: function updatePixels() {
                textureAsset.uploadData(updateView);
              }
            };
          }
        };
      }

      function enableVertexId(mesh, subMeshIndex, gfxDevice) {
        mesh.renderingSubMeshes[subMeshIndex].enableVertexIdChannel(gfxDevice);
      }

      function bestSizeToHavePixels(nPixels) {
        if (nPixels < 5) {
          nPixels = 5;
        }

        var aligned = nextPow2$1(nPixels);
        var epxSum = log2(aligned);
        var h = epxSum >> 1;
        var w = epxSum & 1 ? h + 1 : h;
        return {
          width: 1 << w,
          height: 1 << h
        };
      }

      var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;

      function getIndexStrideCtor(stride) {
        switch (stride) {
          case 1:
            return Uint8Array;

          case 2:
            return Uint16Array;

          case 4:
            return Uint32Array;

          default:
            return Uint8Array;
        }
      }

      var v3_1 = new Vec3();
      var v3_2 = new Vec3();
      var globalEmptyMeshBuffer = new Uint8Array();
      var Mesh = exports('Mesh', (_dec = ccclass('cc.Mesh'), _dec(_class = (_class2 = (_temp = function (_Asset) {
        _inheritsLoose(Mesh, _Asset);

        function Mesh() {
          var _this;

          _this = _Asset.call(this) || this;
          _this.morphRendering = null;

          _initializerDefineProperty(_this, "_struct", _descriptor, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_hash", _descriptor2, _assertThisInitialized(_this));

          _this._data = globalEmptyMeshBuffer;
          _this._initialized = false;

          _initializerDefineProperty(_this, "_allowDataAccess", _descriptor3, _assertThisInitialized(_this));

          _this._isMeshDataUploaded = false;
          _this._renderingSubMeshes = null;
          _this._boneSpaceBounds = new Map();
          _this._jointBufferIndices = null;
          return _this;
        }

        var _proto = Mesh.prototype;

        _proto.onLoaded = function onLoaded() {
          this.initialize();
        };

        _proto.initialize = function initialize() {
          var _this2 = this;

          if (this._initialized) {
            return;
          }

          this._initialized = true;

          if (this._struct.dynamic) {
            var device = deviceManager.gfxDevice;
            var vertexBuffers = [];
            var subMeshes = [];

            for (var i = 0; i < this._struct.vertexBundles.length; i++) {
              var _vertexBundle = this._struct.vertexBundles[i];
              var vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, _vertexBundle.view.length, _vertexBundle.view.stride));
              vertexBuffers.push(vertexBuffer);
            }

            for (var _i = 0; _i < this._struct.primitives.length; _i++) {
              var primitive = this._struct.primitives[_i];
              var indexView = primitive.indexView;
              var indexBuffer = null;

              if (indexView) {
                indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, indexView.length, indexView.stride));
              }

              var subVBs = [];

              for (var k = 0; k < primitive.vertexBundelIndices.length; k++) {
                var idx = primitive.vertexBundelIndices[k];
                subVBs.push(vertexBuffers[idx]);
              }

              var attributes = [];

              for (var _k = 0; _k < primitive.vertexBundelIndices.length; _k++) {
                var _idx = primitive.vertexBundelIndices[_k];
                var _vertexBundle2 = this._struct.vertexBundles[_idx];

                for (var _iterator = _createForOfIteratorHelperLoose(_vertexBundle2.attributes), _step; !(_step = _iterator()).done;) {
                  var attr = _step.value;
                  var attribute = new Attribute();
                  attribute.copy(attr);
                  attributes.push(attribute);
                }
              }

              var subMesh = new RenderingSubMesh(subVBs, attributes, primitive.primitiveMode, indexBuffer);
              subMesh.drawInfo = new DrawInfo();
              subMesh.mesh = this;
              subMesh.subMeshIdx = _i;
              subMeshes.push(subMesh);
            }

            this._renderingSubMeshes = subMeshes;
          } else {
            (function () {
              var buffer = _this2._data.buffer;
              var gfxDevice = deviceManager.gfxDevice;

              var vertexBuffers = _this2._createVertexBuffers(gfxDevice, buffer);
              var subMeshes = [];

              for (var _i2 = 0; _i2 < _this2._struct.primitives.length; _i2++) {
                var prim = _this2._struct.primitives[_i2];

                if (prim.vertexBundelIndices.length === 0) {
                  continue;
                }

                var _indexBuffer = null;
                var ib = null;

                if (prim.indexView) {
                  var idxView = prim.indexView;
                  var dstStride = idxView.stride;
                  var dstSize = idxView.length;

                  if (dstStride === 4 && !gfxDevice.hasFeature(Feature.ELEMENT_INDEX_UINT)) {
                    var vertexCount = _this2._struct.vertexBundles[prim.vertexBundelIndices[0]].view.count;

                    if (vertexCount >= 65536) {
                      warnID(10001, vertexCount, 65536);
                      continue;
                    } else {
                      dstStride >>= 1;
                      dstSize >>= 1;
                    }
                  }

                  _indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX, MemoryUsageBit.DEVICE, dstSize, dstStride));
                  ib = new (getIndexStrideCtor(idxView.stride))(buffer, idxView.offset, idxView.count);

                  if (idxView.stride !== dstStride) {
                    ib = getIndexStrideCtor(dstStride).from(ib);
                  }

                  _indexBuffer.update(ib);
                }

                var vbReference = prim.vertexBundelIndices.map(function (idx) {
                  return vertexBuffers[idx];
                });
                var gfxAttributes = [];

                if (prim.vertexBundelIndices.length > 0) {
                  var _idx2 = prim.vertexBundelIndices[0];
                  var _vertexBundle3 = _this2._struct.vertexBundles[_idx2];
                  var attrs = _vertexBundle3.attributes;

                  for (var j = 0; j < attrs.length; ++j) {
                    var _attr = attrs[j];
                    gfxAttributes[j] = new Attribute(_attr.name, _attr.format, _attr.isNormalized, _attr.stream, _attr.isInstanced, _attr.location);
                  }
                }

                var _subMesh = new RenderingSubMesh(vbReference, gfxAttributes, prim.primitiveMode, _indexBuffer);

                _subMesh.mesh = _this2;
                _subMesh.subMeshIdx = _i2;
                subMeshes.push(_subMesh);
              }

              _this2._renderingSubMeshes = subMeshes;

              if (_this2._struct.morph) {
                _this2.morphRendering = createMorphRendering(_this2, gfxDevice);
              }

              _this2._isMeshDataUploaded = true;

              if (!_this2._allowDataAccess) {
                _this2.releaseData();
              }
            })();
          }
        };

        _proto.updateSubMesh = function updateSubMesh(primitiveIndex, geometry) {
          if (!this._struct.dynamic) {
            warnID(14200);
            return;
          }

          if (primitiveIndex >= this._struct.primitives.length) {
            warnID(14201);
            return;
          }

          var buffers = [];

          if (geometry.positions.length > 0) {
            buffers.push(geometry.positions);
          }

          if (geometry.normals && geometry.normals.length > 0) {
            buffers.push(geometry.normals);
          }

          if (geometry.uvs && geometry.uvs.length > 0) {
            buffers.push(geometry.uvs);
          }

          if (geometry.tangents && geometry.tangents.length > 0) {
            buffers.push(geometry.tangents);
          }

          if (geometry.colors && geometry.colors.length > 0) {
            buffers.push(geometry.colors);
          }

          if (geometry.customAttributes) {
            for (var k = 0; k < geometry.customAttributes.length; k++) {
              buffers.push(geometry.customAttributes[k].values);
            }
          }

          var dynamic = this._struct.dynamic;
          var info = dynamic.info;
          var primitive = this._struct.primitives[primitiveIndex];
          var subMesh = this._renderingSubMeshes[primitiveIndex];
          var drawInfo = subMesh.drawInfo;

          for (var index = 0; index < buffers.length; index++) {
            var vertices = buffers[index];
            var bundle = this._struct.vertexBundles[primitive.vertexBundelIndices[index]];
            var stride = bundle.view.stride;
            var vertexCount = vertices.byteLength / stride;
            var updateSize = vertices.byteLength;
            var dstBuffer = new Uint8Array(this._data.buffer, bundle.view.offset, updateSize);
            var srcBuffer = new Uint8Array(vertices.buffer, vertices.byteOffset, updateSize);
            var vertexBuffer = subMesh.vertexBuffers[index];
            assertIsTrue(vertexCount <= info.maxSubMeshVertices, 'Too many vertices.');

            if (updateSize > 0) {
              dstBuffer.set(srcBuffer);
              vertexBuffer.update(srcBuffer, updateSize);
            }

            bundle.view.count = vertexCount;
            drawInfo.vertexCount = vertexCount;
          }

          if (primitive.indexView) {
            var indexView = primitive.indexView;
            var _stride = indexView.stride;
            var indexCount = _stride === 2 ? geometry.indices16.length : geometry.indices32.length;

            var _updateSize = indexCount * _stride;

            var _dstBuffer = new Uint8Array(this._data.buffer, indexView.offset, _updateSize);

            var _srcBuffer = _stride === 2 ? new Uint8Array(geometry.indices16.buffer, geometry.indices16.byteOffset, _updateSize) : new Uint8Array(geometry.indices32.buffer, geometry.indices32.byteOffset, _updateSize);

            var indexBuffer = subMesh.indexBuffer;
            assertIsTrue(indexCount <= info.maxSubMeshIndices, 'Too many indices.');

            if (_updateSize > 0) {
              _dstBuffer.set(_srcBuffer);

              indexBuffer.update(_srcBuffer, _updateSize);
            }

            indexView.count = indexCount;
            drawInfo.indexCount = indexCount;
          }

          if (geometry.minPos && geometry.maxPos) {
            var minPos = new Vec3(geometry.minPos.x, geometry.minPos.y, geometry.minPos.z);
            var maxPos = new Vec3(geometry.maxPos.x, geometry.maxPos.y, geometry.maxPos.z);

            if (!dynamic.bounds[primitiveIndex]) {
              dynamic.bounds[primitiveIndex] = new AABB();
            }

            AABB.fromPoints(dynamic.bounds[primitiveIndex], minPos, maxPos);
            var subMin = new Vec3();
            var subMax = new Vec3();

            for (var _iterator2 = _createForOfIteratorHelperLoose(dynamic.bounds), _step2; !(_step2 = _iterator2()).done;) {
              var bound = _step2.value;

              if (bound) {
                bound.getBoundary(subMin, subMax);
                Vec3.min(minPos, subMin, minPos);
                Vec3.max(maxPos, subMax, maxPos);
              }
            }

            this._struct.minPosition = new Vec3(minPos.x, minPos.y, minPos.z);
            this._struct.maxPosition = new Vec3(maxPos.x, maxPos.y, maxPos.z);
          }

          subMesh.invalidateGeometricInfo();
        };

        _proto.destroy = function destroy() {
          this.destroyRenderingMesh();
          return _Asset.prototype.destroy.call(this);
        };

        _proto.destroyRenderingMesh = function destroyRenderingMesh() {
          if (this._renderingSubMeshes) {
            for (var i = 0; i < this._renderingSubMeshes.length; i++) {
              this._renderingSubMeshes[i].destroy();
            }

            this._renderingSubMeshes = null;
            this._initialized = false;
            this._isMeshDataUploaded = false;
          }
        };

        _proto.assign = function assign(struct, data) {
          this.reset({
            struct: struct,
            data: data
          });
        };

        _proto.reset = function reset(info) {
          this.destroyRenderingMesh();
          this._struct = info.struct;
          this._data = info.data;
          this._hash = 0;
        };

        _proto.getBoneSpaceBounds = function getBoneSpaceBounds(skeleton) {
          if (this._boneSpaceBounds.has(skeleton.hash)) {
            return this._boneSpaceBounds.get(skeleton.hash);
          }

          var bounds = [];

          this._boneSpaceBounds.set(skeleton.hash, bounds);

          var valid = [];
          var bindposes = skeleton.bindposes;

          for (var i = 0; i < bindposes.length; i++) {
            bounds.push(new AABB(Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity));
            valid.push(false);
          }

          var primitives = this._struct.primitives;

          for (var p = 0; p < primitives.length; p++) {
            var joints = this.readAttribute(p, AttributeName.ATTR_JOINTS);
            var weights = this.readAttribute(p, AttributeName.ATTR_WEIGHTS);
            var positions = this.readAttribute(p, AttributeName.ATTR_POSITION);

            if (!joints || !weights || !positions) {
              continue;
            }

            var vertCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3);

            for (var _i3 = 0; _i3 < vertCount; _i3++) {
              Vec3.set(v3_1, positions[3 * _i3 + 0], positions[3 * _i3 + 1], positions[3 * _i3 + 2]);

              for (var j = 0; j < 4; ++j) {
                var idx = 4 * _i3 + j;
                var joint = joints[idx];

                if (weights[idx] === 0 || joint >= bindposes.length) {
                  continue;
                }

                Vec3.transformMat4(v3_2, v3_1, bindposes[joint]);
                valid[joint] = true;
                var b = bounds[joint];
                Vec3.min(b.center, b.center, v3_2);
                Vec3.max(b.halfExtents, b.halfExtents, v3_2);
              }
            }
          }

          for (var _i4 = 0; _i4 < bindposes.length; _i4++) {
            var _b = bounds[_i4];

            if (!valid[_i4]) {
              bounds[_i4] = null;
            } else {
              AABB.fromPoints(_b, _b.center, _b.halfExtents);
            }
          }

          return bounds;
        };

        _proto.merge = function merge(mesh, worldMatrix, validate) {
          if (validate) {
            if (!this.validateMergingMesh(mesh)) {
              return false;
            }
          }

          var vec3_temp = new Vec3();
          var rotate = worldMatrix && new Quat();
          var boundingBox = worldMatrix && new AABB();

          if (rotate) {
            worldMatrix.getRotation(rotate);
          }

          if (!this._initialized) {
            var struct = JSON.parse(JSON.stringify(mesh._struct));

            var data = mesh._data.slice();

            if (worldMatrix) {
              if (struct.maxPosition && struct.minPosition) {
                Vec3.add(boundingBox.center, struct.maxPosition, struct.minPosition);
                Vec3.multiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                Vec3.subtract(boundingBox.halfExtents, struct.maxPosition, struct.minPosition);
                Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                AABB.transform(boundingBox, boundingBox, worldMatrix);
                Vec3.add(struct.maxPosition, boundingBox.center, boundingBox.halfExtents);
                Vec3.subtract(struct.minPosition, boundingBox.center, boundingBox.halfExtents);
              }

              for (var i = 0; i < struct.vertexBundles.length; i++) {
                var vtxBdl = struct.vertexBundles[i];

                for (var j = 0; j < vtxBdl.attributes.length; j++) {
                  if (vtxBdl.attributes[j].name === AttributeName.ATTR_POSITION || vtxBdl.attributes[j].name === AttributeName.ATTR_NORMAL) {
                    var format = vtxBdl.attributes[j].format;
                    var inputView = new DataView(data.buffer, vtxBdl.view.offset + getOffset(vtxBdl.attributes, j));
                    var reader = getReader(inputView, format);
                    var writer = getWriter(inputView, format);

                    if (!reader || !writer) {
                      continue;
                    }

                    var vertexCount = vtxBdl.view.count;
                    var vertexStride = vtxBdl.view.stride;
                    var attrComponentByteLength = getComponentByteLength(format);

                    for (var vtxIdx = 0; vtxIdx < vertexCount; vtxIdx++) {
                      var xOffset = vtxIdx * vertexStride;
                      var yOffset = xOffset + attrComponentByteLength;
                      var zOffset = yOffset + attrComponentByteLength;
                      vec3_temp.set(reader(xOffset), reader(yOffset), reader(zOffset));

                      switch (vtxBdl.attributes[j].name) {
                        case AttributeName.ATTR_POSITION:
                          vec3_temp.transformMat4(worldMatrix);
                          break;

                        case AttributeName.ATTR_NORMAL:
                          Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                          break;
                      }

                      writer(xOffset, vec3_temp.x);
                      writer(yOffset, vec3_temp.y);
                      writer(zOffset, vec3_temp.z);
                    }
                  }
                }
              }
            }

            this.reset({
              struct: struct,
              data: data
            });
            this.initialize();
            return true;
          }

          var bufferBlob = new BufferBlob();
          var vertCount = 0;
          var vertStride = 0;
          var srcOffset = 0;
          var dstOffset = 0;
          var vb;
          var vbView;
          var srcVBView;
          var dstVBView;
          var srcAttrOffset = 0;
          var srcVBOffset = 0;
          var dstVBOffset = 0;
          var attrSize = 0;
          var dstAttrView;
          var hasAttr = false;
          var vertexBundles = new Array(this._struct.vertexBundles.length);

          for (var _i5 = 0; _i5 < this._struct.vertexBundles.length; ++_i5) {
            var bundle = this._struct.vertexBundles[_i5];
            var dstBundle = mesh._struct.vertexBundles[_i5];
            srcOffset = bundle.view.offset;
            dstOffset = dstBundle.view.offset;
            vertStride = bundle.view.stride;
            vertCount = bundle.view.count + dstBundle.view.count;
            vb = new ArrayBuffer(vertCount * vertStride);
            vbView = new Uint8Array(vb);
            srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length);
            srcOffset += srcVBView.length;
            dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length);
            dstOffset += dstVBView.length;
            vbView.set(srcVBView);
            srcAttrOffset = 0;

            for (var _iterator3 = _createForOfIteratorHelperLoose(bundle.attributes), _step3; !(_step3 = _iterator3()).done;) {
              var attr = _step3.value;
              dstVBOffset = 0;
              hasAttr = false;

              for (var _iterator4 = _createForOfIteratorHelperLoose(dstBundle.attributes), _step4; !(_step4 = _iterator4()).done;) {
                var dstAttr = _step4.value;

                if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                  hasAttr = true;
                  break;
                }

                dstVBOffset += FormatInfos[dstAttr.format].size;
              }

              if (hasAttr) {
                attrSize = FormatInfos[attr.format].size;
                srcVBOffset = bundle.view.length + srcAttrOffset;

                for (var v = 0; v < dstBundle.view.count; ++v) {
                  dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize);
                  vbView.set(dstAttrView, srcVBOffset);

                  if ((attr.name === AttributeName.ATTR_POSITION || attr.name === AttributeName.ATTR_NORMAL) && worldMatrix) {
                    var f32_temp = new Float32Array(vbView.buffer, srcVBOffset, 3);
                    vec3_temp.set(f32_temp[0], f32_temp[1], f32_temp[2]);

                    switch (attr.name) {
                      case AttributeName.ATTR_POSITION:
                        vec3_temp.transformMat4(worldMatrix);
                        break;

                      case AttributeName.ATTR_NORMAL:
                        Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                        break;
                    }

                    f32_temp[0] = vec3_temp.x;
                    f32_temp[1] = vec3_temp.y;
                    f32_temp[2] = vec3_temp.z;
                  }

                  srcVBOffset += bundle.view.stride;
                  dstVBOffset += dstBundle.view.stride;
                }
              }

              srcAttrOffset += FormatInfos[attr.format].size;
            }

            vertexBundles[_i5] = {
              attributes: bundle.attributes,
              view: {
                offset: bufferBlob.getLength(),
                length: vb.byteLength,
                count: vertCount,
                stride: vertStride
              }
            };
            bufferBlob.addBuffer(vb);
          }

          var idxCount = 0;
          var idxStride = 2;
          var vertBatchCount = 0;
          var ibView;
          var srcIBView;
          var dstIBView;
          var primitives = new Array(this._struct.primitives.length);

          for (var _i6 = 0; _i6 < this._struct.primitives.length; ++_i6) {
            var prim = this._struct.primitives[_i6];
            var dstPrim = mesh._struct.primitives[_i6];
            primitives[_i6] = {
              primitiveMode: prim.primitiveMode,
              vertexBundelIndices: prim.vertexBundelIndices
            };

            for (var _iterator5 = _createForOfIteratorHelperLoose(prim.vertexBundelIndices), _step5; !(_step5 = _iterator5()).done;) {
              var bundleIdx = _step5.value;
              vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
            }

            if (prim.indexView && dstPrim.indexView) {
              idxCount = prim.indexView.count;
              idxCount += dstPrim.indexView.count;
              srcOffset = prim.indexView.offset;
              dstOffset = dstPrim.indexView.offset;

              if (idxCount < 256) {
                idxStride = 1;
              } else if (idxCount < 65536) {
                idxStride = 2;
              } else {
                idxStride = 4;
              }

              var ib = new ArrayBuffer(idxCount * idxStride);

              if (idxStride === 2) {
                ibView = new Uint16Array(ib);
              } else if (idxStride === 1) {
                ibView = new Uint8Array(ib);
              } else {
                ibView = new Uint32Array(ib);
              }

              if (prim.indexView.stride === 2) {
                srcIBView = new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count);
              } else if (prim.indexView.stride === 1) {
                srcIBView = new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count);
              } else {
                srcIBView = new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count);
              }

              if (idxStride === prim.indexView.stride) {
                ibView.set(srcIBView);
              } else {
                for (var n = 0; n < prim.indexView.count; ++n) {
                  ibView[n] = srcIBView[n];
                }
              }

              srcOffset += prim.indexView.length;

              if (dstPrim.indexView.stride === 2) {
                dstIBView = new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
              } else if (dstPrim.indexView.stride === 1) {
                dstIBView = new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
              } else {
                dstIBView = new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
              }

              for (var _n = 0; _n < dstPrim.indexView.count; ++_n) {
                ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
              }

              dstOffset += dstPrim.indexView.length;
              primitives[_i6].indexView = {
                offset: bufferBlob.getLength(),
                length: ib.byteLength,
                count: idxCount,
                stride: idxStride
              };
              bufferBlob.setNextAlignment(idxStride);
              bufferBlob.addBuffer(ib);
            }
          }

          var meshStruct = {
            vertexBundles: vertexBundles,
            primitives: primitives,
            minPosition: this._struct.minPosition,
            maxPosition: this._struct.maxPosition
          };

          if (meshStruct.minPosition && mesh._struct.minPosition && meshStruct.maxPosition && mesh._struct.maxPosition) {
            if (worldMatrix) {
              Vec3.add(boundingBox.center, mesh._struct.maxPosition, mesh._struct.minPosition);
              Vec3.multiplyScalar(boundingBox.center, boundingBox.center, 0.5);
              Vec3.subtract(boundingBox.halfExtents, mesh._struct.maxPosition, mesh._struct.minPosition);
              Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
              AABB.transform(boundingBox, boundingBox, worldMatrix);
              Vec3.add(vec3_temp, boundingBox.center, boundingBox.halfExtents);
              Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, vec3_temp);
              Vec3.subtract(vec3_temp, boundingBox.center, boundingBox.halfExtents);
              Vec3.min(meshStruct.minPosition, meshStruct.minPosition, vec3_temp);
            } else {
              Vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition);
              Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition);
            }
          }

          this.reset({
            struct: meshStruct,
            data: new Uint8Array(bufferBlob.getCombined())
          });
          this.initialize();
          return true;
        };

        _proto.validateMergingMesh = function validateMergingMesh(mesh) {
          if (this._struct.dynamic || mesh._struct.dynamic) {
            return false;
          }

          if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) {
            return false;
          }

          for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
            var bundle = this._struct.vertexBundles[i];
            var dstBundle = mesh._struct.vertexBundles[i];

            if (bundle.attributes.length !== dstBundle.attributes.length) {
              return false;
            }

            for (var j = 0; j < bundle.attributes.length; ++j) {
              if (bundle.attributes[j].format !== dstBundle.attributes[j].format) {
                return false;
              }
            }
          }

          if (this._struct.primitives.length !== mesh._struct.primitives.length) {
            return false;
          }

          for (var _i7 = 0; _i7 < this._struct.primitives.length; ++_i7) {
            var prim = this._struct.primitives[_i7];
            var dstPrim = mesh._struct.primitives[_i7];

            if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) {
              return false;
            }

            for (var _j = 0; _j < prim.vertexBundelIndices.length; ++_j) {
              if (prim.vertexBundelIndices[_j] !== dstPrim.vertexBundelIndices[_j]) {
                return false;
              }
            }

            if (prim.primitiveMode !== dstPrim.primitiveMode) {
              return false;
            }

            if (prim.indexView) {
              if (dstPrim.indexView === undefined) {
                return false;
              }
            } else if (dstPrim.indexView) {
              return false;
            }
          }

          return true;
        };

        _proto.readAttribute = function readAttribute(primitiveIndex, attributeName) {
          var _this3 = this;

          var result = null;

          this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
            var vertexCount = vertexBundle.view.count;
            var format = vertexBundle.attributes[iAttribute].format;
            var StorageConstructor = getTypedArrayConstructor(FormatInfos[format]);

            if (vertexCount === 0) {
              return;
            }

            var inputView = new DataView(_this3._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
            var formatInfo = FormatInfos[format];
            var reader = getReader(inputView, format);

            if (!StorageConstructor || !reader) {
              return;
            }

            var componentCount = formatInfo.count;
            var storage = new StorageConstructor(vertexCount * componentCount);
            var inputStride = vertexBundle.view.stride;

            for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
              for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
              }
            }

            result = storage;
          });

          return result;
        };

        _proto.copyAttribute = function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
          var _this4 = this;

          var written = false;

          this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
            var vertexCount = vertexBundle.view.count;

            if (vertexCount === 0) {
              written = true;
              return;
            }

            var format = vertexBundle.attributes[iAttribute].format;
            var inputView = new DataView(_this4._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
            var outputView = new DataView(buffer, offset);
            var formatInfo = FormatInfos[format];
            var reader = getReader(inputView, format);
            var writer = getWriter(outputView, format);

            if (!reader || !writer) {
              return;
            }

            var componentCount = formatInfo.count;
            var inputStride = vertexBundle.view.stride;
            var inputComponentByteLength = getComponentByteLength(format);
            var outputStride = stride;
            var outputComponentByteLength = inputComponentByteLength;

            for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
              for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                var inputOffset = inputStride * iVertex + inputComponentByteLength * iComponent;
                var outputOffset = outputStride * iVertex + outputComponentByteLength * iComponent;
                writer(outputOffset, reader(inputOffset));
              }
            }

            written = true;
          });

          return written;
        };

        _proto.readIndices = function readIndices(primitiveIndex) {
          if (primitiveIndex >= this._struct.primitives.length) {
            return null;
          }

          var primitive = this._struct.primitives[primitiveIndex];

          if (!primitive.indexView) {
            return null;
          }

          var stride = primitive.indexView.stride;
          var Ctor = stride === 1 ? Uint8Array : stride === 2 ? Uint16Array : Uint32Array;
          return new Ctor(this._data.buffer, primitive.indexView.offset, primitive.indexView.count);
        };

        _proto.copyIndices = function copyIndices(primitiveIndex, outputArray) {
          if (primitiveIndex >= this._struct.primitives.length) {
            return false;
          }

          var primitive = this._struct.primitives[primitiveIndex];

          if (!primitive.indexView) {
            return false;
          }

          var indexCount = primitive.indexView.count;
          var indexFormat = primitive.indexView.stride === 1 ? Format.R8UI : primitive.indexView.stride === 2 ? Format.R16UI : Format.R32UI;
          var reader = getReader(new DataView(this._data.buffer), indexFormat);

          for (var i = 0; i < indexCount; ++i) {
            outputArray[i] = reader(primitive.indexView.offset + FormatInfos[indexFormat].size * i);
          }

          return true;
        };

        _proto.readAttributeFormat = function readAttributeFormat(primitiveIndex, attributeName) {
          var result = null;

          this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
            var format = vertexBundle.attributes[iAttribute].format;
            result = FormatInfos[format];
          });

          return result;
        };

        _proto._accessAttribute = function _accessAttribute(primitiveIndex, attributeName, accessor) {
          if (primitiveIndex >= this._struct.primitives.length) {
            return;
          }

          var primitive = this._struct.primitives[primitiveIndex];

          for (var _iterator6 = _createForOfIteratorHelperLoose(primitive.vertexBundelIndices), _step6; !(_step6 = _iterator6()).done;) {
            var vertexBundleIndex = _step6.value;
            var _vertexBundle4 = this._struct.vertexBundles[vertexBundleIndex];

            var _iAttribute = _vertexBundle4.attributes.findIndex(function (a) {
              return a.name === attributeName;
            });

            if (_iAttribute < 0) {
              continue;
            }

            accessor(_vertexBundle4, _iAttribute);
            break;
          }
        };

        _proto._createVertexBuffers = function _createVertexBuffers(gfxDevice, data) {
          return this._struct.vertexBundles.map(function (vertexBundle) {
            var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX, MemoryUsageBit.DEVICE, vertexBundle.view.length, vertexBundle.view.stride));
            var view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);
            vertexBuffer.update(view);
            return vertexBuffer;
          });
        };

        _proto.initDefault = function initDefault(uuid) {
          _Asset.prototype.initDefault.call(this, uuid);

          this.reset({
            struct: {
              vertexBundles: [],
              primitives: []
            },
            data: globalEmptyMeshBuffer
          });
        };

        _proto.releaseData = function releaseData() {
          this._data = globalEmptyMeshBuffer;
        };

        _createClass(Mesh, [{
          key: "_nativeAsset",
          get: function get() {
            return this._data.buffer;
          },
          set: function set(value) {
            this._data = new Uint8Array(value);
          }
        }, {
          key: "subMeshCount",
          get: function get() {
            var renderingMesh = this.renderingSubMeshes;
            return renderingMesh ? renderingMesh.length : 0;
          }
        }, {
          key: "minPosition",
          get: function get() {
            return this.struct.minPosition;
          }
        }, {
          key: "maxPosition",
          get: function get() {
            return this.struct.maxPosition;
          }
        }, {
          key: "struct",
          get: function get() {
            return this._struct;
          }
        }, {
          key: "data",
          get: function get() {
            return this._data;
          }
        }, {
          key: "hash",
          get: function get() {
            if (!this._hash) {
              this._hash = murmurhash2_32_gc(this._data, 666);
            }

            return this._hash;
          }
        }, {
          key: "jointBufferIndices",
          get: function get() {
            if (this._jointBufferIndices) {
              return this._jointBufferIndices;
            }

            return this._jointBufferIndices = this._struct.primitives.map(function (p) {
              return p.jointMapIndex || 0;
            });
          }
        }, {
          key: "renderingSubMeshes",
          get: function get() {
            this.initialize();
            return this._renderingSubMeshes;
          }
        }, {
          key: "allowDataAccess",
          get: function get() {
            return this._allowDataAccess;
          },
          set: function set(allowDataAccess) {
            this._allowDataAccess = allowDataAccess;

            if (this._isMeshDataUploaded && !this._allowDataAccess) {
              this.releaseData();
            }
          }
        }]);

        return Mesh;
      }(Asset), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_struct", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {
            vertexBundles: [],
            primitives: []
          };
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_hash", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_allowDataAccess", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class2)) || _class));
      legacyCC.Mesh = Mesh;

      function getOffset(attributes, attributeIndex) {
        var result = 0;

        for (var i = 0; i < attributeIndex; ++i) {
          var attribute = attributes[i];
          result += FormatInfos[attribute.format].size;
        }

        return result;
      }

      var isLittleEndian = sys.isLittleEndian;

      function getComponentByteLength(format) {
        var info = FormatInfos[format];
        return info.size / info.count;
      }

      function getReader(dataView, format) {
        var info = FormatInfos[format];
        var stride = info.size / info.count;

        switch (info.type) {
          case FormatType.UNORM:
            {
              switch (stride) {
                case 1:
                  return function (offset) {
                    return dataView.getUint8(offset);
                  };

                case 2:
                  return function (offset) {
                    return dataView.getUint16(offset, isLittleEndian);
                  };

                case 4:
                  return function (offset) {
                    return dataView.getUint32(offset, isLittleEndian);
                  };
              }

              break;
            }

          case FormatType.SNORM:
            {
              switch (stride) {
                case 1:
                  return function (offset) {
                    return dataView.getInt8(offset);
                  };

                case 2:
                  return function (offset) {
                    return dataView.getInt16(offset, isLittleEndian);
                  };

                case 4:
                  return function (offset) {
                    return dataView.getInt32(offset, isLittleEndian);
                  };
              }

              break;
            }

          case FormatType.INT:
            {
              switch (stride) {
                case 1:
                  return function (offset) {
                    return dataView.getInt8(offset);
                  };

                case 2:
                  return function (offset) {
                    return dataView.getInt16(offset, isLittleEndian);
                  };

                case 4:
                  return function (offset) {
                    return dataView.getInt32(offset, isLittleEndian);
                  };
              }

              break;
            }

          case FormatType.UINT:
            {
              switch (stride) {
                case 1:
                  return function (offset) {
                    return dataView.getUint8(offset);
                  };

                case 2:
                  return function (offset) {
                    return dataView.getUint16(offset, isLittleEndian);
                  };

                case 4:
                  return function (offset) {
                    return dataView.getUint32(offset, isLittleEndian);
                  };
              }

              break;
            }

          case FormatType.FLOAT:
            {
              return function (offset) {
                return dataView.getFloat32(offset, isLittleEndian);
              };
            }
        }

        return null;
      }

      function getWriter(dataView, format) {
        var info = FormatInfos[format];
        var stride = info.size / info.count;

        switch (info.type) {
          case FormatType.UNORM:
            {
              switch (stride) {
                case 1:
                  return function (offset, value) {
                    return dataView.setUint8(offset, value);
                  };

                case 2:
                  return function (offset, value) {
                    return dataView.setUint16(offset, value, isLittleEndian);
                  };

                case 4:
                  return function (offset, value) {
                    return dataView.setUint32(offset, value, isLittleEndian);
                  };
              }

              break;
            }

          case FormatType.SNORM:
            {
              switch (stride) {
                case 1:
                  return function (offset, value) {
                    return dataView.setInt8(offset, value);
                  };

                case 2:
                  return function (offset, value) {
                    return dataView.setInt16(offset, value, isLittleEndian);
                  };

                case 4:
                  return function (offset, value) {
                    return dataView.setInt32(offset, value, isLittleEndian);
                  };
              }

              break;
            }

          case FormatType.INT:
            {
              switch (stride) {
                case 1:
                  return function (offset, value) {
                    return dataView.setInt8(offset, value);
                  };

                case 2:
                  return function (offset, value) {
                    return dataView.setInt16(offset, value, isLittleEndian);
                  };

                case 4:
                  return function (offset, value) {
                    return dataView.setInt32(offset, value, isLittleEndian);
                  };
              }

              break;
            }

          case FormatType.UINT:
            {
              switch (stride) {
                case 1:
                  return function (offset, value) {
                    return dataView.setUint8(offset, value);
                  };

                case 2:
                  return function (offset, value) {
                    return dataView.setUint16(offset, value, isLittleEndian);
                  };

                case 4:
                  return function (offset, value) {
                    return dataView.setUint32(offset, value, isLittleEndian);
                  };
              }

              break;
            }

          case FormatType.FLOAT:
            {
              return function (offset, value) {
                return dataView.setFloat32(offset, value, isLittleEndian);
              };
            }
        }

        return null;
      }

      var _defAttrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_TANGENT, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      var v3_1$1 = new Vec3();

      function _createMesh(geometry, out, options) {
        options = options || {};
        var attributes = [];
        var stride = 0;
        var channels = [];
        var vertCount = 0;
        var attr;
        var positions = geometry.positions.slice();

        if (positions.length > 0) {
          attr = null;

          if (geometry.attributes) {
            for (var _iterator = _createForOfIteratorHelperLoose(geometry.attributes), _step; !(_step = _iterator()).done;) {
              var att = _step.value;

              if (att.name === AttributeName.ATTR_POSITION) {
                attr = att;
                break;
              }
            }
          }

          if (!attr) {
            attr = _defAttrs[0];
          }

          attributes.push(attr);
          var info = FormatInfos[attr.format];
          vertCount = Math.max(vertCount, Math.floor(positions.length / info.count));
          channels.push({
            offset: stride,
            data: positions,
            attribute: attr
          });
          stride += info.size;
        }

        if (geometry.normals && geometry.normals.length > 0) {
          attr = null;

          if (geometry.attributes) {
            for (var _iterator2 = _createForOfIteratorHelperLoose(geometry.attributes), _step2; !(_step2 = _iterator2()).done;) {
              var _att = _step2.value;

              if (_att.name === AttributeName.ATTR_NORMAL) {
                attr = _att;
                break;
              }
            }
          }

          if (!attr) {
            attr = _defAttrs[1];
          }

          var _info = FormatInfos[attr.format];
          attributes.push(attr);
          vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count));
          channels.push({
            offset: stride,
            data: geometry.normals,
            attribute: attr
          });
          stride += _info.size;
        }

        if (geometry.uvs && geometry.uvs.length > 0) {
          attr = null;

          if (geometry.attributes) {
            for (var _iterator3 = _createForOfIteratorHelperLoose(geometry.attributes), _step3; !(_step3 = _iterator3()).done;) {
              var _att2 = _step3.value;

              if (_att2.name === AttributeName.ATTR_TEX_COORD) {
                attr = _att2;
                break;
              }
            }
          }

          if (!attr) {
            attr = _defAttrs[2];
          }

          var _info2 = FormatInfos[attr.format];
          attributes.push(attr);
          vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count));
          channels.push({
            offset: stride,
            data: geometry.uvs,
            attribute: attr
          });
          stride += _info2.size;
        }

        if (geometry.tangents && geometry.tangents.length > 0) {
          attr = null;

          if (geometry.attributes) {
            for (var _iterator4 = _createForOfIteratorHelperLoose(geometry.attributes), _step4; !(_step4 = _iterator4()).done;) {
              var _att3 = _step4.value;

              if (_att3.name === AttributeName.ATTR_TANGENT) {
                attr = _att3;
                break;
              }
            }
          }

          if (!attr) {
            attr = _defAttrs[3];
          }

          var _info3 = FormatInfos[attr.format];
          attributes.push(attr);
          vertCount = Math.max(vertCount, Math.floor(geometry.tangents.length / _info3.count));
          channels.push({
            offset: stride,
            data: geometry.tangents,
            attribute: attr
          });
          stride += _info3.size;
        }

        if (geometry.colors && geometry.colors.length > 0) {
          attr = null;

          if (geometry.attributes) {
            for (var _iterator5 = _createForOfIteratorHelperLoose(geometry.attributes), _step5; !(_step5 = _iterator5()).done;) {
              var _att4 = _step5.value;

              if (_att4.name === AttributeName.ATTR_COLOR) {
                attr = _att4;
                break;
              }
            }
          }

          if (!attr) {
            attr = _defAttrs[4];
          }

          var _info4 = FormatInfos[attr.format];
          attributes.push(attr);
          vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info4.count));
          channels.push({
            offset: stride,
            data: geometry.colors,
            attribute: attr
          });
          stride += _info4.size;
        }

        if (geometry.customAttributes) {
          for (var k = 0; k < geometry.customAttributes.length; k++) {
            var ca = geometry.customAttributes[k];
            var _info5 = FormatInfos[ca.attr.format];
            attributes.push(ca.attr);
            vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info5.count));
            channels.push({
              offset: stride,
              data: ca.values,
              attribute: ca.attr
            });
            stride += _info5.size;
          }
        }

        var bufferBlob = new BufferBlob();
        var vertexBuffer = new ArrayBuffer(vertCount * stride);
        var vertexBufferView = new DataView(vertexBuffer);

        for (var _i = 0, _channels = channels; _i < _channels.length; _i++) {
          var channel = _channels[_i];
          writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
        }

        bufferBlob.setNextAlignment(0);
        var vertexBundle = {
          attributes: attributes,
          view: {
            offset: bufferBlob.getLength(),
            length: vertexBuffer.byteLength,
            count: vertCount,
            stride: stride
          }
        };
        bufferBlob.addBuffer(vertexBuffer);
        var indexBuffer = null;
        var idxCount = 0;
        var idxStride = 2;

        if (geometry.indices) {
          var indices = geometry.indices;
          idxCount = indices.length;
          indexBuffer = new ArrayBuffer(idxStride * idxCount);
          var indexBufferView = new DataView(indexBuffer);
          writeBuffer(indexBufferView, indices, Format.R16UI);
        }

        var primitive = {
          primitiveMode: geometry.primitiveMode || PrimitiveMode.TRIANGLE_LIST,
          vertexBundelIndices: [0]
        };

        if (indexBuffer) {
          bufferBlob.setNextAlignment(idxStride);
          primitive.indexView = {
            offset: bufferBlob.getLength(),
            length: indexBuffer.byteLength,
            count: idxCount,
            stride: idxStride
          };
          bufferBlob.addBuffer(indexBuffer);
        }

        var minPosition = geometry.minPos;

        if (!minPosition && options.calculateBounds) {
          minPosition = Vec3.set(new Vec3(), Infinity, Infinity, Infinity);

          for (var iVertex = 0; iVertex < vertCount; ++iVertex) {
            Vec3.set(v3_1$1, positions[iVertex * 3 + 0], positions[iVertex * 3 + 1], positions[iVertex * 3 + 2]);
            Vec3.min(minPosition, minPosition, v3_1$1);
          }
        }

        var maxPosition = geometry.maxPos;

        if (!maxPosition && options.calculateBounds) {
          maxPosition = Vec3.set(new Vec3(), -Infinity, -Infinity, -Infinity);

          for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) {
            Vec3.set(v3_1$1, positions[_iVertex * 3 + 0], positions[_iVertex * 3 + 1], positions[_iVertex * 3 + 2]);
            Vec3.max(maxPosition, maxPosition, v3_1$1);
          }
        }

        var meshStruct = {
          vertexBundles: [vertexBundle],
          primitives: [primitive]
        };

        if (minPosition) {
          meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z);
        }

        if (maxPosition) {
          meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z);
        }

        if (!out) {
          out = new Mesh();
        }

        out.reset({
          struct: meshStruct,
          data: new Uint8Array(bufferBlob.getCombined())
        });
        return out;
      }

      function getPadding(length, align) {
        if (align > 0) {
          var remainder = length % align;

          if (remainder !== 0) {
            var padding = align - remainder;
            return padding;
          }
        }

        return 0;
      }

      function _createDynamicMesh(primitiveIndex, geometry, out, options) {
        options = options || {
          maxSubMeshes: 1,
          maxSubMeshVertices: 1024,
          maxSubMeshIndices: 1024
        };
        var attributes = [];
        var stream = 0;

        if (geometry.positions.length > 0) {
          attributes.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F, false, stream++, false, 0));
        }

        if (geometry.normals && geometry.normals.length > 0) {
          attributes.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F, false, stream++, false, 0));
        }

        if (geometry.uvs && geometry.uvs.length > 0) {
          attributes.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F, false, stream++, false, 0));
        }

        if (geometry.tangents && geometry.tangents.length > 0) {
          attributes.push(new Attribute(AttributeName.ATTR_TANGENT, Format.RGBA32F, false, stream++, false, 0));
        }

        if (geometry.colors && geometry.colors.length > 0) {
          attributes.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F, false, stream++, false, 0));
        }

        if (geometry.customAttributes) {
          for (var k = 0; k < geometry.customAttributes.length; k++) {
            var ca = geometry.customAttributes[k];
            var attr = new Attribute();
            attr.copy(ca.attr);
            attr.stream = stream++;
            attributes.push(attr);
          }
        }

        var vertexBundles = [];
        var primitives = [];
        var dataSize = 0;

        for (var i = 0; i < options.maxSubMeshes; i++) {
          var primitive = {
            vertexBundelIndices: [],
            primitiveMode: geometry.primitiveMode || PrimitiveMode.TRIANGLE_LIST
          };

          for (var _iterator6 = _createForOfIteratorHelperLoose(attributes), _step6; !(_step6 = _iterator6()).done;) {
            var _attr = _step6.value;
            var formatInfo = FormatInfos[_attr.format];
            var vertexBufferSize = options.maxSubMeshVertices * formatInfo.size;
            var vertexView = {
              offset: dataSize,
              length: vertexBufferSize,
              count: 0,
              stride: formatInfo.size
            };
            var vertexBundle = {
              view: vertexView,
              attributes: [_attr]
            };
            var vertexBundleIndex = vertexBundles.length;
            primitive.vertexBundelIndices.push(vertexBundleIndex);
            vertexBundles.push(vertexBundle);
            dataSize += vertexBufferSize;
          }

          var stride = 0;

          if (geometry.indices16 && geometry.indices16.length > 0) {
            stride = 2;
          } else if (geometry.indices32 && geometry.indices32.length > 0) {
            stride = 4;
          }

          if (stride > 0) {
            dataSize += getPadding(dataSize, stride);
            var indexBufferSize = options.maxSubMeshIndices * stride;
            var indexView = {
              offset: dataSize,
              length: indexBufferSize,
              count: 0,
              stride: stride
            };
            primitive.indexView = indexView;
            dataSize += indexBufferSize;
          }

          primitives.push(primitive);
        }

        var dynamicInfo = {
          maxSubMeshes: options.maxSubMeshes,
          maxSubMeshVertices: options.maxSubMeshVertices,
          maxSubMeshIndices: options.maxSubMeshIndices
        };
        var dynamicStruct = {
          info: dynamicInfo,
          bounds: []
        };
        dynamicStruct.bounds.length = options.maxSubMeshes;
        var meshStruct = {
          vertexBundles: vertexBundles,
          primitives: primitives,
          dynamic: dynamicStruct
        };
        var createInfo = {
          struct: meshStruct,
          data: new Uint8Array(dataSize)
        };

        if (!out) {
          out = new Mesh();
        }

        out.reset(createInfo);
        out.initialize();
        out.updateSubMesh(primitiveIndex, geometry);
        return out;
      }

      var MeshUtils = function () {
        function MeshUtils() {}

        MeshUtils.createMesh = function createMesh(geometry, out, options) {
          return _createMesh(geometry, out, options);
        };

        MeshUtils.createDynamicMesh = function createDynamicMesh(primitiveIndex, geometry, out, options) {
          return _createDynamicMesh(primitiveIndex, geometry, out, options);
        };

        return MeshUtils;
      }();

      var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        find: find,
        toPPM: toPPM,
        readMesh: readMesh,
        createMesh: _createMesh,
        MeshUtils: MeshUtils,
        readBuffer: readBuffer,
        writeBuffer: writeBuffer,
        mapBuffer: mapBuffer
      });
      exports('utils', utils);

      var _dec$1, _class$1, _class2$1, _temp$1;
      var INSET_LEFT = 0;
      var INSET_TOP = 1;
      var INSET_RIGHT = 2;
      var INSET_BOTTOM = 3;
      var temp_vec3 = new Vec3();
      var temp_matrix = new Mat4();
      var MeshType;

      (function (MeshType) {
        MeshType[MeshType["RECT"] = 0] = "RECT";
        MeshType[MeshType["POLYGON"] = 1] = "POLYGON";
      })(MeshType || (MeshType = {}));

      var temp_uvs = [{
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }];
      var SpriteFrame = exports('SpriteFrame', (_dec$1 = ccclass('cc.SpriteFrame'), _dec$1(_class$1 = (_temp$1 = _class2$1 = function (_Asset) {
        _inheritsLoose(SpriteFrame, _Asset);

        SpriteFrame.createWithImage = function createWithImage(imageSourceOrImageAsset) {
          var img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset);
          var tex = new Texture2D();
          tex.image = img;
          var spf = new SpriteFrame();
          spf.texture = tex;
          return spf;
        };

        function SpriteFrame() {
          var _this;

          _this = _Asset.call(this) || this;
          _this.vertices = null;
          _this.uv = [];
          _this.unbiasUV = [];
          _this.uvSliced = [];
          _this._rect = new Rect();
          _this._trimmedBorder = new Vec4();
          _this._offset = new Vec2();
          _this._originalSize = new Size();
          _this._rotated = false;
          _this._capInsets = [0, 0, 0, 0];
          _this._atlasUuid = '';
          _this._texture = void 0;
          _this._isFlipUVY = false;
          _this._isFlipUVX = false;
          _this._original = null;
          _this._packable = true;
          _this._pixelsToUnit = 100;
          _this._pivot = new Vec2(0.5, 0.5);
          _this._meshType = MeshType.RECT;
          _this._extrude = 0;
          _this._customOutLine = [];
          _this._minPos = new Vec3();
          _this._maxPos = new Vec3();

          return _this;
        }

        var _proto = SpriteFrame.prototype;

        _proto.textureLoaded = function textureLoaded() {
          return !!this.texture;
        };

        _proto.isRotated = function isRotated() {
          return this._rotated;
        };

        _proto.setRotated = function setRotated(rotated) {
          this.rotated = rotated;
        };

        _proto.getRect = function getRect(out) {
          if (out) {
            out.set(this._rect);
            return out;
          }

          return this._rect.clone();
        };

        _proto.setRect = function setRect(rect) {
          this.rect = rect;
        };

        _proto.getOriginalSize = function getOriginalSize(out) {
          if (out) {
            out.set(this._originalSize);
            return out;
          }

          return this._originalSize.clone();
        };

        _proto.setOriginalSize = function setOriginalSize(size) {
          this.originalSize = size;
        };

        _proto.getOffset = function getOffset(out) {
          if (out) {
            out.set(this._offset);
            return out;
          }

          return this._offset.clone();
        };

        _proto.setOffset = function setOffset(offset) {
          this.offset = offset;
        };

        _proto.getGFXTexture = function getGFXTexture() {
          return this._texture.getGFXTexture();
        };

        _proto.getGFXSampler = function getGFXSampler() {
          return this._texture.getGFXSampler();
        };

        _proto.getHash = function getHash() {
          return this._texture.getHash();
        };

        _proto.getSamplerInfo = function getSamplerInfo() {
          return this._texture.getSamplerInfo();
        };

        _proto.reset = function reset(info, clearData) {
          if (clearData === void 0) {
            clearData = false;
          }

          var calUV = false;

          if (clearData) {
            this._originalSize.set(0, 0);

            this._rect.set(0, 0, 0, 0);

            this._offset.set(0, 0);

            this._capInsets = [0, 0, 0, 0];
            this._rotated = false;
            calUV = true;
          }

          if (info) {
            if (info.texture) {
              this._rect.x = this._rect.y = 0;
              this._rect.width = info.texture.width;
              this._rect.height = info.texture.height;

              this._refreshTexture(info.texture);

              this.checkRect(this._texture);
            }

            if (info.originalSize) {
              this._originalSize.set(info.originalSize);
            }

            if (info.rect) {
              this._rect.set(info.rect);
            }

            if (info.offset) {
              this._offset.set(info.offset);
            }

            if (info.borderTop !== undefined) {
              this._capInsets[INSET_TOP] = info.borderTop;
            }

            if (info.borderBottom !== undefined) {
              this._capInsets[INSET_BOTTOM] = info.borderBottom;
            }

            if (info.borderLeft !== undefined) {
              this._capInsets[INSET_LEFT] = info.borderLeft;
            }

            if (info.borderRight !== undefined) {
              this._capInsets[INSET_RIGHT] = info.borderRight;
            }

            if (info.isRotate !== undefined) {
              this._rotated = !!info.isRotate;
            }

            if (info.isFlipUv !== undefined) {
              this._isFlipUVY = !!info.isFlipUv;
            }

            calUV = true;
          }

          if (calUV && this.texture) {
            this._calculateUV();
          }

          this._calcTrimmedBorder();
        };

        _proto.checkRect = function checkRect(texture) {
          var rect = this._rect;
          var maxX = rect.x;
          var maxY = rect.y;

          if (this._rotated) {
            maxX += rect.height;
            maxY += rect.width;
          } else {
            maxX += rect.width;
            maxY += rect.height;
          }

          if (maxX > texture.width) {
            errorID(3300, this.name + "/" + texture.name, maxX, texture.width);
            return false;
          }

          if (maxY > texture.height) {
            errorID(3301, this.name + "/" + texture.name, maxY, texture.height);
            return false;
          }

          return true;
        };

        _proto._calcTrimmedBorder = function _calcTrimmedBorder() {
          var ow = this._originalSize.width;
          var oh = this._originalSize.height;
          var rw = this._rect.width;
          var rh = this._rect.height;
          var halfTrimmedWidth = (ow - rw) * 0.5;
          var halfTrimmedHeight = (oh - rh) * 0.5;
          this._trimmedBorder.x = this._offset.x + halfTrimmedWidth;
          this._trimmedBorder.y = this._offset.x - halfTrimmedWidth;
          this._trimmedBorder.z = this._offset.y + halfTrimmedHeight;
          this._trimmedBorder.w = this._offset.y - halfTrimmedHeight;
        };

        _proto.ensureMeshData = function ensureMeshData() {
          if (this._mesh) return;

          this._initVertices();

          this._createMesh();
        };

        _proto.destroy = function destroy() {
          if (this._packable && dynamicAtlasManager) {
            dynamicAtlasManager.deleteAtlasSpriteFrame(this);
          }

          return _Asset.prototype.destroy.call(this);
        };

        _proto._calculateSlicedUV = function _calculateSlicedUV() {
          var rect = this._rect;
          var tex = this.texture;
          var atlasWidth = tex.width;
          var atlasHeight = tex.height;
          var leftWidth = this._capInsets[INSET_LEFT];
          var rightWidth = this._capInsets[INSET_RIGHT];
          var centerWidth = rect.width - leftWidth - rightWidth;
          var topHeight = this._capInsets[INSET_TOP];
          var bottomHeight = this._capInsets[INSET_BOTTOM];
          var centerHeight = rect.height - topHeight - bottomHeight;
          var uvSliced = this.uvSliced;
          uvSliced.length = 0;

          if (this._rotated) {
            temp_uvs[0].u = rect.x / atlasWidth;
            temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
            temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
            temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
            temp_uvs[3].v = rect.y / atlasHeight;
            temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
            temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
            temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;

            for (var row = 0; row < 4; ++row) {
              var rowD = temp_uvs[row];

              for (var col = 0; col < 4; ++col) {
                var colD = temp_uvs[3 - col];
                uvSliced.push({
                  u: rowD.u,
                  v: colD.v
                });
              }
            }
          } else {
            temp_uvs[0].u = rect.x / atlasWidth;
            temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
            temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
            temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
            temp_uvs[3].v = rect.y / atlasHeight;
            temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
            temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
            temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;

            for (var _row = 0; _row < 4; ++_row) {
              var _rowD = temp_uvs[_row];

              for (var _col = 0; _col < 4; ++_col) {
                var _colD = temp_uvs[_col];
                uvSliced.push({
                  u: _colD.u,
                  v: _rowD.v
                });
              }
            }
          }

          this.emit(SpriteFrame.EVENT_UV_UPDATED, this);
        };

        _proto._calculateUV = function _calculateUV() {
          var rect = this._rect;
          var uv = this.uv;
          var unbiasUV = this.unbiasUV;
          var tex = this.texture;
          var texw = tex.width;
          var texh = tex.height;

          if (this._rotated) {
            var l = texw === 0 ? 0 : rect.x / texw;
            var r = texw === 0 ? 1 : (rect.x + rect.height) / texw;
            var t = texh === 0 ? 0 : rect.y / texh;
            var b = texh === 0 ? 1 : (rect.y + rect.width) / texh;

            if (this._isFlipUVX && this._isFlipUVY) {
              uv[0] = r;
              uv[1] = b;
              uv[2] = r;
              uv[3] = t;
              uv[4] = l;
              uv[5] = b;
              uv[6] = l;
              uv[7] = t;
            } else if (this._isFlipUVX) {
              uv[0] = r;
              uv[1] = t;
              uv[2] = r;
              uv[3] = b;
              uv[4] = l;
              uv[5] = t;
              uv[6] = l;
              uv[7] = b;
            } else if (this._isFlipUVY) {
              uv[0] = l;
              uv[1] = b;
              uv[2] = l;
              uv[3] = t;
              uv[4] = r;
              uv[5] = b;
              uv[6] = r;
              uv[7] = t;
            } else {
              uv[0] = l;
              uv[1] = t;
              uv[2] = l;
              uv[3] = b;
              uv[4] = r;
              uv[5] = t;
              uv[6] = r;
              uv[7] = b;
            }

            var ul = texw === 0 ? 0 : rect.x / texw;
            var ur = texw === 0 ? 1 : (rect.x + rect.height) / texw;
            var ut = texh === 0 ? 0 : rect.y / texh;
            var ub = texh === 0 ? 1 : (rect.y + rect.width) / texh;

            if (this._isFlipUVX && this._isFlipUVY) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ub;
              unbiasUV[2] = ur;
              unbiasUV[3] = ut;
              unbiasUV[4] = ul;
              unbiasUV[5] = ub;
              unbiasUV[6] = ul;
              unbiasUV[7] = ut;
            } else if (this._isFlipUVX) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ut;
              unbiasUV[2] = ur;
              unbiasUV[3] = ub;
              unbiasUV[4] = ul;
              unbiasUV[5] = ut;
              unbiasUV[6] = ul;
              unbiasUV[7] = ub;
            } else if (this._isFlipUVY) {
              unbiasUV[0] = ul;
              unbiasUV[1] = ub;
              unbiasUV[2] = ul;
              unbiasUV[3] = ut;
              unbiasUV[4] = ur;
              unbiasUV[5] = ub;
              unbiasUV[6] = ur;
              unbiasUV[7] = ut;
            } else {
              unbiasUV[0] = ul;
              unbiasUV[1] = ut;
              unbiasUV[2] = ul;
              unbiasUV[3] = ub;
              unbiasUV[4] = ur;
              unbiasUV[5] = ut;
              unbiasUV[6] = ur;
              unbiasUV[7] = ub;
            }
          } else {
            var _l = texw === 0 ? 0 : rect.x / texw;

            var _r = texw === 0 ? 1 : (rect.x + rect.width) / texw;

            var _b = texh === 0 ? 1 : (rect.y + rect.height) / texh;

            var _t = texh === 0 ? 0 : rect.y / texh;

            if (this._isFlipUVX && this._isFlipUVY) {
              uv[0] = _r;
              uv[1] = _t;
              uv[2] = _l;
              uv[3] = _t;
              uv[4] = _r;
              uv[5] = _b;
              uv[6] = _l;
              uv[7] = _b;
            } else if (this._isFlipUVX) {
              uv[0] = _r;
              uv[1] = _b;
              uv[2] = _l;
              uv[3] = _b;
              uv[4] = _r;
              uv[5] = _t;
              uv[6] = _l;
              uv[7] = _t;
            } else if (this._isFlipUVY) {
              uv[0] = _l;
              uv[1] = _t;
              uv[2] = _r;
              uv[3] = _t;
              uv[4] = _l;
              uv[5] = _b;
              uv[6] = _r;
              uv[7] = _b;
            } else {
              uv[0] = _l;
              uv[1] = _b;
              uv[2] = _r;
              uv[3] = _b;
              uv[4] = _l;
              uv[5] = _t;
              uv[6] = _r;
              uv[7] = _t;
            }

            var _ul = texw === 0 ? 0 : rect.x / texw;

            var _ur = texw === 0 ? 1 : (rect.x + rect.width) / texw;

            var _ub = texh === 0 ? 1 : (rect.y + rect.height) / texh;

            var _ut = texh === 0 ? 0 : rect.y / texh;

            if (this._isFlipUVX && this._isFlipUVY) {
              unbiasUV[0] = _ur;
              unbiasUV[1] = _ut;
              unbiasUV[2] = _ul;
              unbiasUV[3] = _ut;
              unbiasUV[4] = _ur;
              unbiasUV[5] = _ub;
              unbiasUV[6] = _ul;
              unbiasUV[7] = _ub;
            } else if (this._isFlipUVX) {
              unbiasUV[0] = _ur;
              unbiasUV[1] = _ub;
              unbiasUV[2] = _ul;
              unbiasUV[3] = _ub;
              unbiasUV[4] = _ur;
              unbiasUV[5] = _ut;
              unbiasUV[6] = _ul;
              unbiasUV[7] = _ut;
            } else if (this._isFlipUVY) {
              unbiasUV[0] = _ul;
              unbiasUV[1] = _ut;
              unbiasUV[2] = _ur;
              unbiasUV[3] = _ut;
              unbiasUV[4] = _ul;
              unbiasUV[5] = _ub;
              unbiasUV[6] = _ur;
              unbiasUV[7] = _ub;
            } else {
              unbiasUV[0] = _ul;
              unbiasUV[1] = _ub;
              unbiasUV[2] = _ur;
              unbiasUV[3] = _ub;
              unbiasUV[4] = _ul;
              unbiasUV[5] = _ut;
              unbiasUV[6] = _ur;
              unbiasUV[7] = _ut;
            }
          }

          this._calculateSlicedUV();
        };

        _proto._setDynamicAtlasFrame = function _setDynamicAtlasFrame(frame) {
          if (!frame) return;
          this._original = {
            _texture: this._texture,
            _x: this._rect.x,
            _y: this._rect.y
          };
          this._texture = frame.texture;
          this._rect.x = frame.x;
          this._rect.y = frame.y;

          this._calculateUV();
        };

        _proto._resetDynamicAtlasFrame = function _resetDynamicAtlasFrame() {
          if (!this._original) return;
          this._rect.x = this._original._x;
          this._rect.y = this._original._y;
          this._texture = this._original._texture;
          this._original = null;

          this._calculateUV();
        };

        _proto._checkPackable = function _checkPackable() {
          var dynamicAtlas = dynamicAtlasManager;
          if (!dynamicAtlas) return;
          var texture = this._texture;

          if (!(texture instanceof Texture2D) || texture.isCompressed) {
            this._packable = false;
            return;
          }

          var w = this.width;
          var h = this.height;

          if (!texture.image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {
            this._packable = false;
            return;
          }

          if (texture.image && texture.image instanceof HTMLCanvasElement) {
            this._packable = true;
          }
        };

        _proto._serialize = function _serialize(ctxForExporting) {

          return null;
        };

        _proto._deserialize = function _deserialize(serializeData, handle) {
          var data = serializeData;
          var rect = data.rect;

          if (rect) {
            this._rect = new Rect(rect.x, rect.y, rect.width, rect.height);
          }

          var offset = data.offset;

          if (data.offset) {
            this._offset = new Vec2(offset.x, offset.y);
          }

          var originalSize = data.originalSize;

          if (data.originalSize) {
            this._originalSize = new Size(originalSize.width, originalSize.height);
          }

          this._rotated = !!data.rotated;
          this._name = data.name;
          this._packable = !!data.packable;
          this._pixelsToUnit = data.pixelsToUnit;
          var pivot = data.pivot;

          if (pivot) {
            this._pivot = new Vec2(pivot.x, pivot.y);
          }

          this._meshType = data.meshType;
          var capInsets = data.capInsets;

          if (capInsets) {
            this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
            this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
            this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
            this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
          }

          var vertices = data.vertices;

          if (vertices) {
            if (!this.vertices) {
              this.vertices = {
                rawPosition: [],
                positions: [],
                indexes: vertices.indexes,
                uv: vertices.uv,
                nuv: vertices.nuv,
                minPos: new Vec3(vertices.minPos.x, vertices.minPos.y, vertices.minPos.z),
                maxPos: new Vec3(vertices.maxPos.x, vertices.maxPos.y, vertices.maxPos.z)
              };
            }

            this.vertices.rawPosition.length = 0;
            var rawPosition = vertices.rawPosition;

            for (var i = 0; i < rawPosition.length; i += 3) {
              this.vertices.rawPosition.push(new Vec3(rawPosition[i], rawPosition[i + 1], rawPosition[i + 2]));
            }

            this._updateMeshVertices();
          }
        };

        _proto.clone = function clone() {
          var _sp$uv, _sp$unbiasUV, _sp$uvSliced, _sp$_capInsets;

          var sp = new SpriteFrame();
          var v = this.vertices;
          sp.vertices = v ? {
            rawPosition: v.rawPosition.slice(0),
            positions: v.positions.slice(0),
            indexes: v.indexes.slice(0),
            uv: v.uv.slice(0),
            nuv: v.nuv.slice(0),
            minPos: v.minPos.clone(),
            maxPos: v.minPos.clone()
          } : null;

          (_sp$uv = sp.uv).splice.apply(_sp$uv, [0, sp.uv.length].concat(this.uv));

          (_sp$unbiasUV = sp.unbiasUV).splice.apply(_sp$unbiasUV, [0, sp.unbiasUV.length].concat(this.unbiasUV));

          (_sp$uvSliced = sp.uvSliced).splice.apply(_sp$uvSliced, [0, sp.uvSliced.length].concat(this.uvSliced));

          sp._rect.set(this._rect);

          sp._offset.set(this._offset);

          sp._originalSize.set(this._originalSize);

          sp._rotated = this._rotated;

          (_sp$_capInsets = sp._capInsets).splice.apply(_sp$_capInsets, [0, sp._capInsets.length].concat(this._capInsets));

          sp._atlasUuid = this._atlasUuid;
          sp._texture = this._texture;
          sp._isFlipUVX = this._isFlipUVX;
          sp._isFlipUVY = this._isFlipUVY;
          sp._pixelsToUnit = this._pixelsToUnit;

          sp._pivot.set(this._pivot);

          sp._meshType = this._meshType;
          return sp;
        };

        _proto._refreshTexture = function _refreshTexture(texture) {
          this._texture = texture;
          var tex = this._texture;
          var config = {};
          var isReset = false;

          if (this._rect.width === 0 || this._rect.height === 0 || !this.checkRect(tex)) {
            config.rect = new Rect(0, 0, tex.width, tex.height);
            isReset = true;
          }

          if (this._originalSize.width === 0 || this._originalSize.height === 0 || isReset) {
            config.originalSize = new Size(tex.width, tex.height);
            isReset = true;
          }

          if (isReset) {
            this.reset(config);
          }

          this._checkPackable();

          if (this._mesh) {
            this._updateMesh();
          }
        };

        _proto.onLoaded = function onLoaded() {
          this._calcTrimmedBorder();
        };

        _proto.initDefault = function initDefault(uuid) {
          _Asset.prototype.initDefault.call(this, uuid);

          var texture = new Texture2D();
          texture.initDefault();

          this._refreshTexture(texture);

          this._calculateUV();
        };

        _proto.validate = function validate() {
          return this._texture && this._rect && this._rect.width !== 0 && this._rect.height !== 0;
        };

        _proto._initVertices = function _initVertices() {
          if (!this.vertices) {
            this.vertices = {
              rawPosition: [],
              positions: [],
              indexes: [],
              uv: [],
              nuv: [],
              minPos: new Vec3(),
              maxPos: new Vec3()
            };
          } else {
            this.vertices.rawPosition.length = 0;
            this.vertices.positions.length = 0;
            this.vertices.indexes.length = 0;
            this.vertices.uv.length = 0;
            this.vertices.nuv.length = 0;
            this.vertices.minPos.set(0, 0, 0);
            this.vertices.maxPos.set(0, 0, 0);
          }

          if (this._meshType === MeshType.POLYGON) ; else {
            var tex = this.texture;
            var texw = tex.width;
            var texh = tex.height;
            var rect = this.rect;
            var width = rect.width;
            var height = rect.height;
            var rectX = rect.x;
            var rectY = texh - rect.y - height;
            var halfWidth = width / 2;
            var halfHeight = height / 2;
            var l = texw === 0 ? 0 : rectX / texw;
            var r = texw === 0 ? 1 : (rectX + width) / texw;
            var t = texh === 0 ? 1 : (rectY + height) / texh;
            var b = texh === 0 ? 0 : rect.y / texh;
            temp_vec3.set(-halfWidth, -halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX);
            this.vertices.uv.push(rectY + height);
            this.vertices.nuv.push(l);
            this.vertices.nuv.push(b);
            this.vertices.minPos.set(temp_vec3);
            temp_vec3.set(halfWidth, -halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX + width);
            this.vertices.uv.push(rectY + height);
            this.vertices.nuv.push(r);
            this.vertices.nuv.push(b);
            temp_vec3.set(-halfWidth, halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX);
            this.vertices.uv.push(rectY);
            this.vertices.nuv.push(l);
            this.vertices.nuv.push(t);
            temp_vec3.set(halfWidth, halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX + width);
            this.vertices.uv.push(rectY);
            this.vertices.nuv.push(r);
            this.vertices.nuv.push(t);
            this.vertices.maxPos.set(temp_vec3);
            this.vertices.indexes.push(0);
            this.vertices.indexes.push(1);
            this.vertices.indexes.push(2);
            this.vertices.indexes.push(2);
            this.vertices.indexes.push(1);
            this.vertices.indexes.push(3);
          }

          this._updateMeshVertices();
        };

        _proto._updateMeshVertices = function _updateMeshVertices() {
          temp_matrix.identity();
          var units = 1 / this._pixelsToUnit;
          var temp_vec3 = new Vec3(units, units, 1);
          temp_matrix.scale(temp_vec3);
          var PosX = -(this._pivot.x - 0.5) * this.rect.width * units;
          var PosY = -(this._pivot.y - 0.5) * this.rect.height * units;
          temp_vec3.set(PosX, PosY, 0);
          temp_matrix.translate(temp_vec3);
          var vertices = this.vertices;

          for (var i = 0; i < vertices.rawPosition.length; i++) {
            var pos = vertices.rawPosition[i];
            Vec3.transformMat4(temp_vec3, pos, temp_matrix);
            Vec3.toArray(vertices.positions, temp_vec3, 3 * i);
          }

          Vec3.transformMat4(this._minPos, vertices.minPos, temp_matrix);
          Vec3.transformMat4(this._maxPos, vertices.maxPos, temp_matrix);
        };

        _proto._createMesh = function _createMesh$1() {
          this._mesh = _createMesh({
            primitiveMode: PrimitiveMode.TRIANGLE_LIST,
            positions: this.vertices.positions,
            uvs: this.vertices.nuv,
            indices: this.vertices.indexes,
            minPos: this._minPos,
            maxPos: this._maxPos,
            attributes: [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F)]
          });
        };

        _proto._updateMesh = function _updateMesh() {
          if (this._mesh) {
            this._mesh.destroy();
          }

          this._initVertices();

          this._createMesh();
        };

        _createClass(SpriteFrame, [{
          key: "insetTop",
          get: function get() {
            return this._capInsets[INSET_TOP];
          },
          set: function set(value) {
            if (this._capInsets[INSET_TOP] === value) {
              return;
            }

            this._capInsets[INSET_TOP] = value;

            if (this._texture) {
              this._calculateSlicedUV();
            }
          }
        }, {
          key: "insetBottom",
          get: function get() {
            return this._capInsets[INSET_BOTTOM];
          },
          set: function set(value) {
            if (this._capInsets[INSET_BOTTOM] === value) {
              return;
            }

            this._capInsets[INSET_BOTTOM] = value;

            if (this._texture) {
              this._calculateSlicedUV();
            }
          }
        }, {
          key: "insetLeft",
          get: function get() {
            return this._capInsets[INSET_LEFT];
          },
          set: function set(value) {
            if (this._capInsets[INSET_LEFT] === value) {
              return;
            }

            this._capInsets[INSET_LEFT] = value;

            if (this._texture) {
              this._calculateSlicedUV();
            }
          }
        }, {
          key: "insetRight",
          get: function get() {
            return this._capInsets[INSET_RIGHT];
          },
          set: function set(value) {
            if (this._capInsets[INSET_RIGHT] === value) {
              return;
            }

            this._capInsets[INSET_RIGHT] = value;

            if (this._texture) {
              this._calculateSlicedUV();
            }
          }
        }, {
          key: "rect",
          get: function get() {
            return this._rect;
          },
          set: function set(value) {
            if (this._rect.equals(value)) {
              return;
            }

            this._rect.set(value);

            if (this._texture) {
              this._calculateUV();
            }

            this._calcTrimmedBorder();
          }
        }, {
          key: "originalSize",
          get: function get() {
            return this._originalSize;
          },
          set: function set(value) {
            if (this._originalSize.equals(value)) {
              return;
            }

            this._originalSize.set(value);

            if (this._texture) {
              this._calculateUV();
            }

            this._calcTrimmedBorder();
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset.set(value);

            this._calcTrimmedBorder();
          }
        }, {
          key: "rotated",
          get: function get() {
            return this._rotated;
          },
          set: function set(rotated) {
            if (this._rotated === rotated) {
              return;
            }

            this._rotated = rotated;

            if (this._texture) {
              this._calculateUV();
            }
          }
        }, {
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(value) {
            if (!value) {
              warnID(3122, this.name);
              return;
            }

            if (value === this._texture) {
              return;
            }

            this.reset({
              texture: value
            }, true);
          }
        }, {
          key: "atlasUuid",
          get: function get() {
            return this._atlasUuid;
          },
          set: function set(value) {
            this._atlasUuid = value;
          }
        }, {
          key: "width",
          get: function get() {
            return this._texture.width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._texture.height;
          }
        }, {
          key: "_textureSource",
          set: function set(value) {
            if (window.Build) {
              this._texture = value;
              return;
            }

            if (value) {
              this._refreshTexture(value);

              this._calculateUV();
            }
          }
        }, {
          key: "flipUVX",
          get: function get() {
            return this._isFlipUVX;
          },
          set: function set(value) {
            this._isFlipUVX = value;

            this._calculateUV();
          }
        }, {
          key: "flipUVY",
          get: function get() {
            return this._isFlipUVY;
          },
          set: function set(value) {
            this._isFlipUVY = value;

            this._calculateUV();
          }
        }, {
          key: "packable",
          get: function get() {
            return this._packable;
          },
          set: function set(value) {
            this._packable = value;
          }
        }, {
          key: "original",
          get: function get() {
            return this._original;
          }
        }, {
          key: "pixelsToUnit",
          get: function get() {
            return this._pixelsToUnit;
          }
        }, {
          key: "pivot",
          get: function get() {
            return this._pivot;
          }
        }, {
          key: "mesh",
          get: function get() {
            return this._mesh;
          }
        }, {
          key: "trimmedBorder",
          get: function get() {
            return this._trimmedBorder;
          }
        }]);

        return SpriteFrame;
      }(Asset), _class2$1.EVENT_UV_UPDATED = 'uv_updated', _class2$1.MeshType = MeshType, _temp$1)) || _class$1));
      legacyCC.SpriteFrame = SpriteFrame;

      var _dec$2, _class$2, _class2$2, _descriptor$1, _temp$2;
      var SpriteAtlas = exports('SpriteAtlas', (_dec$2 = ccclass('cc.SpriteAtlas'), _dec$2(_class$2 = (_class2$2 = (_temp$2 = function (_Asset) {
        _inheritsLoose(SpriteAtlas, _Asset);

        function SpriteAtlas() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "spriteFrames", _descriptor$1, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = SpriteAtlas.prototype;

        _proto.getTexture = function getTexture() {
          var keys = Object.keys(this.spriteFrames);

          if (keys.length > 0) {
            var spriteFrame = this.spriteFrames[keys[0]];
            return spriteFrame && spriteFrame.texture;
          } else {
            return null;
          }
        };

        _proto.getSpriteFrame = function getSpriteFrame(key) {
          var sf = this.spriteFrames[key];

          if (!sf) {
            return null;
          }

          if (!sf.name) {
            sf.name = key;
          }

          return sf;
        };

        _proto.getSpriteFrames = function getSpriteFrames() {
          var frames = [];
          var spriteFrames = this.spriteFrames;

          for (var _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
            var _key2 = _Object$keys[_i];
            frames.push(spriteFrames[_key2]);
          }

          return frames;
        };

        _proto._serialize = function _serialize(ctxForExporting) {
        };

        _proto._deserialize = function _deserialize(serializeData, handle) {
          var data = serializeData;
          this._name = data.name;
          var frames = data.spriteFrames;
          this.spriteFrames = createMap();

          for (var i = 0; i < frames.length; i += 2) {
            handle.result.push(this.spriteFrames, frames[i], frames[i + 1], getClassId(SpriteFrame));
          }
        };

        return SpriteAtlas;
      }(Asset), _temp$2), (_descriptor$1 = _applyDecoratedDescriptor(_class2$2.prototype, "spriteFrames", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return createMap();
        }
      })), _class2$2)) || _class$2));
      legacyCC.SpriteAtlas = SpriteAtlas;

      var _dec$3, _class$3;
      var Font = exports('Font', (_dec$3 = ccclass('cc.Font'), _dec$3(_class$3 = function (_Asset) {
        _inheritsLoose(Font, _Asset);

        function Font() {
          return _Asset.apply(this, arguments) || this;
        }

        return Font;
      }(Asset)) || _class$3));
      legacyCC.Font = Font;

      var _dec$4, _class$4, _class2$3, _descriptor$2, _temp$3;
      var TTFFont = exports('TTFFont', (_dec$4 = ccclass('cc.TTFFont'), _dec$4(_class$4 = (_class2$3 = (_temp$3 = function (_Font) {
        _inheritsLoose(TTFFont, _Font);

        function TTFFont() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Font.call.apply(_Font, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_fontFamily", _descriptor$2, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = TTFFont.prototype;

        _proto.initDefault = function initDefault(uuid) {
          this._fontFamily = 'Arial';

          _Font.prototype.initDefault.call(this, uuid);
        };

        _createClass(TTFFont, [{
          key: "_nativeAsset",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            this._fontFamily = value || 'Arial';
          }
        }, {
          key: "_nativeDep",
          get: function get() {
            return {
              uuid: this._uuid,
              __nativeName__: this._native,
              ext: extname(this._native),
              __isNative__: true
            };
          }
        }]);

        return TTFFont;
      }(Font), _temp$3), (_descriptor$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_fontFamily", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$3.prototype, "_nativeAsset", [override, string], Object.getOwnPropertyDescriptor(_class2$3.prototype, "_nativeAsset"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$3.prototype, "_nativeDep"), _class2$3.prototype)), _class2$3)) || _class$4));
      legacyCC.TTFFont = TTFFont;

      var _dec$5, _dec2, _class$5, _class2$4, _descriptor$3, _descriptor2$1, _descriptor3$1, _descriptor4, _temp$4;
      var FontLetterDefinition = function FontLetterDefinition() {
        this.u = 0;
        this.v = 0;
        this.w = 0;
        this.h = 0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.textureID = 0;
        this.valid = false;
        this.xAdvance = 0;
      };
      var FontAtlas = function () {
        function FontAtlas(texture) {
          this.letterDefinitions = {};
          this.texture = texture;
        }

        var _proto = FontAtlas.prototype;

        _proto.addLetterDefinitions = function addLetterDefinitions(letter, letterDefinition) {
          this.letterDefinitions[letter] = letterDefinition;
        };

        _proto.cloneLetterDefinition = function cloneLetterDefinition() {
          var copyLetterDefinitions = {};

          for (var _i = 0, _Object$keys = Object.keys(this.letterDefinitions); _i < _Object$keys.length; _i++) {
            var _key = _Object$keys[_i];
            var value = new FontLetterDefinition();
            mixin(value, this.letterDefinitions[_key]);
            copyLetterDefinitions[_key] = value;
          }

          return copyLetterDefinitions;
        };

        _proto.getTexture = function getTexture() {
          return this.texture;
        };

        _proto.getLetter = function getLetter(key) {
          return this.letterDefinitions[key];
        };

        _proto.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char, labelInfo) {
          var key = _char.charCodeAt(0);

          var hasKey = this.letterDefinitions.hasOwnProperty(key);
          var letter;

          if (hasKey) {
            letter = this.letterDefinitions[key];
          } else {
            letter = null;
          }

          return letter;
        };

        _proto.clear = function clear() {
          this.letterDefinitions = {};
        };

        return FontAtlas;
      }();
      var BitmapFont = exports('BitmapFont', (_dec$5 = ccclass('cc.BitmapFont'), _dec2 = type(SpriteFrame), _dec$5(_class$5 = (_class2$4 = (_temp$4 = function (_Font) {
        _inheritsLoose(BitmapFont, _Font);

        function BitmapFont() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
          }

          _this = _Font.call.apply(_Font, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "fntDataStr", _descriptor$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "spriteFrame", _descriptor2$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "fontSize", _descriptor3$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "fntConfig", _descriptor4, _assertThisInitialized(_this));

          return _this;
        }

        var _proto2 = BitmapFont.prototype;

        _proto2.onLoaded = function onLoaded() {
          var spriteFrame = this.spriteFrame;

          if (!this.fontDefDictionary && spriteFrame) {
            this.fontDefDictionary = new FontAtlas(spriteFrame.texture);
          }

          var fntConfig = this.fntConfig;

          if (!fntConfig) {
            warn('The fnt config is not exists!');
            return;
          }

          var fontDict = fntConfig.fontDefDictionary;

          for (var fontDef in fontDict) {
            var letter = new FontLetterDefinition();
            var rect = fontDict[fontDef].rect;
            letter.offsetX = fontDict[fontDef].xOffset;
            letter.offsetY = fontDict[fontDef].yOffset;
            letter.w = rect.width;
            letter.h = rect.height;
            letter.u = rect.x;
            letter.v = rect.y;
            letter.textureID = 0;
            letter.valid = true;
            letter.xAdvance = fontDict[fontDef].xAdvance;
            this.fontDefDictionary.addLetterDefinitions(fontDef, letter);
          }
        };

        return BitmapFont;
      }(Font), _temp$4), (_descriptor$3 = _applyDecoratedDescriptor(_class2$4.prototype, "fntDataStr", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$4.prototype, "spriteFrame", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$4.prototype, "fontSize", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -1;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2$4.prototype, "fntConfig", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$4)) || _class$5));
      legacyCC.BitmapFont = BitmapFont;

      var _dec$6, _class$6;
      var LabelAtlas = exports('LabelAtlas', (_dec$6 = ccclass('cc.LabelAtlas'), _dec$6(_class$6 = function (_BitmapFont) {
        _inheritsLoose(LabelAtlas, _BitmapFont);

        function LabelAtlas() {
          return _BitmapFont.apply(this, arguments) || this;
        }

        return LabelAtlas;
      }(BitmapFont)) || _class$6));
      legacyCC.LabelAtlas = LabelAtlas;

      var BASELINE_RATIO = exports('BASELINE_RATIO', 0.26);
      var _BASELINE_OFFSET = 0;

      var MIDDLE_RATIO = exports('MIDDLE_RATIO', (BASELINE_RATIO + 1) / 2 - BASELINE_RATIO);
      function getBaselineOffset() {
        return _BASELINE_OFFSET;
      }
      var MAX_CACHE_SIZE = 100;
      var pool = new Pool$1(2);

      pool.get = function () {
        return this._get() || {
          key: '',
          value: 0,
          prev: null,
          next: null
        };
      };

      var LRUCache = function () {
        function LRUCache(size) {
          this.count = 0;
          this.limit = 0;
          this.datas = {};
          this.limit = size;
        }

        var _proto = LRUCache.prototype;

        _proto.moveToHead = function moveToHead(node) {
          node.next = this.head;
          node.prev = null;
          if (this.head) this.head.prev = node;
          this.head = node;
          if (!this.tail) this.tail = node;
          this.count++;
          this.datas[node.key] = node;
        };

        _proto.put = function put(key, value) {
          var node = pool.get();
          node.key = key;
          node.value = value;

          if (this.count >= this.limit) {
            var discard = this.tail;
            delete this.datas[discard.key];
            this.count--;
            this.tail = discard.prev;
            this.tail.next = null;
            discard.prev = null;
            discard.next = null;
            pool.put(discard);
          }

          this.moveToHead(node);
        };

        _proto.remove = function remove(node) {
          if (node.prev) {
            node.prev.next = node.next;
          } else {
            this.head = node.next;
          }

          if (node.next) {
            node.next.prev = node.prev;
          } else {
            this.tail = node.prev;
          }

          delete this.datas[node.key];
          this.count--;
        };

        _proto.get = function get(key) {
          var node = this.datas[key];

          if (node) {
            this.remove(node);
            this.moveToHead(node);
            return node.value;
          }

          return null;
        };

        _proto.clear = function clear() {
          this.count = 0;
          this.datas = {};
          this.head = null;
          this.tail = null;
        };

        _proto.has = function has(key) {
          return !!this.datas[key];
        };

        _proto["delete"] = function _delete(key) {
          var node = this.datas[key];
          this.remove(node);
        };

        return LRUCache;
      }();

      var measureCache = new LRUCache(MAX_CACHE_SIZE);
      var WORD_REG = /([a-zA-Z0-9--]+|\S)/;
      var SYMBOL_REG = /^[!,.:;'}\]%\?>]/;
      var LAST_WORD_REG = /([a-zA-Z0-9--iI]+|\S)$/;
      var LAST_ENGLISH_REG = /[a-zA-Z0-9--iI]+$/;
      var FIRST_ENGLISH_REG = /^[a-zA-Z0-9--iI]/;
      function isUnicodeCJK(ch) {
        var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
        var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
        var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
        return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
      }
      function isUnicodeSpace(ch) {
        var chCode = ch.charCodeAt(0);
        return chCode >= 9 && chCode <= 13 || chCode === 32 || chCode === 133 || chCode === 160 || chCode === 5760 || chCode >= 8192 && chCode <= 8202 || chCode === 8232 || chCode === 8233 || chCode === 8239 || chCode === 8287 || chCode === 12288;
      }
      function safeMeasureText(ctx, string, desc) {
        var font = desc || ctx.font;
        var key = font + "\uD83C\uDFAE" + string;
        var cache = measureCache.get(key);

        if (cache !== null) {
          return cache;
        }

        var metric = ctx.measureText(string);
        var width = metric && metric.width || 0;
        measureCache.put(key, width);
        return width;
      }

      function _safeSubstring(targetString, startIndex, endIndex) {
        var newStartIndex = startIndex;
        var newEndIndex = endIndex;
        var startChar = targetString[startIndex];

        if (startChar >= "\uDC00" && startChar <= "\uDFFF") {
          newStartIndex--;
        }

        if (endIndex !== undefined) {
          if (endIndex - 1 !== startIndex) {
            var endChar = targetString[endIndex - 1];

            if (endChar >= "\uD800" && endChar <= "\uDBFF") {
              newEndIndex--;
            }
          } else if (startChar >= "\uD800" && startChar <= "\uDBFF") {
            newEndIndex++;
          }
        }

        return targetString.substring(newStartIndex, newEndIndex);
      }

      function isEnglishWordPartAtFirst(stringToken) {
        return FIRST_ENGLISH_REG.test(stringToken);
      }
      function isEnglishWordPartAtLast(stringToken) {
        return LAST_ENGLISH_REG.test(stringToken);
      }
      function getEnglishWordPartAtFirst(stringToken) {
        var result = FIRST_ENGLISH_REG.exec(stringToken);
        return result;
      }
      function getEnglishWordPartAtLast(stringToken) {
        var result = LAST_ENGLISH_REG.exec(stringToken);
        return result;
      }
      function fragmentText(stringToken, allWidth, maxWidth, measureText) {
        var wrappedWords = [];

        if (stringToken.length === 0 || maxWidth < 0) {
          wrappedWords.push('');
          return wrappedWords;
        }

        var text = stringToken;

        while (allWidth > maxWidth && text.length > 1) {
          var fuzzyLen = text.length * (maxWidth / allWidth) | 0;

          var tmpText = _safeSubstring(text, fuzzyLen);

          var width = allWidth - measureText(tmpText);
          var sLine = tmpText;
          var pushNum = 0;
          var checkWhile = 0;
          var checkCount = 100;

          while (width > maxWidth && checkWhile++ < checkCount) {
            fuzzyLen *= maxWidth / width;
            fuzzyLen |= 0;
            tmpText = _safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }

          checkWhile = 0;

          while (tmpText && width <= maxWidth && checkWhile++ < checkCount) {
            var exec = WORD_REG.exec(tmpText);
            pushNum = exec ? exec[0].length : 1;
            sLine = tmpText;
            fuzzyLen += pushNum;
            tmpText = _safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }

          fuzzyLen -= pushNum;

          if (fuzzyLen === 0) {
            fuzzyLen = 1;
            sLine = _safeSubstring(text, 1);
          } else if (fuzzyLen === 1 && text[0] >= "\uD800" && text[0] <= "\uDBFF") {
            fuzzyLen = 2;
            sLine = _safeSubstring(text, 2);
          }

          var sText = _safeSubstring(text, 0, fuzzyLen);

          var result = void 0;

          {
            if (SYMBOL_REG.test(sLine || tmpText)) {
              result = LAST_WORD_REG.exec(sText);
              fuzzyLen -= result ? result[0].length : 0;

              if (fuzzyLen === 0) {
                fuzzyLen = 1;
              }

              sLine = _safeSubstring(text, fuzzyLen);
              sText = _safeSubstring(text, 0, fuzzyLen);
            }
          }

          if (FIRST_ENGLISH_REG.test(sLine)) {
            result = LAST_ENGLISH_REG.exec(sText);

            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = _safeSubstring(text, fuzzyLen);
              sText = _safeSubstring(text, 0, fuzzyLen);
            }
          }

          if (wrappedWords.length === 0) {
            wrappedWords.push(sText);
          } else {
            sText = sText.trim();

            if (sText.length > 0) {
              wrappedWords.push(sText);
            }
          }

          text = sLine || tmpText;
          allWidth = measureText(text);
        }

        if (wrappedWords.length === 0) {
          wrappedWords.push(text);
        } else {
          text = text.trim();

          if (text.length > 0) {
            wrappedWords.push(text);
          }
        }

        return wrappedWords;
      }

      var _canvasPool;

      var CanvasPool = exports('CanvasPool', function () {
        function CanvasPool() {
          this.pool = [];
        }

        CanvasPool.getInstance = function getInstance() {
          if (!_canvasPool) {
            _canvasPool = new CanvasPool();
          }

          return _canvasPool;
        };

        var _proto = CanvasPool.prototype;

        _proto.get = function get() {
          var data = this.pool.pop();

          if (!data) {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            data = {
              canvas: canvas,
              context: context
            };
          }

          return data;
        };

        _proto.put = function put(canvas) {
          if (this.pool.length >= macro.MAX_LABEL_CANVAS_POOL_SIZE) {
            return;
          }

          this.pool.push(canvas);
        };

        return CanvasPool;
      }());
      var WHITE = Color.WHITE.clone();
      var space$1 = 0;
      var bleed = 2;

      var FontLetterDefinition$1 = function FontLetterDefinition() {
        this.u = 0;
        this.v = 0;
        this.w = 0;
        this.h = 0;
        this.texture = null;
        this.offsetX = 0;
        this.offsetY = 0;
        this.valid = false;
        this.xAdvance = 0;
      };

      var _backgroundStyle = "rgba(255, 255, 255, " + (1 / 255).toFixed(3) + ")";

      var BASELINE_OFFSET = getBaselineOffset();

      var LetterTexture = function () {
        function LetterTexture(_char, labelInfo) {
          this.image = null;
          this.labelInfo = void 0;
          this["char"] = void 0;
          this.data = null;
          this.canvas = null;
          this.context = null;
          this.width = 0;
          this.height = 0;
          this.offsetY = 0;
          this.hash = void 0;
          this["char"] = _char;
          this.labelInfo = labelInfo;
          this.hash = _char.charCodeAt(0) + labelInfo.hash;
        }

        var _proto2 = LetterTexture.prototype;

        _proto2.updateRenderData = function updateRenderData() {
          this._updateProperties();

          this._updateTexture();
        };

        _proto2.destroy = function destroy() {
          this.image = null;
          CanvasPool.getInstance().put(this.data);
        };

        _proto2._updateProperties = function _updateProperties() {
          this.data = CanvasPool.getInstance().get();
          this.canvas = this.data.canvas;
          this.context = this.data.context;

          if (this.context) {
            this.context.font = this.labelInfo.fontDesc;
            var width = safeMeasureText(this.context, this["char"], this.labelInfo.fontDesc);
            var blank = this.labelInfo.margin * 2 + bleed;
            this.width = parseFloat(width.toFixed(2)) + blank;
            this.height = (1 + BASELINE_RATIO) * this.labelInfo.fontSize + blank;
            this.offsetY = -(this.labelInfo.fontSize * BASELINE_RATIO) / 2;
          }

          if (this.canvas.width !== this.width) {
            this.canvas.width = this.width;
          }

          if (this.canvas.height !== this.height) {
            this.canvas.height = this.height;
          }

          if (!this.image) {
            this.image = new ImageAsset();
          }

          this.image.reset(this.canvas);
        };

        _proto2._updateTexture = function _updateTexture() {
          if (!this.context || !this.canvas) {
            return;
          }

          var context = this.context;
          var labelInfo = this.labelInfo;
          var width = this.canvas.width;
          var height = this.canvas.height;
          context.textAlign = 'center';
          context.textBaseline = 'alphabetic';
          context.clearRect(0, 0, width, height);
          context.fillStyle = _backgroundStyle;
          context.fillRect(0, 0, width, height);
          context.font = labelInfo.fontDesc;
          var fontSize = labelInfo.fontSize;
          var startX = width / 2;
          var startY = height / 2 + fontSize * MIDDLE_RATIO + fontSize * BASELINE_OFFSET;
          var color = labelInfo.color;
          context.lineJoin = 'round';
          context.fillStyle = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + 1 + ")";

          if (labelInfo.isOutlined) {
            var strokeColor = labelInfo.out || WHITE;
            context.strokeStyle = "rgba(" + strokeColor.r + ", " + strokeColor.g + ", " + strokeColor.b + ", " + strokeColor.a / 255 + ")";
            context.lineWidth = labelInfo.margin * 2;
            context.strokeText(this["char"], startX, startY);
          }

          context.fillText(this["char"], startX, startY);
        };

        return LetterTexture;
      }();

      var LetterRenderTexture = function (_Texture2D) {
        _inheritsLoose(LetterRenderTexture, _Texture2D);

        function LetterRenderTexture() {
          return _Texture2D.apply(this, arguments) || this;
        }

        var _proto3 = LetterRenderTexture.prototype;

        _proto3.initWithSize = function initWithSize(width, height, format) {
          if (format === void 0) {
            format = PixelFormat.RGBA8888;
          }

          this.reset({
            width: width,
            height: height,
            format: format
          });
        };

        _proto3.drawTextureAt = function drawTextureAt(image, x, y) {
          var gfxTexture = this.getGFXTexture();

          if (!image || !gfxTexture) {
            return;
          }

          var gfxDevice = this._getGFXDevice();

          if (!gfxDevice) {
            console.warn('Unable to get device');
            return;
          }

          var region = new BufferTextureCopy();
          region.texOffset.x = x;
          region.texOffset.y = y;
          region.texExtent.width = image.width;
          region.texExtent.height = image.height;
          gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
        };

        return LetterRenderTexture;
      }(Texture2D);
      var LetterAtlas = function () {
        function LetterAtlas(width, height) {
          this._x = space$1;
          this._y = space$1;
          this._nextY = space$1;
          this._width = 0;
          this._height = 0;
          this._halfBleed = 0;
          this._dirty = false;
          var texture = new LetterRenderTexture();
          texture.initWithSize(width, height);
          this.fontDefDictionary = new FontAtlas(texture);
          this._halfBleed = bleed / 2;
          this._width = width;
          this._height = height;
          director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
        }

        var _proto4 = LetterAtlas.prototype;

        _proto4.insertLetterTexture = function insertLetterTexture(letterTexture) {
          var texture = letterTexture.image;
          var device = director.root.device;

          if (!texture || !this.fontDefDictionary || !device) {
            return null;
          }

          var width = texture.width;
          var height = texture.height;

          if (this._x + width + space$1 > this._width) {
            this._x = space$1;
            this._y = this._nextY;
          }

          if (this._y + height > this._nextY) {
            this._nextY = this._y + height + space$1;
          }

          if (this._nextY > this._height) {
            warnID(12100);
            return null;
          }

          this.fontDefDictionary.texture.drawTextureAt(texture, this._x, this._y);
          this._dirty = true;
          var letterDefinition = new FontLetterDefinition$1();
          letterDefinition.u = this._x + this._halfBleed;
          letterDefinition.v = this._y + this._halfBleed;
          letterDefinition.texture = this.fontDefDictionary.texture;
          letterDefinition.valid = true;
          letterDefinition.w = letterTexture.width - bleed;
          letterDefinition.h = letterTexture.height - bleed;
          letterDefinition.xAdvance = letterDefinition.w;
          letterDefinition.offsetY = letterTexture.offsetY;
          this._x += width + space$1;
          this.fontDefDictionary.addLetterDefinitions(letterTexture.hash, letterDefinition);
          return letterDefinition;
        };

        _proto4.update = function update() {
          if (!this._dirty) {
            return;
          }

          this._dirty = false;
        };

        _proto4.reset = function reset() {
          this._x = space$1;
          this._y = space$1;
          this._nextY = space$1;
          this.fontDefDictionary.clear();
        };

        _proto4.destroy = function destroy() {
          this.reset();

          if (this.fontDefDictionary) {
            this.fontDefDictionary.texture.destroy();
            this.fontDefDictionary.texture = null;
          }
        };

        _proto4.getTexture = function getTexture() {
          return this.fontDefDictionary.getTexture();
        };

        _proto4.beforeSceneLoad = function beforeSceneLoad() {
          this.clearAllCache();
        };

        _proto4.clearAllCache = function clearAllCache() {
          this.destroy();
          var texture = new LetterRenderTexture();
          texture.initWithSize(this._width, this._height);
          this.fontDefDictionary.texture = texture;
        };

        _proto4.getLetter = function getLetter(key) {
          return this.fontDefDictionary.letterDefinitions[key];
        };

        _proto4.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char2, labelInfo) {
          var hash = _char2.charCodeAt(0) + labelInfo.hash;
          var letter = this.fontDefDictionary.letterDefinitions[hash];

          if (!letter) {
            var temp = new LetterTexture(_char2, labelInfo);
            temp.updateRenderData();
            letter = this.insertLetterTexture(temp);
            temp.destroy();
          }

          return letter;
        };

        _createClass(LetterAtlas, [{
          key: "width",
          get: function get() {
            return this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          }
        }]);

        return LetterAtlas;
      }();
      var shareLabelInfo = {
        fontAtlas: null,
        fontSize: 0,
        lineHeight: 0,
        hAlign: 0,
        vAlign: 0,
        hash: '',
        fontFamily: '',
        fontDesc: 'Arial',
        color: Color.WHITE.clone(),
        isOutlined: false,
        out: Color.WHITE.clone(),
        margin: 0
      };
      function computeHash(labelInfo) {
        var hashData = '';
        var color = labelInfo.color.toHEX();
        var out = '';

        if (labelInfo.isOutlined && labelInfo.margin > 0) {
          out = out + labelInfo.margin + labelInfo.out.toHEX();
        }

        return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
      }

      var vfmt = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F)];
      var vfmtPosColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      var vfmtPosUvColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      var vfmtPosUvColor4B = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
      var vfmtPosUvTwoColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA32F)];
      var vfmtPosUvTwoColor4B = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA8, true)];
      function getComponentPerVertex(attrs) {
        var count = 0;

        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          var info = FormatInfos[attr.format];
          count += info.count;
        }

        return count;
      }
      function getAttributeStride(attrs) {
        var count = 0;

        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          var info = FormatInfos[attr.format];
          count += info.size;
        }

        return count;
      }
      legacyCC.internal.vfmtPosUvColor = vfmtPosUvColor;
      legacyCC.internal.vfmtPosUvTwoColor = vfmtPosUvTwoColor;
      legacyCC.internal.vfmtPosUvColor4B = vfmtPosUvColor4B;
      legacyCC.internal.vfmtPosUvTwoColor4B = vfmtPosUvTwoColor4B;

      var vertexFormat = /*#__PURE__*/Object.freeze({
        __proto__: null,
        vfmt: vfmt,
        vfmtPosColor: vfmtPosColor,
        vfmtPosUvColor: vfmtPosUvColor,
        vfmtPosUvColor4B: vfmtPosUvColor4B,
        vfmtPosUvTwoColor: vfmtPosUvTwoColor,
        vfmtPosUvTwoColor4B: vfmtPosUvTwoColor4B,
        getComponentPerVertex: getComponentPerVertex,
        getAttributeStride: getAttributeStride
      });
      exports('UIVertexFormat', vertexFormat);

      var MeshBufferSharedBufferView;

      (function (MeshBufferSharedBufferView) {
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["byteOffset"] = 0] = "byteOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["vertexOffset"] = 1] = "vertexOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["indexOffset"] = 2] = "indexOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["dirty"] = 3] = "dirty";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["count"] = 4] = "count";
      })(MeshBufferSharedBufferView || (MeshBufferSharedBufferView = {}));

      var MeshBuffer = exports('MeshBuffer', function () {
        var _proto = MeshBuffer.prototype;

        _proto.initSharedBuffer = function initSharedBuffer() {
        };

        _proto.syncSharedBufferToNative = function syncSharedBufferToNative() {
        };

        function MeshBuffer() {
          this._byteOffset = 0;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._dirty = false;
          this._floatsPerVertex = 0;
          this._vData = null;
          this._iData = null;
          this._useLinkedData = false;
          this._vertexFormatBytes = 0;
          this._initVDataCount = 0;
          this._initIDataCount = 0;
          this._attributes = null;
          this._iaPool = [];
          this._iaInfo = null;
          this._nextFreeIAHandle = 0;

          this.initSharedBuffer();
          this.syncSharedBufferToNative();
        }

        _proto.initialize = function initialize(device, attrs, vFloatCount, iCount) {
          this._initVDataCount = vFloatCount;
          this._initIDataCount = iCount;
          this._attributes = attrs;
          this.floatsPerVertex = getAttributeStride(attrs) >> 2;
          assertIsTrue(this._initVDataCount / this._floatsPerVertex < 65536, getError(9005));

          if (!this.vData || !this.iData) {
            this.vData = new Float32Array(this._initVDataCount);
            this.iData = new Uint16Array(this._initIDataCount);
          }

          this._iaPool.push(this.createNewIA(device));
        };

        _proto.reset = function reset() {
          this._nextFreeIAHandle = 0;
          this.dirty = false;
        };

        _proto.destroy = function destroy() {
          this.reset();
          this._attributes = null;
          this._iaInfo = null;
          this.vData = null;
          this.iData = null;

          for (var i = 0; i < this._iaPool.length; ++i) {
            var iaRef = this._iaPool[i];

            if (iaRef.vertexBuffers[0]) {
              iaRef.vertexBuffers[0].destroy();
            }

            if (iaRef.indexBuffer) {
              iaRef.indexBuffer.destroy();
            }

            iaRef.ia.destroy();
          }

          this._iaPool.length = 0;
        };

        _proto.setDirty = function setDirty() {
          this.dirty = true;
        };

        _proto.request = function request(vertexCount, indexCount) {
          warnID(9002);
          return false;
        };

        _proto.requireFreeIA = function requireFreeIA(device) {
          if (this._iaPool.length <= this._nextFreeIAHandle) {
            this._iaPool.push(this.createNewIA(device));
          }

          var ia = this._iaPool[this._nextFreeIAHandle++].ia;
          return ia;
        };

        _proto.recycleIA = function recycleIA(ia) {
          var pool = this._iaPool;

          for (var i = 0; i < this._nextFreeIAHandle; ++i) {
            if (ia === pool[i].ia) {
              var iaRef = pool[i];
              pool[i] = pool[--this._nextFreeIAHandle];
              pool[this._nextFreeIAHandle] = iaRef;
              return;
            }
          }
        };

        _proto.checkCapacity = function checkCapacity(vertexCount, indexCount) {
          var maxVertex = (this.vertexOffset + vertexCount) * this._floatsPerVertex;
          var maxIndex = this.indexOffset + indexCount;

          if (maxVertex > this._initVDataCount || maxIndex > this._initIDataCount) {
            return false;
          }

          return true;
        };

        _proto.uploadBuffers = function uploadBuffers() {
          if (this.byteOffset === 0 || !this._dirty) {
            return;
          }

          var iOS14 = sys.__isWebIOS14OrIPadOS14Env;
          var submitCount = iOS14 ? this._nextFreeIAHandle : 1;
          var byteCount = this.byteOffset;
          var indexCount = this.indexOffset;

          for (var i = 0; i < submitCount; ++i) {
            var iaRef = this._iaPool[i];
            var verticesData = new Float32Array(this.vData.buffer, 0, byteCount >> 2);
            var indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
            var vertexBuffer = iaRef.vertexBuffers[0];

            if (byteCount > vertexBuffer.size) {
              vertexBuffer.resize(byteCount);
            }

            vertexBuffer.update(verticesData);

            if (indexCount * 2 > iaRef.indexBuffer.size) {
              iaRef.indexBuffer.resize(indexCount * 2);
            }

            iaRef.indexBuffer.update(indicesData);
          }

          this.dirty = false;
        };

        _proto.createNewIA = function createNewIA(device) {
          var ia;
          var vertexBuffers;
          var indexBuffer;

          if (sys.__isWebIOS14OrIPadOS14Env || !this._iaPool[0]) {
            var vbStride = this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
            var ibStride = Uint16Array.BYTES_PER_ELEMENT;
            var vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbStride, vbStride));
            indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, ibStride, ibStride));
            vertexBuffers = [vertexBuffer];
            this._iaInfo = new InputAssemblerInfo(this._attributes, vertexBuffers, indexBuffer);
            ia = device.createInputAssembler(this._iaInfo);
          } else {
            ia = device.createInputAssembler(this._iaInfo);
            vertexBuffers = this._iaInfo.vertexBuffers;
            indexBuffer = this._iaInfo.indexBuffer;
          }

          return {
            ia: ia,
            vertexBuffers: vertexBuffers,
            indexBuffer: indexBuffer
          };
        };

        _createClass(MeshBuffer, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexFormatBytes",
          get: function get() {
            return this._vertexFormatBytes;
          }
        }, {
          key: "byteOffset",
          get: function get() {
            return this._byteOffset;
          },
          set: function set(val) {
            this._byteOffset = val;
          }
        }, {
          key: "vertexOffset",
          get: function get() {
            return this._vertexOffset;
          },
          set: function set(val) {
            this._vertexOffset = val;
          }
        }, {
          key: "indexOffset",
          get: function get() {
            return this._indexOffset;
          },
          set: function set(val) {
            this._indexOffset = val;
          }
        }, {
          key: "dirty",
          get: function get() {
            return this._dirty;
          },
          set: function set(val) {
            this._dirty = val;
          }
        }, {
          key: "floatsPerVertex",
          get: function get() {
            return this._floatsPerVertex;
          },
          set: function set(val) {
            this._floatsPerVertex = val;
          }
        }, {
          key: "vData",
          get: function get() {
            return this._vData;
          },
          set: function set(val) {
            this._vData = val;
          }
        }, {
          key: "iData",
          get: function get() {
            return this._iData;
          },
          set: function set(val) {
            this._iData = val;
          }
        }, {
          key: "useLinkedData",
          get: function get() {
            return this._useLinkedData;
          },
          set: function set(val) {

            this._useLinkedData = val;
          }
        }, {
          key: "nativeObj",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "sharedBuffer",
          get: function get() {
            return this._sharedBuffer;
          }
        }]);

        return MeshBuffer;
      }());

      var BufferAccessor = function () {
        function BufferAccessor(device, attributes) {
          this._device = null;
          this._attributes = null;
          this._vertexFormatBytes = void 0;
          this._floatsPerVertex = void 0;
          this._buffers = [];
          this._device = device;
          this._attributes = attributes;
          this._floatsPerVertex = getAttributeStride(attributes) >> 2;
          this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
        }

        var _proto = BufferAccessor.prototype;

        _proto.initialize = function initialize() {};

        _proto.reset = function reset() {};

        _proto.request = function request(vertexCount, indexCount) {
        };

        _proto.appendBuffers = function appendBuffers(vertices, indices) {};

        _proto.uploadBuffers = function uploadBuffers() {};

        _proto.destroy = function destroy() {
          this._attributes.length = 0;
        };

        _createClass(BufferAccessor, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexFormatBytes",
          get: function get() {
            return this._vertexFormatBytes;
          }
        }, {
          key: "floatsPerVertex",
          get: function get() {
            return this._floatsPerVertex;
          }
        }]);

        return BufferAccessor;
      }();

      var _entryPool = new Pool(function () {
        return {
          offset: 0,
          length: 0
        };
      }, 32);

      var StaticVBChunk = function () {
        function StaticVBChunk(vertexAccessor, bufferId, meshBuffer, vertexOffset, vb, indexCount) {
          this._ib = void 0;
          this.vertexAccessor = vertexAccessor;
          this.bufferId = bufferId;
          this.meshBuffer = meshBuffer;
          this.vertexOffset = vertexOffset;
          this.vb = vb;
          this.indexCount = indexCount;
          this._ib = new Uint16Array(indexCount);
          assertIsTrue(meshBuffer === vertexAccessor.getMeshBuffer(bufferId));
        }

        var _proto = StaticVBChunk.prototype;

        _proto.setIndexBuffer = function setIndexBuffer(indices) {
        };

        _createClass(StaticVBChunk, [{
          key: "ib",
          get: function get() {
            return this._ib;
          }
        }]);

        return StaticVBChunk;
      }();
      var StaticVBAccessor = function (_BufferAccessor) {
        _inheritsLoose(StaticVBAccessor, _BufferAccessor);

        function StaticVBAccessor(device, attributes, vCount, iCount) {
          var _this;

          _this = _BufferAccessor.call(this, device, attributes) || this;
          _this._freeLists = [];
          _this._vCount = 0;
          _this._iCount = 0;
          _this._id = 0;
          _this._vCount = vCount || Math.floor(macro.BATCHER2D_MEM_INCREMENT * 1024 / _this._vertexFormatBytes);
          _this._iCount = iCount || _this._vCount * StaticVBAccessor.IB_SCALE;
          _this._id = StaticVBAccessor.generateID();

          _this._allocateBuffer();

          return _this;
        }

        var _proto2 = StaticVBAccessor.prototype;

        _proto2.destroy = function destroy() {
          for (var i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();

            var freeList = this._freeLists[i];

            for (var j = 0; j < freeList.length; ++j) {
              _entryPool.free(freeList[j]);
            }
          }

          this._buffers.length = 0;
          this._freeLists.length = 0;

          _BufferAccessor.prototype.destroy.call(this);
        };

        _proto2.reset = function reset() {
          for (var i = 0; i < this._buffers.length; ++i) {
            var buffer = this._buffers[i];
            buffer.indexOffset = 0;
            buffer.reset();
          }
        };

        _proto2.getVertexBuffer = function getVertexBuffer(bid) {
          return this._buffers[bid].vData;
        };

        _proto2.getIndexBuffer = function getIndexBuffer(bid) {
          return this._buffers[bid].iData;
        };

        _proto2.getMeshBuffer = function getMeshBuffer(bid) {
          return this._buffers[bid];
        };

        _proto2.uploadBuffers = function uploadBuffers() {
          for (var i = 0; i < this._buffers.length; ++i) {
            var firstEntry = this._freeLists[i][0];
            var buffer = this._buffers[i];

            if (!firstEntry || firstEntry.length < buffer.vData.byteLength) {
              buffer.uploadBuffers();
            }
          }
        };

        _proto2.appendIndices = function appendIndices(bufferId, indices) {
          var buf = this._buffers[bufferId];
          var iCount = indices.length;

          if (iCount) {
            buf.iData.set(indices, buf.indexOffset);
            buf.indexOffset += indices.length;
          }
        };

        _proto2.allocateChunk = function allocateChunk(vertexCount, indexCount) {
          var byteLength = vertexCount * this.vertexFormatBytes;
          var buf = null;
          var freeList;
          var bid = 0;
          var eid = -1;
          var entry = null;

          for (var i = 0; i < this._buffers.length; ++i) {
            buf = this._buffers[i];
            freeList = this._freeLists[i];

            for (var e = 0; e < freeList.length; ++e) {
              if (freeList[e].length >= byteLength) {
                entry = freeList[e];
                bid = i;
                eid = e;
                break;
              }
            }

            if (entry) break;
          }

          if (!entry) {
            bid = this._allocateBuffer();
            buf = this._buffers[bid];

            if (buf && buf.checkCapacity(vertexCount, indexCount)) {
              eid = 0;
              entry = this._freeLists[bid][eid];
            }
          }

          if (entry) {
            var _vertexOffset = entry.offset / this.vertexFormatBytes;

            assertIsTrue(Number.isInteger(_vertexOffset));

            var _vb = new Float32Array(buf.vData.buffer, entry.offset, byteLength >> 2).fill(0);

            this._allocateChunkFromEntry(bid, eid, entry, byteLength);

            return new StaticVBChunk(this, bid, buf, _vertexOffset, _vb, indexCount);
          } else {
            errorID(9004, byteLength);
            return null;
          }
        };

        _proto2.recycleChunk = function recycleChunk(chunk) {
          var freeList = this._freeLists[chunk.bufferId];
          var buf = this._buffers[chunk.bufferId];
          var offset = chunk.vertexOffset * this.vertexFormatBytes;
          var bytes = chunk.vb.byteLength;
          if (bytes === 0) return;
          var recycled = false;
          var i = 0;
          var prevEntry = null;
          var nextEntry = freeList[i];

          while (nextEntry && nextEntry.offset < offset) {
            prevEntry = nextEntry;
            nextEntry = freeList[++i];
          }

          if (prevEntry) {
            var distance = offset - (prevEntry.offset + prevEntry.length);
            assertIsTrue(distance >= 0);

            if (distance === 0) {
              prevEntry.length += bytes;
              offset = prevEntry.offset;
              bytes = prevEntry.length;

              if (nextEntry && nextEntry.offset - (offset + bytes) === 0) {
                prevEntry.length += nextEntry.length;
                freeList.splice(i, 1);

                _entryPool.free(nextEntry);

                nextEntry = null;
              }

              recycled = true;
            }
          }

          if (!recycled && nextEntry) {
            var _distance = nextEntry.offset - (offset + bytes);

            assertIsTrue(_distance >= 0);

            if (_distance === 0) {
              nextEntry.offset = offset;
              nextEntry.length += bytes;
            } else {
              var newEntry = _entryPool.alloc();

              newEntry.offset = offset;
              newEntry.length = bytes;
              freeList.splice(i, 0, newEntry);
            }

            recycled = true;
          }

          if (recycled) {
            if (offset + bytes === buf.byteOffset) {
              buf.byteOffset = offset;
            }
          } else {
            var _newEntry = _entryPool.alloc();

            _newEntry.offset = offset;
            _newEntry.length = bytes;
            freeList.push(_newEntry);
          }
        };

        _proto2._allocateChunkFromEntry = function _allocateChunkFromEntry(bid, eid, entry, bytes) {
          var remaining = entry.length - bytes;
          var offset = entry.offset + bytes;
          var buf = this._buffers[bid];

          if (buf.byteOffset < offset) {
            buf.byteOffset = offset;
          }

          assertID(remaining >= 0, 9004, bid, entry.offset, entry.length);

          if (remaining === 0) {
            this._freeLists[bid].splice(eid, 1);

            _entryPool.free(entry);
          } else {
            entry.offset += bytes;
            entry.length = remaining;
          }
        };

        _proto2._allocateBuffer = function _allocateBuffer() {
          assertID(this._buffers.length === this._freeLists.length, 9003);
          var buffer = new MeshBuffer();
          var vFloatCount = this._vCount * this._floatsPerVertex;
          buffer.initialize(this._device, this._attributes, vFloatCount, this._iCount);

          this._buffers.push(buffer);

          var entry = _entryPool.alloc();

          entry.offset = 0;
          entry.length = buffer.vData.byteLength;
          var freeList = [entry];

          this._freeLists.push(freeList);

          var batcher = director.root.batcher2D;
          batcher.syncMeshBuffersToNative(this.id, this._buffers);
          return this._buffers.length - 1;
        };

        StaticVBAccessor.generateID = function generateID() {
          return StaticVBAccessor.ID_COUNT++;
        };

        _createClass(StaticVBAccessor, [{
          key: "id",
          get: function get() {
            return this._id;
          }
        }]);

        return StaticVBAccessor;
      }(BufferAccessor);
      StaticVBAccessor.IB_SCALE = 4;
      StaticVBAccessor.ID_COUNT = 0;

      var AttrUInt8ArrayView;

      (function (AttrUInt8ArrayView) {
        AttrUInt8ArrayView[AttrUInt8ArrayView["DrawInfoType"] = 0] = "DrawInfoType";
        AttrUInt8ArrayView[AttrUInt8ArrayView["VertDirty"] = 1] = "VertDirty";
        AttrUInt8ArrayView[AttrUInt8ArrayView["IsMeshBuffer"] = 2] = "IsMeshBuffer";
        AttrUInt8ArrayView[AttrUInt8ArrayView["Stride"] = 3] = "Stride";
        AttrUInt8ArrayView[AttrUInt8ArrayView["Count"] = 4] = "Count";
      })(AttrUInt8ArrayView || (AttrUInt8ArrayView = {}));

      var AttrUInt16ArrayView;

      (function (AttrUInt16ArrayView) {
        AttrUInt16ArrayView[AttrUInt16ArrayView["BufferID"] = 0] = "BufferID";
        AttrUInt16ArrayView[AttrUInt16ArrayView["AccessorID"] = 1] = "AccessorID";
        AttrUInt16ArrayView[AttrUInt16ArrayView["Count"] = 2] = "Count";
      })(AttrUInt16ArrayView || (AttrUInt16ArrayView = {}));

      var AttrUInt32ArrayView;

      (function (AttrUInt32ArrayView) {
        AttrUInt32ArrayView[AttrUInt32ArrayView["VertexOffset"] = 0] = "VertexOffset";
        AttrUInt32ArrayView[AttrUInt32ArrayView["IndexOffset"] = 1] = "IndexOffset";
        AttrUInt32ArrayView[AttrUInt32ArrayView["VBCount"] = 2] = "VBCount";
        AttrUInt32ArrayView[AttrUInt32ArrayView["IBCount"] = 3] = "IBCount";
        AttrUInt32ArrayView[AttrUInt32ArrayView["DataHash"] = 4] = "DataHash";
        AttrUInt32ArrayView[AttrUInt32ArrayView["Count"] = 5] = "Count";
      })(AttrUInt32ArrayView || (AttrUInt32ArrayView = {}));

      var RenderDrawInfoType;

      (function (RenderDrawInfoType) {
        RenderDrawInfoType[RenderDrawInfoType["COMP"] = 0] = "COMP";
        RenderDrawInfoType[RenderDrawInfoType["MODEL"] = 1] = "MODEL";
        RenderDrawInfoType[RenderDrawInfoType["IA"] = 2] = "IA";
        RenderDrawInfoType[RenderDrawInfoType["SUB_NODE"] = 3] = "SUB_NODE";
      })(RenderDrawInfoType || (RenderDrawInfoType = {}));

      var RenderDrawInfo = function () {
        function RenderDrawInfo(nativeDrawInfo) {
          this._accId = -1;
          this._bufferId = -1;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._vb = null;
          this._ib = null;
          this._vData = null;
          this._iData = null;
          this._vertDirty = false;
          this._vbCount = 0;
          this._ibCount = 0;
          this._dataHash = 0;
          this._isMeshBuffer = false;
          this._material = null;
          this._texture = null;
          this._sampler = null;
          this._stride = 0;
          this._useLocal = false;
          this._model = null;
          this._drawInfoType = RenderDrawInfoType.COMP;
          this._subNode = null;
          this._uint8SharedBuffer = void 0;
          this._uint16SharedBuffer = void 0;
          this._uint32SharedBuffer = void 0;
          this.init(nativeDrawInfo);

          var attrSharedBuffer = this._nativeObj.getAttrSharedBufferForJS();

          var offset = 0;
          this._uint8SharedBuffer = new Uint8Array(attrSharedBuffer, offset, AttrUInt8ArrayView.Count);
          offset += AttrUInt8ArrayView.Count * Uint8Array.BYTES_PER_ELEMENT;
          this._uint16SharedBuffer = new Uint16Array(attrSharedBuffer, offset, AttrUInt16ArrayView.Count);
          offset += AttrUInt16ArrayView.Count * Uint16Array.BYTES_PER_ELEMENT;
          this._uint32SharedBuffer = new Uint32Array(attrSharedBuffer, offset, AttrUInt32ArrayView.Count);
        }

        var _proto = RenderDrawInfo.prototype;

        _proto.init = function init(nativeDrawInfo) {
        };

        _proto.clear = function clear() {
          this._bufferId = 0;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._vertDirty = false;
        };

        _proto.setAccId = function setAccId(accId) {

          this._accId = accId;
        };

        _proto.setBufferId = function setBufferId(bufferId) {

          this._bufferId = bufferId;
        };

        _proto.setAccAndBuffer = function setAccAndBuffer(accId, bufferId) {

          this._bufferId = bufferId;
          this._accId = accId;
        };

        _proto.setVertexOffset = function setVertexOffset(vertexOffset) {
          this._vertexOffset = vertexOffset;
        };

        _proto.setIndexOffset = function setIndexOffset(indexOffset) {
          this._indexOffset = indexOffset;
        };

        _proto.setVB = function setVB(vbBuffer) {
        };

        _proto.setIB = function setIB(ibBuffer) {
        };

        _proto.setVData = function setVData(vDataBuffer) {
        };

        _proto.setIData = function setIData(iDataBuffer) {
        };

        _proto.setVBCount = function setVBCount(vbCount) {

          this._vbCount = vbCount;
        };

        _proto.setIBCount = function setIBCount(ibCount) {
        };

        _proto.setVertDirty = function setVertDirty(val) {

          this._vertDirty = val;
        };

        _proto.setDataHash = function setDataHash(dataHash) {

          this._dataHash = dataHash;
        };

        _proto.setIsMeshBuffer = function setIsMeshBuffer(isMeshBuffer) {

          this._isMeshBuffer = isMeshBuffer;
        };

        _proto.setMaterial = function setMaterial(material) {

          this._material = material;
        };

        _proto.setTexture = function setTexture(texture) {

          this._texture = texture;
        };

        _proto.setSampler = function setSampler(sampler) {

          this._sampler = sampler;
        };

        _proto.setModel = function setModel(model) {
        };

        _proto.setDrawInfoType = function setDrawInfoType(drawInfoType) {

          this._drawInfoType = drawInfoType;
        };

        _proto.setSubNode = function setSubNode(node) {

          this._subNode = node;
        };

        _proto.setStride = function setStride(stride) {

          this._stride = stride;
        };

        _proto.initRender2dBuffer = function initRender2dBuffer() {
        };

        _proto.fillRender2dBuffer = function fillRender2dBuffer(vertexDataArr) {
        };

        _createClass(RenderDrawInfo, [{
          key: "nativeObj",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "render2dBuffer",
          get: function get() {
            return this._render2dBuffer;
          }
        }]);

        return RenderDrawInfo;
      }();

      var Stage;

      (function (Stage) {
        Stage[Stage["DISABLED"] = 0] = "DISABLED";
        Stage[Stage["CLEAR"] = 1] = "CLEAR";
        Stage[Stage["ENTER_LEVEL"] = 2] = "ENTER_LEVEL";
        Stage[Stage["ENABLED"] = 3] = "ENABLED";
        Stage[Stage["EXIT_LEVEL"] = 4] = "EXIT_LEVEL";
        Stage[Stage["CLEAR_INVERTED"] = 5] = "CLEAR_INVERTED";
        Stage[Stage["ENTER_LEVEL_INVERTED"] = 6] = "ENTER_LEVEL_INVERTED";
      })(Stage || (Stage = {}));

      var StencilSharedBufferView;

      (function (StencilSharedBufferView) {
        StencilSharedBufferView[StencilSharedBufferView["stencilTest"] = 0] = "stencilTest";
        StencilSharedBufferView[StencilSharedBufferView["func"] = 1] = "func";
        StencilSharedBufferView[StencilSharedBufferView["stencilMask"] = 2] = "stencilMask";
        StencilSharedBufferView[StencilSharedBufferView["writeMask"] = 3] = "writeMask";
        StencilSharedBufferView[StencilSharedBufferView["failOp"] = 4] = "failOp";
        StencilSharedBufferView[StencilSharedBufferView["zFailOp"] = 5] = "zFailOp";
        StencilSharedBufferView[StencilSharedBufferView["passOp"] = 6] = "passOp";
        StencilSharedBufferView[StencilSharedBufferView["ref"] = 7] = "ref";
        StencilSharedBufferView[StencilSharedBufferView["count"] = 8] = "count";
      })(StencilSharedBufferView || (StencilSharedBufferView = {}));

      var StencilManager = exports('StencilManager', function () {
        function StencilManager() {
          this._maskStack = [];
          this._stencilPattern = {
            stencilTest: true,
            func: ComparisonFunc.ALWAYS,
            stencilMask: 0xffff,
            writeMask: 0xffff,
            failOp: StencilOp.KEEP,
            zFailOp: StencilOp.KEEP,
            passOp: StencilOp.KEEP,
            ref: 1
          };
          this._stage = Stage.DISABLED;
          this.stencilStateMap = new Map();
          this.stencilStateMapWithDepth = new Map();
        }

        var _proto = StencilManager.prototype;

        _proto.pushMask = function pushMask(mask) {
          this._maskStack.push(mask);
        };

        _proto.clear = function clear(comp) {
          var isInverted = comp.stencilStage !== Stage.ENTER_LEVEL;
          return isInverted ? Stage.CLEAR_INVERTED : Stage.CLEAR;
        };

        _proto.enableMask = function enableMask() {
          this.stage = Stage.ENABLED;
        };

        _proto.exitMask = function exitMask() {
          if (this._maskStack.length === 0) {
            return;
          }

          this._maskStack.pop();

          if (this._maskStack.length === 0) {
            this.stage = Stage.DISABLED;
          } else {
            this.stage = Stage.ENABLED;
          }
        };

        _proto.getWriteMask = function getWriteMask() {
          return 1 << this._maskStack.length - 1;
        };

        _proto.getExitWriteMask = function getExitWriteMask() {
          return 1 << this._maskStack.length;
        };

        _proto.getStencilRef = function getStencilRef() {
          var result = 0;

          for (var i = 0; i < this._maskStack.length; ++i) {
            result += 0x00000001 << i;
          }

          return result;
        };

        _proto.getMaskStackSize = function getMaskStackSize() {
          return this._maskStack.length;
        };

        _proto.reset = function reset() {
          this._maskStack.length = 0;
          this.stage = Stage.DISABLED;
        };

        _proto.destroy = function destroy() {
          this.stencilStateMap.forEach(function (value, key) {
            value.destroy();
          });
          this.stencilStateMap.clear();
        };

        _proto.getStencilStage = function getStencilStage(stage, mat) {
          var key = 0;
          var depthTest = false;
          var depthWrite = false;
          var depthFunc = ComparisonFunc.LESS;
          var cacheMap = this.stencilStateMap;

          if (mat && mat.passes[0]) {
            var pass = mat.passes[0];
            var dss = pass.depthStencilState;
            var depthTestValue = 0;
            var depthWriteValue = 0;
            if (dss.depthTest) depthTestValue = 1;
            if (dss.depthWrite) depthWriteValue = 1;
            key = depthTestValue | depthWriteValue << 1 | dss.depthFunc << 2 | stage << 6 | this._maskStack.length << 9;
            depthTest = dss.depthTest;
            depthWrite = dss.depthWrite;
            depthFunc = dss.depthFunc;
            cacheMap = this.stencilStateMapWithDepth;
          } else {
            key = stage << 16 | this._maskStack.length;
          }

          if (cacheMap && cacheMap.has(key)) {
            return cacheMap.get(key);
          }

          this.setStateFromStage(stage);
          var depthStencilState = new DepthStencilState(depthTest, depthWrite, depthFunc, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
          cacheMap.set(key, depthStencilState);
          return depthStencilState;
        };

        _proto.getStencilHash = function getStencilHash(stage) {
          return stage << 8 | this._maskStack.length;
        };

        _proto.setStateFromStage = function setStateFromStage(stage) {
          var pattern = this._stencilPattern;

          if (stage === Stage.DISABLED) {
            pattern.stencilTest = false;
            pattern.func = ComparisonFunc.ALWAYS;
            pattern.failOp = StencilOp.KEEP;
            pattern.stencilMask = pattern.writeMask = 0xffff;
            pattern.ref = 1;
          } else {
            pattern.stencilTest = true;

            if (stage === Stage.ENABLED) {
              pattern.func = ComparisonFunc.EQUAL;
              pattern.failOp = StencilOp.KEEP;
              pattern.stencilMask = pattern.ref = this.getStencilRef();
              pattern.writeMask = this.getWriteMask();
            } else if (stage === Stage.CLEAR) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.ZERO;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.CLEAR_INVERTED) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.REPLACE;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.ENTER_LEVEL) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.REPLACE;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.ENTER_LEVEL_INVERTED) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.ZERO;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            }
          }
        };

        _createClass(StencilManager, [{
          key: "stage",
          get: function get() {
            return this._stage;
          },
          set: function set(val) {
            this._stage = val;
          }
        }, {
          key: "pattern",
          get: function get() {
            return this._stencilPattern;
          }
        }]);

        return StencilManager;
      }());
      StencilManager.sharedManager = null;
      StencilManager.sharedManager = new StencilManager();

      var RenderEntityType;

      (function (RenderEntityType) {
        RenderEntityType[RenderEntityType["STATIC"] = 0] = "STATIC";
        RenderEntityType[RenderEntityType["DYNAMIC"] = 1] = "DYNAMIC";
        RenderEntityType[RenderEntityType["CROSSED"] = 2] = "CROSSED";
      })(RenderEntityType || (RenderEntityType = {}));

      var RenderEntityFloatSharedBufferView;

      (function (RenderEntityFloatSharedBufferView) {
        RenderEntityFloatSharedBufferView[RenderEntityFloatSharedBufferView["localOpacity"] = 0] = "localOpacity";
        RenderEntityFloatSharedBufferView[RenderEntityFloatSharedBufferView["count"] = 1] = "count";
      })(RenderEntityFloatSharedBufferView || (RenderEntityFloatSharedBufferView = {}));

      var RenderEntityUInt8SharedBufferView;

      (function (RenderEntityUInt8SharedBufferView) {
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorR"] = 0] = "colorR";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorG"] = 1] = "colorG";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorB"] = 2] = "colorB";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorA"] = 3] = "colorA";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["maskMode"] = 4] = "maskMode";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["count"] = 5] = "count";
      })(RenderEntityUInt8SharedBufferView || (RenderEntityUInt8SharedBufferView = {}));

      var RenderEntityBoolSharedBufferView;

      (function (RenderEntityBoolSharedBufferView) {
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["colorDirty"] = 0] = "colorDirty";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["enabled"] = 1] = "enabled";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["useLocal"] = 2] = "useLocal";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["count"] = 3] = "count";
      })(RenderEntityBoolSharedBufferView || (RenderEntityBoolSharedBufferView = {}));

      var MaskMode;

      (function (MaskMode) {
        MaskMode[MaskMode["NONE"] = 0] = "NONE";
        MaskMode[MaskMode["MASK"] = 1] = "MASK";
        MaskMode[MaskMode["MASK_INVERTED"] = 2] = "MASK_INVERTED";
        MaskMode[MaskMode["MASK_NODE"] = 3] = "MASK_NODE";
        MaskMode[MaskMode["MASK_NODE_INVERTED"] = 4] = "MASK_NODE_INVERTED";
      })(MaskMode || (MaskMode = {}));

      var RenderEntity = function () {
        function RenderEntity(entityType) {
          this._renderEntityType = RenderEntityType.STATIC;
          this._dynamicDrawInfoArr = [];
          this._node = null;
          this._renderTransform = null;
          this._stencilStage = Stage.DISABLED;
          this._useLocal = false;
          this._maskMode = MaskMode.NONE;
          this._color = Color.WHITE;
          this._localOpacity = 255;
          this._colorDirty = true;
          this._enabled = false;
        }

        var _proto = RenderEntity.prototype;

        _proto.addDynamicRenderDrawInfo = function addDynamicRenderDrawInfo(renderDrawInfo) {
        };

        _proto.removeDynamicRenderDrawInfo = function removeDynamicRenderDrawInfo() {
        };

        _proto.clearDynamicRenderDrawInfos = function clearDynamicRenderDrawInfos() {
        };

        _proto.clearStaticRenderDrawInfos = function clearStaticRenderDrawInfos() {
        };

        _proto.setDynamicRenderDrawInfo = function setDynamicRenderDrawInfo(renderDrawInfo, index) {
        };

        _proto.setMaskMode = function setMaskMode(mode) {

          this._maskMode = mode;
        };

        _proto.getStaticRenderDrawInfo = function getStaticRenderDrawInfo() {

          return null;
        };

        _proto.setNode = function setNode(node) {

          this._node = node;
        };

        _proto.setRenderTransform = function setRenderTransform(renderTransform) {

          this._renderTransform = renderTransform;
        };

        _proto.setStencilStage = function setStencilStage(stage) {

          this._stencilStage = stage;
        };

        _proto.setUseLocal = function setUseLocal(useLocal) {

          this._useLocal = useLocal;
        };

        _proto.initSharedBuffer = function initSharedBuffer() {
        };

        _createClass(RenderEntity, [{
          key: "nativeObj",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "renderDrawInfoArr",
          get: function get() {
            return this._dynamicDrawInfoArr;
          }
        }, {
          key: "renderEntityType",
          get: function get() {
            return this._renderEntityType;
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(val) {
            this._color = val;
          }
        }, {
          key: "localOpacity",
          get: function get() {
            return this._localOpacity;
          },
          set: function set(val) {
            this._localOpacity = val;
          }
        }, {
          key: "colorDirty",
          get: function get() {
            return this._colorDirty;
          },
          set: function set(val) {
            this._colorDirty = val;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._enabled = val;
          }
        }]);

        return RenderEntity;
      }();

      var DEFAULT_STRIDE = getAttributeStride(vfmtPosUvColor) >> 2;

      var _dataPool = new Pool(function () {
        return {
          x: 0,
          y: 0,
          z: 0,
          u: 0,
          v: 0,
          color: Color.WHITE.clone()
        };
      }, 128);
      var BaseRenderData = exports('BaseRenderData', function () {
        function BaseRenderData(vertexFormat) {
          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          this.chunk = null;
          this._renderDrawInfo = null;
          this._material = null;
          this._dataHash = 0;
          this._isMeshBuffer = false;
          this._vc = 0;
          this._ic = 0;
          this._floatStride = 0;
          this._vertexFormat = vfmtPosUvColor;
          this._drawInfoType = RenderDrawInfoType.COMP;
          this._multiOwner = false;
          this._batcher = null;
          this._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          this._vertexFormat = vertexFormat;
        }

        var _proto = BaseRenderData.prototype;

        _proto.isValid = function isValid() {
          return this._ic > 0 && this.chunk.vertexAccessor;
        };

        _proto.initRenderDrawInfo = function initRenderDrawInfo(comp, drawInfoType) {
          if (drawInfoType === void 0) {
            drawInfoType = RenderDrawInfoType.COMP;
          }
        };

        _proto.removeRenderDrawInfo = function removeRenderDrawInfo(comp) {
        };

        _proto.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
        };

        _createClass(BaseRenderData, [{
          key: "vertexCount",
          get: function get() {
            return this._vc;
          }
        }, {
          key: "indexCount",
          get: function get() {
            return this._ic;
          }
        }, {
          key: "stride",
          get: function get() {
            return this._floatStride << 2;
          }
        }, {
          key: "floatStride",
          get: function get() {
            return this._floatStride;
          }
        }, {
          key: "vertexFormat",
          get: function get() {
            return this._vertexFormat;
          }
        }, {
          key: "drawInfoType",
          get: function get() {
            return this._drawInfoType;
          },
          set: function set(type) {
            this._drawInfoType = type;

            if (this._renderDrawInfo) {
              this._renderDrawInfo.setDrawInfoType(type);
            }
          }
        }, {
          key: "renderDrawInfo",
          get: function get() {
            return this._renderDrawInfo;
          }
        }, {
          key: "material",
          get: function get() {
            return this._material;
          },
          set: function set(val) {
            this._material = val;

            if (this._renderDrawInfo) {
              this._renderDrawInfo.setMaterial(val);
            }
          }
        }, {
          key: "dataHash",
          get: function get() {
            return this._dataHash;
          },
          set: function set(val) {
            this._dataHash = val;

            if (this._renderDrawInfo) {
              this._renderDrawInfo.setDataHash(val);
            }
          }
        }, {
          key: "multiOwner",
          get: function get() {
            return this._multiOwner;
          },
          set: function set(val) {
            this._multiOwner = val;
          }
        }, {
          key: "batcher",
          get: function get() {
            if (!this._batcher) {
              this._batcher = director.root.batcher2D;
            }

            return this._batcher;
          }
        }]);

        return BaseRenderData;
      }());
      var RenderData = exports('RenderData', function (_BaseRenderData) {
        _inheritsLoose(RenderData, _BaseRenderData);

        RenderData.add = function add(vertexFormat, accessor) {
          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          var rd = new RenderData(vertexFormat, accessor);

          if (!accessor) {
            var batcher = director.root.batcher2D;
            accessor = batcher.switchBufferAccessor(rd._vertexFormat);
          }

          rd._accessor = accessor;
          return rd;
        };

        RenderData.remove = function remove(data) {
          data.clear();
          data._accessor = null;
        };

        function RenderData(vertexFormat, accessor) {
          var _this;

          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          _this = _BaseRenderData.call(this, vertexFormat) || this;
          _this._vertDirty = true;
          _this._textureHash = 0;
          _this.indices = null;
          _this.layer = 0;
          _this.nodeDirty = true;
          _this.passDirty = true;
          _this.textureDirty = true;
          _this.hashDirty = true;
          _this._data = [];
          _this._pivotX = 0;
          _this._pivotY = 0;
          _this._width = 0;
          _this._height = 0;
          _this._frame = null;
          _this._accessor = null;
          _this.vertexRow = 1;
          _this.vertexCol = 1;

          if (!accessor) {
            accessor = _this.batcher.switchBufferAccessor(_this._vertexFormat);
          }

          _this._accessor = accessor;
          return _this;
        }

        var _proto2 = RenderData.prototype;

        _proto2.resize = function resize(vertexCount, indexCount) {
          if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
          this._vc = vertexCount;
          this._ic = indexCount;

          if (this.chunk) {
            this._accessor.recycleChunk(this.chunk);

            this.chunk = null;
          }

          this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
          this.updateHash();
        };

        _proto2.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
        };

        _proto2.fillDrawInfoAttributes = function fillDrawInfoAttributes(drawInfo) {
        };

        _proto2.syncRender2dBuffer = function syncRender2dBuffer() {
        };

        _proto2.resizeAndCopy = function resizeAndCopy(vertexCount, indexCount) {
          if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
          this._vc = vertexCount;
          this._ic = indexCount;
          var oldChunk = this.chunk;
          this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);

          if (oldChunk) {
            this.chunk.vb.set(oldChunk.vb);

            this._accessor.recycleChunk(oldChunk);
          }

          this.updateHash();
        };

        _proto2.getMeshBuffer = function getMeshBuffer() {
          if (this.chunk && this._accessor) {
            return this._accessor.getMeshBuffer(this.chunk.bufferId);
          } else {
            return null;
          }
        };

        _proto2.updateNode = function updateNode(comp) {
          this.layer = comp.node.layer;
          this.nodeDirty = false;
          this.hashDirty = true;
        };

        _proto2.updatePass = function updatePass(comp) {
          this.material = comp.getRenderMaterial(0);
          this.passDirty = false;
          this.hashDirty = true;
        };

        _proto2.updateTexture = function updateTexture(frame) {
          this.frame = frame;
          this.textureHash = frame.getHash();
          this.textureDirty = false;
          this.hashDirty = true;
        };

        _proto2.updateHash = function updateHash() {
          var bid = this.chunk ? this.chunk.bufferId : -1;
          var hashString = "" + bid + this.layer + " " + this.textureHash;
          this.dataHash = murmurhash2_32_gc(hashString, 666);
          this.hashDirty = false;
        };

        _proto2.updateRenderData = function updateRenderData(comp, frame) {
          if (this.passDirty) {
            this.material = comp.getRenderMaterial(0);
            this.passDirty = false;
            this.hashDirty = true;

            if (this._renderDrawInfo) {
              this._renderDrawInfo.setMaterial(this.material);
            }
          }

          if (this.nodeDirty) {
            var renderScene = comp.node.scene ? comp._getRenderScene() : null;
            this.layer = comp.node.layer;

            if (renderScene !== null) {
              this.nodeDirty = false;
            }

            this.hashDirty = true;
          }

          if (this.textureDirty) {
            this.frame = frame;
            this.textureHash = frame.getHash();
            this.textureDirty = false;
            this.hashDirty = true;

            if (this._renderDrawInfo) {
              this._renderDrawInfo.setTexture(this.frame ? this.frame.getGFXTexture() : null);

              this._renderDrawInfo.setSampler(this.frame ? this.frame.getGFXSampler() : null);
            }
          }

          if (this.hashDirty) {
            this.updateHash();

            if (this._renderDrawInfo) {
              this._renderDrawInfo.setDataHash(this.dataHash);
            }
          }
        };

        _proto2.updateSizeNPivot = function updateSizeNPivot(width, height, pivotX, pivotY) {
          if (width !== this._width || height !== this._height || pivotX !== this._pivotX || pivotY !== this._pivotY) {
            this._width = width;
            this._height = height;
            this._pivotX = pivotX;
            this._pivotY = pivotY;
            this.vertDirty = true;
          }
        };

        _proto2.clear = function clear() {
          this.resize(0, 0);
          this._data.length = 0;
          this._pivotX = 0;
          this._pivotY = 0;
          this._width = 0;
          this._height = 0;
          this.indices = null;
          this.vertDirty = true;
          this.material = null;
          this.nodeDirty = true;
          this.passDirty = true;
          this.textureDirty = true;
          this.hashDirty = true;
          this.layer = 0;
          this.frame = null;
          this.textureHash = 0;
          this.dataHash = 0;
        };

        RenderData.createStaticVBAccessor = function createStaticVBAccessor(attributes, vCount, iCount) {
          var device = director.root.device;
          var accessor = new StaticVBAccessor(device, attributes, vCount, iCount);
          return accessor;
        };

        _createClass(RenderData, [{
          key: "dataLength",
          get: function get() {
            return this._data.length;
          },
          set: function set(length) {
            var data = this._data;

            if (data.length !== length) {
              var value = data.length;
              var i = 0;

              for (i = length; i < value; i++) {
                _dataPool.free(data[i]);
              }

              for (i = value; i < length; i++) {
                data[i] = _dataPool.alloc();
              }

              data.length = length;
            }

            this.syncRender2dBuffer();
          }
        }, {
          key: "data",
          get: function get() {
            return this._data;
          }
        }, {
          key: "vertDirty",
          get: function get() {
            return this._vertDirty;
          },
          set: function set(val) {
            this._vertDirty = val;

            if (this._renderDrawInfo && val) {
              this._renderDrawInfo.setVertDirty(val);
            }
          }
        }, {
          key: "textureHash",
          get: function get() {
            return this._textureHash;
          },
          set: function set(val) {
            this._textureHash = val;
          }
        }, {
          key: "frame",
          get: function get() {
            return this._frame;
          },
          set: function set(val) {
            this._frame = val;

            if (this._renderDrawInfo) {
              if (this._frame) {
                this._renderDrawInfo.setTexture(this._frame.getGFXTexture());

                this._renderDrawInfo.setSampler(this._frame.getGFXSampler());
              } else {
                this._renderDrawInfo.setTexture(null);

                this._renderDrawInfo.setSampler(null);
              }
            }
          }
        }, {
          key: "accessor",
          get: function get() {
            return this._accessor;
          }
        }]);

        return RenderData;
      }(BaseRenderData));
      var MeshRenderData = exports('MeshRenderData', function (_BaseRenderData2) {
        _inheritsLoose(MeshRenderData, _BaseRenderData2);

        MeshRenderData.add = function add(vertexFormat) {
          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          var rd = new MeshRenderData();
          rd._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          rd._vertexFormat = vertexFormat;
          return rd;
        };

        MeshRenderData.remove = function remove(data) {
          data.clear();
        };

        function MeshRenderData(vertexFormat) {
          var _this2;

          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          _this2 = _BaseRenderData2.call(this, vertexFormat) || this;
          _this2._isMeshBuffer = true;
          _this2.vData = void 0;
          _this2.iData = void 0;
          _this2.vertexStart = 0;
          _this2.vertexRange = 0;
          _this2.indexStart = 0;
          _this2.indexRange = 0;
          _this2.lastFilledIndex = 0;
          _this2.lastFilledVertex = 0;
          _this2.frame = void 0;
          _this2._byteLength = 0;
          _this2._vertexBuffers = [];
          _this2._indexBuffer = null;
          _this2._iaPool = null;
          _this2._iaInfo = null;
          _this2.vData = new Float32Array(256 * _this2.stride);
          _this2.iData = new Uint16Array(256 * 6);
          return _this2;
        }

        var _proto3 = MeshRenderData.prototype;

        _proto3.request = function request(vertexCount, indexCount) {
          var byteOffset = this._byteLength + vertexCount * this.stride;
          var succeed = this.reserve(vertexCount, indexCount);
          if (!succeed) return false;
          this._vc += vertexCount;
          this._ic += indexCount;
          this._byteLength = byteOffset;
          this.vertexRange = this._vc;
          this.indexRange = this._ic;
          return true;
        };

        _proto3.reserve = function reserve(vertexCount, indexCount) {
          var newVBytes = this._byteLength + vertexCount * this.stride;
          var newICount = this.indexCount + indexCount;

          if (vertexCount + this.vertexCount > 65535) {
            return false;
          }

          var byteLength = this.vData.byteLength;
          var indicesLength = this.iData.length;
          var vCount = this.vData.length;
          var iCount = this.iData.length;

          if (newVBytes > byteLength || newICount > indicesLength) {
            while (byteLength < newVBytes || indicesLength < newICount) {
              vCount *= 2;
              iCount *= 2;
              byteLength = vCount * 4;
              indicesLength = iCount;
            }

            this._reallocBuffer(vCount, iCount);
          }

          return true;
        };

        _proto3.resize = function resize(vertexCount, indexCount) {
          var byteLength = vertexCount * this.stride;
          assertIsTrue(vertexCount >= 0 && indexCount >= 0 && byteLength <= this.vData.byteLength && indexCount <= this.iData.length);
          this._vc = vertexCount;
          this._ic = indexCount;
          this._byteLength = byteLength;
          this.updateRange(0, vertexCount, 0, indexCount);
        };

        _proto3.updateRange = function updateRange(vertOffset, vertexCount, indexOffset, indexCount) {
          assertIsTrue(vertexCount >= 0 && indexCount >= 0 && vertexCount <= this._vc && indexCount <= this._ic);
          this.vertexStart = vertOffset;
          this.indexStart = indexOffset;
          this.vertexRange = vertexCount;
          this.indexRange = indexCount;
        };

        _proto3.requestIA = function requestIA(device) {
          this._initIAInfo(device);

          var ia = this._iaPool.add();

          ia.firstIndex = this.indexStart;
          ia.indexCount = this.indexRange;
          return ia;
        };

        _proto3.uploadBuffers = function uploadBuffers() {
          if (this._byteLength === 0 || !this._vertexBuffers[0] || !this._indexBuffer) {
            return;
          }

          var indexCount = this._ic;
          var verticesData = new Float32Array(this.vData.buffer, 0, this._byteLength >> 2);
          var indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
          var vertexBuffer = this._vertexBuffers[0];

          if (this._byteLength > vertexBuffer.size) {
            vertexBuffer.resize(this._byteLength);
          }

          vertexBuffer.update(verticesData);
          var indexBytes = indexCount << 1;

          if (indexBytes > this._indexBuffer.size) {
            this._indexBuffer.resize(indexBytes);
          }

          this._indexBuffer.update(indicesData);
        };

        _proto3.freeIAPool = function freeIAPool() {
          if (this._iaPool) {
            this._iaPool.reset();
          }
        };

        _proto3.reset = function reset() {
          this._vc = 0;
          this._ic = 0;
          this._byteLength = 0;
          this.vertexStart = 0;
          this.vertexRange = 0;
          this.indexStart = 0;
          this.indexRange = 0;
          this.lastFilledIndex = 0;
          this.lastFilledVertex = 0;
          this.material = null;
          this.freeIAPool();
        };

        _proto3.clear = function clear() {
          this.reset();

          if (this._iaPool) {
            this._iaPool.destroy();
          }

          if (this._vertexBuffers[0]) {
            this._vertexBuffers[0].destroy();

            this._vertexBuffers = [];
          }

          this._iaInfo = null;
          this.vData = new Float32Array(256 * this.stride);
          this.iData = new Uint16Array(256 * 6);
        };

        _proto3._initIAInfo = function _initIAInfo(device) {
          var _this3 = this;

          if (!this._iaInfo) {
            var vbStride = this.stride;
            var vbs = this._vertexBuffers;

            if (!vbs.length) {
              vbs.push(device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbStride, vbStride)));
            }

            var ibStride = Uint16Array.BYTES_PER_ELEMENT;

            if (!this._indexBuffer) {
              this._indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibStride, ibStride));
            }

            this._iaInfo = new InputAssemblerInfo(this._vertexFormat, vbs, this._indexBuffer);
            this._iaPool = new RecyclePool(function () {
              return device.createInputAssembler(_this3._iaInfo);
            }, 1, function (ia) {
              ia.destroy();
            });
          }
        };

        _proto3._reallocBuffer = function _reallocBuffer(vCount, iCount) {
          var oldVData = this.vData;
          this.vData = new Float32Array(vCount);

          if (oldVData) {
            this.vData.set(oldVData, 0);
          }

          var oldIData = this.iData;
          this.iData = new Uint16Array(iCount);

          if (oldIData) {
            this.iData.set(oldIData, 0);
          }
        };

        _proto3.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
        };

        _proto3.particleInitRenderDrawInfo = function particleInitRenderDrawInfo(entity) {
        };

        _createClass(MeshRenderData, [{
          key: "formatByte",
          get: function get() {
            return this.stride;
          },
          set: function set(value) {}
        }, {
          key: "floatStride",
          get: function get() {
            return this._floatStride;
          }
        }, {
          key: "vDataOffset",
          get: function get() {
            return this._byteLength >>> 2;
          }
        }]);

        return MeshRenderData;
      }(BaseRenderData));

      var _meshDataPool = new RecyclePool(function () {
        return new MeshRenderData();
      }, 32);

      var _dec$7, _dec2$1, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class$7, _class2$5, _descriptor$4, _descriptor2$2, _class3, _temp$5;

      var _vec2a = new Vec2();

      var _vec2b = new Vec2();

      var _vec3a = new Vec3();

      var _mat4_temp = new Mat4();

      var _matrix = new Mat4();

      var _worldMatrix = new Mat4();

      var _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

      var _rect = new Rect();

      var UITransform = function (v) { return exports({ UITransform: v, UITransformComponent: v }), v; }((_dec$7 = ccclass('cc.UITransform'), _dec2$1 = help(), _dec3 = executionOrder(110), _dec4 = menu(), _dec5 = displayOrder(), _dec6 = tooltip(), _dec7 = displayOrder(), _dec8 = tooltip(), _dec$7(_class$7 = _dec2$1(_class$7 = _dec3(_class$7 = _dec4(_class$7 = disallowMultiple(_class$7 = executeInEditMode(_class$7 = (_class2$5 = (_temp$5 = _class3 = function (_Component) {
        _inheritsLoose(UITransform, _Component);

        function UITransform() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._priority = 0;

          _initializerDefineProperty(_this, "_contentSize", _descriptor$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_anchorPoint", _descriptor2$2, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = UITransform.prototype;

        _proto.__preload = function __preload() {
          this.node._uiProps.uiTransformComp = this;
        };

        _proto.onLoad = function onLoad() {
          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        };

        _proto.onEnable = function onEnable() {
          this.node.on(NodeEventType.PARENT_CHANGED, this._parentChanged, this);

          this._markRenderDataDirty();
        };

        _proto.onDisable = function onDisable() {
          this.node.off(NodeEventType.PARENT_CHANGED, this._parentChanged, this);
        };

        _proto.onDestroy = function onDestroy() {
          this.node._uiProps.uiTransformComp = null;
        };

        _proto.setContentSize = function setContentSize(size, height) {
          var locContentSize = this._contentSize;

          if (height === undefined) {
            size = size;

            if (approx(size.width, locContentSize.width, EPSILON$2) && approx(size.height, locContentSize.height, EPSILON$2)) {
              return;
            }

            locContentSize.width = size.width;
            locContentSize.height = size.height;
          } else {
            size = size;

            if (approx(size, locContentSize.width, EPSILON$2) && approx(height, locContentSize.height, EPSILON$2)) {
              return;
            }

            locContentSize.width = size;
            locContentSize.height = height;
          }

          {
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }

          this._markRenderDataDirty();
        };

        _proto.setAnchorPoint = function setAnchorPoint(point, y) {
          var locAnchorPoint = this._anchorPoint;

          if (y === undefined) {
            point = point;

            if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
              return;
            }

            locAnchorPoint.x = point.x;
            locAnchorPoint.y = point.y;
          } else {
            if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
              return;
            }

            locAnchorPoint.x = point;
            locAnchorPoint.y = y;
          }

          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

          this._markRenderDataDirty();
        };

        _proto.isHit = function isHit(uiPoint) {
          var w = this._contentSize.width;
          var h = this._contentSize.height;
          var v2WorldPt = _vec2a;
          var testPt = _vec2b;

          var cameras = this._getRenderScene().cameras;

          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            if (!(camera.visibility & this.node.layer)) continue;
            camera.node.getWorldRT(_mat4_temp);
            var m12 = _mat4_temp.m12;
            var m13 = _mat4_temp.m13;
            var center = visibleRect.center;
            _mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13);
            _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13);
            Mat4.invert(_mat4_temp, _mat4_temp);
            Vec2.transformMat4(v2WorldPt, uiPoint, _mat4_temp);
            this.node.getWorldMatrix(_worldMatrix);
            Mat4.invert(_mat4_temp, _worldMatrix);

            if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
              continue;
            }

            Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp);
            testPt.x += this._anchorPoint.x * w;
            testPt.y += this._anchorPoint.y * h;
            var hit = false;

            if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
              hit = this._maskTest(v2WorldPt);
            }

            if (hit) {
              return true;
            }
          }

          return false;
        };

        _proto.hitTest = function hitTest(screenPoint) {
          var w = this._contentSize.width;
          var h = this._contentSize.height;
          var v3WorldPt = _vec3a;
          var v2WorldPt = _vec2a;
          var testPt = _vec2b;

          var cameras = this._getRenderScene().cameras;

          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            if (!(camera.visibility & this.node.layer) || camera.window && !camera.window.swapchain) continue;
            Vec3.set(v3WorldPt, screenPoint.x, screenPoint.y, 0);
            camera.screenToWorld(v3WorldPt, v3WorldPt);
            Vec2.set(v2WorldPt, v3WorldPt.x, v3WorldPt.y);
            this.node.getWorldMatrix(_worldMatrix);
            Mat4.invert(_mat4_temp, _worldMatrix);

            if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
              continue;
            }

            Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp);
            testPt.x += this._anchorPoint.x * w;
            testPt.y += this._anchorPoint.y * h;
            var hit = false;

            if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
              hit = this._maskTest(v2WorldPt);
            }

            if (hit) {
              return true;
            }
          }

          return false;
        };

        _proto._maskTest = function _maskTest(pointInWorldSpace) {
          var _this$node, _this$node$eventProce;

          var maskList = (_this$node = this.node) === null || _this$node === void 0 ? void 0 : (_this$node$eventProce = _this$node.eventProcessor) === null || _this$node$eventProce === void 0 ? void 0 : _this$node$eventProce.maskList;

          if (maskList) {
            var parent = this.node;
            var length = maskList.length;

            for (var i = 0, j = 0; parent && j < length; ++i, parent = parent.parent) {
              var temp = maskList[j];

              if (i === temp.index) {
                if (parent === temp.comp.node) {
                  var comp = temp.comp;

                  if (comp && comp._enabled && !comp.isHit(pointInWorldSpace)) {
                    return false;
                  }

                  j++;
                } else {
                  maskList.length = j;
                  break;
                }
              } else if (i > temp.index) {
                maskList.length = j;
                break;
              }
            }
          }

          return true;
        };

        _proto.convertToNodeSpaceAR = function convertToNodeSpaceAR(worldPoint, out) {
          this.node.getWorldMatrix(_worldMatrix);
          Mat4.invert(_mat4_temp, _worldMatrix);

          if (!out) {
            out = new Vec3();
          }

          return Vec3.transformMat4(out, worldPoint, _mat4_temp);
        };

        _proto.convertToWorldSpaceAR = function convertToWorldSpaceAR(nodePoint, out) {
          this.node.getWorldMatrix(_worldMatrix);

          if (!out) {
            out = new Vec3();
          }

          return Vec3.transformMat4(out, nodePoint, _worldMatrix);
        };

        _proto.getBoundingBox = function getBoundingBox() {
          Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
          var width = this._contentSize.width;
          var height = this._contentSize.height;
          var rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
          rect.transformMat4(_matrix);
          return rect;
        };

        _proto.getBoundingBoxToWorld = function getBoundingBoxToWorld() {
          if (this.node.parent) {
            this.node.parent.getWorldMatrix(_worldMatrix);
            return this.getBoundingBoxTo(_worldMatrix);
          }

          return this.getBoundingBox();
        };

        _proto.getBoundingBoxTo = function getBoundingBoxTo(parentMat) {
          Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
          var width = this._contentSize.width;
          var height = this._contentSize.height;
          var rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
          Mat4.multiply(_worldMatrix, parentMat, _matrix);
          rect.transformMat4(_worldMatrix);

          if (!this.node.children) {
            return rect;
          }

          var locChildren = this.node.children;

          for (var _iterator = _createForOfIteratorHelperLoose(locChildren), _step; !(_step = _iterator()).done;) {
            var child = _step.value;

            if (child && child.active) {
              var uiTransform = child.getComponent(UITransform);

              if (uiTransform) {
                var childRect = uiTransform.getBoundingBoxTo(parentMat);

                if (childRect) {
                  Rect.union(rect, rect, childRect);
                }
              }
            }
          }

          return rect;
        };

        _proto.getComputeAABB = function getComputeAABB(out) {
          var width = this._contentSize.width;
          var height = this._contentSize.height;

          _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);

          _rect.transformMat4(this.node.worldMatrix);

          var px = _rect.x + _rect.width * 0.5;
          var py = _rect.y + _rect.height * 0.5;
          var pz = this.node.worldPosition.z;
          var w = _rect.width / 2;
          var h = _rect.height / 2;
          var l = 0.001;

          if (out != null) {
            AABB.set(out, px, py, pz, w, h, l);
            return out;
          } else {
            return new AABB(px, py, pz, w, h, l);
          }
        };

        _proto._parentChanged = function _parentChanged(node) {
          if (this.node.getComponent('cc.RenderRoot2D')) {
            return;
          }

          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        };

        _proto._markRenderDataDirty = function _markRenderDataDirty() {
          var uiComp = this.node._uiProps.uiComp;

          if (uiComp) {
            uiComp.markForUpdateRenderData();
          }
        };

        UITransform.insertChangeMap = function insertChangeMap(node) {
          var key = node.uuid;

          if (!UITransform.priorityChangeNodeMap.has(key)) {
            UITransform.priorityChangeNodeMap.set(key, node);
          }
        };

        UITransform._sortChildrenSibling = function _sortChildrenSibling(node) {
          var siblings = node.children;

          if (siblings) {
            siblings.sort(function (a, b) {
              var aComp = a._uiProps.uiTransformComp;
              var bComp = b._uiProps.uiTransformComp;
              var ca = aComp ? aComp._priority : 0;
              var cb = bComp ? bComp._priority : 0;
              var diff = ca - cb;
              if (diff === 0) return a.getSiblingIndex() - b.getSiblingIndex();
              return diff;
            });
          }
        };

        UITransform._sortSiblings = function _sortSiblings() {
          UITransform.priorityChangeNodeMap.forEach(function (node, ID) {
            UITransform._sortChildrenSibling(node);

            node._updateSiblingIndex();

            node.emit('childrenSiblingOrderChanged');
          });
          UITransform.priorityChangeNodeMap.clear();
        };

        UITransform._cleanChangeMap = function _cleanChangeMap() {
          UITransform.priorityChangeNodeMap.clear();
        };

        _createClass(UITransform, [{
          key: "contentSize",
          get: function get() {
            return this._contentSize;
          },
          set: function set(value) {
            if (this._contentSize.equals(value)) {
              return;
            }

            this._contentSize.set(value);

            {
              this.node.emit(NodeEventType.SIZE_CHANGED);
            }

            this._markRenderDataDirty();
          }
        }, {
          key: "width",
          get: function get() {
            return this._contentSize.width;
          },
          set: function set(value) {
            if (this._contentSize.width === value) {
              return;
            }

            this._contentSize.width = value;

            {
              this.node.emit(NodeEventType.SIZE_CHANGED);
            }

            this._markRenderDataDirty();
          }
        }, {
          key: "height",
          get: function get() {
            return this._contentSize.height;
          },
          set: function set(value) {
            if (this.contentSize.height === value) {
              return;
            }

            this._contentSize.height = value;

            {
              this.node.emit(NodeEventType.SIZE_CHANGED);
            }

            this._markRenderDataDirty();
          }
        }, {
          key: "anchorPoint",
          get: function get() {
            return this._anchorPoint;
          },
          set: function set(value) {
            if (this._anchorPoint.equals(value)) {
              return;
            }

            this._anchorPoint.set(value);

            this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

            this._markRenderDataDirty();
          }
        }, {
          key: "anchorX",
          get: function get() {
            return this._anchorPoint.x;
          },
          set: function set(value) {
            if (this._anchorPoint.x === value) {
              return;
            }

            this._anchorPoint.x = value;
            this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

            this._markRenderDataDirty();
          }
        }, {
          key: "anchorY",
          get: function get() {
            return this._anchorPoint.y;
          },
          set: function set(value) {
            if (this._anchorPoint.y === value) {
              return;
            }

            this._anchorPoint.y = value;
            this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

            this._markRenderDataDirty();
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(value) {
            if (this._priority === value) {
              return;
            }

            if (this.node.getComponent('cc.RenderRoot2D')) {
              warnID(6706);
              return;
            }

            this._priority = value;

            if (this.node.parent) {
              UITransform.insertChangeMap(this.node.parent);
            }
          }
        }, {
          key: "visibility",
          get: function get() {
            var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
            return camera ? camera.visibility : 0;
          }
        }, {
          key: "cameraPriority",
          get: function get() {
            var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
            return camera ? camera.priority : 0;
          }
        }]);

        return UITransform;
      }(Component), _class3.EventType = NodeEventType, _class3.priorityChangeNodeMap = new Map(), _temp$5), (_applyDecoratedDescriptor(_class2$5.prototype, "contentSize", [_dec5, _dec6], Object.getOwnPropertyDescriptor(_class2$5.prototype, "contentSize"), _class2$5.prototype), _applyDecoratedDescriptor(_class2$5.prototype, "anchorPoint", [_dec7, _dec8], Object.getOwnPropertyDescriptor(_class2$5.prototype, "anchorPoint"), _class2$5.prototype), _descriptor$4 = _applyDecoratedDescriptor(_class2$5.prototype, "_contentSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(100, 100);
        }
      }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_anchorPoint", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(0.5, 0.5);
        }
      })), _class2$5)) || _class$7) || _class$7) || _class$7) || _class$7) || _class$7) || _class$7));
      director.on(Director.EVENT_AFTER_UPDATE, UITransform._sortSiblings);
      director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, UITransform._cleanChangeMap);

      var _dec$8, _dec2$2, _dec3$1, _dec4$1, _dec5$1, _dec6$1, _dec7$1, _dec8$1, _dec9, _dec10, _class$8, _class2$6, _descriptor$5, _descriptor2$3, _descriptor3$2, _descriptor4$1, _descriptor5, _class3$1, _temp$6;
      ccenum(BlendFactor);
      var InstanceMaterialType;

      (function (InstanceMaterialType) {
        InstanceMaterialType[InstanceMaterialType["ADD_COLOR"] = 0] = "ADD_COLOR";
        InstanceMaterialType[InstanceMaterialType["ADD_COLOR_AND_TEXTURE"] = 1] = "ADD_COLOR_AND_TEXTURE";
        InstanceMaterialType[InstanceMaterialType["GRAYSCALE"] = 2] = "GRAYSCALE";
        InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED"] = 3] = "USE_ALPHA_SEPARATED";
        InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED_AND_GRAY"] = 4] = "USE_ALPHA_SEPARATED_AND_GRAY";
      })(InstanceMaterialType || (InstanceMaterialType = exports('InstanceMaterialType', {})));

      var UIRenderer = function (v) { return exports({ UIRenderer: v, RenderComponent: v, UIRenderable: v, Renderable2D: v }), v; }((_dec$8 = ccclass('cc.UIRenderer'), _dec2$2 = requireComponent(UITransform), _dec3$1 = visible(), _dec4$1 = type(Material), _dec5$1 = displayOrder(), _dec6$1 = tooltip(), _dec7$1 = displayName(), _dec8$1 = displayOrder(), _dec9 = tooltip(), _dec10 = type(Material), _dec$8(_class$8 = _dec2$2(_class$8 = executeInEditMode(_class$8 = (_class2$6 = (_temp$6 = _class3$1 = function (_Renderer) {
        _inheritsLoose(UIRenderer, _Renderer);

        function UIRenderer() {
          var _this;

          _this = _Renderer.call(this) || this;
          _this._renderData = null;

          _initializerDefineProperty(_this, "_materials", _descriptor$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_customMaterial", _descriptor2$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_srcBlendFactor", _descriptor3$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_dstBlendFactor", _descriptor4$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_color", _descriptor5, _assertThisInitialized(_this));

          _this._stencilStage = Stage.DISABLED;
          _this._assembler = null;
          _this._postAssembler = null;
          _this._renderDataFlag = true;
          _this._renderFlag = true;
          _this._renderEntity = void 0;
          _this._instanceMaterialType = -1;
          _this._srcBlendFactorCache = BlendFactor.SRC_ALPHA;
          _this._dstBlendFactorCache = BlendFactor.ONE_MINUS_SRC_ALPHA;
          _this._dirtyVersion = -1;
          _this._internalId = -1;
          _this._useVertexOpacity = false;
          _this._lastParent = null;
          _this._renderEntity = _this.createRenderEntity();
          return _this;
        }

        var _proto = UIRenderer.prototype;

        _proto.onLoad = function onLoad() {
          this._renderEntity.setNode(this.node);
        };

        _proto.__preload = function __preload() {
          this.node._uiProps.uiComp = this;

          if (this._flushAssembler) {
            this._flushAssembler();
          }
        };

        _proto.onEnable = function onEnable() {
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
          this.updateMaterial();

          this._colorDirty();

          uiRendererManager.addRenderer(this);
          this.markForUpdateRenderData();
        };

        _proto.onRestore = function onRestore() {
          this.updateMaterial();
          this.markForUpdateRenderData();
        };

        _proto.onDisable = function onDisable() {
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
          uiRendererManager.removeRenderer(this);
          this._renderFlag = false;
          this._renderEntity.enabled = false;
        };

        _proto.onDestroy = function onDestroy() {
          this._renderEntity.setNode(null);

          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }

          this.destroyRenderData();

          if (this._materialInstances) {
            for (var i = 0; i < this._materialInstances.length; i++) {
              var instance = this._materialInstances[i];

              if (instance) {
                instance.destroy();
              }
            }
          }
        };

        _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
          if (enable === void 0) {
            enable = true;
          }

          if (enable) {
            var renderData = this.renderData;

            if (renderData) {
              renderData.vertDirty = true;
            }

            uiRendererManager.markDirtyRenderer(this);
          }
        };

        _proto.requestRenderData = function requestRenderData(drawInfoType) {
          if (drawInfoType === void 0) {
            drawInfoType = RenderDrawInfoType.COMP;
          }

          var data = RenderData.add();
          data.initRenderDrawInfo(this, drawInfoType);
          this._renderData = data;
          return data;
        };

        _proto.destroyRenderData = function destroyRenderData() {
          if (!this.renderData) {
            return;
          }

          this.renderData.removeRenderDrawInfo(this);
          RenderData.remove(this.renderData);
          this._renderData = null;
        };

        _proto.updateRenderer = function updateRenderer() {
          if (this._assembler) {
            this._assembler.updateRenderData(this);
          }

          this._renderFlag = this._canRender();
          this._renderEntity.enabled = this._renderFlag;
        };

        _proto.fillBuffers = function fillBuffers(render) {
          if (this._renderFlag) {
            this._render(render);
          }
        };

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {
          if (this._postAssembler && this._renderFlag) {
            this._postRender(render);
          }
        };

        _proto._render = function _render(render) {};

        _proto._postRender = function _postRender(render) {};

        _proto._canRender = function _canRender() {
          {
            assert(this.isValid, 'this component should not be invalid!');
          }

          return this.getMaterial(0) !== null && this._enabled && this._color.a > 0;
        };

        _proto._postCanRender = function _postCanRender() {};

        _proto.updateMaterial = function updateMaterial() {
          if (this._customMaterial) {
            this.setMaterial(this._customMaterial, 0);
            return;
          }

          var mat = this._updateBuiltinMaterial();

          this.setMaterial(mat, 0);

          if (this.stencilStage === Stage.ENTER_LEVEL || this.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
            this.getMaterialInstance(0).recompileShaders({
              USE_ALPHA_TEST: true
            });
          }

          this._updateBlendFunc();
        };

        _proto._updateColor = function _updateColor() {
          this.node._uiProps.colorDirty = true;
          this.setEntityColorDirty(true);
          this.setEntityColor(this._color);
          this.setEntityOpacity(this.node._uiProps.localOpacity);

          if (this._assembler) {
            this._assembler.updateColor(this);

            this._renderFlag = this._canRender();
            this.setEntityEnabled(this._renderFlag);
          }
        };

        UIRenderer.setEntityColorDirtyRecursively = function setEntityColorDirtyRecursively(node, dirty) {
          var render = node._uiProps.uiComp;

          if (render && render.color) {
            render._renderEntity.colorDirty = dirty;
          }

          for (var i = 0; i < node.children.length; i++) {
            UIRenderer.setEntityColorDirtyRecursively(node.children[i], dirty);
          }
        };

        _proto.setEntityColorDirty = function setEntityColorDirty(dirty) {
        };

        _proto.setEntityColor = function setEntityColor(color) {
        };

        _proto.setEntityOpacity = function setEntityOpacity(opacity) {
        };

        _proto.setEntityEnabled = function setEntityEnabled(enabled) {
        };

        _proto._updateBlendFunc = function _updateBlendFunc() {
          var target = this.getRenderMaterial(0).passes[0].blendState.targets[0];
          this._dstBlendFactorCache = target.blendDst;
          this._srcBlendFactorCache = target.blendSrc;

          if (this._dstBlendFactorCache !== this._dstBlendFactor || this._srcBlendFactorCache !== this._srcBlendFactor) {
            target = this.getMaterialInstance(0).passes[0].blendState.targets[0];
            target.blend = true;
            target.blendDstAlpha = BlendFactor.ONE_MINUS_SRC_ALPHA;
            target.blendDst = this._dstBlendFactor;
            target.blendSrc = this._srcBlendFactor;
            var targetPass = this.getMaterialInstance(0).passes[0];
            targetPass.blendState.setTarget(0, target);

            targetPass._updatePassHash();

            this._dstBlendFactorCache = this._dstBlendFactor;
            this._srcBlendFactorCache = this._srcBlendFactor;
          }
        };

        _proto._nodeStateChange = function _nodeStateChange(transformType) {
          if (this.renderData) {
            this.markForUpdateRenderData();
          }

          for (var i = 0; i < this.node.children.length; ++i) {
            var child = this.node.children[i];
            var renderComp = child.getComponent(UIRenderer);

            if (renderComp) {
              renderComp.markForUpdateRenderData();
            }
          }
        };

        _proto._colorDirty = function _colorDirty() {
          this.node._uiProps.colorDirty = true;
          this.setEntityColorDirty(true);
        };

        _proto._onMaterialModified = function _onMaterialModified(idx, material) {
          if (this.renderData) {
            this.markForUpdateRenderData();
            this.renderData.passDirty = true;
          }

          _Renderer.prototype._onMaterialModified.call(this, idx, material);
        };

        _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
          var mat;

          switch (this._instanceMaterialType) {
            case InstanceMaterialType.ADD_COLOR:
              mat = builtinResMgr.get("ui-base-material");
              break;

            case InstanceMaterialType.GRAYSCALE:
              mat = builtinResMgr.get("ui-sprite-gray-material");
              break;

            case InstanceMaterialType.USE_ALPHA_SEPARATED:
              mat = builtinResMgr.get("ui-sprite-alpha-sep-material");
              break;

            case InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY:
              mat = builtinResMgr.get("ui-sprite-gray-alpha-sep-material");
              break;

            default:
              mat = builtinResMgr.get("ui-sprite-material");
              break;
          }

          return mat;
        };

        _proto.setNodeDirty = function setNodeDirty() {
          if (this.renderData) {
            this.renderData.nodeDirty = true;
          }
        };

        _proto.setTextureDirty = function setTextureDirty() {
          if (this.renderData) {
            this.renderData.textureDirty = true;
          }
        };

        _proto.createRenderEntity = function createRenderEntity() {
          return new RenderEntity(RenderEntityType.STATIC);
        };

        _createClass(UIRenderer, [{
          key: "sharedMaterials",
          get: function get() {
            return  this._materials;
          },
          set: function set(val) {
            for (var i = 0; i < val.length; i++) {
              if (val[i] !== this._materials[i]) {
                this.setMaterial(val[i], i);
              }
            }

            if (val.length < this._materials.length) {
              for (var _i = val.length; _i < this._materials.length; _i++) {
                this.setMaterial(null, _i);
              }

              this._materials.splice(val.length);
            }
          }
        }, {
          key: "customMaterial",
          get: function get() {
            return this._customMaterial;
          },
          set: function set(val) {
            this._customMaterial = val;
            this.updateMaterial();
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color.equals(value)) {
              return;
            }

            this._color.set(value);

            this._updateColor();
          }
        }, {
          key: "renderData",
          get: function get() {
            return this._renderData;
          }
        }, {
          key: "useVertexOpacity",
          get: function get() {
            return this._useVertexOpacity;
          }
        }, {
          key: "stencilStage",
          get: function get() {
            return this._stencilStage;
          },
          set: function set(val) {
            this._stencilStage = val;

            this._renderEntity.setStencilStage(val);
          }
        }, {
          key: "batcher",
          get: function get() {
            return director.root.batcher2D;
          }
        }, {
          key: "renderEntity",
          get: function get() {
            {
              assert(this._renderEntity, 'this._renderEntity should not be invalid');
            }

            return this._renderEntity;
          }
        }]);

        return UIRenderer;
      }(Renderer), _class3$1.BlendState = BlendFactor, _class3$1.Assembler = null, _class3$1.PostAssembler = null, _temp$6), (_applyDecoratedDescriptor(_class2$6.prototype, "sharedMaterials", [override, _dec3$1], Object.getOwnPropertyDescriptor(_class2$6.prototype, "sharedMaterials"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "customMaterial", [_dec4$1, _dec5$1, _dec6$1, _dec7$1, disallowAnimation], Object.getOwnPropertyDescriptor(_class2$6.prototype, "customMaterial"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "color", [_dec8$1, _dec9], Object.getOwnPropertyDescriptor(_class2$6.prototype, "color"), _class2$6.prototype), _descriptor$5 = _applyDecoratedDescriptor(_class2$6.prototype, "_materials", [override], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$6.prototype, "_customMaterial", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$6.prototype, "_srcBlendFactor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return BlendFactor.SRC_ALPHA;
        }
      }), _descriptor4$1 = _applyDecoratedDescriptor(_class2$6.prototype, "_dstBlendFactor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return BlendFactor.ONE_MINUS_SRC_ALPHA;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2$6.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      })), _class2$6)) || _class$8) || _class$8) || _class$8));
      legacyCC.internal.UIRenderer = UIRenderer;

      var _dec$9, _dec2$3, _dec3$2, _dec4$2, _dec5$2, _dec6$2, _dec7$2, _dec8$2, _dec9$1, _dec10$1, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _class$9, _class2$7, _descriptor$6, _descriptor2$4, _descriptor3$3, _descriptor4$2, _descriptor5$1, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _class3$2, _temp$7;
      var tempColor = Color.WHITE.clone();
      var HorizontalTextAlignment;

      (function (HorizontalTextAlignment) {
        HorizontalTextAlignment[HorizontalTextAlignment["LEFT"] = 0] = "LEFT";
        HorizontalTextAlignment[HorizontalTextAlignment["CENTER"] = 1] = "CENTER";
        HorizontalTextAlignment[HorizontalTextAlignment["RIGHT"] = 2] = "RIGHT";
      })(HorizontalTextAlignment || (HorizontalTextAlignment = exports('HorizontalTextAlignment', {})));

      ccenum(HorizontalTextAlignment);
      var VerticalTextAlignment;

      (function (VerticalTextAlignment) {
        VerticalTextAlignment[VerticalTextAlignment["TOP"] = 0] = "TOP";
        VerticalTextAlignment[VerticalTextAlignment["CENTER"] = 1] = "CENTER";
        VerticalTextAlignment[VerticalTextAlignment["BOTTOM"] = 2] = "BOTTOM";
      })(VerticalTextAlignment || (VerticalTextAlignment = exports('VerticalTextAlignment', {})));

      ccenum(VerticalTextAlignment);
      var Overflow;

      (function (Overflow) {
        Overflow[Overflow["NONE"] = 0] = "NONE";
        Overflow[Overflow["CLAMP"] = 1] = "CLAMP";
        Overflow[Overflow["SHRINK"] = 2] = "SHRINK";
        Overflow[Overflow["RESIZE_HEIGHT"] = 3] = "RESIZE_HEIGHT";
      })(Overflow || (Overflow = exports('Overflow', {})));

      ccenum(Overflow);
      var CacheMode;

      (function (CacheMode) {
        CacheMode[CacheMode["NONE"] = 0] = "NONE";
        CacheMode[CacheMode["BITMAP"] = 1] = "BITMAP";
        CacheMode[CacheMode["CHAR"] = 2] = "CHAR";
      })(CacheMode || (CacheMode = exports('CacheMode', {})));

      ccenum(CacheMode);
      var Label = function (v) { return exports({ Label: v, LabelComponent: v }), v; }((_dec$9 = ccclass('cc.Label'), _dec2$3 = help(), _dec3$2 = executionOrder(110), _dec4$2 = menu(), _dec5$2 = displayOrder(), _dec6$2 = tooltip(), _dec7$2 = type(HorizontalTextAlignment), _dec8$2 = displayOrder(), _dec9$1 = tooltip(), _dec10$1 = type(VerticalTextAlignment), _dec11 = displayOrder(), _dec12 = tooltip(), _dec13 = displayOrder(), _dec14 = tooltip(), _dec15 = displayOrder(), _dec16 = visible(), _dec17 = tooltip(), _dec18 = displayOrder(), _dec19 = tooltip(), _dec20 = visible(), _dec21 = displayOrder(), _dec22 = tooltip(), _dec23 = type(Overflow), _dec24 = displayOrder(), _dec25 = tooltip(), _dec26 = displayOrder(), _dec27 = tooltip(), _dec28 = type(Font), _dec29 = displayOrder(), _dec30 = visible(), _dec31 = tooltip(), _dec32 = displayOrder(), _dec33 = tooltip(), _dec34 = type(CacheMode), _dec35 = displayOrder(), _dec36 = tooltip(), _dec37 = displayOrder(), _dec38 = tooltip(), _dec39 = displayOrder(), _dec40 = tooltip(), _dec41 = displayOrder(), _dec42 = tooltip(), _dec43 = visible(), _dec44 = displayOrder(), _dec45 = tooltip(), _dec$9(_class$9 = _dec2$3(_class$9 = _dec3$2(_class$9 = _dec4$2(_class$9 = (_class2$7 = (_temp$7 = _class3$2 = function (_UIRenderer) {
        _inheritsLoose(Label, _UIRenderer);

        function Label() {
          var _this;

          _this = _UIRenderer.call(this) || this;

          _initializerDefineProperty(_this, "_string", _descriptor$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalAlign", _descriptor2$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalAlign", _descriptor3$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_actualFontSize", _descriptor4$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fontSize", _descriptor5$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fontFamily", _descriptor6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lineHeight", _descriptor7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_overflow", _descriptor8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_enableWrapText", _descriptor9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_font", _descriptor10, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor11, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spacingX", _descriptor12, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isItalic", _descriptor13, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isBold", _descriptor14, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isUnderline", _descriptor15, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_underlineHeight", _descriptor16, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cacheMode", _descriptor17, _assertThisInitialized(_this));

          _this._N$file = null;
          _this._texture = null;
          _this._ttfSpriteFrame = null;
          _this._userDefinedFont = null;
          _this._assemblerData = null;
          _this._fontAtlas = null;
          _this._letterTexture = null;
          _this._contentWidth = 0;

          _this._ttfSpriteFrame = null;
          return _this;
        }

        var _proto = Label.prototype;

        _proto.onEnable = function onEnable() {
          _UIRenderer.prototype.onEnable.call(this);

          if (!this._font && !this._isSystemFontUsed) {
            this.useSystemFont = true;
          }

          if (this._isSystemFontUsed && !this._fontFamily) {
            this.fontFamily = 'Arial';
          }

          this._applyFontTexture();
        };

        _proto.onDestroy = function onDestroy() {
          if (this._assembler && this._assembler.resetAssemblerData) {
            this._assembler.resetAssemblerData(this._assemblerData);
          }

          this._assemblerData = null;

          if (this._ttfSpriteFrame) {
            this._ttfSpriteFrame._resetDynamicAtlasFrame();

            var tex = this._ttfSpriteFrame.texture;

            this._ttfSpriteFrame.destroy();

            if (tex) {
              var tex2d = tex;

              if (tex2d.image) {
                tex2d.image.destroy();
              }

              tex.destroy();
            }

            this._ttfSpriteFrame = null;
          }

          this._letterTexture = null;

          _UIRenderer.prototype.onDestroy.call(this);
        };

        _proto.updateRenderData = function updateRenderData(force) {
          if (force === void 0) {
            force = false;
          }

          if (force) {
            this._flushAssembler();

            if (this.renderData) this.renderData.vertDirty = true;

            this._applyFontTexture();
          }

          if (this._assembler) {
            this._assembler.updateRenderData(this);
          }
        };

        _proto._render = function _render(render) {
          render.commitComp(this, this.renderData, this._texture, this._assembler, null);
        };

        _proto._updateColor = function _updateColor() {
          _UIRenderer.prototype._updateColor.call(this);

          this.markForUpdateRenderData();
        };

        _proto.setEntityColor = function setEntityColor(color) {
        };

        _proto._canRender = function _canRender() {
          if (!_UIRenderer.prototype._canRender.call(this) || !this._string) {
            return false;
          }

          var font = this._font;

          if (font && font instanceof BitmapFont) {
            var spriteFrame = font.spriteFrame;

            if (!spriteFrame || !spriteFrame.texture) {
              return false;
            }
          }

          return true;
        };

        _proto._flushAssembler = function _flushAssembler() {
          var assembler = Label.Assembler.getAssembler(this);

          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
          }

          if (!this.renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this.renderData.material = this.material;

              this._updateColor();
            }
          }
        };

        _proto._applyFontTexture = function _applyFontTexture() {
          this.markForUpdateRenderData();
          var font = this._font;

          if (font instanceof BitmapFont) {
            var spriteFrame = font.spriteFrame;

            if (spriteFrame && spriteFrame.texture) {
              this._texture = spriteFrame;

              if (this.renderData) {
                this.renderData.textureDirty = true;
              }

              this.changeMaterialForDefine();

              if (this._assembler) {
                this._assembler.updateRenderData(this);
              }
            }
          } else {
            if (this.cacheMode === CacheMode.CHAR) {
              this._letterTexture = this._assembler.getAssemblerData();
              this._texture = this._letterTexture;
            } else if (!this._ttfSpriteFrame) {
              this._ttfSpriteFrame = new SpriteFrame();
              this._assemblerData = this._assembler.getAssemblerData();
              var image = new ImageAsset(this._assemblerData.canvas);
              var texture = new Texture2D();
              texture.image = image;
              this._ttfSpriteFrame.texture = texture;
            }

            if (this.cacheMode !== CacheMode.CHAR) {
              this._texture = this._ttfSpriteFrame;
            }

            this.changeMaterialForDefine();
          }
        };

        _proto.changeMaterialForDefine = function changeMaterialForDefine() {
          if (!this._texture) {
            return;
          }

          var value = false;

          if (this.cacheMode !== CacheMode.CHAR) {
            var spriteFrame = this._texture;
            var texture = spriteFrame.texture;

            if (texture instanceof TextureBase) {
              var format = texture.getPixelFormat();
              value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
            }
          }

          if (value) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
          } else {
            this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
          }

          this.updateMaterial();
        };

        _proto._updateBlendFunc = function _updateBlendFunc() {

          _UIRenderer.prototype._updateBlendFunc.call(this);
        };

        _createClass(Label, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            if (value === null || value === undefined) {
              value = '';
            } else {
              value = value.toString();
            }

            if (this._string === value) {
              return;
            }

            this._string = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "horizontalAlign",
          get: function get() {
            return this._horizontalAlign;
          },
          set: function set(value) {
            if (this._horizontalAlign === value) {
              return;
            }

            this._horizontalAlign = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "verticalAlign",
          get: function get() {
            return this._verticalAlign;
          },
          set: function set(value) {
            if (this._verticalAlign === value) {
              return;
            }

            this._verticalAlign = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "actualFontSize",
          get: function get() {
            return this._actualFontSize;
          },
          set: function set(value) {
            this._actualFontSize = value;
          }
        }, {
          key: "fontSize",
          get: function get() {
            return this._fontSize;
          },
          set: function set(value) {
            if (this._fontSize === value) {
              return;
            }

            this._fontSize = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "fontFamily",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            if (this._fontFamily === value) {
              return;
            }

            this._fontFamily = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "lineHeight",
          get: function get() {
            return this._lineHeight;
          },
          set: function set(value) {
            if (this._lineHeight === value) {
              return;
            }

            this._lineHeight = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "spacingX",
          get: function get() {
            return this._spacingX;
          },
          set: function set(value) {
            if (this._spacingX === value) {
              return;
            }

            this._spacingX = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "overflow",
          get: function get() {
            return this._overflow;
          },
          set: function set(value) {
            if (this._overflow === value) {
              return;
            }

            this._overflow = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "enableWrapText",
          get: function get() {
            return this._enableWrapText;
          },
          set: function set(value) {
            if (this._enableWrapText === value) {
              return;
            }

            this._enableWrapText = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "font",
          get: function get() {
            return this._font;
          },
          set: function set(value) {
            if (this._font === value) {
              return;
            }

            this._isSystemFontUsed = !value;

            this._font = value;
            this.destroyRenderData();
            this._fontAtlas = null;
            this.updateRenderData(true);
          }
        }, {
          key: "useSystemFont",
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(value) {
            if (this._isSystemFontUsed === value) {
              return;
            }

            this.destroyRenderData();

            this._isSystemFontUsed = !!value;

            if (value) {
              this.font = null;
            }

            this._flushAssembler();

            this.markForUpdateRenderData();
          }
        }, {
          key: "cacheMode",
          get: function get() {
            return this._cacheMode;
          },
          set: function set(value) {
            if (this._cacheMode === value) {
              return;
            }

            if (this._cacheMode === CacheMode.BITMAP && !(this._font instanceof BitmapFont) && this._ttfSpriteFrame) {
              this._ttfSpriteFrame._resetDynamicAtlasFrame();
            }

            if (this._cacheMode === CacheMode.CHAR) {
              this._ttfSpriteFrame = null;
            }

            this._cacheMode = value;
            this.updateRenderData(true);
          }
        }, {
          key: "isBold",
          get: function get() {
            return this._isBold;
          },
          set: function set(value) {
            if (this._isBold === value) {
              return;
            }

            this._isBold = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "isItalic",
          get: function get() {
            return this._isItalic;
          },
          set: function set(value) {
            if (this._isItalic === value) {
              return;
            }

            this._isItalic = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "isUnderline",
          get: function get() {
            return this._isUnderline;
          },
          set: function set(value) {
            if (this._isUnderline === value) {
              return;
            }

            this._isUnderline = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "underlineHeight",
          get: function get() {
            return this._underlineHeight;
          },
          set: function set(value) {
            if (this._underlineHeight === value) return;
            this._underlineHeight = value;
            this.markForUpdateRenderData();
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._texture;
          }
        }, {
          key: "ttfSpriteFrame",
          get: function get() {
            return this._ttfSpriteFrame;
          }
        }, {
          key: "assemblerData",
          get: function get() {
            return this._assemblerData;
          }
        }, {
          key: "fontAtlas",
          get: function get() {
            return this._fontAtlas;
          },
          set: function set(value) {
            this._fontAtlas = value;
          }
        }, {
          key: "_bmFontOriginalSize",
          get: function get() {
            if (this._font instanceof BitmapFont) {
              return this._font.fontSize;
            } else {
              return -1;
            }
          }
        }, {
          key: "contentWidth",
          get: function get() {
            return this._contentWidth;
          },
          set: function set(val) {
            this._contentWidth = val;
          }
        }]);

        return Label;
      }(UIRenderer), _class3$2.HorizontalAlign = HorizontalTextAlignment, _class3$2.VerticalAlign = VerticalTextAlignment, _class3$2.Overflow = Overflow, _class3$2.CacheMode = CacheMode, _class3$2._canvasPool = CanvasPool.getInstance(), _temp$7), (_applyDecoratedDescriptor(_class2$7.prototype, "string", [_dec5$2, _dec6$2, multiline], Object.getOwnPropertyDescriptor(_class2$7.prototype, "string"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "horizontalAlign", [_dec7$2, _dec8$2, _dec9$1], Object.getOwnPropertyDescriptor(_class2$7.prototype, "horizontalAlign"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "verticalAlign", [_dec10$1, _dec11, _dec12], Object.getOwnPropertyDescriptor(_class2$7.prototype, "verticalAlign"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "fontSize", [_dec13, _dec14], Object.getOwnPropertyDescriptor(_class2$7.prototype, "fontSize"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "fontFamily", [_dec15, _dec16, _dec17], Object.getOwnPropertyDescriptor(_class2$7.prototype, "fontFamily"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "lineHeight", [_dec18, _dec19], Object.getOwnPropertyDescriptor(_class2$7.prototype, "lineHeight"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "spacingX", [_dec20, _dec21, _dec22], Object.getOwnPropertyDescriptor(_class2$7.prototype, "spacingX"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "overflow", [_dec23, _dec24, _dec25], Object.getOwnPropertyDescriptor(_class2$7.prototype, "overflow"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "enableWrapText", [_dec26, _dec27], Object.getOwnPropertyDescriptor(_class2$7.prototype, "enableWrapText"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "font", [_dec28, _dec29, _dec30, _dec31], Object.getOwnPropertyDescriptor(_class2$7.prototype, "font"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "useSystemFont", [_dec32, _dec33], Object.getOwnPropertyDescriptor(_class2$7.prototype, "useSystemFont"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "cacheMode", [_dec34, _dec35, _dec36], Object.getOwnPropertyDescriptor(_class2$7.prototype, "cacheMode"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "isBold", [_dec37, _dec38], Object.getOwnPropertyDescriptor(_class2$7.prototype, "isBold"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "isItalic", [_dec39, _dec40], Object.getOwnPropertyDescriptor(_class2$7.prototype, "isItalic"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "isUnderline", [_dec41, _dec42], Object.getOwnPropertyDescriptor(_class2$7.prototype, "isUnderline"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "underlineHeight", [_dec43, editable, _dec44, _dec45], Object.getOwnPropertyDescriptor(_class2$7.prototype, "underlineHeight"), _class2$7.prototype), _descriptor$6 = _applyDecoratedDescriptor(_class2$7.prototype, "_string", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'label';
        }
      }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$7.prototype, "_horizontalAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return HorizontalTextAlignment.CENTER;
        }
      }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$7.prototype, "_verticalAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return VerticalTextAlignment.CENTER;
        }
      }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$7.prototype, "_actualFontSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor5$1 = _applyDecoratedDescriptor(_class2$7.prototype, "_fontSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2$7.prototype, "_fontFamily", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'Arial';
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2$7.prototype, "_lineHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2$7.prototype, "_overflow", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Overflow.NONE;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2$7.prototype, "_enableWrapText", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2$7.prototype, "_font", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2$7.prototype, "_isSystemFontUsed", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2$7.prototype, "_spacingX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2$7.prototype, "_isItalic", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2$7.prototype, "_isBold", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2$7.prototype, "_isUnderline", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2$7.prototype, "_underlineHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2$7.prototype, "_cacheMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return CacheMode.NONE;
        }
      })), _class2$7)) || _class$9) || _class$9) || _class$9) || _class$9));
      legacyCC.Label = Label;

      var _stageOffset = 0;
      var _name2stageID = {};
      var config = {
        addStage: function addStage(name) {
          if (_name2stageID[name] !== undefined) {
            return;
          }

          var stageID = 1 << _stageOffset;
          _name2stageID[name] = stageID;
          _stageOffset += 1;
        },
        stageID: function stageID(name) {
          var id = _name2stageID[name];

          if (id === undefined) {
            return -1;
          }

          return id;
        },
        stageIDs: function stageIDs(nameList) {
          var key = 0;

          for (var _iterator = _createForOfIteratorHelperLoose(nameList), _step; !(_step = _iterator()).done;) {
            var name = _step.value;
            var id = _name2stageID[name];

            if (id !== undefined) {
              key |= id;
            }
          }

          return key;
        }
      };

      function createIA(device, data) {
        if (!data.positions) {
          console.error('The data must have positions field');
          return null;
        }

        var verts = [];
        var vcount = data.positions.length / 3;

        for (var i = 0; i < vcount; ++i) {
          verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);

          if (data.normals) {
            verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
          }

          if (data.uvs) {
            verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
          }

          if (data.colors) {
            verts.push(data.colors[3 * i], data.colors[3 * i + 1], data.colors[3 * i + 2]);
          }
        }

        var vfmt = [];
        vfmt.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F));

        if (data.normals) {
          vfmt.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F));
        }

        if (data.uvs) {
          vfmt.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F));
        }

        if (data.colors) {
          vfmt.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGB32F));
        }

        var vb = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, verts.length * 4, verts.length * 4 / vcount));
        vb.update(new Float32Array(verts));
        var ib = null;

        if (data.indices) {
          ib = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, data.indices.length * 2, 2));
          ib.update(new Uint16Array(data.indices));
        }

        return device.createInputAssembler(new InputAssemblerInfo(vfmt, [vb], ib));
      }

      var RenderQueue;

      (function (RenderQueue) {
        RenderQueue[RenderQueue["OPAQUE"] = 0] = "OPAQUE";
        RenderQueue[RenderQueue["TRANSPARENT"] = 1] = "TRANSPARENT";
        RenderQueue[RenderQueue["OVERLAY"] = 2] = "OVERLAY";
      })(RenderQueue || (RenderQueue = {}));

      var PassStage;

      (function (PassStage) {
        PassStage[PassStage["DEFAULT"] = 1] = "DEFAULT";
        PassStage[PassStage["FORWARD"] = 2] = "FORWARD";
        PassStage[PassStage["SHADOWCAST"] = 4] = "SHADOWCAST";
      })(PassStage || (PassStage = {}));

      function nearestPOT(num) {
        --num;
        num |= num >> 16;
        num |= num >> 8;
        num |= num >> 4;
        num |= num >> 2;
        num |= num >> 1;
        ++num;
        return num;
      }

      function roundUp(n, alignment) {
        return Math.ceil(n / alignment) * alignment;
      }

      var TextureBufferPool = function () {
        function TextureBufferPool(device) {
          this._device = void 0;
          this._format = Format.UNKNOWN;
          this._formatSize = 0;
          this._chunks = [];
          this._chunkCount = 0;
          this._handles = [];
          this._region0 = new BufferTextureCopy();
          this._region1 = new BufferTextureCopy();
          this._region2 = new BufferTextureCopy();
          this._roundUpFn = null;
          this._bufferViewCtor = Uint8Array;
          this._channels = 4;
          this._alignment = 1;
          this._device = device;
        }

        var _proto = TextureBufferPool.prototype;

        _proto.initialize = function initialize(info) {
          var formatInfo = FormatInfos[info.format];
          this._format = info.format;
          this._formatSize = formatInfo.size;
          this._channels = formatInfo.count;
          this._bufferViewCtor = getTypedArrayConstructor(formatInfo);
          this._roundUpFn = info.roundUpFn || null;
          this._alignment = info.alignment || 1;

          if (info.inOrderFree) {
            this.alloc = this._McDonaldAlloc;
          }
        };

        _proto.destroy = function destroy() {
          for (var i = 0; i < this._chunkCount; ++i) {
            var chunk = this._chunks[i];
            chunk.texture.destroy();
          }

          this._chunks.length = 0;
          this._handles.length = 0;
        };

        _proto.alloc = function alloc(size, chunkIdx) {
          size = roundUp(size, this._alignment);
          var index = -1;
          var start = -1;

          if (chunkIdx !== undefined) {
            index = chunkIdx;
            start = this._findAvailableSpace(size, index);
          }

          if (start < 0) {
            for (var i = 0; i < this._chunkCount; ++i) {
              index = i;
              start = this._findAvailableSpace(size, index);

              if (start >= 0) {
                break;
              }
            }
          }

          if (start >= 0) {
            var chunk = this._chunks[index];
            chunk.start += size;
            var handle = {
              chunkIdx: index,
              start: start,
              end: start + size,
              texture: chunk.texture
            };

            this._handles.push(handle);

            return handle;
          }

          var targetSize = Math.sqrt(size / this._formatSize);
          var texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

          var newChunk = this._chunks[this.createChunk(texLength)];

          newChunk.start += size;
          var texHandle = {
            chunkIdx: this._chunkCount - 1,
            start: 0,
            end: size,
            texture: newChunk.texture
          };

          this._handles.push(texHandle);

          return texHandle;
        };

        _proto.free = function free(handle) {
          for (var i = 0; i < this._handles.length; ++i) {
            if (this._handles[i] === handle) {
              this._chunks[handle.chunkIdx].end = handle.end;

              this._handles.splice(i, 1);

              return;
            }
          }
        };

        _proto.createChunk = function createChunk(length) {
          var texSize = length * length * this._formatSize;
          debug("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + texSize + ", format: " + this._format);

          var texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, this._format, length, length));

          var chunk = {
            texture: texture,
            size: texSize,
            start: 0,
            end: texSize
          };
          this._chunks[this._chunkCount] = chunk;
          return this._chunkCount++;
        };

        _proto.update = function update(handle, buffer) {
          var buffers = [];
          var regions = [];
          var start = handle.start / this._formatSize;
          var remainSize = buffer.byteLength / this._formatSize;
          var offsetX = start % handle.texture.width;
          var offsetY = Math.floor(start / handle.texture.width);
          var copySize = Math.min(handle.texture.width - offsetX, remainSize);
          var begin = 0;

          if (offsetX > 0) {
            this._region0.texOffset.x = offsetX;
            this._region0.texOffset.y = offsetY;
            this._region0.texExtent.width = copySize;
            this._region0.texExtent.height = 1;
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
            regions.push(this._region0);
            offsetX = 0;
            offsetY += 1;
            remainSize -= copySize;
            begin += copySize;
          }

          if (remainSize > 0) {
            this._region1.texOffset.x = offsetX;
            this._region1.texOffset.y = offsetY;

            if (remainSize > handle.texture.width) {
              this._region1.texExtent.width = handle.texture.width;
              this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width);
              copySize = this._region1.texExtent.width * this._region1.texExtent.height;
            } else {
              copySize = remainSize;
              this._region1.texExtent.width = copySize;
              this._region1.texExtent.height = 1;
            }

            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
            regions.push(this._region1);
            offsetX = 0;
            offsetY += this._region1.texExtent.height;
            remainSize -= copySize;
            begin += copySize;
          }

          if (remainSize > 0) {
            this._region2.texOffset.x = offsetX;
            this._region2.texOffset.y = offsetY;
            this._region2.texExtent.width = remainSize;
            this._region2.texExtent.height = 1;
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels));
            regions.push(this._region2);
          }

          this._device.copyBuffersToTexture(buffers, handle.texture, regions);
        };

        _proto._findAvailableSpace = function _findAvailableSpace(size, chunkIdx) {
          var chunk = this._chunks[chunkIdx];
          var isFound = false;
          var start = chunk.start;

          if (start + size <= chunk.size) {
            isFound = true;
          } else {
            start = 0;

            var handles = this._handles.filter(function (h) {
              return h.chunkIdx === chunkIdx;
            }).sort(function (a, b) {
              return a.start - b.start;
            });

            for (var i = 0; i < handles.length; i++) {
              var handle = handles[i];

              if (start + size <= handle.start) {
                isFound = true;
                break;
              }

              start = handle.end;
            }

            if (!isFound && start + size <= chunk.size) {
              isFound = true;
            }
          }

          return isFound ? start : -1;
        };

        _proto._McDonaldAlloc = function _McDonaldAlloc(size) {
          size = roundUp(size, this._alignment);

          for (var i = 0; i < this._chunkCount; ++i) {
            var chunk = this._chunks[i];
            var isFound = false;
            var start = chunk.start;

            if (start + size <= chunk.end) {
              isFound = true;
            } else if (start > chunk.end) {
              if (start + size <= chunk.size) {
                isFound = true;
              } else if (size <= chunk.end) {
                chunk.start = start = 0;
                isFound = true;
              }
            } else if (start === chunk.end) {
              chunk.start = start = 0;
              chunk.end = chunk.size;

              if (size <= chunk.end) {
                isFound = true;
              }
            }

            if (isFound) {
              chunk.start += size;
              var handle = {
                chunkIdx: i,
                start: start,
                end: start + size,
                texture: chunk.texture
              };

              this._handles.push(handle);

              return handle;
            }
          }

          var targetSize = Math.sqrt(size / this._formatSize);
          var texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

          var newChunk = this._chunks[this.createChunk(texLength)];

          newChunk.start += size;
          var texHandle = {
            chunkIdx: this._chunkCount,
            start: 0,
            end: size,
            texture: newChunk.texture
          };

          this._handles.push(texHandle);

          return texHandle;
        };

        return TextureBufferPool;
      }();

      var NativeBufferPool = function () {
        function NativeBufferPool(dataType, entryBits, stride) {
          this._arrayBuffers = [];
          this._chunkSize = void 0;
          this._chunkSize = stride * (1 << entryBits);
        }

        var _proto = NativeBufferPool.prototype;

        _proto.allocateNewChunk = function allocateNewChunk() {
          return new ArrayBuffer(this._chunkSize);
        };

        return NativeBufferPool;
      }();

      var _Render2dViewDataType, _Render2dViewDataMemb, _NodeViewDataType, _NodeViewDataMembers, _PassViewDataType, _PassViewDataMembers, _AABBViewDataType, _AABBViewDataMembers;

      var contains = function contains(a, t) {
        for (var i = 0; i < a.length; ++i) {
          if (a[i] === t) return true;
        }

        return false;
      };

      var BufferDataType;

      (function (BufferDataType) {
        BufferDataType[BufferDataType["UINT32"] = 0] = "UINT32";
        BufferDataType[BufferDataType["FLOAT32"] = 1] = "FLOAT32";
        BufferDataType[BufferDataType["NEVER"] = 2] = "NEVER";
      })(BufferDataType || (BufferDataType = {}));

      var BufferPool = function () {
        function BufferPool(poolType, dataType, dataMembers, enumType, entryBits) {
          if (entryBits === void 0) {
            entryBits = 8;
          }

          this._dataType = void 0;
          this._dataMembers = void 0;
          this._elementCount = void 0;
          this._entryBits = void 0;
          this._stride = void 0;
          this._entriesPerChunk = void 0;
          this._entryMask = void 0;
          this._chunkMask = void 0;
          this._poolFlag = void 0;
          this._arrayBuffers = [];
          this._freeLists = [];
          this._uint32BufferViews = [];
          this._float32BufferViews = [];
          this._hasUint32 = false;
          this._hasFloat32 = false;
          this._nativePool = void 0;
          this._elementCount = enumType.COUNT;
          this._entryBits = entryBits;
          this._dataType = dataType;
          this._dataMembers = dataMembers;
          var bytesPerElement = 4;
          this._stride = bytesPerElement * this._elementCount;
          this._entriesPerChunk = 1 << entryBits;
          this._entryMask = this._entriesPerChunk - 1;
          this._poolFlag = 1 << 30;
          this._chunkMask = ~(this._entryMask | this._poolFlag);
          this._nativePool = new NativeBufferPool(poolType, entryBits, this._stride);
          var type = BufferDataType.NEVER;
          var hasFloat32 = false;
          var hasUint32 = false;

          for (var e in dataType) {
            hasFloat32 = this._hasFloat32;
            hasUint32 = this._hasUint32;

            if (hasUint32 && hasFloat32) {
              break;
            }

            type = dataType[e];

            if (!hasFloat32 && type === BufferDataType.FLOAT32) {
              this._hasFloat32 = true;
            } else if (!hasUint32 && type === BufferDataType.UINT32) {
              this._hasUint32 = true;
            }
          }
        }

        var _proto = BufferPool.prototype;

        _proto.alloc = function alloc() {
          var i = 0;

          for (; i < this._freeLists.length; i++) {
            var list = this._freeLists[i];

            if (list.length) {
              var j = list[list.length - 1];
              list.length--;
              return (i << this._entryBits) + j + this._poolFlag;
            }
          }

          var buffer = this._nativePool.allocateNewChunk();

          var float32BufferViews = [];
          var uint32BufferViews = [];
          var freeList = [];
          var hasFloat32 = this._hasFloat32;
          var hasUint32 = this._hasUint32;

          for (var _j = 0; _j < this._entriesPerChunk; _j++) {
            if (hasFloat32) {
              float32BufferViews.push(new Float32Array(buffer, this._stride * _j, this._elementCount));
            }

            if (hasUint32) {
              uint32BufferViews.push(new Uint32Array(buffer, this._stride * _j, this._elementCount));
            }

            if (_j) {
              freeList.push(_j);
            }
          }

          if (hasUint32) {
            this._uint32BufferViews.push(uint32BufferViews);
          }

          if (hasFloat32) {
            this._float32BufferViews.push(float32BufferViews);
          }

          this._freeLists.push(freeList);

          this._arrayBuffers.push(buffer);

          var handle = (i << this._entryBits) + this._poolFlag;
          return handle;
        };

        _proto.getBuffer = function getBuffer(handle) {
          var chunk = (this._chunkMask & handle) >> this._entryBits;
          var entry = this._entryMask & handle;
          var bufferViews = this._hasFloat32 ? this._float32BufferViews : this._uint32BufferViews;

          if ( (!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return [];
          }

          return bufferViews[chunk][entry];
        };

        _proto.getTypedArray = function getTypedArray(handle, element) {
          var chunk = (this._chunkMask & handle) >> this._entryBits;
          var entry = this._entryMask & handle;
          var bufferViews = this._dataType[element] === BufferDataType.UINT32 ? this._uint32BufferViews : this._float32BufferViews;

          if ( (!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return [];
          }

          var index = element;
          var view = bufferViews[chunk][entry];
          var count = this._dataMembers[element];
          return view.subarray(index, index + count);
        };

        _proto.free = function free(handle) {
          var chunk = (this._chunkMask & handle) >> this._entryBits;
          var entry = this._entryMask & handle;

          if ( (!handle || chunk < 0 || chunk >= this._freeLists.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return;
          }

          var bufferViews = this._hasUint32 ? this._uint32BufferViews : this._float32BufferViews;
          bufferViews[chunk][entry].fill(0);

          this._freeLists[chunk].push(entry);
        };

        return BufferPool;
      }();

      var PoolType;

      (function (PoolType) {
        PoolType[PoolType["NODE"] = 0] = "NODE";
        PoolType[PoolType["PASS"] = 1] = "PASS";
        PoolType[PoolType["AABB"] = 2] = "AABB";
        PoolType[PoolType["RENDER2D"] = 3] = "RENDER2D";
      })(PoolType || (PoolType = {}));

      var NULL_HANDLE = 0;
      var Render2dView;

      (function (Render2dView) {
        Render2dView[Render2dView["POSITION"] = 0] = "POSITION";
        Render2dView[Render2dView["UV"] = 3] = "UV";
        Render2dView[Render2dView["COLOR"] = 5] = "COLOR";
        Render2dView[Render2dView["COUNT"] = 9] = "COUNT";
      })(Render2dView || (Render2dView = {}));

      var Render2dViewDataType = (_Render2dViewDataType = {}, _Render2dViewDataType[Render2dView.POSITION] = BufferDataType.FLOAT32, _Render2dViewDataType[Render2dView.UV] = BufferDataType.FLOAT32, _Render2dViewDataType[Render2dView.COLOR] = BufferDataType.UINT32, _Render2dViewDataType[Render2dView.COUNT] = BufferDataType.NEVER, _Render2dViewDataType);
      var Render2dViewDataMembers = (_Render2dViewDataMemb = {}, _Render2dViewDataMemb[Render2dView.POSITION] = Render2dView.UV - Render2dView.POSITION, _Render2dViewDataMemb[Render2dView.UV] = Render2dView.COLOR - Render2dView.UV, _Render2dViewDataMemb[Render2dView.COLOR] = Render2dView.COUNT - Render2dView.COLOR, _Render2dViewDataMemb[Render2dView.COUNT] = 1, _Render2dViewDataMemb);
      var Render2dPool = new BufferPool(PoolType.RENDER2D, Render2dViewDataType, Render2dViewDataMembers, Render2dView);
      var NodeView;

      (function (NodeView) {
        NodeView[NodeView["DIRTY_FLAG"] = 0] = "DIRTY_FLAG";
        NodeView[NodeView["LAYER"] = 1] = "LAYER";
        NodeView[NodeView["WORLD_SCALE"] = 2] = "WORLD_SCALE";
        NodeView[NodeView["WORLD_POSITION"] = 5] = "WORLD_POSITION";
        NodeView[NodeView["WORLD_ROTATION"] = 8] = "WORLD_ROTATION";
        NodeView[NodeView["WORLD_MATRIX"] = 12] = "WORLD_MATRIX";
        NodeView[NodeView["LOCAL_SCALE"] = 28] = "LOCAL_SCALE";
        NodeView[NodeView["LOCAL_POSITION"] = 31] = "LOCAL_POSITION";
        NodeView[NodeView["LOCAL_ROTATION"] = 34] = "LOCAL_ROTATION";
        NodeView[NodeView["COUNT"] = 38] = "COUNT";
      })(NodeView || (NodeView = {}));

      var NodeViewDataType = (_NodeViewDataType = {}, _NodeViewDataType[NodeView.DIRTY_FLAG] = BufferDataType.UINT32, _NodeViewDataType[NodeView.LAYER] = BufferDataType.UINT32, _NodeViewDataType[NodeView.WORLD_SCALE] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.WORLD_POSITION] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.WORLD_ROTATION] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.WORLD_MATRIX] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.LOCAL_SCALE] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.LOCAL_POSITION] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.LOCAL_ROTATION] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.COUNT] = BufferDataType.NEVER, _NodeViewDataType);
      var NodeViewDataMembers = (_NodeViewDataMembers = {}, _NodeViewDataMembers[NodeView.DIRTY_FLAG] = NodeView.LAYER - NodeView.DIRTY_FLAG, _NodeViewDataMembers[NodeView.LAYER] = NodeView.WORLD_SCALE - NodeView.LAYER, _NodeViewDataMembers[NodeView.WORLD_SCALE] = NodeView.WORLD_POSITION - NodeView.WORLD_SCALE, _NodeViewDataMembers[NodeView.WORLD_POSITION] = NodeView.WORLD_ROTATION - NodeView.WORLD_POSITION, _NodeViewDataMembers[NodeView.WORLD_ROTATION] = NodeView.WORLD_MATRIX - NodeView.WORLD_ROTATION, _NodeViewDataMembers[NodeView.WORLD_MATRIX] = NodeView.LOCAL_SCALE - NodeView.WORLD_MATRIX, _NodeViewDataMembers[NodeView.LOCAL_SCALE] = NodeView.LOCAL_POSITION - NodeView.LOCAL_SCALE, _NodeViewDataMembers[NodeView.LOCAL_POSITION] = NodeView.LOCAL_ROTATION - NodeView.LOCAL_POSITION, _NodeViewDataMembers[NodeView.LOCAL_ROTATION] = NodeView.COUNT - NodeView.LOCAL_ROTATION, _NodeViewDataMembers[NodeView.COUNT] = 1, _NodeViewDataMembers);
      var NodePool = new BufferPool(PoolType.NODE, NodeViewDataType, NodeViewDataMembers, NodeView);
      var PassView;

      (function (PassView) {
        PassView[PassView["PRIORITY"] = 0] = "PRIORITY";
        PassView[PassView["STAGE"] = 1] = "STAGE";
        PassView[PassView["PHASE"] = 2] = "PHASE";
        PassView[PassView["PRIMITIVE"] = 3] = "PRIMITIVE";
        PassView[PassView["BATCHING_SCHEME"] = 4] = "BATCHING_SCHEME";
        PassView[PassView["DYNAMIC_STATE"] = 5] = "DYNAMIC_STATE";
        PassView[PassView["HASH"] = 6] = "HASH";
        PassView[PassView["COUNT"] = 7] = "COUNT";
      })(PassView || (PassView = {}));

      var PassViewDataType = (_PassViewDataType = {}, _PassViewDataType[PassView.PRIORITY] = BufferDataType.UINT32, _PassViewDataType[PassView.STAGE] = BufferDataType.UINT32, _PassViewDataType[PassView.PHASE] = BufferDataType.UINT32, _PassViewDataType[PassView.PRIMITIVE] = BufferDataType.UINT32, _PassViewDataType[PassView.BATCHING_SCHEME] = BufferDataType.UINT32, _PassViewDataType[PassView.DYNAMIC_STATE] = BufferDataType.UINT32, _PassViewDataType[PassView.HASH] = BufferDataType.UINT32, _PassViewDataType[PassView.COUNT] = BufferDataType.NEVER, _PassViewDataType);
      var PassViewDataMembers = (_PassViewDataMembers = {}, _PassViewDataMembers[PassView.PRIORITY] = PassView.STAGE - PassView.PRIORITY, _PassViewDataMembers[PassView.STAGE] = PassView.PHASE - PassView.STAGE, _PassViewDataMembers[PassView.PHASE] = PassView.PRIMITIVE - PassView.PHASE, _PassViewDataMembers[PassView.PRIMITIVE] = PassView.BATCHING_SCHEME - PassView.PRIMITIVE, _PassViewDataMembers[PassView.BATCHING_SCHEME] = PassView.DYNAMIC_STATE - PassView.BATCHING_SCHEME, _PassViewDataMembers[PassView.DYNAMIC_STATE] = PassView.HASH - PassView.DYNAMIC_STATE, _PassViewDataMembers[PassView.HASH] = PassView.COUNT - PassView.HASH, _PassViewDataMembers[PassView.COUNT] = 1, _PassViewDataMembers);
      var PassPool = new BufferPool(PoolType.PASS, PassViewDataType, PassViewDataMembers, PassView);
      var AABBView;

      (function (AABBView) {
        AABBView[AABBView["CENTER"] = 0] = "CENTER";
        AABBView[AABBView["HALFEXTENTS"] = 3] = "HALFEXTENTS";
        AABBView[AABBView["COUNT"] = 6] = "COUNT";
      })(AABBView || (AABBView = {}));

      var AABBViewDataType = (_AABBViewDataType = {}, _AABBViewDataType[AABBView.CENTER] = BufferDataType.FLOAT32, _AABBViewDataType[AABBView.HALFEXTENTS] = BufferDataType.FLOAT32, _AABBViewDataType[AABBView.COUNT] = BufferDataType.NEVER, _AABBViewDataType);
      var AABBViewDataMembers = (_AABBViewDataMembers = {}, _AABBViewDataMembers[AABBView.CENTER] = AABBView.HALFEXTENTS - AABBView.CENTER, _AABBViewDataMembers[AABBView.HALFEXTENTS] = AABBView.COUNT - AABBView.HALFEXTENTS, _AABBViewDataMembers[AABBView.COUNT] = 1, _AABBViewDataMembers);
      var AABBPool = new BufferPool(PoolType.AABB, AABBViewDataType, AABBViewDataMembers, AABBView);

      removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
        name: 'raycastUI2DNode'
      }, {
        name: 'raycastUINode'
      }]);
      removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
        name: 'raycastAll',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastAllModels',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastSingleModel',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastAllCanvas',
        suggest: 'using intersect.rayAABB in geometry'
      }, {
        name: 'rayResultCanvas'
      }, {
        name: 'rayResultModels'
      }, {
        name: 'rayResultAll'
      }, {
        name: 'rayResultSingleModel'
      }]);
      var CameraVisFlags = {};
      removeProperty(CameraVisFlags, 'CameraVisFlags', [{
        name: 'GENERAL'
      }]);
      replaceProperty(CameraVisFlags, 'CameraVisFlags', [{
        name: 'PROFILER',
        newName: 'PROFILER',
        target: Layers.BitMask,
        targetName: 'PROFILER'
      }, {
        name: 'GIZMOS',
        newName: 'GIZMOS',
        target: Layers.BitMask,
        targetName: 'GIZMOS'
      }, {
        name: 'EDITOR',
        newName: 'EDITOR',
        target: Layers.BitMask,
        targetName: 'EDITOR'
      }, {
        name: 'UI',
        newName: 'UI',
        target: Layers.BitMask,
        targetName: 'UI_3D'
      }, {
        name: 'UI2D',
        newName: 'UI2D',
        target: Layers.BitMask,
        targetName: 'UI_2D'
      }]);
      legacyCC.CameraVisFlags = CameraVisFlags;
      var VisibilityFlags = {};
      removeProperty(VisibilityFlags, 'VisibilityFlags', [{
        name: 'GENERAL'
      }]);
      replaceProperty(VisibilityFlags, 'VisibilityFlags', [{
        name: 'ALWALS',
        newName: 'ALWALS',
        target: Layers.Enum,
        targetName: 'ALWALS'
      }, {
        name: 'PROFILER',
        newName: 'PROFILER',
        target: Layers.Enum,
        targetName: 'PROFILER'
      }, {
        name: 'GIZMOS',
        newName: 'GIZMOS',
        target: Layers.Enum,
        targetName: 'GIZMOS'
      }, {
        name: 'EDITOR',
        newName: 'EDITOR',
        target: Layers.Enum,
        targetName: 'EDITOR'
      }, {
        name: 'UI',
        newName: 'UI',
        target: Layers.Enum,
        targetName: 'UI_3D'
      }, {
        name: 'UI2D',
        newName: 'UI2D',
        target: Layers.Enum,
        targetName: 'UI_2D'
      }]);
      legacyCC.VisibilityFlags = VisibilityFlags;
      replaceProperty(Pass.prototype, 'Pass.prototype', [{
        name: 'getBindingTypeFromHandle',
        newName: 'getDescriptorTypeFromHandle'
      }]);
      removeProperty(Camera.prototype, 'Camera.prototype', [{
        name: 'getSplitFrustum'
      }, {
        name: 'setMatView'
      }, {
        name: 'setMatViewInv'
      }, {
        name: 'setMatProjInv'
      }, {
        name: 'setMatViewProjInv'
      }, {
        name: 'setMatProj'
      }, {
        name: 'setMatViewProj'
      }, {
        name: 'getMatViewInv'
      }]);
      removeProperty(Shadows.prototype, 'Shadows.prototype', [{
        name: 'aspect'
      }, {
        name: 'selfShadow'
      }, {
        name: 'linear'
      }, {
        name: 'packing'
      }, {
        name: 'autoAdapt'
      }, {
        name: 'fixedArea'
      }, {
        name: 'pcf'
      }, {
        name: 'bias'
      }, {
        name: 'normalBias'
      }, {
        name: 'near'
      }, {
        name: 'far'
      }, {
        name: 'shadowDistance'
      }, {
        name: 'invisibleOcclusionRange'
      }, {
        name: 'orthoSize'
      }, {
        name: 'saturation'
      }]);
      removeProperty(SpotLight$1.prototype, 'SpotLight.prototype', [{
        name: 'aspect'
      }]);

      var addStage = config.addStage;

      var renderer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addStage: addStage,
        scene: index$2,
        createIA: createIA,
        get RenderQueue () { return RenderQueue; },
        get PassStage () { return PassStage; },
        genHandle: genHandle,
        getTypeFromHandle: getTypeFromHandle,
        getBindingFromHandle: getBindingFromHandle,
        getCountFromHandle: getCountFromHandle,
        getOffsetFromHandle: getOffsetFromHandle,
        customizeType: customizeType,
        type2reader: type2reader,
        type2writer: type2writer,
        getDefaultFromType: getDefaultFromType,
        getStringFromType: getStringFromType,
        overrideMacros: overrideMacros,
        get BatchingSchemes () { return BatchingSchemes; },
        Pass: Pass,
        getDeviceShaderVersion: getDeviceShaderVersion,
        programLib: programLib,
        nearestPOT: nearestPOT,
        TextureBufferPool: TextureBufferPool,
        MaterialInstance: MaterialInstance,
        PassInstance: PassInstance,
        get PoolType () { return PoolType; },
        NULL_HANDLE: NULL_HANDLE,
        get Render2dView () { return Render2dView; },
        Render2dPool: Render2dPool,
        get NodeView () { return NodeView; },
        NodePool: NodePool,
        get PassView () { return PassView; },
        PassPool: PassPool,
        get AABBView () { return AABBView; },
        AABBPool: AABBPool,
        RenderScene: RenderScene,
        CameraVisFlags: CameraVisFlags,
        VisibilityFlags: VisibilityFlags
      });
      exports('renderer', renderer);

      var LineCap;

      (function (LineCap) {
        LineCap[LineCap["BUTT"] = 0] = "BUTT";
        LineCap[LineCap["ROUND"] = 1] = "ROUND";
        LineCap[LineCap["SQUARE"] = 2] = "SQUARE";
      })(LineCap || (LineCap = {}));

      ccenum(LineCap);
      var LineJoin;

      (function (LineJoin) {
        LineJoin[LineJoin["BEVEL"] = 0] = "BEVEL";
        LineJoin[LineJoin["ROUND"] = 1] = "ROUND";
        LineJoin[LineJoin["MITER"] = 2] = "MITER";
      })(LineJoin || (LineJoin = {}));

      ccenum(LineJoin);
      var PointFlags;

      (function (PointFlags) {
        PointFlags[PointFlags["PT_CORNER"] = 1] = "PT_CORNER";
        PointFlags[PointFlags["PT_LEFT"] = 2] = "PT_LEFT";
        PointFlags[PointFlags["PT_BEVEL"] = 4] = "PT_BEVEL";
        PointFlags[PointFlags["PT_INNERBEVEL"] = 8] = "PT_INNERBEVEL";
      })(PointFlags || (PointFlags = {}));

      ccenum(PointFlags);

      var PI = Math.PI;
      var min = Math.min;
      var max = Math.max;
      var cos = Math.cos;
      var sin = Math.sin;
      var abs = Math.abs;
      var sign = Math.sign;
      var KAPPA90 = 0.5522847493;
      function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
        counterclockwise = counterclockwise || false;
        var a = 0;
        var da = 0;
        var hda = 0;
        var kappa = 0;
        var dx = 0;
        var dy = 0;
        var x = 0;
        var y = 0;
        var tanx = 0;
        var tany = 0;
        var px = 0;
        var py = 0;
        var ptanx = 0;
        var ptany = 0;
        var i = 0;
        var ndivs = 0;
        da = endAngle - startAngle;

        if (counterclockwise) {
          if (abs(da) >= PI * 2) {
            da = PI * 2;
          } else {
            while (da < 0) {
              da += PI * 2;
            }
          }
        } else if (abs(da) >= PI * 2) {
          da = -PI * 2;
        } else {
          while (da > 0) {
            da -= PI * 2;
          }
        }

        ndivs = max(1, min(abs(da) / (PI * 0.5) + 0.5, 5)) | 0;
        hda = da / ndivs / 2.0;
        kappa = abs(4.0 / 3.0 * (1 - cos(hda)) / sin(hda));

        if (!counterclockwise) {
          kappa = -kappa;
        }

        for (i = 0; i <= ndivs; i++) {
          a = startAngle + da * (i / ndivs);
          dx = cos(a);
          dy = sin(a);
          x = cx + dx * r;
          y = cy + dy * r;
          tanx = -dy * r * kappa;
          tany = dx * r * kappa;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
          }

          px = x;
          py = y;
          ptanx = tanx;
          ptany = tany;
        }
      }
      function ellipse(ctx, cx, cy, rx, ry) {
        ctx.moveTo(cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
        ctx.close();
      }
      function roundRect(ctx, x, y, w, h, r) {
        if (r < 0.1) {
          ctx.rect(x, y, w, h);
        } else {
          var rx = min(r, abs(w) * 0.5) * sign(w);
          var ry = min(r, abs(h) * 0.5) * sign(h);
          ctx.moveTo(x, y + ry);
          ctx.lineTo(x, y + h - ry);
          ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
          ctx.lineTo(x + w - rx, y + h);
          ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
          ctx.lineTo(x + w, y + ry);
          ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
          ctx.lineTo(x + rx, y);
          ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
          ctx.close();
        }
      }
      function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
        var x12 = 0;
        var y12 = 0;
        var x23 = 0;
        var y23 = 0;
        var x34 = 0;
        var y34 = 0;
        var x123 = 0;
        var y123 = 0;
        var x234 = 0;
        var y234 = 0;
        var x1234 = 0;
        var y1234 = 0;
        var dx = 0;
        var dy = 0;
        var d2 = 0;
        var d3 = 0;

        if (level > 10) {
          return;
        }

        x12 = (x1 + x2) * 0.5;
        y12 = (y1 + y2) * 0.5;
        x23 = (x2 + x3) * 0.5;
        y23 = (y2 + y3) * 0.5;
        x34 = (x3 + x4) * 0.5;
        y34 = (y3 + y4) * 0.5;
        x123 = (x12 + x23) * 0.5;
        y123 = (y12 + y23) * 0.5;
        dx = x4 - x1;
        dy = y4 - y1;
        d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
        d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);

        if ((d2 + d3) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy)) {
          ctx.addPoint(x4, y4, type === 0 ? type | PointFlags.PT_BEVEL : type);
          return;
        }

        x234 = (x23 + x34) * 0.5;
        y234 = (y23 + y34) * 0.5;
        x1234 = (x123 + x234) * 0.5;
        y1234 = (y123 + y234) * 0.5;
        tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
        tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
      }

      var Point = function (_Vec) {
        _inheritsLoose(Point, _Vec);

        function Point(x, y) {
          var _this;

          _this = _Vec.call(this, x, y) || this;
          _this.dx = 0;
          _this.dy = 0;
          _this.dmx = 0;
          _this.dmy = 0;
          _this.flags = 0;
          _this.len = 0;

          _this.reset();

          return _this;
        }

        var _proto = Point.prototype;

        _proto.reset = function reset() {
          this.dx = 0;
          this.dy = 0;
          this.dmx = 0;
          this.dmy = 0;
          this.flags = 0;
          this.len = 0;
        };

        return Point;
      }(Vec2);
      var Path = function () {
        function Path() {
          this.closed = false;
          this.bevel = 0;
          this.complex = true;
          this.points = [];
          this.reset();
        }

        var _proto2 = Path.prototype;

        _proto2.reset = function reset() {
          this.closed = false;
          this.bevel = 0;
          this.complex = true;

          if (this.points) {
            this.points.length = 0;
          } else {
            this.points = [];
          }
        };

        return Path;
      }();
      var Impl = function () {
        function Impl(comp) {
          this.dataOffset = 0;
          this.updatePathOffset = false;
          this.pathLength = 0;
          this.pathOffset = 0;
          this.paths = [];
          this.tessTol = 0.25;
          this.distTol = 0.01;
          this.fillColor = Color.WHITE.clone();
          this.lineCap = LineCap.BUTT;
          this.strokeColor = Color.BLACK.clone();
          this.lineJoin = LineJoin.MITER;
          this.lineWidth = 0;
          this.pointsOffset = 0;
          this._commandX = 0;
          this._commandY = 0;
          this._points = [];
          this._renderDataList = [];
          this._curPath = null;
          this._comp = void 0;
          this._comp = comp;
        }

        var _proto3 = Impl.prototype;

        _proto3.moveTo = function moveTo(x, y) {
          if (this.updatePathOffset) {
            this.pathOffset = this.pathLength;
            this.updatePathOffset = false;
          }

          this._addPath();

          this.addPoint(x, y, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        };

        _proto3.lineTo = function lineTo(x, y) {
          this.addPoint(x, y, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        };

        _proto3.bezierCurveTo = function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          var path = this._curPath;
          var last = path.points[path.points.length - 1];

          if (!last) {
            return;
          }

          if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
            this.lineTo(x, y);
            return;
          }

          tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        };

        _proto3.quadraticCurveTo = function quadraticCurveTo(cx, cy, x, y) {
          var x0 = this._commandX;
          var y0 = this._commandY;
          this.bezierCurveTo(x0 + 2.0 / 3.0 * (cx - x0), y0 + 2.0 / 3.0 * (cy - y0), x + 2.0 / 3.0 * (cx - x), y + 2.0 / 3.0 * (cy - y), x, y);
        };

        _proto3.arc = function arc$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
          arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
        };

        _proto3.ellipse = function ellipse$1(cx, cy, rx, ry) {
          ellipse(this, cx, cy, rx, ry);

          this._curPath.complex = false;
        };

        _proto3.circle = function circle(cx, cy, r) {
          ellipse(this, cx, cy, r, r);

          this._curPath.complex = false;
        };

        _proto3.rect = function rect(x, y, w, h) {
          this.moveTo(x, y);
          this.lineTo(x + w, y);
          this.lineTo(x + w, y + h);
          this.lineTo(x, y + h);
          this.close();
          this._curPath.complex = false;
        };

        _proto3.roundRect = function roundRect$1(x, y, w, h, r) {
          roundRect(this, x, y, w, h, r);

          this._curPath.complex = false;
        };

        _proto3.clear = function clear() {
          this.pathLength = 0;
          this.pathOffset = 0;
          this.pointsOffset = 0;
          this.dataOffset = 0;
          this._curPath = null;
          this.paths.length = 0;
          this._points.length = 0;
          var dataList = this._renderDataList;

          for (var i = 0, l = dataList.length; i < l; i++) {
            var data = dataList[i];

            if (!data) {
              continue;
            }

            MeshRenderData.remove(data);
            data.removeRenderDrawInfo(this._comp);
          }

          this._renderDataList.length = 0;
        };

        _proto3.close = function close() {
          this._curPath.closed = true;
        };

        _proto3.requestRenderData = function requestRenderData() {
          var renderData = MeshRenderData.add();

          this._renderDataList.push(renderData);

          return renderData;
        };

        _proto3.getRenderDataList = function getRenderDataList() {
          if (this._renderDataList.length === 0) {
            this.requestRenderData();
          }

          return this._renderDataList;
        };

        _proto3.addPoint = function addPoint(x, y, flags) {
          var path = this._curPath;

          if (!path) {
            return;
          }

          var points = this._points;
          var pathPoints = path.points;
          var offset = this.pointsOffset++;
          var pt = points[offset];

          if (!pt) {
            pt = new Point(x, y);
            points.push(pt);
          } else {
            pt.x = x;
            pt.y = y;
          }

          pt.flags = flags;
          pathPoints.push(pt);
        };

        _proto3._addPath = function _addPath() {
          var offset = this.pathLength;
          var path = this.paths[offset];

          if (!path) {
            path = new Path();
            this.paths.push(path);
          } else {
            path.reset();
          }

          this.pathLength++;
          this._curPath = path;
          return path;
        };

        return Impl;
      }();

      var _dec$a, _dec2$4, _dec3$3, _dec4$3, _dec5$3, _dec6$3, _dec7$3, _dec8$3, _dec9$2, _dec10$2, _dec11$1, _dec12$1, _dec13$1, _class$a, _class2$8, _descriptor$7, _descriptor2$5, _descriptor3$4, _descriptor4$3, _descriptor5$2, _descriptor6$1, _class3$3, _temp$8;
      var attributes = vfmtPosColor.concat([new Attribute('a_dist', Format.R32F)]);
      var componentPerVertex = getComponentPerVertex(attributes);
      var stride = getAttributeStride(attributes);
      var Graphics = function (v) { return exports({ Graphics: v, GraphicsComponent: v }), v; }((_dec$a = ccclass('cc.Graphics'), _dec2$4 = help(), _dec3$3 = executionOrder(110), _dec4$3 = menu(), _dec5$3 = tooltip(), _dec6$3 = type(LineJoin), _dec7$3 = tooltip(), _dec8$3 = type(LineCap), _dec9$2 = tooltip(), _dec10$2 = tooltip(), _dec11$1 = tooltip(), _dec12$1 = tooltip(), _dec13$1 = visible(), _dec$a(_class$a = _dec2$4(_class$a = _dec3$3(_class$a = _dec4$3(_class$a = (_class2$8 = (_temp$8 = _class3$3 = function (_UIRenderer) {
        _inheritsLoose(Graphics, _UIRenderer);

        function Graphics() {
          var _this;

          _this = _UIRenderer.call(this) || this;
          _this.impl = null;
          _this.model = null;

          _initializerDefineProperty(_this, "_lineWidth", _descriptor$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_strokeColor", _descriptor2$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lineJoin", _descriptor3$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lineCap", _descriptor4$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillColor", _descriptor5$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_miterLimit", _descriptor6$1, _assertThisInitialized(_this));

          _this._isDrawing = false;
          _this._isNeedUploadData = true;
          _this._graphicsUseSubMeshes = [];
          _this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
          _this.impl = new Impl(_assertThisInitialized(_this));

          return _this;
        }

        var _proto = Graphics.prototype;

        _proto.onRestore = function onRestore() {
          if (!this.impl) {
            this._flushAssembler();
          }
        };

        _proto.onLoad = function onLoad() {
          _UIRenderer.prototype.onLoad.call(this);

          {
            this.model = director.root.createModel(Model);
            this.model.node = this.model.transform = this.node;
          }

          this._flushAssembler();
        };

        _proto.onEnable = function onEnable() {
          _UIRenderer.prototype.onEnable.call(this);

          this._updateMtlForGraphics();
        };

        _proto.onDestroy = function onDestroy() {
          this._sceneGetter = null;

          {
            if (this.model) {
              director.root.destroyModel(this.model);
              this.model = null;
            }

            var subMeshLength = this._graphicsUseSubMeshes.length;

            if (subMeshLength > 0) {
              for (var i = 0; i < subMeshLength; ++i) {
                this._graphicsUseSubMeshes[i].destroy();
              }

              this._graphicsUseSubMeshes.length = 0;
            }
          }

          if (this.impl) {
            this._isDrawing = false;
            this.impl.clear();
            this.impl = null;
          }

          _UIRenderer.prototype.onDestroy.call(this);
        };

        _proto.moveTo = function moveTo(x, y) {
          if (!this.impl) {
            return;
          }

          this.impl.moveTo(x, y);
        };

        _proto.lineTo = function lineTo(x, y) {
          if (!this.impl) {
            return;
          }

          this.impl.lineTo(x, y);
        };

        _proto.bezierCurveTo = function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          if (!this.impl) {
            return;
          }

          this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
        };

        _proto.quadraticCurveTo = function quadraticCurveTo(cx, cy, x, y) {
          if (!this.impl) {
            return;
          }

          this.impl.quadraticCurveTo(cx, cy, x, y);
        };

        _proto.arc = function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
          if (!this.impl) {
            return;
          }

          this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
        };

        _proto.ellipse = function ellipse(cx, cy, rx, ry) {
          if (!this.impl) {
            return;
          }

          this.impl.ellipse(cx, cy, rx, ry);
        };

        _proto.circle = function circle(cx, cy, r) {
          if (!this.impl) {
            return;
          }

          this.impl.circle(cx, cy, r);
        };

        _proto.rect = function rect(x, y, w, h) {
          if (!this.impl) {
            return;
          }

          this.impl.rect(x, y, w, h);
        };

        _proto.roundRect = function roundRect(x, y, w, h, r) {
          if (!this.impl) {
            return;
          }

          this.impl.roundRect(x, y, w, h, r);
        };

        _proto.fillRect = function fillRect(x, y, w, h) {
          this.rect(x, y, w, h);
          this.fill();
        };

        _proto.clear = function clear() {
          if (!this.impl) {
            return;
          }

          this.impl.clear();
          this._isDrawing = false;

          if (this.model) {
            for (var i = 0; i < this.model.subModels.length; i++) {
              var subModel = this.model.subModels[i];
              subModel.inputAssembler.indexCount = 0;
            }
          }

          this.markForUpdateRenderData();
        };

        _proto.close = function close() {
          if (!this.impl) {
            return;
          }

          this.impl.close();
        };

        _proto.stroke = function stroke() {
          if (!this._assembler) {
            this._flushAssembler();
          }

          this._isDrawing = true;
          this._isNeedUploadData = true;

          this._assembler.stroke(this);
        };

        _proto.fill = function fill() {
          if (!this._assembler) {
            this._flushAssembler();
          }

          this._isDrawing = true;
          this._isNeedUploadData = true;

          this._assembler.fill(this);
        };

        _proto._updateMtlForGraphics = function _updateMtlForGraphics() {
          var mat;

          if (this._customMaterial) {
            mat = this.getMaterialInstance(0);
          } else {
            mat = builtinResMgr.get('ui-graphics-material');
            this.setMaterial(mat, 0);
            mat = this.getMaterialInstance(0);
            mat.recompileShaders({
              USE_LOCAL: true
            });
          }
        };

        _proto.activeSubModel = function activeSubModel(idx) {
          if (!this.model) {
            warnID(4500, this.node.name);
            return;
          }

          if (this.model.subModels.length <= idx) {
            var gfxDevice = deviceManager.gfxDevice;
            var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * stride, stride));
            var indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * Uint16Array.BYTES_PER_ELEMENT * 2, Uint16Array.BYTES_PER_ELEMENT));
            var renderMesh = new RenderingSubMesh([vertexBuffer], attributes, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
            renderMesh.subMeshIdx = 0;
            this.model.initSubModel(idx, renderMesh, this.getMaterialInstance(0));

            this._graphicsUseSubMeshes.push(renderMesh);
          }
        };

        _proto._uploadData = function _uploadData() {
          var impl = this.impl;

          if (!impl) {
            return;
          }

          var renderDataList = impl && impl.getRenderDataList();

          if (renderDataList.length <= 0 || !this.model) {
            return;
          }

          var subModelList = this.model.subModels;

          for (var i = 0; i < renderDataList.length; i++) {
            var renderData = renderDataList[i];
            var ia = subModelList[i].inputAssembler;

            if (renderData.lastFilledVertex === renderData.vertexStart) {
              continue;
            }

            var vb = new Float32Array(renderData.vData.buffer, 0, renderData.vertexStart * componentPerVertex);
            ia.vertexBuffers[0].update(vb);
            ia.vertexCount = renderData.vertexStart;
            var ib = new Uint16Array(renderData.iData.buffer, 0, renderData.indexStart);
            ia.indexBuffer.update(ib);
            ia.indexCount = renderData.indexStart;
            renderData.lastFilledVertex = renderData.vertexStart;
            renderData.lastFilledIndex = renderData.indexStart;
          }

          this._isNeedUploadData = false;
        };

        _proto._render = function _render(render) {
          if (this._isNeedUploadData) {
            if (this.impl) {
              var renderDataList = this.impl.getRenderDataList();
              var len = this.model.subModels.length;

              if (renderDataList.length > len) {
                for (var i = len; i < renderDataList.length; i++) {
                  this.activeSubModel(i);
                }
              }
            }

            this._uploadData();
          }

          render.commitModel(this, this.model, this.getMaterialInstance(0));
        };

        _proto._flushAssembler = function _flushAssembler() {
          var assembler = Graphics.Assembler.getAssembler(this);

          if (this._assembler !== assembler) {
            this._assembler = assembler;
          }
        };

        _proto._canRender = function _canRender() {
          if (!_UIRenderer.prototype._canRender.call(this)) {
            return false;
          }

          {
            return !!this.model && this._isDrawing;
          }
        };

        _proto.updateRenderer = function updateRenderer() {
          _UIRenderer.prototype.updateRenderer.call(this);
        };

        _proto.createRenderEntity = function createRenderEntity() {
          return new RenderEntity(RenderEntityType.DYNAMIC);
        };

        _createClass(Graphics, [{
          key: "lineWidth",
          get: function get() {
            return this._lineWidth;
          },
          set: function set(value) {
            this._lineWidth = value;

            if (!this.impl) {
              return;
            }

            this.impl.lineWidth = value;
          }
        }, {
          key: "lineJoin",
          get: function get() {
            return this._lineJoin;
          },
          set: function set(value) {
            this._lineJoin = value;

            if (!this.impl) {
              return;
            }

            this.impl.lineJoin = value;
          }
        }, {
          key: "lineCap",
          get: function get() {
            return this._lineCap;
          },
          set: function set(value) {
            this._lineCap = value;

            if (!this.impl) {
              return;
            }

            this.impl.lineCap = value;
          }
        }, {
          key: "strokeColor",
          get: function get() {
            return this._strokeColor;
          },
          set: function set(value) {
            if (!this.impl) {
              return;
            }

            this._strokeColor.set(value);

            this.impl.strokeColor = this._strokeColor;
          }
        }, {
          key: "fillColor",
          get: function get() {
            return this._fillColor;
          },
          set: function set(value) {
            if (!this.impl) {
              return;
            }

            this._fillColor.set(value);

            this.impl.fillColor = this._fillColor;
          }
        }, {
          key: "miterLimit",
          get: function get() {
            return this._miterLimit;
          },
          set: function set(value) {
            this._miterLimit = value;
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);
          }
        }, {
          key: "srcBlendFactor",
          get: function get() {
            return this._srcBlendFactor;
          },
          set: function set(value) {}
        }, {
          key: "dstBlendFactor",
          get: function get() {
            return this._dstBlendFactor;
          },
          set: function set(value) {}
        }, {
          key: "graphicsNativeProxy",
          get: function get() {
            return this._graphicsNativeProxy;
          }
        }]);

        return Graphics;
      }(UIRenderer), _class3$3.LineJoin = LineJoin, _class3$3.LineCap = LineCap, _temp$8), (_applyDecoratedDescriptor(_class2$8.prototype, "lineWidth", [editable, _dec5$3], Object.getOwnPropertyDescriptor(_class2$8.prototype, "lineWidth"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "lineJoin", [_dec6$3, _dec7$3], Object.getOwnPropertyDescriptor(_class2$8.prototype, "lineJoin"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "lineCap", [_dec8$3, _dec9$2], Object.getOwnPropertyDescriptor(_class2$8.prototype, "lineCap"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "strokeColor", [_dec10$2], Object.getOwnPropertyDescriptor(_class2$8.prototype, "strokeColor"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "fillColor", [_dec11$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "fillColor"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "miterLimit", [_dec12$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "miterLimit"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "color", [override, _dec13$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "color"), _class2$8.prototype), _descriptor$7 = _applyDecoratedDescriptor(_class2$8.prototype, "_lineWidth", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$8.prototype, "_strokeColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.BLACK.clone();
        }
      }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$8.prototype, "_lineJoin", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return LineJoin.MITER;
        }
      }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$8.prototype, "_lineCap", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return LineCap.BUTT;
        }
      }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$8.prototype, "_fillColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor6$1 = _applyDecoratedDescriptor(_class2$8.prototype, "_miterLimit", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      })), _class2$8)) || _class$a) || _class$a) || _class$a) || _class$a));
      legacyCC.Graphics = Graphics;

      var _dec$b, _dec2$5, _dec3$4, _dec4$4, _dec5$4, _dec6$4, _dec7$4, _dec8$4, _dec9$3, _dec10$3, _dec11$2, _dec12$2, _dec13$2, _dec14$1, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _dec30$1, _dec31$1, _dec32$1, _class$b, _class2$9, _descriptor$8, _descriptor2$6, _descriptor3$5, _descriptor4$4, _descriptor5$3, _descriptor6$2, _descriptor7$1, _descriptor8$1, _descriptor9$1, _descriptor10$1, _class3$4, _temp$9;
      var SpriteType;

      (function (SpriteType) {
        SpriteType[SpriteType["SIMPLE"] = 0] = "SIMPLE";
        SpriteType[SpriteType["SLICED"] = 1] = "SLICED";
        SpriteType[SpriteType["TILED"] = 2] = "TILED";
        SpriteType[SpriteType["FILLED"] = 3] = "FILLED";
      })(SpriteType || (SpriteType = {}));

      ccenum(SpriteType);
      var FillType;

      (function (FillType) {
        FillType[FillType["HORIZONTAL"] = 0] = "HORIZONTAL";
        FillType[FillType["VERTICAL"] = 1] = "VERTICAL";
        FillType[FillType["RADIAL"] = 2] = "RADIAL";
      })(FillType || (FillType = {}));

      ccenum(FillType);
      var SizeMode;

      (function (SizeMode) {
        SizeMode[SizeMode["CUSTOM"] = 0] = "CUSTOM";
        SizeMode[SizeMode["TRIMMED"] = 1] = "TRIMMED";
        SizeMode[SizeMode["RAW"] = 2] = "RAW";
      })(SizeMode || (SizeMode = {}));

      ccenum(SizeMode);
      var EventType;

      (function (EventType) {
        EventType["SPRITE_FRAME_CHANGED"] = "spriteframe-changed";
      })(EventType || (EventType = {}));

      var Sprite = function (v) { return exports({ Sprite: v, SpriteComponent: v }), v; }((_dec$b = ccclass('cc.Sprite'), _dec2$5 = help(), _dec3$4 = executionOrder(110), _dec4$4 = menu(), _dec5$4 = type(SpriteAtlas), _dec6$4 = displayOrder(), _dec7$4 = tooltip(), _dec8$4 = type(SpriteFrame), _dec9$3 = displayOrder(), _dec10$3 = tooltip(), _dec11$2 = type(SpriteType), _dec12$2 = displayOrder(), _dec13$2 = tooltip(), _dec14$1 = type(FillType), _dec15$1 = displayOrder(), _dec16$1 = tooltip(), _dec17$1 = displayOrder(), _dec18$1 = tooltip(), _dec19$1 = range(), _dec20$1 = displayOrder(), _dec21$1 = tooltip(), _dec22$1 = range(), _dec23$1 = displayOrder(), _dec24$1 = tooltip(), _dec25$1 = visible(), _dec26$1 = displayOrder(), _dec27$1 = tooltip(), _dec28$1 = displayOrder(), _dec29$1 = tooltip(), _dec30$1 = type(SizeMode), _dec31$1 = displayOrder(), _dec32$1 = tooltip(), _dec$b(_class$b = _dec2$5(_class$b = _dec3$4(_class$b = _dec4$4(_class$b = (_class2$9 = (_temp$9 = _class3$4 = function (_UIRenderer) {
        _inheritsLoose(Sprite, _UIRenderer);

        function Sprite() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _UIRenderer.call.apply(_UIRenderer, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_spriteFrame", _descriptor$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_type", _descriptor2$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillType", _descriptor3$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_sizeMode", _descriptor4$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillCenter", _descriptor5$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillStart", _descriptor6$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillRange", _descriptor7$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isTrimmedMode", _descriptor8$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_useGrayscale", _descriptor9$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_atlas", _descriptor10$1, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = Sprite.prototype;

        _proto.__preload = function __preload() {
          this.changeMaterialForDefine();

          _UIRenderer.prototype.__preload.call(this);
        };

        _proto.onEnable = function onEnable() {
          _UIRenderer.prototype.onEnable.call(this);

          this._activateMaterial();

          var spriteFrame = this._spriteFrame;

          if (spriteFrame) {
            this._updateUVs();

            if (this._type === SpriteType.SLICED) {
              spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        };

        _proto.onDisable = function onDisable() {
          _UIRenderer.prototype.onDisable.call(this);

          if (this._spriteFrame && this._type === SpriteType.SLICED) {
            this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
          }
        };

        _proto.onDestroy = function onDestroy() {

          _UIRenderer.prototype.onDestroy.call(this);
        };

        _proto.changeSpriteFrameFromAtlas = function changeSpriteFrameFromAtlas(name) {
          if (!this._atlas) {
            console.warn('SpriteAtlas is null.');
            return;
          }

          var sprite = this._atlas.getSpriteFrame(name);

          this.spriteFrame = sprite;
        };

        _proto.changeMaterialForDefine = function changeMaterialForDefine() {
          var texture;
          var lastInstanceMaterialType = this._instanceMaterialType;

          if (this._spriteFrame) {
            texture = this._spriteFrame.texture;
          }

          var value = false;

          if (texture instanceof TextureBase) {
            var format = texture.getPixelFormat();
            value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
          }

          if (value && this.grayscale) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY;
          } else if (value) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
          } else if (this.grayscale) {
            this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
          } else {
            this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
          }

          if (lastInstanceMaterialType !== this._instanceMaterialType) {
            this.updateMaterial();
          }
        };

        _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
          var mat = _UIRenderer.prototype._updateBuiltinMaterial.call(this);

          if (this.spriteFrame && this.spriteFrame.texture instanceof RenderTexture) {
            var defines = _extends({
              SAMPLE_FROM_RT: true
            }, mat.passes[0].defines);

            var renderMat = new Material();
            renderMat.initialize({
              effectAsset: mat.effectAsset,
              defines: defines
            });
            mat = renderMat;
          }

          return mat;
        };

        _proto._render = function _render(render) {
          render.commitComp(this, this.renderData, this._spriteFrame, this._assembler, null);
        };

        _proto._canRender = function _canRender() {
          if (!_UIRenderer.prototype._canRender.call(this)) {
            return false;
          }

          var spriteFrame = this._spriteFrame;

          if (!spriteFrame || !spriteFrame.texture) {
            return false;
          }

          return true;
        };

        _proto._flushAssembler = function _flushAssembler() {
          var assembler = Sprite.Assembler.getAssembler(this);

          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
          }

          if (!this.renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this.renderData.material = this.getRenderMaterial(0);
              this.markForUpdateRenderData();

              if (this.spriteFrame) {
                this._assembler.updateUVs(this);
              }

              this._updateColor();
            }
          }

          if (this._spriteFrame) {
            if (this._type === SpriteType.SLICED) {
              this._spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            } else {
              this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        };

        _proto._applySpriteSize = function _applySpriteSize() {
          if (this._spriteFrame) {
            {
              if (SizeMode.RAW === this._sizeMode) {
                var size = this._spriteFrame.originalSize;

                this.node._uiProps.uiTransformComp.setContentSize(size);
              } else if (SizeMode.TRIMMED === this._sizeMode) {
                var rect = this._spriteFrame.rect;

                this.node._uiProps.uiTransformComp.setContentSize(rect.width, rect.height);
              }
            }
          }
        };

        _proto._resized = function _resized() {
          {
            return;
          }
        };

        _proto._activateMaterial = function _activateMaterial() {
          var spriteFrame = this._spriteFrame;
          var material = this.getRenderMaterial(0);

          if (spriteFrame) {
            if (material) {
              this.markForUpdateRenderData();
            }
          }

          if (this.renderData) {
            this.renderData.material = material;
          }
        };

        _proto._updateUVs = function _updateUVs() {
          if (this._assembler) {
            this._assembler.updateUVs(this);
          }
        };

        _proto._applySpriteFrame = function _applySpriteFrame(oldFrame) {
          var spriteFrame = this._spriteFrame;

          if (oldFrame && this._type === SpriteType.SLICED) {
            oldFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
          }

          var textureChanged = false;

          if (spriteFrame) {
            if (!oldFrame || oldFrame.texture !== spriteFrame.texture) {
              textureChanged = true;
            }

            if (textureChanged) {
              if (this.renderData) this.renderData.textureDirty = true;
              this.changeMaterialForDefine();
            }

            this._applySpriteSize();

            if (this._type === SpriteType.SLICED) {
              spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        };

        _createClass(Sprite, [{
          key: "spriteAtlas",
          get: function get() {
            return this._atlas;
          },
          set: function set(value) {
            if (this._atlas === value) {
              return;
            }

            this._atlas = value;
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value) {
            if (this._spriteFrame === value) {
              return;
            }

            var lastSprite = this._spriteFrame;
            this._spriteFrame = value;
            this.markForUpdateRenderData();

            this._applySpriteFrame(lastSprite);
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            if (this._type !== value) {
              this._type = value;

              this._flushAssembler();
            }
          }
        }, {
          key: "fillType",
          get: function get() {
            return this._fillType;
          },
          set: function set(value) {
            if (this._fillType !== value) {
              if (value === FillType.RADIAL || this._fillType === FillType.RADIAL) {
                this.destroyRenderData();
              } else if (this.renderData) {
                this.markForUpdateRenderData(true);
              }
            }

            this._fillType = value;

            this._flushAssembler();
          }
        }, {
          key: "fillCenter",
          get: function get() {
            return this._fillCenter;
          },
          set: function set(value) {
            this._fillCenter.x = value.x;
            this._fillCenter.y = value.y;

            if (this._type === SpriteType.FILLED && this.renderData) {
              this.markForUpdateRenderData();
            }
          }
        }, {
          key: "fillStart",
          get: function get() {
            return this._fillStart;
          },
          set: function set(value) {
            this._fillStart = clamp$1(value, 0, 1);

            if (this._type === SpriteType.FILLED && this.renderData) {
              this.markForUpdateRenderData();

              this._updateUVs();
            }
          }
        }, {
          key: "fillRange",
          get: function get() {
            return this._fillRange;
          },
          set: function set(value) {
            this._fillRange = clamp$1(value, -1, 1);

            if (this._type === SpriteType.FILLED && this.renderData) {
              this.markForUpdateRenderData();

              this._updateUVs();
            }
          }
        }, {
          key: "trim",
          get: function get() {
            return this._isTrimmedMode;
          },
          set: function set(value) {
            if (this._isTrimmedMode === value) {
              return;
            }

            this._isTrimmedMode = value;

            if (this._type === SpriteType.SIMPLE && this.renderData) {
              this.markForUpdateRenderData(true);
            }
          }
        }, {
          key: "grayscale",
          get: function get() {
            return this._useGrayscale;
          },
          set: function set(value) {
            if (this._useGrayscale === value) {
              return;
            }

            this._useGrayscale = value;
            this.changeMaterialForDefine();
            this.updateMaterial();
          }
        }, {
          key: "sizeMode",
          get: function get() {
            return this._sizeMode;
          },
          set: function set(value) {
            if (this._sizeMode === value) {
              return;
            }

            this._sizeMode = value;

            if (value !== SizeMode.CUSTOM) {
              this._applySpriteSize();
            }
          }
        }]);

        return Sprite;
      }(UIRenderer), _class3$4.FillType = FillType, _class3$4.Type = SpriteType, _class3$4.SizeMode = SizeMode, _class3$4.EventType = EventType, _temp$9), (_applyDecoratedDescriptor(_class2$9.prototype, "spriteAtlas", [_dec5$4, _dec6$4, _dec7$4], Object.getOwnPropertyDescriptor(_class2$9.prototype, "spriteAtlas"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "spriteFrame", [_dec8$4, _dec9$3, _dec10$3], Object.getOwnPropertyDescriptor(_class2$9.prototype, "spriteFrame"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "type", [_dec11$2, _dec12$2, _dec13$2], Object.getOwnPropertyDescriptor(_class2$9.prototype, "type"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "fillType", [_dec14$1, _dec15$1, _dec16$1], Object.getOwnPropertyDescriptor(_class2$9.prototype, "fillType"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "fillCenter", [_dec17$1, _dec18$1], Object.getOwnPropertyDescriptor(_class2$9.prototype, "fillCenter"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "fillStart", [_dec19$1, _dec20$1, _dec21$1], Object.getOwnPropertyDescriptor(_class2$9.prototype, "fillStart"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "fillRange", [_dec22$1, _dec23$1, _dec24$1], Object.getOwnPropertyDescriptor(_class2$9.prototype, "fillRange"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "trim", [_dec25$1, _dec26$1, _dec27$1], Object.getOwnPropertyDescriptor(_class2$9.prototype, "trim"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "grayscale", [editable, _dec28$1, _dec29$1], Object.getOwnPropertyDescriptor(_class2$9.prototype, "grayscale"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "sizeMode", [_dec30$1, _dec31$1, _dec32$1], Object.getOwnPropertyDescriptor(_class2$9.prototype, "sizeMode"), _class2$9.prototype), _descriptor$8 = _applyDecoratedDescriptor(_class2$9.prototype, "_spriteFrame", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$9.prototype, "_type", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return SpriteType.SIMPLE;
        }
      }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$9.prototype, "_fillType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return FillType.HORIZONTAL;
        }
      }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$9.prototype, "_sizeMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return SizeMode.TRIMMED;
        }
      }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_fillCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(0, 0);
        }
      }), _descriptor6$2 = _applyDecoratedDescriptor(_class2$9.prototype, "_fillStart", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_fillRange", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_isTrimmedMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor9$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_useGrayscale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor10$1 = _applyDecoratedDescriptor(_class2$9.prototype, "_atlas", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$9)) || _class$b) || _class$b) || _class$b) || _class$b));
      legacyCC.Sprite = Sprite;

      var _dec$c, _dec2$6, _dec3$5, _dec4$5, _dec5$5, _dec6$5, _dec7$5, _dec8$5, _dec9$4, _dec10$4, _dec11$3, _class$c, _class2$a, _descriptor$9, _descriptor2$7, _descriptor3$6, _descriptor4$5, _class3$5, _temp$a;

      var _worldMatrix$1 = new Mat4();

      var _vec2_temp = new Vec2();

      var _mat4_temp$1 = new Mat4();

      var _circlePoints = [];

      function _calculateCircle(center, radius, segments) {
        _circlePoints.length = 0;
        var anglePerStep = Math.PI * 2 / segments;

        for (var step = 0; step < segments; ++step) {
          _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
        }

        return _circlePoints;
      }

      var MaskType;

      (function (MaskType) {
        MaskType[MaskType["GRAPHICS_RECT"] = 0] = "GRAPHICS_RECT";
        MaskType[MaskType["GRAPHICS_ELLIPSE"] = 1] = "GRAPHICS_ELLIPSE";
        MaskType[MaskType["GRAPHICS_STENCIL"] = 2] = "GRAPHICS_STENCIL";
        MaskType[MaskType["SPRITE_STENCIL"] = 3] = "SPRITE_STENCIL";
      })(MaskType || (MaskType = {}));

      ccenum(MaskType);
      var SEGMENTS_MIN = 3;
      var SEGMENTS_MAX = 10000;
      var Mask = function (v) { return exports({ Mask: v, MaskComponent: v }), v; }((_dec$c = ccclass('cc.Mask'), _dec2$6 = help(), _dec3$5 = executionOrder(110), _dec4$5 = menu(), _dec5$5 = type(MaskType), _dec6$5 = tooltip(), _dec7$5 = displayOrder(), _dec8$5 = tooltip(), _dec9$4 = visible(), _dec10$4 = visible(), _dec11$3 = range(), _dec$c(_class$c = _dec2$6(_class$c = _dec3$5(_class$c = _dec4$5(_class$c = executeInEditMode(_class$c = (_class2$a = (_temp$a = _class3$5 = function (_Component) {
        _inheritsLoose(Mask, _Component);

        function Mask() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_type", _descriptor$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_inverted", _descriptor2$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_segments", _descriptor3$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_alphaThreshold", _descriptor4$5, _assertThisInitialized(_this));

          _this._sprite = null;
          _this._graphics = null;
          _this._stencilStage = Stage.DISABLED;
          return _this;
        }

        var _proto = Mask.prototype;

        _proto.onLoad = function onLoad() {
          this._changeRenderType();
        };

        _proto.onEnable = function onEnable() {
          this._changeRenderType();

          this._updateGraphics();

          this._enableRender();

          this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
        };

        _proto.onRestore = function onRestore() {
          this._changeRenderType();

          this._updateGraphics();
        };

        _proto.onDisable = function onDisable() {
          this._disableRender();

          this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
        };

        _proto.onDestroy = function onDestroy() {
          this._removeMaskNode();
        };

        _proto.isHit = function isHit(worldPt) {
          var uiTrans = this.node._uiProps.uiTransformComp;
          var size = uiTrans.contentSize;
          var w = size.width;
          var h = size.height;
          var testPt = _vec2_temp;
          this.node.getWorldMatrix(_worldMatrix$1);
          Mat4.invert(_mat4_temp$1, _worldMatrix$1);
          Vec2.transformMat4(testPt, worldPt, _mat4_temp$1);
          var ap = uiTrans.anchorPoint;
          testPt.x += ap.x * w;
          testPt.y += ap.y * h;
          var result = false;

          if (this.type === MaskType.GRAPHICS_RECT || this.type === MaskType.GRAPHICS_STENCIL || this.type === MaskType.SPRITE_STENCIL) {
            result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h;
          } else if (this.type === MaskType.GRAPHICS_ELLIPSE) {
            var rx = w / 2;
            var ry = h / 2;
            var px = testPt.x - 0.5 * w;
            var py = testPt.y - 0.5 * h;
            result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
          }

          if (this._inverted) {
            result = !result;
          }

          return result;
        };

        _proto._nodeStateChange = function _nodeStateChange(type) {
          this._updateGraphics();
        };

        _proto._changeRenderType = function _changeRenderType() {
          var isGraphics = this._type !== MaskType.SPRITE_STENCIL;

          if (isGraphics) {
            this._createGraphics();
          } else {
            this._createSprite();
          }
        };

        _proto._createSprite = function _createSprite() {
          if (!this._sprite) {
            var sprite = this._sprite = this.node.getComponent(Sprite);

            if (!sprite) {
              var node = this.node;
              sprite = this._sprite = node.addComponent(Sprite);
            }

            sprite.color = Color.WHITE.clone();
            sprite.sizeMode = 0;
          }

          this._sprite.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;

          this._sprite.updateMaterial();
        };

        _proto._createGraphics = function _createGraphics() {
          if (!this._graphics) {
            var graphics = this._graphics = this.node.getComponent(Graphics);

            if (!graphics) {
              var node = this.node;
              graphics = this._graphics = node.addComponent(Graphics);
            }

            graphics.lineWidth = 1;
            var color = Color.WHITE.clone();
            color.a = 0;
            graphics.fillColor = color;
          }

          this._graphics.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
        };

        _proto._updateGraphics = function _updateGraphics() {
          if (!this._graphics || this._type !== MaskType.GRAPHICS_RECT && this._type !== MaskType.GRAPHICS_ELLIPSE) {
            return;
          }

          var uiTrans = this.node._uiProps.uiTransformComp;
          var graphics = this._graphics;
          graphics.clear();
          var size = uiTrans.contentSize;
          var width = size.width;
          var height = size.height;
          var ap = uiTrans.anchorPoint;
          var x = -width * ap.x;
          var y = -height * ap.y;

          if (this._type === MaskType.GRAPHICS_RECT) {
            graphics.rect(x, y, width, height);
          } else if (this._type === MaskType.GRAPHICS_ELLIPSE) {
            var center = new Vec3(x + width / 2, y + height / 2, 0);
            var radius = new Vec3(width / 2, height / 2, 0);

            var points = _calculateCircle(center, radius, this._segments);

            for (var i = 0; i < points.length; ++i) {
              var point = points[i];

              if (i === 0) {
                graphics.moveTo(point.x, point.y);
              } else {
                graphics.lineTo(point.x, point.y);
              }
            }

            graphics.close();
          }

          graphics.fill();
        };

        _proto._enableRender = function _enableRender() {
          if (this.subComp) {
            this.subComp.enabled = true;
          }
        };

        _proto._disableRender = function _disableRender() {
          if (this.subComp) {
            this.subComp.stencilStage = Stage.DISABLED;
            this.subComp.updateMaterial();

            if (this.node.activeInHierarchy) {
              this.subComp.enabled = false;
            }
          }
        };

        _proto._removeMaskNode = function _removeMaskNode() {
          if (this._sprite) {
            this._sprite.destroy();

            this._sprite = null;
          }

          if (this._graphics) {
            this._graphics.destroy();

            this._graphics = null;
          }
        };

        _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
          if (enable === void 0) {
            enable = true;
          }

          warnID(9007);

          if (this.subComp) {
            this.subComp.markForUpdateRenderData(enable);
          }
        };

        _proto.requestRenderData = function requestRenderData(any) {
          warnID(9007);
        };

        _proto.destroyRenderData = function destroyRenderData() {
          warnID(9007);
        };

        _proto.updateRenderer = function updateRenderer() {
          warnID(9007);

          if (this.subComp) {
            this.subComp.updateRenderer();
          }
        };

        _proto.fillBuffers = function fillBuffers(render) {
          warnID(9007);
        };

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {
          warnID(9007);
        };

        _proto.setNodeDirty = function setNodeDirty() {
          warnID(9007);

          if (this.subComp) {
            this.subComp.setNodeDirty();
          }
        };

        _proto.setTextureDirty = function setTextureDirty() {
          warnID(9007);

          if (this.subComp) {
            this.subComp.setTextureDirty();
          }
        };

        _proto.getMaterial = function getMaterial(idx) {
          warnID(9007);

          if (this.subComp) {
            return this.subComp.getMaterial(idx);
          }

          return null;
        };

        _proto.setMaterial = function setMaterial(material, index) {
          warnID(9007);

          if (this.subComp) {
            this.subComp.setMaterial(material, index);
          }
        };

        _proto.getMaterialInstance = function getMaterialInstance(idx) {
          warnID(9007);

          if (this.subComp) {
            return this.subComp.getMaterialInstance(idx);
          }

          return null;
        };

        _proto.setMaterialInstance = function setMaterialInstance(matInst, index) {
          warnID(9007);

          if (this.subComp) {
            this.subComp.setMaterialInstance(matInst, index);
          }
        };

        _proto.getRenderMaterial = function getRenderMaterial(index) {
          warnID(9007);

          if (this.subComp) {
            return this.subComp.getRenderMaterial(index);
          }

          return null;
        };

        _createClass(Mask, [{
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            if (this._type === value) {
              return;
            }

            this._type = value;

            if (this._type !== MaskType.SPRITE_STENCIL) {
              if (this._sprite) {
                this.node.removeComponent(Sprite);

                this._sprite._destroyImmediate();

                this._sprite = null;
              }

              this._changeRenderType();

              this._updateGraphics();
            } else {
              if (this._graphics) {
                this._graphics.clear();

                this.node.removeComponent(Graphics);

                this._graphics._destroyImmediate();

                this._graphics = null;
              }

              this._changeRenderType();
            }
          }
        }, {
          key: "inverted",
          get: function get() {
            return this._inverted;
          },
          set: function set(value) {
            this._inverted = value;
            this.subComp.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
          }
        }, {
          key: "segments",
          get: function get() {
            return this._segments;
          },
          set: function set(value) {
            if (this._segments === value) {
              return;
            }

            this._segments = clamp$1(value, SEGMENTS_MIN, SEGMENTS_MAX);

            this._updateGraphics();
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            if (this._sprite) {
              return this._sprite.spriteFrame;
            }

            return null;
          },
          set: function set(value) {
            if (this._sprite) {
              this._sprite.spriteFrame = value;
            } else {
              console.error('please change type to sprite_stencil first');
            }
          }
        }, {
          key: "alphaThreshold",
          get: function get() {
            return this._alphaThreshold;
          },
          set: function set(value) {
            if (this._alphaThreshold === value) {
              return;
            }

            this._alphaThreshold = value;

            if (this.type === MaskType.SPRITE_STENCIL && this._sprite) {
              var mat = this._sprite.getMaterialInstance(0);

              mat.setProperty('alphaThreshold', this._alphaThreshold);
            }
          }
        }, {
          key: "subComp",
          get: function get() {
            return this._graphics || this._sprite;
          }
        }, {
          key: "customMaterial",
          get: function get() {
            warnID(9007);

            if (this.subComp) {
              return this.subComp.customMaterial;
            }

            return null;
          },
          set: function set(val) {
            warnID(9007);

            if (this.subComp) {
              this.subComp.customMaterial = val;
            }
          }
        }, {
          key: "color",
          get: function get() {
            warnID(9007);

            if (this.subComp) {
              return this.subComp.color;
            }

            return null;
          },
          set: function set(value) {
            warnID(9007);

            if (this.subComp && value) {
              this.subComp.color = value;
            }
          }
        }, {
          key: "sharedMaterial",
          get: function get() {
            warnID(9007);

            if (this.subComp) {
              return this.subComp.sharedMaterial;
            }

            return null;
          }
        }, {
          key: "sharedMaterials",
          get: function get() {
            warnID(9007);

            if (this.subComp) {
              return this.subComp.sharedMaterials;
            }

            return null;
          },
          set: function set(val) {
            warnID(9007);

            if (this.subComp && val) {
              this.subComp.sharedMaterials = val;
            }
          }
        }, {
          key: "material",
          get: function get() {
            warnID(9007);

            if (this.subComp) {
              return this.subComp.material;
            }

            return null;
          },
          set: function set(val) {
            warnID(9007);

            if (this.subComp) {
              this.subComp.material = val;
            }
          }
        }, {
          key: "materials",
          get: function get() {
            warnID(9007);

            if (this.subComp) {
              return this.subComp.materials;
            }

            return [null];
          },
          set: function set(val) {
            warnID(9007);

            if (this.subComp) {
              this.subComp.materials = val;
            }
          }
        }]);

        return Mask;
      }(Component), _class3$5.Type = MaskType, _temp$a), (_applyDecoratedDescriptor(_class2$a.prototype, "type", [_dec5$5, _dec6$5], Object.getOwnPropertyDescriptor(_class2$a.prototype, "type"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "inverted", [_dec7$5, _dec8$5], Object.getOwnPropertyDescriptor(_class2$a.prototype, "inverted"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "segments", [_dec9$4], Object.getOwnPropertyDescriptor(_class2$a.prototype, "segments"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "alphaThreshold", [_dec10$4, _dec11$3, slide], Object.getOwnPropertyDescriptor(_class2$a.prototype, "alphaThreshold"), _class2$a.prototype), _descriptor$9 = _applyDecoratedDescriptor(_class2$a.prototype, "_type", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return MaskType.GRAPHICS_RECT;
        }
      }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$a.prototype, "_inverted", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$a.prototype, "_segments", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 64;
        }
      }), _descriptor4$5 = _applyDecoratedDescriptor(_class2$a.prototype, "_alphaThreshold", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      })), _class2$a)) || _class$c) || _class$c) || _class$c) || _class$c) || _class$c));
      NodeEventProcessor._maskComp = Mask;
      legacyCC.Mask = Mask;

      var eventRegx = /^(click)(\s)*=|(param)(\s)*=/;
      var imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
      var HtmlTextParser = exports('HtmlTextParser', function () {
        function HtmlTextParser() {
          this._specialSymbolArray = [];
          this._stack = [];
          this._resultObjectArray = [];

          this._specialSymbolArray.push([/&lt;/g, '<']);

          this._specialSymbolArray.push([/&gt;/g, '>']);

          this._specialSymbolArray.push([/&amp;/g, '&']);

          this._specialSymbolArray.push([/&quot;/g, '"']);

          this._specialSymbolArray.push([/&apos;/g, '\'']);
        }

        var _proto = HtmlTextParser.prototype;

        _proto.parse = function parse(htmlString) {
          this._resultObjectArray.length = 0;
          this._stack.length = 0;
          var startIndex = 0;
          var length = htmlString.length;

          while (startIndex < length) {
            var tagEndIndex = htmlString.indexOf('>', startIndex);
            var tagBeginIndex = -1;

            if (tagEndIndex >= 0) {
              tagBeginIndex = htmlString.lastIndexOf('<', tagEndIndex);
              var noTagBegin = tagBeginIndex < startIndex - 1;

              if (noTagBegin) {
                tagBeginIndex = htmlString.indexOf('<', tagEndIndex + 1);
                tagEndIndex = htmlString.indexOf('>', tagBeginIndex + 1);
              }
            }

            if (tagBeginIndex < 0) {
              this._stack.pop();

              this._processResult(htmlString.substring(startIndex));

              startIndex = length;
            } else {
              var newStr = htmlString.substring(startIndex, tagBeginIndex);
              var tagStr = htmlString.substring(tagBeginIndex + 1, tagEndIndex);
              if (tagStr === '') newStr = htmlString.substring(startIndex, tagEndIndex + 1);

              this._processResult(newStr);

              if (tagEndIndex === -1) {
                tagEndIndex = tagBeginIndex;
              } else if (htmlString.charAt(tagBeginIndex + 1) === '/') {
                this._stack.pop();
              } else {
                this._addToStack(tagStr);
              }

              startIndex = tagEndIndex + 1;
            }
          }

          return this._resultObjectArray;
        };

        _proto._attributeToObject = function _attributeToObject(attribute) {
          attribute = attribute.trim();
          var obj = {};
          var header = /^(color|size)(\s)*=/.exec(attribute);
          var tagName = '';
          var nextSpace = 0;
          var eventHanlderString = '';

          if (header) {
            tagName = header[0];
            attribute = attribute.substring(tagName.length).trim();

            if (attribute === '') {
              return obj;
            }

            nextSpace = attribute.indexOf(' ');

            switch (tagName[0]) {
              case 'c':
                if (nextSpace > -1) {
                  obj.color = attribute.substring(0, nextSpace).trim();
                } else {
                  obj.color = attribute;
                }

                break;

              case 's':
                obj.size = parseInt(attribute);
                break;
            }

            if (nextSpace > -1) {
              eventHanlderString = attribute.substring(nextSpace + 1).trim();
              obj.event = this._processEventHandler(eventHanlderString);
            }

            return obj;
          }

          header = /^(br(\s)*\/)/.exec(attribute);

          if (header && header[0].length > 0) {
            tagName = header[0].trim();

            if (tagName.startsWith('br') && tagName[tagName.length - 1] === '/') {
              obj.isNewLine = true;

              this._resultObjectArray.push({
                text: '',
                style: {
                  isNewLine: true
                }
              });

              return obj;
            }
          }

          header = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(attribute);
          var remainingArgument = '';
          var rightQuot = -1;

          if (header && header[0].length > 0) {
            tagName = header[0].trim();

            if (tagName.startsWith('img') && tagName[tagName.length - 1] === '/') {
              header = imageAttrReg.exec(attribute);
              var tagValue;
              var isValidImageTag = false;

              while (header) {
                attribute = attribute.substring(attribute.indexOf(header[0]));
                tagName = attribute.substr(0, header[0].length);
                var originTagNameLength = tagName.length;
                tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                tagName = tagName.toLowerCase();
                remainingArgument = attribute.substring(originTagNameLength).trim();

                if (tagName === 'src') {
                  rightQuot = this.getRightQuotationIndex(remainingArgument);
                } else {
                  rightQuot = -1;
                }

                nextSpace = remainingArgument.indexOf(' ', rightQuot + 1 >= remainingArgument.length ? -1 : rightQuot + 1);
                tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
                attribute = remainingArgument.substring(nextSpace).trim();

                if (tagValue.endsWith('/')) {
                  tagValue = tagValue.slice(0, -1);
                }

                if (tagName === 'src') {
                  switch (tagValue.charCodeAt(0)) {
                    case 34:
                    case 39:
                      isValidImageTag = true;
                      tagValue = tagValue.slice(1, -1);
                      break;
                  }

                  obj.isImage = true;
                  obj.src = tagValue;
                } else if (tagName === 'height') {
                  obj.imageHeight = parseInt(tagValue);
                } else if (tagName === 'width') {
                  obj.imageWidth = parseInt(tagValue);
                } else if (tagName === 'align') {
                  switch (tagValue.charCodeAt(0)) {
                    case 34:
                    case 39:
                      tagValue = tagValue.slice(1, -1);
                      break;
                  }

                  obj.imageAlign = tagValue.toLowerCase();
                } else if (tagName === 'offset') {
                  obj.imageOffset = tagValue;
                } else if (tagName === 'click') {
                  obj.event = this._processEventHandler(tagName + "=" + tagValue);
                }

                if (obj.event && tagName === 'param') {
                  obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                }

                header = imageAttrReg.exec(attribute);
              }

              if (isValidImageTag && obj.isImage) {
                this._resultObjectArray.push({
                  text: '',
                  style: obj
                });
              }

              return {};
            }
          }

          header = /^(outline(\s)*[^>]*)/.exec(attribute);

          if (header) {
            attribute = header[0].substring('outline'.length).trim();
            var defaultOutlineObject = {
              color: '#ffffff',
              width: 1
            };

            if (attribute) {
              var outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
              header = outlineAttrReg.exec(attribute);

              var _tagValue;

              while (header) {
                attribute = attribute.substring(attribute.indexOf(header[0]));
                tagName = attribute.substr(0, header[0].length);
                remainingArgument = attribute.substring(tagName.length).trim();
                nextSpace = remainingArgument.indexOf(' ');

                if (nextSpace > -1) {
                  _tagValue = remainingArgument.substr(0, nextSpace);
                } else {
                  _tagValue = remainingArgument;
                }

                tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                tagName = tagName.toLowerCase();
                attribute = remainingArgument.substring(nextSpace).trim();

                if (tagName === 'click') {
                  obj.event = this._processEventHandler(tagName + "=" + _tagValue);
                } else if (tagName === 'color') {
                  defaultOutlineObject.color = _tagValue;
                } else if (tagName === 'width') {
                  defaultOutlineObject.width = parseInt(_tagValue);
                }

                if (obj.event && tagName === 'param') {
                  obj.event[tagName] = _tagValue.replace(/^"|"$/g, '');
                }

                header = outlineAttrReg.exec(attribute);
              }
            }

            obj.outline = defaultOutlineObject;
          }

          header = /^(on|u|b|i)(\s)*/.exec(attribute);

          if (header && header[0].length > 0) {
            tagName = header[0];
            attribute = attribute.substring(tagName.length).trim();

            switch (tagName[0]) {
              case 'u':
                obj.underline = true;
                break;

              case 'i':
                obj.italic = true;
                break;

              case 'b':
                obj.bold = true;
                break;
            }

            if (attribute === '') {
              return obj;
            }

            obj.event = this._processEventHandler(attribute);
          }

          return obj;
        };

        _proto.getRightQuotationIndex = function getRightQuotationIndex(remainingArgument) {
          var leftQuot = -1;
          var rightQuot = -1;
          var leftSingleQuot = remainingArgument.indexOf('\'');
          var leftDoubleQuot = remainingArgument.indexOf('"');
          var useSingleQuot = leftSingleQuot > -1 && (leftSingleQuot < leftDoubleQuot || leftDoubleQuot === -1);
          var useDoubleQuot = leftDoubleQuot > -1 && (leftDoubleQuot < leftSingleQuot || leftSingleQuot === -1);

          if (useSingleQuot) {
            leftQuot = leftSingleQuot;
            rightQuot = remainingArgument.indexOf('\'', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
          } else if (useDoubleQuot) {
            leftQuot = leftDoubleQuot;
            rightQuot = remainingArgument.indexOf('"', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
          }

          return rightQuot;
        };

        _proto._processEventHandler = function _processEventHandler(eventString) {
          var obj = {};
          var index = 0;
          var isValidTag = false;
          var eventNames = eventRegx.exec(eventString);

          while (eventNames) {
            var eventName = eventNames[0];
            var eventValue = '';
            isValidTag = false;
            eventString = eventString.substring(eventName.length).trim();

            if (eventString.charAt(0) === '"') {
              index = eventString.indexOf('"', 1);

              if (index > -1) {
                eventValue = eventString.substring(1, index).trim();
                isValidTag = true;
              }

              index++;
            } else if (eventString.charAt(0) === '\'') {
              index = eventString.indexOf('\'', 1);

              if (index > -1) {
                eventValue = eventString.substring(1, index).trim();
                isValidTag = true;
              }

              index++;
            } else {
              var match = /(\S)+/.exec(eventString);

              if (match) {
                eventValue = match[0];
              } else {
                eventValue = '';
              }

              index = eventValue.length;
            }

            if (isValidTag) {
              eventName = eventName.substring(0, eventName.length - 1).trim();
              obj[eventName] = eventValue;
            }

            eventString = eventString.substring(index).trim();
            eventNames = eventRegx.exec(eventString);
          }

          return obj;
        };

        _proto._addToStack = function _addToStack(attribute) {
          var obj = this._attributeToObject(attribute);

          if (this._stack.length === 0) {
            this._stack.push(obj);
          } else {
            if (obj.isNewLine || obj.isImage) {
              return;
            }

            var previousTagObj = this._stack[this._stack.length - 1];

            for (var key in previousTagObj) {
              if (!obj[key]) {
                obj[key] = previousTagObj[key];
              }
            }

            this._stack.push(obj);
          }
        };

        _proto._processResult = function _processResult(value) {
          if (value.length === 0) {
            return;
          }

          value = this._escapeSpecialSymbol(value);

          if (this._stack.length > 0) {
            this._resultObjectArray.push({
              text: value,
              style: this._stack[this._stack.length - 1]
            });
          } else {
            this._resultObjectArray.push({
              text: value
            });
          }
        };

        _proto._escapeSpecialSymbol = function _escapeSpecialSymbol(str) {
          for (var _iterator = _createForOfIteratorHelperLoose(this._specialSymbolArray), _step; !(_step = _iterator()).done;) {
            var symbolArr = _step.value;
            var key = symbolArr[0];
            var value = symbolArr[1];
            str = str.replace(key, value);
          }

          return str;
        };

        return HtmlTextParser;
      }());

      var _dec$d, _dec2$7, _dec3$6, _dec4$6, _dec5$6, _dec6$6, _dec7$6, _class$d, _class2$b, _descriptor$a, _descriptor2$8, _temp$b;
      var LabelOutline = function (v) { return exports({ LabelOutline: v, LabelOutlineComponent: v }), v; }((_dec$d = ccclass('cc.LabelOutline'), _dec2$7 = help(), _dec3$6 = executionOrder(110), _dec4$6 = menu(), _dec5$6 = requireComponent(Label), _dec6$6 = tooltip(), _dec7$6 = tooltip(), _dec$d(_class$d = _dec2$7(_class$d = _dec3$6(_class$d = _dec4$6(_class$d = _dec5$6(_class$d = executeInEditMode(_class$d = (_class2$b = (_temp$b = function (_Component) {
        _inheritsLoose(LabelOutline, _Component);

        function LabelOutline() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_color", _descriptor$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_width", _descriptor2$8, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = LabelOutline.prototype;

        _proto.onEnable = function onEnable() {
          this._updateRenderData();
        };

        _proto.onDisable = function onDisable() {
          this._updateRenderData();
        };

        _proto._updateRenderData = function _updateRenderData() {
          var label = this.node.getComponent(Label);

          if (label) {
            label.updateRenderData(true);
          }
        };

        _createClass(LabelOutline, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);

            this._updateRenderData();
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          },
          set: function set(value) {
            if (this._width === value) {
              return;
            }

            this._width = value;

            this._updateRenderData();
          }
        }]);

        return LabelOutline;
      }(Component), _temp$b), (_descriptor$a = _applyDecoratedDescriptor(_class2$b.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(0, 0, 0, 255);
        }
      }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$b.prototype, "_width", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _applyDecoratedDescriptor(_class2$b.prototype, "color", [_dec6$6], Object.getOwnPropertyDescriptor(_class2$b.prototype, "color"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "width", [_dec7$6], Object.getOwnPropertyDescriptor(_class2$b.prototype, "width"), _class2$b.prototype)), _class2$b)) || _class$d) || _class$d) || _class$d) || _class$d) || _class$d) || _class$d));
      legacyCC.LabelOutline = LabelOutline;

      deprecateModuleExportedName({
        RenderComponent: {
          newName: 'UIRenderer',
          since: '1.2.0',
          removed: true
        },
        UITransformComponent: {
          newName: 'UITransform',
          since: '1.2.0',
          removed: false
        },
        CanvasComponent: {
          newName: 'Canvas',
          since: '1.2.0',
          removed: false
        }
      });

      deprecateModuleExportedName({
        UIRenderable: {
          newName: 'UIRenderer',
          since: '3.0.0',
          removed: true
        }
      });

      deprecateModuleExportedName({
        Renderable2D: {
          newName: 'UIRenderer',
          since: '3.6.0',
          removed: true
        }
      });

      var _dec$e, _dec2$8, _dec3$7, _dec4$7, _class$e;
      var RenderRoot2D = exports('RenderRoot2D', (_dec$e = ccclass('cc.RenderRoot2D'), _dec2$8 = executionOrder(100), _dec3$7 = menu(), _dec4$7 = requireComponent(UITransform), _dec$e(_class$e = _dec2$8(_class$e = _dec3$7(_class$e = _dec4$7(_class$e = disallowMultiple(_class$e = executeInEditMode(_class$e = function (_Component) {
        _inheritsLoose(RenderRoot2D, _Component);

        function RenderRoot2D() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = RenderRoot2D.prototype;

        _proto.onEnable = function onEnable() {
          legacyCC.director.root.batcher2D.addScreen(this);
        };

        _proto.onDisable = function onDisable() {
          legacyCC.director.root.batcher2D.removeScreen(this);
        };

        _proto.onDestroy = function onDestroy() {
          legacyCC.director.root.batcher2D.removeScreen(this);
        };

        return RenderRoot2D;
      }(Component)) || _class$e) || _class$e) || _class$e) || _class$e) || _class$e) || _class$e));

      var _dec$f, _dec2$9, _dec3$8, _dec4$8, _dec5$7, _dec6$7, _dec7$7, _dec8$6, _class$f, _class2$c, _descriptor$b, _descriptor2$9, _temp$c;

      var _worldPos = new Vec3();

      var RenderMode = Enum({
        OVERLAY: 0,
        INTERSPERSE: 1
      });
      var Canvas = function (v) { return exports({ Canvas: v, CanvasComponent: v }), v; }((_dec$f = ccclass('cc.Canvas'), _dec2$9 = help(), _dec3$8 = executionOrder(100), _dec4$8 = menu(), _dec5$7 = type(Camera$1), _dec6$7 = tooltip(), _dec7$7 = tooltip(), _dec8$6 = type(Camera$1), _dec$f(_class$f = _dec2$9(_class$f = _dec3$8(_class$f = _dec4$8(_class$f = executeInEditMode(_class$f = disallowMultiple(_class$f = (_class2$c = (_temp$c = function (_RenderRoot2D) {
        _inheritsLoose(Canvas, _RenderRoot2D);

        function Canvas() {
          var _this;

          _this = _RenderRoot2D.call(this) || this;

          _initializerDefineProperty(_this, "_cameraComponent", _descriptor$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_alignCanvasWithScreen", _descriptor2$9, _assertThisInitialized(_this));

          _this._thisOnCameraResized = void 0;
          _this._fitDesignResolution = void 0;
          _this._pos = new Vec3();
          _this._renderMode = RenderMode.OVERLAY;
          _this._thisOnCameraResized = _this._onResizeCamera.bind(_assertThisInitialized(_this));

          return _this;
        }

        var _proto = Canvas.prototype;

        _proto.__preload = function __preload() {
          var widget = this.getComponent('cc.Widget');

          if (widget) {
            widget.updateAlignment();
          }

          {
            if (this._cameraComponent) {
              this._cameraComponent._createCamera();

              this._cameraComponent.node.on(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
            }
          }

          this._onResizeCamera();

          {
            this.node.on(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
          }
        };

        _proto.onEnable = function onEnable() {
          _RenderRoot2D.prototype.onEnable.call(this);

          if ( this._cameraComponent) {
            this._cameraComponent.node.on(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
          }
        };

        _proto.onDisable = function onDisable() {
          _RenderRoot2D.prototype.onDisable.call(this);

          if (this._cameraComponent) {
            this._cameraComponent.node.off(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
          }
        };

        _proto.onDestroy = function onDestroy() {
          _RenderRoot2D.prototype.onDestroy.call(this);

          {
            this.node.off(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
          }
        };

        _proto._onResizeCamera = function _onResizeCamera() {
          if (this._cameraComponent && this._alignCanvasWithScreen) {
            if (this._cameraComponent.targetTexture) {
              this._cameraComponent.orthoHeight = visibleRect.height / 2;
            } else {
              var size = screen.windowSize;
              this._cameraComponent.orthoHeight = size.height / view.getScaleY() / 2;
            }

            this.node.getWorldPosition(_worldPos);

            this._cameraComponent.node.setWorldPosition(_worldPos.x, _worldPos.y, 1000);
          }
        };

        _proto._getViewPriority = function _getViewPriority() {
          if (this._cameraComponent) {
            var _this$cameraComponent;

            var priority = (_this$cameraComponent = this.cameraComponent) === null || _this$cameraComponent === void 0 ? void 0 : _this$cameraComponent.priority;
            priority = this._renderMode === RenderMode.OVERLAY ? priority | 1 << 30 : priority & ~(1 << 30);
            return priority;
          }

          return 0;
        };

        _createClass(Canvas, [{
          key: "renderMode",
          get: function get() {
            return this._renderMode;
          },
          set: function set(val) {
            this._renderMode = val;

            if (this._cameraComponent) {
              this._cameraComponent.priority = this._getViewPriority();
            }
          }
        }, {
          key: "cameraComponent",
          get: function get() {
            return this._cameraComponent;
          },
          set: function set(value) {
            if (this._cameraComponent === value) {
              return;
            }

            this._cameraComponent = value;

            this._onResizeCamera();
          }
        }, {
          key: "alignCanvasWithScreen",
          get: function get() {
            return this._alignCanvasWithScreen;
          },
          set: function set(value) {
            this._alignCanvasWithScreen = value;

            this._onResizeCamera();
          }
        }]);

        return Canvas;
      }(RenderRoot2D), _temp$c), (_applyDecoratedDescriptor(_class2$c.prototype, "cameraComponent", [_dec5$7, _dec6$7], Object.getOwnPropertyDescriptor(_class2$c.prototype, "cameraComponent"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "alignCanvasWithScreen", [_dec7$7], Object.getOwnPropertyDescriptor(_class2$c.prototype, "alignCanvasWithScreen"), _class2$c.prototype), _descriptor$b = _applyDecoratedDescriptor(_class2$c.prototype, "_cameraComponent", [_dec8$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$c.prototype, "_alignCanvasWithScreen", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class2$c)) || _class$f) || _class$f) || _class$f) || _class$f) || _class$f) || _class$f));
      legacyCC.Canvas = Canvas;

      var _dec$g, _dec2$a, _dec3$9, _class$g, _temp$d;
      var UIComponent = exports('UIComponent', (_dec$g = ccclass('cc.UIComponent'), _dec2$a = requireComponent(UITransform), _dec3$9 = executionOrder(110), _dec$g(_class$g = _dec2$a(_class$g = _dec3$9(_class$g = disallowMultiple(_class$g = executeInEditMode(_class$g = (_temp$d = function (_Component) {
        _inheritsLoose(UIComponent, _Component);

        function UIComponent() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._lastParent = null;
          _this.stencilStage = Stage.DISABLED;
          return _this;
        }

        var _proto = UIComponent.prototype;

        _proto.__preload = function __preload() {
          this.node._uiProps.uiComp = this;
        };

        _proto.onEnable = function onEnable() {};

        _proto.onDisable = function onDisable() {};

        _proto.onDestroy = function onDestroy() {
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }
        };

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

        _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
        };

        _proto.setNodeDirty = function setNodeDirty() {};

        _proto.setTextureDirty = function setTextureDirty() {};

        return UIComponent;
      }(Component), _temp$d)) || _class$g) || _class$g) || _class$g) || _class$g) || _class$g));

      removeProperty(UIComponent.prototype, 'UIComponent', [{
        name: '_visibility'
      }, {
        name: 'setVisibility'
      }]);
      removeProperty(UIRenderer.prototype, 'Renderable2D.prototype', [{
        name: 'srcBlendFactor'
      }, {
        name: 'dstBlendFactor'
      }]);
      replaceProperty(Canvas.prototype, 'Canvas.prototype', [{
        name: 'camera',
        newName: 'cameraComponent.camera',
        customGetter: function customGetter() {
          return this._cameraComponent.camera;
        }
      }, {
        name: 'clearFlag',
        newName: 'cameraComponent.clearFlags',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearFlags : 0;
        },
        customSetter: function customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.clearFlags = val;
        }
      }, {
        name: 'color',
        newName: 'cameraComponent.clearColor',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearColor : Color.BLACK;
        },
        customSetter: function customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.clearColor = val;
        }
      }, {
        name: 'priority',
        newName: 'cameraComponent.priority',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.priority : 0;
        },
        customSetter: function customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.priority = val;
        }
      }, {
        name: 'targetTexture',
        newName: 'cameraComponent.targetTexture',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.targetTexture : null;
        },
        customSetter: function customSetter(value) {
          if (this._cameraComponent) this._cameraComponent.targetTexture = value;
        }
      }, {
        name: 'visibility',
        newName: 'cameraComponent.visibility',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.visibility : 0;
        }
      }]);
      markAsWarning(UITransform.prototype, 'UITransform.prototype', [{
        name: 'priority',
        suggest: "Please use setSiblingIndex to change index of the current node in its parent's children array."
      }]);
      legacyCC.UITransformComponent = UITransform;
      js.setClassAlias(UITransform, 'cc.UITransformComponent');
      js.setClassAlias(UIRenderer, 'cc.RenderComponent');
      legacyCC.CanvasComponent = Canvas;
      js.setClassAlias(Canvas, 'cc.CanvasComponent');
      legacyCC.internal.Renderable2D = UIRenderer;
      js.setClassAlias(UIRenderer, 'cc.Renderable2D');

      var _dec$h, _dec2$b, _dec3$a, _dec4$9, _dec5$8, _dec6$8, _class$h, _class2$d, _descriptor$c, _descriptor2$a, _descriptor3$7, _descriptor4$6, _descriptor5$4, _descriptor6$3, _temp$e;
      var SpriteMode;

      (function (SpriteMode) {
        SpriteMode[SpriteMode["SIMPLE"] = 0] = "SIMPLE";
        SpriteMode[SpriteMode["SLICED"] = 1] = "SLICED";
        SpriteMode[SpriteMode["TILED"] = 2] = "TILED";
      })(SpriteMode || (SpriteMode = {}));

      var SpriteRenderer = exports('SpriteRenderer', (_dec$h = ccclass('cc.SpriteRenderer'), _dec2$b = help(), _dec3$a = executionOrder(100), _dec4$9 = menu(), _dec5$8 = type(SpriteFrame), _dec6$8 = visible(), _dec$h(_class$h = _dec2$b(_class$h = _dec3$a(_class$h = _dec4$9(_class$h = executeInEditMode(_class$h = (_class2$d = (_temp$e = function (_ModelRenderer) {
        _inheritsLoose(SpriteRenderer, _ModelRenderer);

        function SpriteRenderer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ModelRenderer.call.apply(_ModelRenderer, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_spriteFrame", _descriptor$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mode", _descriptor2$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_color", _descriptor3$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_flipX", _descriptor4$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_flipY", _descriptor5$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_size", _descriptor6$3, _assertThisInitialized(_this));

          _this._model = null;
          return _this;
        }

        var _proto = SpriteRenderer.prototype;

        _proto.onLoad = function onLoad() {
          if (this._spriteFrame) {
            if (!this._spriteFrame.mesh) {
              this._spriteFrame.ensureMeshData();
            }

            this._spriteFrame.mesh.initialize();
          }

          this._updateModels();
        };

        _proto.onRestore = function onRestore() {
          this._updateModels();

          if (this.enabledInHierarchy) {
            this._attachToScene();
          }
        };

        _proto.onEnable = function onEnable() {
          if (!this._model) {
            this._updateModels();
          }

          this._attachToScene();
        };

        _proto.onDisable = function onDisable() {
          if (this._model) {
            this._detachFromScene();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
            this._models.length = 0;
          }
        };

        _proto._updateModels = function _updateModels() {
          if (!this._spriteFrame) {
            return;
          }

          var model = this._model;

          if (model) {
            model.destroy();
            model.initialize();
            model.node = model.transform = this.node;
          } else {
            this._createModel();
          }

          if (this._model) {
            var mesh = this._spriteFrame.mesh;

            this._model.createBoundingShape(mesh.struct.minPosition, mesh.struct.maxPosition);

            this._updateModelParams();

            this._onUpdateLocalDescriptorSet();
          }
        };

        _proto._createModel = function _createModel() {
          var model = this._model = legacyCC.director.root.createModel(Model);
          model.visFlags = this.visibility;
          model.node = model.transform = this.node;
          this._models.length = 0;

          this._models.push(this._model);
        };

        _proto._updateModelParams = function _updateModelParams() {
          if (!this._spriteFrame || !this._model) {
            return;
          }

          this._spriteFrame.ensureMeshData();

          var mesh = this._spriteFrame.mesh;
          this.node.hasChangedFlags |= TransformBit.POSITION;
          this._model.transform.hasChangedFlags |= TransformBit.POSITION;
          var meshCount = mesh ? mesh.renderingSubMeshes.length : 0;
          var renderingMesh = mesh.renderingSubMeshes;

          if (renderingMesh) {
            for (var i = 0; i < meshCount; ++i) {
              var material = this.getRenderMaterial(i);

              if (material && !material.isValid) {
                material = null;
              }

              var subMeshData = renderingMesh[i];

              if (subMeshData) {
                this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
              }
            }
          }

          this._model.enabled = true;
        };

        _proto._getBuiltinMaterial = function _getBuiltinMaterial() {
          return builtinResMgr.get('missing-material');
        };

        _proto._onMaterialModified = function _onMaterialModified(idx, material) {
          _ModelRenderer.prototype._onMaterialModified.call(this, idx, material);

          if (!this._spriteFrame || !this._model || !this._model.inited) {
            return;
          }

          this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
        };

        _proto._onRebuildPSO = function _onRebuildPSO(idx, material) {
          if (!this._model || !this._model.inited) {
            return;
          }

          this._model.setSubModelMaterial(idx, material);

          this._onUpdateLocalDescriptorSet();
        };

        _proto._onUpdateLocalDescriptorSet = function _onUpdateLocalDescriptorSet() {
          if (!this._spriteFrame || !this._model || !this._model.inited) {
            return;
          }

          var texture = this._spriteFrame.getGFXTexture();

          var sampler = this._spriteFrame.getGFXSampler();

          var subModels = this._model.subModels;
          var binding = ModelLocalBindings.SAMPLER_SPRITE;

          for (var i = 0; i < subModels.length; i++) {
            var descriptorSet = subModels[i].descriptorSet;
            descriptorSet.bindTexture(binding, texture);
            descriptorSet.bindSampler(binding, sampler);
            descriptorSet.update();
          }
        };

        _proto._attachToScene = function _attachToScene() {
          if (!this.node.scene || !this._model) {
            return;
          }

          var renderScene = this._getRenderScene();

          if (this._model.scene !== null) {
            this._detachFromScene();
          }

          renderScene.addModel(this._model);
        };

        _proto._detachFromScene = function _detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        };

        _createClass(SpriteRenderer, [{
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value) {
            if (this._spriteFrame === value) {
              return;
            }

            var lastSprite = this._spriteFrame;
            this._spriteFrame = value;

            if (this._spriteFrame) {
              this._spriteFrame.ensureMeshData();

              var mesh = this._spriteFrame.mesh;
              mesh.initialize();
            }

            this._updateModels();

            if (this.enabledInHierarchy) {
              this._attachToScene();
            }
          }
        }, {
          key: "model",
          get: function get() {
            return this._model;
          }
        }]);

        return SpriteRenderer;
      }(ModelRenderer), _temp$e), (_applyDecoratedDescriptor(_class2$d.prototype, "spriteFrame", [_dec5$8], Object.getOwnPropertyDescriptor(_class2$d.prototype, "spriteFrame"), _class2$d.prototype), _descriptor$c = _applyDecoratedDescriptor(_class2$d.prototype, "_spriteFrame", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$a = _applyDecoratedDescriptor(_class2$d.prototype, "_mode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return SpriteMode.SIMPLE;
        }
      }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$d.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$d.prototype, "_flipX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$d.prototype, "_flipY", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor6$3 = _applyDecoratedDescriptor(_class2$d.prototype, "_size", [_dec6$8, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2();
        }
      })), _class2$d)) || _class$h) || _class$h) || _class$h) || _class$h) || _class$h));

      var _dec$i, _dec2$c, _dec3$b, _dec4$a, _dec5$9, _dec6$9, _dec7$8, _dec8$7, _dec9$5, _dec10$5, _dec11$4, _dec12$3, _dec13$3, _dec14$2, _dec15$2, _dec16$2, _dec17$2, _dec18$2, _dec19$2, _dec20$2, _dec21$2, _dec22$2, _class$i, _class2$e, _descriptor$d, _descriptor2$b, _descriptor3$8, _descriptor4$7, _descriptor5$5, _descriptor6$4, _descriptor7$2, _descriptor8$2, _descriptor9$2, _descriptor10$2, _descriptor11$1, _descriptor12$1, _descriptor13$1, _class3$6, _temp$f;

      var _htmlTextParser = new HtmlTextParser();

      var RichTextChildName = 'RICHTEXT_CHILD';
      var RichTextChildImageName = 'RICHTEXT_Image_CHILD';
      var labelPool = new Pool$1(function (seg) {

        if (!legacyCC.isValid(seg.node)) {
          return false;
        } else {
          var outline = seg.node.getComponent(LabelOutline);

          if (outline) {
            outline.width = 0;
          }
        }

        return true;
      }, 20);
      var imagePool = new Pool$1(function (seg) {

        return legacyCC.isValid(seg.node);
      }, 10);

      function createSegment(type) {
        return {
          node: new Node(type),
          comp: null,
          lineCount: 0,
          styleIndex: 0,
          imageOffset: '',
          clickParam: '',
          clickHandler: '',
          type: type
        };
      }

      function getSegmentByPool(type, content) {
        var seg;

        if (type === RichTextChildName) {
          seg = labelPool._get();
        } else if (type === RichTextChildImageName) {
          seg = imagePool._get();
        }

        seg = seg || createSegment(type);
        var node = seg.node;

        if (!node) {
          node = new Node(type);
        }

        node.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;

        if (type === RichTextChildImageName) {
          seg.comp = node.getComponent(Sprite) || node.addComponent(Sprite);
          seg.comp.spriteFrame = content;
          seg.comp.type = Sprite.Type.SLICED;
          seg.comp.sizeMode = Sprite.SizeMode.CUSTOM;
        } else {
          seg.comp = node.getComponent(Label) || node.addComponent(Label);
          seg.comp.string = content;
          seg.comp.horizontalAlign = HorizontalTextAlignment.LEFT;
          seg.comp.verticalAlign = VerticalTextAlignment.TOP;
          seg.comp.underlineHeight = 2;
        }

        node.setPosition(0, 0, 0);
        var trans = node._uiProps.uiTransformComp;
        trans.setAnchorPoint(0.5, 0.5);
        seg.node = node;
        seg.lineCount = 0;
        seg.styleIndex = 0;
        seg.imageOffset = '';
        seg.clickParam = '';
        seg.clickHandler = '';
        return seg;
      }

      var RichText = function (v) { return exports({ RichText: v, RichTextComponent: v }), v; }((_dec$i = ccclass('cc.RichText'), _dec2$c = help(), _dec3$b = executionOrder(110), _dec4$a = menu(), _dec5$9 = tooltip(), _dec6$9 = type(HorizontalTextAlignment), _dec7$8 = tooltip(), _dec8$7 = type(VerticalTextAlignment), _dec9$5 = tooltip(), _dec10$5 = tooltip(), _dec11$4 = tooltip(), _dec12$3 = type(Font), _dec13$3 = tooltip(), _dec14$2 = tooltip(), _dec15$2 = displayOrder(), _dec16$2 = type(CacheMode), _dec17$2 = tooltip(), _dec18$2 = tooltip(), _dec19$2 = tooltip(), _dec20$2 = type(SpriteAtlas), _dec21$2 = tooltip(), _dec22$2 = tooltip(), _dec$i(_class$i = _dec2$c(_class$i = _dec3$b(_class$i = _dec4$a(_class$i = executeInEditMode(_class$i = (_class2$e = (_temp$f = _class3$6 = function (_Component) {
        _inheritsLoose(RichText, _Component);

        function RichText() {
          var _this;

          _this = _Component.call(this) || this;

          _initializerDefineProperty(_this, "_lineHeight", _descriptor$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_string", _descriptor2$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalAlign", _descriptor4$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fontSize", _descriptor5$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_maxWidth", _descriptor6$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fontFamily", _descriptor7$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_font", _descriptor8$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor9$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_userDefinedFont", _descriptor10$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cacheMode", _descriptor11$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_imageAtlas", _descriptor12$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_handleTouchEvent", _descriptor13$1, _assertThisInitialized(_this));

          _this._textArray = [];
          _this._segments = [];
          _this._labelSegmentsCache = [];
          _this._linesWidth = [];
          _this._lineCount = 1;
          _this._labelWidth = 0;
          _this._labelHeight = 0;
          _this._layoutDirty = true;
          _this._lineOffsetX = 0;
          _this._updateRichTextStatus = void 0;
          _this._labelChildrenNum = 0;

          _this._updateRichTextStatus = _this._updateRichText;
          return _this;
        }

        var _proto = RichText.prototype;

        _proto.onLoad = function onLoad() {
          this.node.on(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
        };

        _proto.onEnable = function onEnable() {
          if (this.handleTouchEvent) {
            this._addEventListeners();
          }

          this._updateRichText();

          this._activateChildren(true);
        };

        _proto.onDisable = function onDisable() {
          if (this.handleTouchEvent) {
            this._removeEventListeners();
          }

          this._activateChildren(false);
        };

        _proto.start = function start() {
          this._onTTFLoaded();

          this.node.on(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
        };

        _proto.onRestore = function onRestore() {
          {
            return;
          }
        };

        _proto.onDestroy = function onDestroy() {
          for (var _iterator = _createForOfIteratorHelperLoose(this._segments), _step; !(_step = _iterator()).done;) {
            var seg = _step.value;
            seg.node.removeFromParent();

            if (seg.type === RichTextChildName) {
              labelPool.put(seg);
            } else if (seg.type === RichTextChildImageName) {
              imagePool.put(seg);
            }
          }

          this.node.off(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
          this.node.off(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
        };

        _proto._addEventListeners = function _addEventListeners() {
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        };

        _proto._removeEventListeners = function _removeEventListeners() {
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        };

        _proto._updateLabelSegmentTextAttributes = function _updateLabelSegmentTextAttributes() {
          var _this2 = this;

          this._segments.forEach(function (item) {
            _this2._applyTextAttribute(item);
          });
        };

        _proto._createFontLabel = function _createFontLabel(str) {
          return getSegmentByPool(RichTextChildName, str);
        };

        _proto._createImage = function _createImage(spriteFrame) {
          return getSegmentByPool(RichTextChildImageName, spriteFrame);
        };

        _proto._onTTFLoaded = function _onTTFLoaded() {
          if (this._font instanceof TTFFont) {
            this._layoutDirty = true;

            this._updateRichText();
          } else {
            this._layoutDirty = true;

            this._updateRichText();
          }
        };

        _proto.SplitLongStringApproximatelyIn2048 = function SplitLongStringApproximatelyIn2048(text, styleIndex) {
          var labelSize = this._calculateSize(styleIndex, text);

          var partStringArr = [];

          if (labelSize.x < 2048) {
            partStringArr.push(text);
          } else {
            var multilineTexts = text.split('\n');

            for (var i = 0; i < multilineTexts.length; i++) {
              var thisPartSize = this._calculateSize(styleIndex, multilineTexts[i]);

              if (thisPartSize.x < 2048) {
                partStringArr.push(multilineTexts[i]);
              } else {
                var thisPartSplitResultArr = this.splitLongStringOver2048(multilineTexts[i], styleIndex);
                partStringArr.push.apply(partStringArr, thisPartSplitResultArr);
              }
            }
          }

          return partStringArr;
        };

        _proto.splitLongStringOver2048 = function splitLongStringOver2048(text, styleIndex) {
          var partStringArr = [];
          var longStr = text;
          var curStart = 0;
          var curEnd = longStr.length / 2;
          var curString = longStr.substring(curStart, curEnd);
          var leftString = longStr.substring(curEnd);

          var curStringSize = this._calculateSize(styleIndex, curString);

          var leftStringSize = this._calculateSize(styleIndex, leftString);

          var lineCountForOnePart = 1;
          var sizeForOnePart = lineCountForOnePart * this.maxWidth;

          while (curStringSize.x > sizeForOnePart) {
            curEnd /= 2;

            if (curEnd < 1) {
              curEnd *= 2;
              break;
            }

            curString = curString.substring(curStart, curEnd);
            leftString = longStr.substring(curEnd);
            curStringSize = this._calculateSize(styleIndex, curString);
          }

          var leftTryTimes = 1000;
          var curWordStep = 1;

          while (leftTryTimes && curStart < text.length) {
            while (leftTryTimes && curStringSize.x < sizeForOnePart) {
              var nextPartExec = getEnglishWordPartAtFirst(leftString);

              if (nextPartExec && nextPartExec.length > 0) {
                curWordStep = nextPartExec[0].length;
              }

              curEnd += curWordStep;
              curString = longStr.substring(curStart, curEnd);
              leftString = longStr.substring(curEnd);
              curStringSize = this._calculateSize(styleIndex, curString);
              leftTryTimes--;
            }

            while (leftTryTimes && curString.length >= 2 && curStringSize.x > sizeForOnePart) {
              curEnd -= curWordStep;
              curString = longStr.substring(curStart, curEnd);
              curStringSize = this._calculateSize(styleIndex, curString);
              curWordStep = 1;
              leftTryTimes--;
            }

            if (curString.length >= 2) {
              var lastWordExec = getEnglishWordPartAtLast(curString);

              if (lastWordExec && lastWordExec.length > 0 && curString !== lastWordExec[0]) {
                curEnd -= lastWordExec[0].length;
                curString = longStr.substring(curStart, curEnd);
              }
            }

            partStringArr.push(curString);
            var partStep = curString.length;
            curStart = curEnd;
            curEnd += partStep;
            curString = longStr.substring(curStart, curEnd);
            leftString = longStr.substring(curEnd);
            leftStringSize = this._calculateSize(styleIndex, leftString);
            leftTryTimes--;

            if (leftStringSize.x < 2048) {
              curStart = text.length;
              curEnd = text.length;
              curString = leftString;
              partStringArr.push(curString);
              break;
            } else {
              curStringSize = this._calculateSize(styleIndex, curString);
            }
          }

          return partStringArr;
        };

        _proto._measureText = function _measureText(styleIndex, string) {
          var _this3 = this;

          var func = function func(s) {
            var labelSize = _this3._calculateSize(styleIndex, s);

            return labelSize.width;
          };

          if (string) {
            return func(string);
          } else {
            return func;
          }
        };

        _proto._calculateSize = function _calculateSize(styleIndex, s) {
          var label;

          if (this._labelSegmentsCache.length === 0) {
            label = this._createFontLabel(s);

            this._labelSegmentsCache.push(label);
          } else {
            label = this._labelSegmentsCache[0];
            label.node.getComponent(Label).string = s;
          }

          label.styleIndex = styleIndex;

          this._applyTextAttribute(label);

          var labelSize = label.node._uiProps.uiTransformComp.contentSize;
          return labelSize;
        };

        _proto._onTouchEnded = function _onTouchEnded(event) {
          var _this4 = this;

          var components = this.node.getComponents(Component);

          var _loop = function _loop() {
            var seg = _step2.value;
            var clickHandler = seg.clickHandler;
            var clickParam = seg.clickParam;

            if (clickHandler && _this4._containsTouchLocation(seg, event.touch.getUILocation())) {
              components.forEach(function (component) {
                var func = component[clickHandler];

                if (component.enabledInHierarchy && func) {
                  func.call(component, event, clickParam);
                }
              });
              event.propagationStopped = true;
            }
          };

          for (var _iterator2 = _createForOfIteratorHelperLoose(this._segments), _step2; !(_step2 = _iterator2()).done;) {
            _loop();
          }
        };

        _proto._containsTouchLocation = function _containsTouchLocation(label, point) {
          var comp = label.node.getComponent(UITransform);

          if (!comp) {
            return false;
          }

          var myRect = comp.getBoundingBoxToWorld();
          return myRect.contains(point);
        };

        _proto._resetState = function _resetState() {
          var children = this.node.children;

          for (var i = children.length - 1; i >= 0; i--) {
            var child = children[i];

            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
              {
                assert(child.parent === this.node);
              }

              child.parent = null;
              var segment = createSegment(child.name);
              segment.node = child;

              if (child.name === RichTextChildName) {
                segment.comp = child.getComponent(Label);
                labelPool.put(segment);
              } else {
                segment.comp = child.getComponent(Sprite);
                imagePool.put(segment);
              }

              this._labelChildrenNum--;
            }
          }

          this._segments.length = 0;
          this._labelSegmentsCache.length = 0;
          this._linesWidth.length = 0;
          this._lineOffsetX = 0;
          this._lineCount = 1;
          this._labelWidth = 0;
          this._labelHeight = 0;
          this._layoutDirty = true;
        };

        _proto._activateChildren = function _activateChildren(active) {
          for (var i = this.node.children.length - 1; i >= 0; i--) {
            var child = this.node.children[i];

            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
              child.active = active;
            }
          }
        };

        _proto._addLabelSegment = function _addLabelSegment(stringToken, styleIndex) {
          var labelSegment;

          if (this._labelSegmentsCache.length === 0) {
            labelSegment = this._createFontLabel(stringToken);
          } else {
            labelSegment = this._labelSegmentsCache.pop();
            var label = labelSegment.node.getComponent(Label);

            if (label) {
              label.string = stringToken;
            }
          }

          var labelComp = labelSegment.comp;

          if (labelComp.verticalAlign !== this._verticalAlign) {
            labelComp.verticalAlign = this._verticalAlign;
          }

          labelSegment.styleIndex = styleIndex;
          labelSegment.lineCount = this._lineCount;

          labelSegment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

          labelSegment.node.layer = this.node.layer;
          this.node.insertChild(labelSegment.node, this._labelChildrenNum++);

          this._applyTextAttribute(labelSegment);

          this._segments.push(labelSegment);

          return labelSegment;
        };

        _proto._updateRichTextWithMaxWidth = function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
          var fragmentWidth = labelWidth;
          var labelSegment;

          if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this._maxWidth) {
            var checkStartIndex = 0;

            while (this._lineOffsetX <= this._maxWidth) {
              var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);

              var checkString = labelString.substr(checkStartIndex, checkEndIndex);

              var checkStringWidth = this._measureText(styleIndex, checkString);

              if (this._lineOffsetX + checkStringWidth <= this._maxWidth) {
                this._lineOffsetX += checkStringWidth;
                checkStartIndex += checkEndIndex;
              } else {
                if (checkStartIndex > 0) {
                  var remainingString = labelString.substr(0, checkStartIndex);

                  this._addLabelSegment(remainingString, styleIndex);

                  labelString = labelString.substr(checkStartIndex, labelString.length);
                  fragmentWidth = this._measureText(styleIndex, labelString);
                }

                this._updateLineInfo();

                break;
              }
            }
          }

          if (fragmentWidth > this._maxWidth) {
            var fragments = fragmentText(labelString, fragmentWidth, this._maxWidth, this._measureText(styleIndex));

            for (var k = 0; k < fragments.length; ++k) {
              var splitString = fragments[k];
              labelSegment = this._addLabelSegment(splitString, styleIndex);
              var labelSize = labelSegment.node._uiProps.uiTransformComp.contentSize;
              this._lineOffsetX += labelSize.width;

              if (fragments.length > 1 && k < fragments.length - 1) {
                this._updateLineInfo();
              }
            }
          } else {
            this._lineOffsetX += fragmentWidth;

            this._addLabelSegment(labelString, styleIndex);
          }
        };

        _proto._isLastComponentCR = function _isLastComponentCR(stringToken) {
          return stringToken.length - 1 === stringToken.lastIndexOf('\n');
        };

        _proto._updateLineInfo = function _updateLineInfo() {
          this._linesWidth.push(this._lineOffsetX);

          this._lineOffsetX = 0;
          this._lineCount++;
        };

        _proto._needsUpdateTextLayout = function _needsUpdateTextLayout(newTextArray) {
          if (this._layoutDirty || !this._textArray || !newTextArray) {
            return true;
          }

          if (this._textArray.length !== newTextArray.length) {
            return true;
          }

          for (var i = 0; i < this._textArray.length; i++) {
            var oldItem = this._textArray[i];
            var newItem = newTextArray[i];

            if (oldItem.text !== newItem.text) {
              return true;
            } else {
              var oldStyle = oldItem.style;
              var newStyle = newItem.style;

              if (oldStyle) {
                if (newStyle) {
                  if (!!newStyle.outline !== !!oldStyle.outline) {
                    return true;
                  }

                  if (oldStyle.size !== newStyle.size || oldStyle.italic !== newStyle.italic || oldStyle.isImage !== newStyle.isImage) {
                    return true;
                  }

                  if (oldStyle.src !== newStyle.src || oldStyle.imageAlign !== newStyle.imageAlign || oldStyle.imageHeight !== newStyle.imageHeight || oldStyle.imageWidth !== newStyle.imageWidth || oldStyle.imageOffset !== newStyle.imageOffset) {
                    return true;
                  }
                } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) {
                  return true;
                }
              } else if (newStyle) {
                if (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline) {
                  return true;
                }
              }
            }
          }

          return false;
        };

        _proto._addRichTextImageElement = function _addRichTextImageElement(richTextElement) {
          if (!richTextElement.style) {
            return;
          }

          var style = richTextElement.style;
          var spriteFrameName = style.src;

          var spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);

          if (!spriteFrame) {
            warnID(4400);
          } else {
            var segment = this._createImage(spriteFrame);

            var sprite = segment.comp;

            switch (style.imageAlign) {
              case 'top':
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);

                break;

              case 'center':
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0.5);

                break;

              default:
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

                break;
            }

            if (style.imageOffset) {
              segment.imageOffset = style.imageOffset;
            }

            segment.node.layer = this.node.layer;
            this.node.insertChild(segment.node, this._labelChildrenNum++);

            this._segments.push(segment);

            var spriteRect = spriteFrame.rect.clone();
            var scaleFactor = 1;
            var spriteWidth = spriteRect.width;
            var spriteHeight = spriteRect.height;
            var expectWidth = style.imageWidth || 0;
            var expectHeight = style.imageHeight || 0;

            if (expectHeight > 0) {
              scaleFactor = expectHeight / spriteHeight;
              spriteWidth *= scaleFactor;
              spriteHeight *= scaleFactor;
            } else {
              scaleFactor = this._lineHeight / spriteHeight;
              spriteWidth *= scaleFactor;
              spriteHeight *= scaleFactor;
            }

            if (expectWidth > 0) {
              spriteWidth = expectWidth;
            }

            if (this._maxWidth > 0) {
              if (this._lineOffsetX + spriteWidth > this._maxWidth) {
                this._updateLineInfo();
              }

              this._lineOffsetX += spriteWidth;
            } else {
              this._lineOffsetX += spriteWidth;

              if (this._lineOffsetX > this._labelWidth) {
                this._labelWidth = this._lineOffsetX;
              }
            }

            segment.node._uiProps.uiTransformComp.setContentSize(spriteWidth, spriteHeight);

            segment.lineCount = this._lineCount;
            segment.clickHandler = '';
            segment.clickParam = '';
            var event = style.event;

            if (event) {
              segment.clickHandler = event.click;
              segment.clickParam = event.param;
            }
          }
        };

        _proto._updateRichText = function _updateRichText() {
          if (!this.enabledInHierarchy) {
            return;
          }

          var newTextArray = _htmlTextParser.parse(this._string);

          if (!this._needsUpdateTextLayout(newTextArray)) {
            this._textArray = newTextArray.slice();

            this._updateLabelSegmentTextAttributes();

            return;
          }

          this._textArray = newTextArray.slice();

          this._resetState();

          var lastEmptyLine = false;
          var label;

          for (var i = 0; i < this._textArray.length; ++i) {
            var richTextElement = this._textArray[i];
            var text = richTextElement.text;

            if (text === undefined) {
              continue;
            }

            if (text === '') {
              if (richTextElement.style && richTextElement.style.isNewLine) {
                this._updateLineInfo();

                continue;
              }

              if (richTextElement.style && richTextElement.style.isImage && this._imageAtlas) {
                this._addRichTextImageElement(richTextElement);

                continue;
              }
            }

            var splitArr = this.SplitLongStringApproximatelyIn2048(text, i);
            text = splitArr.join('\n');
            var multilineTexts = text.split('\n');

            for (var j = 0; j < multilineTexts.length; ++j) {
              var labelString = multilineTexts[j];

              if (labelString === '') {
                if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) {
                  continue;
                }

                this._updateLineInfo();

                lastEmptyLine = true;
                continue;
              }

              lastEmptyLine = false;

              if (this._maxWidth > 0) {
                var labelWidth = this._measureText(i, labelString);

                this._updateRichTextWithMaxWidth(labelString, labelWidth, i);

                if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                  this._updateLineInfo();
                }
              } else {
                label = this._addLabelSegment(labelString, i);
                this._lineOffsetX += label.node._uiProps.uiTransformComp.width;

                if (this._lineOffsetX > this._labelWidth) {
                  this._labelWidth = this._lineOffsetX;
                }

                if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                  this._updateLineInfo();
                }
              }
            }
          }

          if (!lastEmptyLine) {
            this._linesWidth.push(this._lineOffsetX);
          }

          if (this._maxWidth > 0) {
            this._labelWidth = this._maxWidth;
          }

          this._labelHeight = (this._lineCount + BASELINE_RATIO) * this._lineHeight;

          this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight);

          this._updateRichTextPosition();

          this._layoutDirty = false;
        };

        _proto._getFirstWordLen = function _getFirstWordLen(text, startIndex, textLen) {
          var character = text.charAt(startIndex);

          if (isUnicodeCJK(character) || isUnicodeSpace(character)) {
            return 1;
          }

          var len = 1;

          for (var index = startIndex + 1; index < textLen; ++index) {
            character = text.charAt(index);

            if (isUnicodeSpace(character) || isUnicodeCJK(character)) {
              break;
            }

            len++;
          }

          return len;
        };

        _proto._updateRichTextPosition = function _updateRichTextPosition() {
          var nextTokenX = 0;
          var nextLineIndex = 1;
          var totalLineCount = this._lineCount;
          var trans = this.node._uiProps.uiTransformComp;
          var anchorX = trans.anchorX;
          var anchorY = trans.anchorY;

          for (var i = 0; i < this._segments.length; ++i) {
            var segment = this._segments[i];
            var lineCount = segment.lineCount;

            if (lineCount > nextLineIndex) {
              nextTokenX = 0;
              nextLineIndex = lineCount;
            }

            var lineOffsetX = this._labelWidth * (this._horizontalAlign * 0.5 - anchorX);

            switch (this._horizontalAlign) {
              case HorizontalTextAlignment.LEFT:
                break;

              case HorizontalTextAlignment.CENTER:
                lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                break;

              case HorizontalTextAlignment.RIGHT:
                lineOffsetX -= this._linesWidth[lineCount - 1];
                break;
            }

            var pos = segment.node.position;
            segment.node.setPosition(nextTokenX + lineOffsetX, this._lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z);

            if (lineCount === nextLineIndex) {
              nextTokenX += segment.node._uiProps.uiTransformComp.width;
            }

            var sprite = segment.node.getComponent(Sprite);

            if (sprite) {
              var position = segment.node.position.clone();
              var lineHeightSet = this._lineHeight;
              var lineHeightReal = this._lineHeight * (1 + BASELINE_RATIO);

              switch (segment.node._uiProps.uiTransformComp.anchorY) {
                case 1:
                  position.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;
                  break;

                case 0.5:
                  position.y += lineHeightReal / 2;
                  break;

                default:
                  position.y += (lineHeightReal - lineHeightSet) / 2;
                  break;
              }

              if (segment.imageOffset) {
                var offsets = segment.imageOffset.split(',');

                if (offsets.length === 1 && offsets[0]) {
                  var offsetY = parseFloat(offsets[0]);
                  if (Number.isInteger(offsetY)) position.y += offsetY;
                } else if (offsets.length === 2) {
                  var offsetX = parseFloat(offsets[0]);

                  var _offsetY = parseFloat(offsets[1]);

                  if (Number.isInteger(offsetX)) position.x += offsetX;
                  if (Number.isInteger(_offsetY)) position.y += _offsetY;
                }
              }

              segment.node.position = position;
            }

            var outline = segment.node.getComponent(LabelOutline);

            if (outline) {
              var _position = segment.node.position.clone();

              _position.y -= outline.width;
              segment.node.position = _position;
            }
          }
        };

        _proto._convertLiteralColorValue = function _convertLiteralColorValue(color) {
          var colorValue = color.toUpperCase();

          if (Color[colorValue]) {
            var colorUse = Color[colorValue];
            return colorUse;
          } else {
            var out = new Color();
            return out.fromHEX(color);
          }
        };

        _proto._applyTextAttribute = function _applyTextAttribute(labelSeg) {
          var label = labelSeg.node.getComponent(Label);

          if (!label) {
            return;
          }

          this._resetLabelState(label);

          var index = labelSeg.styleIndex;
          var textStyle;

          if (this._textArray[index]) {
            textStyle = this._textArray[index].style;
          }

          if (textStyle) {
            label.color = this._convertLiteralColorValue(textStyle.color || 'white');
            label.isBold = !!textStyle.bold;
            label.isItalic = !!textStyle.italic;
            label.isUnderline = !!textStyle.underline;

            if (textStyle.outline) {
              var labelOutline = labelSeg.node.getComponent(LabelOutline);

              if (!labelOutline) {
                labelOutline = labelSeg.node.addComponent(LabelOutline);
              }

              labelOutline.color = this._convertLiteralColorValue(textStyle.outline.color);
              labelOutline.width = textStyle.outline.width;
            }

            label.fontSize = textStyle.size || this._fontSize;
            labelSeg.clickHandler = '';
            labelSeg.clickParam = '';
            var event = textStyle.event;

            if (event) {
              labelSeg.clickHandler = event.click || '';
              labelSeg.clickParam = event.param || '';
            }
          }

          label.cacheMode = this._cacheMode;
          var isAsset = this._font instanceof Font;

          if (isAsset && !this._isSystemFontUsed) {
            label.font = this._font;
          } else {
            label.fontFamily = this._fontFamily;
          }

          label.useSystemFont = this._isSystemFontUsed;
          label.lineHeight = this._lineHeight;
          label.updateRenderData(true);
          var assembler = label._assembler;

          if (assembler) {
            assembler.updateRenderData(label);
          }
        };

        _proto._applyLayer = function _applyLayer() {
          for (var _iterator3 = _createForOfIteratorHelperLoose(this._segments), _step3; !(_step3 = _iterator3()).done;) {
            var seg = _step3.value;
            seg.node.layer = this.node.layer;
          }
        };

        _proto._resetLabelState = function _resetLabelState(label) {
          label.fontSize = this._fontSize;
          label.color = Color.WHITE;
          label.isBold = false;
          label.isItalic = false;
          label.isUnderline = false;
        };

        _createClass(RichText, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            if (this._string === value) {
              return;
            }

            this._string = value;

            this._updateRichTextStatus();
          }
        }, {
          key: "horizontalAlign",
          get: function get() {
            return this._horizontalAlign;
          },
          set: function set(value) {
            if (this.horizontalAlign === value) {
              return;
            }

            this._horizontalAlign = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "verticalAlign",
          get: function get() {
            return this._verticalAlign;
          },
          set: function set(value) {
            if (this._verticalAlign === value) {
              return;
            }

            this._verticalAlign = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "fontSize",
          get: function get() {
            return this._fontSize;
          },
          set: function set(value) {
            if (this._fontSize === value) {
              return;
            }

            this._fontSize = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "fontFamily",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            if (this._fontFamily === value) return;
            this._fontFamily = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "font",
          get: function get() {
            return this._font;
          },
          set: function set(value) {
            if (this._font === value) {
              return;
            }

            this._font = value;
            this._layoutDirty = true;

            if (this._font) {

              this.useSystemFont = false;

              this._onTTFLoaded();
            } else {
              this.useSystemFont = true;
            }

            this._updateRichTextStatus();
          }
        }, {
          key: "useSystemFont",
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(value) {
            if (this._isSystemFontUsed === value) {
              return;
            }

            this._isSystemFontUsed = value;

            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "cacheMode",
          get: function get() {
            return this._cacheMode;
          },
          set: function set(value) {
            if (this._cacheMode === value) {
              return;
            }

            this._cacheMode = value;

            this._updateRichTextStatus();
          }
        }, {
          key: "maxWidth",
          get: function get() {
            return this._maxWidth;
          },
          set: function set(value) {
            if (this._maxWidth === value) {
              return;
            }

            this._maxWidth = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "lineHeight",
          get: function get() {
            return this._lineHeight;
          },
          set: function set(value) {
            if (this._lineHeight === value) {
              return;
            }

            this._lineHeight = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "imageAtlas",
          get: function get() {
            return this._imageAtlas;
          },
          set: function set(value) {
            if (this._imageAtlas === value) {
              return;
            }

            this._imageAtlas = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "handleTouchEvent",
          get: function get() {
            return this._handleTouchEvent;
          },
          set: function set(value) {
            if (this._handleTouchEvent === value) {
              return;
            }

            this._handleTouchEvent = value;

            if (this.enabledInHierarchy) {
              if (this.handleTouchEvent) {
                this._addEventListeners();
              } else {
                this._removeEventListeners();
              }
            }
          }
        }]);

        return RichText;
      }(Component), _class3$6.HorizontalAlign = HorizontalTextAlignment, _class3$6.VerticalAlign = VerticalTextAlignment, _temp$f), (_applyDecoratedDescriptor(_class2$e.prototype, "string", [multiline, _dec5$9], Object.getOwnPropertyDescriptor(_class2$e.prototype, "string"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "horizontalAlign", [_dec6$9, _dec7$8], Object.getOwnPropertyDescriptor(_class2$e.prototype, "horizontalAlign"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "verticalAlign", [_dec8$7, _dec9$5], Object.getOwnPropertyDescriptor(_class2$e.prototype, "verticalAlign"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "fontSize", [_dec10$5], Object.getOwnPropertyDescriptor(_class2$e.prototype, "fontSize"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "fontFamily", [_dec11$4], Object.getOwnPropertyDescriptor(_class2$e.prototype, "fontFamily"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "font", [_dec12$3, _dec13$3], Object.getOwnPropertyDescriptor(_class2$e.prototype, "font"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "useSystemFont", [_dec14$2, _dec15$2], Object.getOwnPropertyDescriptor(_class2$e.prototype, "useSystemFont"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "cacheMode", [_dec16$2, _dec17$2], Object.getOwnPropertyDescriptor(_class2$e.prototype, "cacheMode"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "maxWidth", [_dec18$2], Object.getOwnPropertyDescriptor(_class2$e.prototype, "maxWidth"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "lineHeight", [_dec19$2], Object.getOwnPropertyDescriptor(_class2$e.prototype, "lineHeight"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "imageAtlas", [_dec20$2, _dec21$2], Object.getOwnPropertyDescriptor(_class2$e.prototype, "imageAtlas"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "handleTouchEvent", [_dec22$2], Object.getOwnPropertyDescriptor(_class2$e.prototype, "handleTouchEvent"), _class2$e.prototype), _descriptor$d = _applyDecoratedDescriptor(_class2$e.prototype, "_lineHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor2$b = _applyDecoratedDescriptor(_class2$e.prototype, "_string", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '<color=#00ff00>Rich</color><color=#0fffff>Text</color>';
        }
      }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$e.prototype, "_horizontalAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return HorizontalTextAlignment.LEFT;
        }
      }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$e.prototype, "_verticalAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return VerticalTextAlignment.TOP;
        }
      }), _descriptor5$5 = _applyDecoratedDescriptor(_class2$e.prototype, "_fontSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor6$4 = _applyDecoratedDescriptor(_class2$e.prototype, "_maxWidth", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$2 = _applyDecoratedDescriptor(_class2$e.prototype, "_fontFamily", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'Arial';
        }
      }), _descriptor8$2 = _applyDecoratedDescriptor(_class2$e.prototype, "_font", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9$2 = _applyDecoratedDescriptor(_class2$e.prototype, "_isSystemFontUsed", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor10$2 = _applyDecoratedDescriptor(_class2$e.prototype, "_userDefinedFont", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$1 = _applyDecoratedDescriptor(_class2$e.prototype, "_cacheMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return CacheMode.NONE;
        }
      }), _descriptor12$1 = _applyDecoratedDescriptor(_class2$e.prototype, "_imageAtlas", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor13$1 = _applyDecoratedDescriptor(_class2$e.prototype, "_handleTouchEvent", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class2$e)) || _class$i) || _class$i) || _class$i) || _class$i) || _class$i));
      legacyCC.RichText = RichText;

      var _dec$j, _dec2$d, _dec3$c, _dec4$b, _class$j, _temp$g;
      var UIMeshRenderer = function (v) { return exports({ UIMeshRenderer: v, UIModelComponent: v }), v; }((_dec$j = ccclass('cc.UIMeshRenderer'), _dec2$d = help(), _dec3$c = executionOrder(110), _dec4$b = menu(), _dec$j(_class$j = _dec2$d(_class$j = _dec3$c(_class$j = _dec4$b(_class$j = executeInEditMode(_class$j = (_temp$g = function (_Component) {
        _inheritsLoose(UIMeshRenderer, _Component);

        function UIMeshRenderer() {
          var _this;

          _this = _Component.call(this) || this;
          _this._modelComponent = null;
          _this.modelCount = 0;
          _this._dirtyVersion = -1;
          _this._internalId = -1;
          _this.stencilStage = Stage.DISABLED;
          _this._renderData = null;
          _this._renderEntity = new RenderEntity(RenderEntityType.DYNAMIC);

          return _this;
        }

        var _proto = UIMeshRenderer.prototype;

        _proto.__preload = function __preload() {
          this.node._uiProps.uiComp = this;
        };

        _proto.onEnable = function onEnable() {
          uiRendererManager.addRenderer(this);
          this.markForUpdateRenderData();
        };

        _proto.onDisable = function onDisable() {
          uiRendererManager.removeRenderer(this);
          this.renderEntity.enabled = this._canRender();
        };

        _proto.onLoad = function onLoad() {
          if (!this.node._uiProps.uiTransformComp) {
            this.node.addComponent('cc.UITransform');
          }

          this._modelComponent = this.getComponent('cc.ModelRenderer');

          if (!this._modelComponent) {
            console.warn("node '" + (this.node && this.node.name) + "' doesn't have any renderable component");
            return;
          }

          this.renderEntity.setNode(this.node);
        };

        _proto.onDestroy = function onDestroy() {
          this.renderEntity.setNode(null);

          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }

          this._modelComponent = this.getComponent('cc.ModelRenderer');

          if (!this._modelComponent) {
            return;
          }

          this._modelComponent._sceneGetter = null;
        };

        _proto._render = function _render(render) {
          if (this._modelComponent) {
            var models = this._modelComponent._collectModels();

            this._modelComponent._detachFromScene();

            for (var i = 0; i < models.length; i++) {
              if (models[i].enabled) {
                render.commitModel(this, models[i], this._modelComponent.material);
              }
            }

            return true;
          }

          return false;
        };

        _proto.fillBuffers = function fillBuffers(render) {
          if (this.enabled) {
            this._render(render);
          }
        };

        _proto.updateRenderer = function updateRenderer() {
        };

        _proto._uploadRenderData = function _uploadRenderData(index) {
        };

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

        _proto.update = function update() {

          this._fitUIRenderQueue();
        };

        _proto._fitUIRenderQueue = function _fitUIRenderQueue() {
          if (!this._modelComponent) {
            return;
          }

          var matNum = this._modelComponent.sharedMaterials.length;

          for (var i = 0; i < matNum; i++) {
            var material = this._modelComponent.getMaterialInstance(i);

            if (material == null) {
              continue;
            }

            var passes = material.passes;
            var passNum = passes.length;

            for (var j = 0; j < passNum; j++) {
              var pass = passes[j];
              pass._priority = RenderPriority.MAX - 11;
              material.recompileShaders({
                CC_FORCE_FORWARD_SHADING: true
              }, j);
            }
          }
        };

        _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {

          uiRendererManager.markDirtyRenderer(this);
        };

        _proto.setNodeDirty = function setNodeDirty() {};

        _proto.setTextureDirty = function setTextureDirty() {};

        _proto._canRender = function _canRender() {
          return this.enabled && this._modelComponent !== null;
        };

        _createClass(UIMeshRenderer, [{
          key: "modelComponent",
          get: function get() {
            return this._modelComponent;
          }
        }, {
          key: "renderEntity",
          get: function get() {
            {
              assert(this._renderEntity, 'this._renderEntity should not be invalid');
            }

            return this._renderEntity;
          }
        }, {
          key: "renderData",
          get: function get() {
            return this._renderData;
          }
        }]);

        return UIMeshRenderer;
      }(Component), _temp$g)) || _class$j) || _class$j) || _class$j) || _class$j) || _class$j));
      legacyCC.UIMeshRenderer = UIMeshRenderer;

      var UI_VIS_FLAG = Layers.Enum.NONE | Layers.Enum.UI_3D;
      var DrawBatch2D = function () {
        function DrawBatch2D() {
          this.model = null;
          this.texture = null;
          this.sampler = null;
          this.useLocalData = null;
          this.isStatic = false;
          this.textureHash = 0;
          this.samplerHash = 0;
          this._passes = [];
          this._shaders = [];
          this._visFlags = UI_VIS_FLAG;
          this._inputAssembler = null;
          this._descriptorSet = null;
        }

        var _proto = DrawBatch2D.prototype;

        _proto.destroy = function destroy(ui) {
          this._passes = [];
        };

        _proto.clear = function clear() {
          this._inputAssembler = null;
          this._descriptorSet = null;
          this.texture = null;
          this.sampler = null;
          this.textureHash = 0;
          this.samplerHash = 0;
          this.model = null;
          this.isStatic = false;
          this.useLocalData = null;
          this.visFlags = UI_VIS_FLAG;
        };

        _proto.fillPasses = function fillPasses(mat, dss, dssHash, patches) {
          if (mat) {
            var passes = mat.passes;

            if (!passes) {
              return;
            }
            this._shaders.length = passes.length;

            for (var i = 0; i < passes.length; i++) {
              if (!this._passes[i]) {
                this._passes[i] = new Pass(legacyCC.director.root);
              }

              var mtlPass = passes[i];
              var passInUse = this._passes[i];
              mtlPass.update();

              if (!dss) {
                dss = mtlPass.depthStencilState;
                dssHash = 0;
              }

              passInUse._initPassFromTarget(mtlPass, dss, dssHash);

              this._shaders[i] = passInUse.getShaderVariant(patches);
            }
          }
        };

        _createClass(DrawBatch2D, [{
          key: "inputAssembler",
          get: function get() {
            return this._inputAssembler;
          },
          set: function set(ia) {
            this._inputAssembler = ia;
          }
        }, {
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          },
          set: function set(ds) {
            this._descriptorSet = ds;
          }
        }, {
          key: "visFlags",
          get: function get() {
            return this._visFlags;
          },
          set: function set(vis) {
            this._visFlags = vis;
          }
        }, {
          key: "passes",
          get: function get() {
            return this._passes;
          }
        }, {
          key: "shaders",
          get: function get() {
            return this._shaders;
          }
        }]);

        return DrawBatch2D;
      }();

      var _dec$k, _dec2$e, _dec3$d, _dec4$c, _dec5$a, _class$k, _class2$f, _temp$h;
      var UIStaticBatch = function (v) { return exports({ UIStaticBatch: v, UIStaticBatchComponent: v }), v; }((_dec$k = ccclass('cc.UIStaticBatch'), _dec2$e = help(), _dec3$d = menu(), _dec4$c = executionOrder(110), _dec5$a = visible(), _dec$k(_class$k = _dec2$e(_class$k = _dec3$d(_class$k = _dec4$c(_class$k = (_class2$f = (_temp$h = function (_UIRenderer) {
        _inheritsLoose(UIStaticBatch, _UIRenderer);

        function UIStaticBatch() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _UIRenderer.call.apply(_UIRenderer, [this].concat(args)) || this;
          _this._init = false;
          _this._bufferAccessor = null;
          _this._dirty = true;
          _this._uiDrawBatchList = [];
          return _this;
        }

        var _proto = UIStaticBatch.prototype;

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

        _proto.markAsDirty = function markAsDirty() {};

        _proto._requireDrawBatch = function _requireDrawBatch() {
          var batch = new DrawBatch2D();
          batch.isStatic = true;

          this._uiDrawBatchList.push(batch);

          return batch;
        };

        _proto._clearData = function _clearData() {
          if (this._bufferAccessor) {
            this._bufferAccessor.reset();

            var ui = this._getBatcher();

            for (var i = 0; i < this._uiDrawBatchList.length; i++) {
              var element = this._uiDrawBatchList[i];
              element.destroy(ui);
            }
          }

          this._uiDrawBatchList.length = 0;
          this._init = false;
        };

        _proto._getBatcher = function _getBatcher() {
          if (director.root && director.root.batcher2D) {
            return director.root.batcher2D;
          }

          warnID(9301);
          return null;
        };

        _createClass(UIStaticBatch, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);
          }
        }, {
          key: "drawBatchList",
          get: function get() {
            return this._uiDrawBatchList;
          }
        }]);

        return UIStaticBatch;
      }(UIRenderer), _temp$h), (_applyDecoratedDescriptor(_class2$f.prototype, "color", [override, _dec5$a], Object.getOwnPropertyDescriptor(_class2$f.prototype, "color"), _class2$f.prototype)), _class2$f)) || _class$k) || _class$k) || _class$k) || _class$k));

      var _dec$l, _dec2$f, _dec3$e, _dec4$d, _dec5$b, _dec6$a, _dec7$9, _dec8$8, _class$l, _class2$g, _descriptor$e, _descriptor2$c, _descriptor3$9, _temp$i;
      var LabelShadow = exports('LabelShadow', (_dec$l = ccclass('cc.LabelShadow'), _dec2$f = help(), _dec3$e = executionOrder(110), _dec4$d = menu(), _dec5$b = requireComponent(Label), _dec6$a = tooltip(), _dec7$9 = tooltip(), _dec8$8 = tooltip(), _dec$l(_class$l = _dec2$f(_class$l = _dec3$e(_class$l = _dec4$d(_class$l = _dec5$b(_class$l = executeInEditMode(_class$l = (_class2$g = (_temp$i = function (_Component) {
        _inheritsLoose(LabelShadow, _Component);

        function LabelShadow() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_color", _descriptor$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_offset", _descriptor2$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_blur", _descriptor3$9, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = LabelShadow.prototype;

        _proto.onEnable = function onEnable() {
          this._updateRenderData();
        };

        _proto.onDisable = function onDisable() {
          this._updateRenderData();
        };

        _proto._updateRenderData = function _updateRenderData() {
          var label = this.node.getComponent(Label);

          if (label) {
            label.updateRenderData(true);
          }
        };

        _createClass(LabelShadow, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);

            this._updateRenderData();
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset = value;

            this._updateRenderData();
          }
        }, {
          key: "blur",
          get: function get() {
            return this._blur;
          },
          set: function set(value) {
            this._blur = value;

            this._updateRenderData();
          }
        }]);

        return LabelShadow;
      }(Component), _temp$i), (_descriptor$e = _applyDecoratedDescriptor(_class2$g.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(0, 0, 0, 255);
        }
      }), _descriptor2$c = _applyDecoratedDescriptor(_class2$g.prototype, "_offset", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(2, 2);
        }
      }), _descriptor3$9 = _applyDecoratedDescriptor(_class2$g.prototype, "_blur", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _applyDecoratedDescriptor(_class2$g.prototype, "color", [_dec6$a], Object.getOwnPropertyDescriptor(_class2$g.prototype, "color"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "offset", [_dec7$9], Object.getOwnPropertyDescriptor(_class2$g.prototype, "offset"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "blur", [_dec8$8], Object.getOwnPropertyDescriptor(_class2$g.prototype, "blur"), _class2$g.prototype)), _class2$g)) || _class$l) || _class$l) || _class$l) || _class$l) || _class$l) || _class$l));

      var _dec$m, _dec2$g, _dec3$f, _dec4$e, _dec5$c, _class$m, _class2$h, _descriptor$f, _temp$j;
      var UIOpacity = function (v) { return exports({ UIOpacity: v, UIOpacityComponent: v }), v; }((_dec$m = ccclass('cc.UIOpacity'), _dec2$g = help(), _dec3$f = executionOrder(110), _dec4$e = menu(), _dec5$c = tooltip(), _dec$m(_class$m = _dec2$g(_class$m = _dec3$f(_class$m = _dec4$e(_class$m = executeInEditMode(_class$m = disallowMultiple(_class$m = (_class2$h = (_temp$j = function (_Component) {
        _inheritsLoose(UIOpacity, _Component);

        function UIOpacity() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_opacity", _descriptor$f, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = UIOpacity.prototype;

        _proto.setEntityLocalOpacityDirtyRecursively = function setEntityLocalOpacityDirtyRecursively(dirty) {
        };

        UIOpacity.setEntityLocalOpacityDirtyRecursively = function setEntityLocalOpacityDirtyRecursively(node, dirty, interruptParentOpacity) {
          if (!node.isValid) {
            return;
          }

          var render = node._uiProps.uiComp;
          var uiOp = node.getComponent(UIOpacity);
          var interruptOpacity = interruptParentOpacity;

          if (render && render.color) {
            render.renderEntity.colorDirty = dirty;

            if (uiOp) {
              render.renderEntity.localOpacity = interruptOpacity * uiOp.opacity / 255;
            } else {
              render.renderEntity.localOpacity = interruptOpacity;
            }

            interruptOpacity = 1;
          } else if (uiOp) {
            interruptOpacity = interruptOpacity * uiOp.opacity / 255;
          }

          for (var i = 0; i < node.children.length; i++) {
            UIOpacity.setEntityLocalOpacityDirtyRecursively(node.children[i], dirty || interruptOpacity < 1, interruptOpacity);
          }
        };

        _proto.onEnable = function onEnable() {
          this.node._uiProps.localOpacity = this._opacity / 255;
          this.setEntityLocalOpacityDirtyRecursively(true);
        };

        _proto.onDisable = function onDisable() {
          this.node._uiProps.localOpacity = 1;
          this.setEntityLocalOpacityDirtyRecursively(true);
        };

        _createClass(UIOpacity, [{
          key: "opacity",
          get: function get() {
            return this._opacity;
          },
          set: function set(value) {
            if (this._opacity === value) {
              return;
            }

            value = clampf(value, 0, 255);
            this._opacity = value;
            this.node._uiProps.localOpacity = value / 255;
            this.setEntityLocalOpacityDirtyRecursively(true);
          }
        }]);

        return UIOpacity;
      }(Component), _temp$j), (_applyDecoratedDescriptor(_class2$h.prototype, "opacity", [editable, _dec5$c], Object.getOwnPropertyDescriptor(_class2$h.prototype, "opacity"), _class2$h.prototype), _descriptor$f = _applyDecoratedDescriptor(_class2$h.prototype, "_opacity", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 255;
        }
      })), _class2$h)) || _class$m) || _class$m) || _class$m) || _class$m) || _class$m) || _class$m));

      legacyCC.MaskComponent = Mask;
      js.setClassAlias(Mask, 'cc.MaskComponent');
      legacyCC.LabelComponent = Label;
      js.setClassAlias(Label, 'cc.LabelComponent');
      legacyCC.LabelOutlineComponent = LabelOutline;
      js.setClassAlias(LabelOutline, 'cc.LabelOutlineComponent');
      legacyCC.RichTextComponent = RichText;
      js.setClassAlias(RichText, 'cc.RichTextComponent');
      legacyCC.SpriteComponent = Sprite;
      js.setClassAlias(Sprite, 'cc.SpriteComponent');
      legacyCC.UIModelComponent = UIMeshRenderer;
      js.setClassAlias(UIMeshRenderer, 'cc.UIModelComponent');
      legacyCC.GraphicsComponent = Graphics;
      js.setClassAlias(Graphics, 'cc.GraphicsComponent');
      js.setClassAlias(UIStaticBatch, 'cc.UIStaticBatchComponent');
      js.setClassAlias(UIOpacity, 'cc.UIOpacityComponent');
      replaceProperty(Mask.prototype, 'Mask', [{
        name: 'graphics',
        newName: 'subComp',
        target: Mask.prototype,
        targetName: 'Mask'
      }]);
      replaceProperty(MaskType, 'MaskType', [{
        name: 'RECT',
        newName: 'GRAPHICS_RECT',
        target: MaskType,
        targetName: 'MaskType'
      }, {
        name: 'ELLIPSE',
        newName: 'GRAPHICS_ELLIPSE',
        target: MaskType,
        targetName: 'MaskType'
      }, {
        name: 'IMAGE_STENCIL',
        newName: 'SPRITE_STENCIL',
        target: MaskType,
        targetName: 'MaskType'
      }]);

      var Aim = function Aim(i, x, y) {
        this.i = void 0;
        this.x = void 0;
        this.y = void 0;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
        this.i = i;
        this.x = x;
        this.y = y;
      };

      function linkedList(datas, start, end, dim, clockwise) {
        var i = 0;
        var last = null;

        if (clockwise === signedArea(datas, start, end, dim) > 0) {
          for (i = start; i < end; i += dim) {
            last = insertNode(i, datas[i], datas[i + 1], last);
          }
        } else {
          for (i = end - dim; i >= start; i -= dim) {
            last = insertNode(i, datas[i], datas[i + 1], last);
          }
        }

        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }

        return last;
      }

      function filterPoints(start, end) {
        if (end === void 0) {
          end = null;
        }

        if (!start) {
          return start;
        }

        if (!end) {
          end = start;
        }

        var p = start;
        var again = false;

        do {
          again = false;

          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;

            if (p === p.next) {
              return null;
            }

            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);

        return end;
      }

      function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
        if (pass === void 0) {
          pass = 0;
        }

        if (!ear) {
          return;
        }

        if (!pass && size) {
          indexCurve(ear, minX, minY, size);
        }

        var stop = ear;
        var prev = null;
        var next = null;

        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;

          if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }

          ear = next;

          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(ear, triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, size, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
          }
        }
      }

      function isEar(ear) {
        var a = ear.prev;
        var b = ear;
        var c = ear.next;

        if (area(a, b, c) >= 0) {
          return false;
        }

        var p = ear.next.next;

        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }

          p = p.next;
        }

        return true;
      }

      function isEarHashed(ear, minX, minY, size) {
        var a = ear.prev;
        var b = ear;
        var c = ear.next;

        if (area(a, b, c) >= 0) {
          return false;
        }

        var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
        var minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
        var maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
        var maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        var minZ = zOrder(minTX, minTY, minX, minY, size);
        var maxZ = zOrder(maxTX, maxTY, minX, minY, size);
        var p = ear.nextZ;

        while (p && p.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }

          p = p.nextZ;
        }

        p = ear.prevZ;

        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }

          p = p.prevZ;
        }

        return true;
      }

      function cureLocalIntersections(start, triangles, dim) {
        var p = start;

        do {
          var a = p.prev;
          var b = p.next.next;

          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }

          p = p.next;
        } while (p !== start);

        return p;
      }

      function splitEarcut(start, triangles, dim, minX, minY, size) {
        var a = start;

        do {
          var b = a.next.next;

          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, size);
              earcutLinked(c, triangles, dim, minX, minY, size);
              return;
            }

            b = b.next;
          }

          a = a.next;
        } while (a !== start);
      }

      function eliminateHoles(datas, holeIndices, outerNode, dim) {
        var queue = [];
        var i = 0;
        var len = 0;
        var start = 0;
        var end = 0;
        var list = null;

        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : datas.length;
          list = linkedList(datas, start, end, dim, false);

          if (!list) {
            continue;
          }

          if (list === list.next) {
            list.steiner = true;
          }

          queue.push(getLeftmost(list));
        }

        queue.sort(compareX);

        if (!outerNode) {
          return outerNode;
        }

        for (i = 0; i < queue.length; i++) {
          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }

        return outerNode;
      }

      function compareX(a, b) {
        return a.x - b.x;
      }

      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);

        if (outerNode) {
          var b = splitPolygon(outerNode, hole);
          filterPoints(b, b.next);
        }
      }

      function findHoleBridge(hole, outerNode) {
        var p = outerNode;
        var hx = hole.x;
        var hy = hole.y;
        var qx = -Infinity;
        var m = null;

        do {
          if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

            if (x <= hx && x > qx) {
              qx = x;

              if (x === hx) {
                if (hy === p.y) {
                  return p;
                }

                if (hy === p.next.y) {
                  return p.next;
                }
              }

              m = p.x < p.next.x ? p : p.next;
            }
          }

          p = p.next;
        } while (p !== outerNode);

        if (!m) {
          return null;
        }

        if (hx === qx) {
          return m.prev;
        }

        var stop = m;
        var mx = m.x;
        var my = m.y;
        var tanMin = Infinity;
        var tan;
        p = m.next;

        while (p !== stop) {
          if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);

            if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
              m = p;
              tanMin = tan;
            }
          }

          p = p.next;
        }

        return m;
      }

      function indexCurve(start, minX, minY, size) {
        var p = start;

        do {
          if (p.z === null) {
            p.z = zOrder(p.x, p.y, minX, minY, size);
          }

          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }

      function sortLinked(list) {
        var i = 0;
        var p = null;
        var q = null;
        var e = null;
        var tail = null;
        var numMerges = 0;
        var pSize = 0;
        var qSize = 0;
        var inSize = 1;

        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;

          while (p) {
            numMerges++;
            q = p;
            pSize = 0;

            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;

              if (!q) {
                break;
              }
            }

            qSize = inSize;

            while (pSize > 0 || qSize > 0 && q) {
              if (pSize === 0) {
                e = q;
                q = q.nextZ;
                qSize--;
              } else if (qSize === 0 || !q) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else if (p.z <= q.z) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }

              if (tail) {
                tail.nextZ = e;
              } else {
                list = e;
              }

              e.prevZ = tail;
              tail = e;
            }

            p = q;
          }

          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);

        return list;
      }

      function zOrder(x, y, minX, minY, size) {
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
        x = (x | x << 8) & 0x00FF00FF;
        x = (x | x << 4) & 0x0F0F0F0F;
        x = (x | x << 2) & 0x33333333;
        x = (x | x << 1) & 0x55555555;
        y = (y | y << 8) & 0x00FF00FF;
        y = (y | y << 4) & 0x0F0F0F0F;
        y = (y | y << 2) & 0x33333333;
        y = (y | y << 1) & 0x55555555;
        return x | y << 1;
      }

      function getLeftmost(start) {
        var p = start;
        var leftmost = start;

        do {
          if (p.x < leftmost.x) {
            leftmost = p;
          }

          p = p.next;
        } while (p !== start);

        return leftmost;
      }

      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
      }

      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
      }

      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }

      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }

      function intersects(p1, q1, p2, q2) {
        if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) {
          return true;
        }

        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
      }

      function intersectsPolygon(a, b) {
        var p = a;

        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
            return true;
          }

          p = p.next;
        } while (p !== a);

        return false;
      }

      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }

      function middleInside(a, b) {
        var p = a;
        var inside = false;
        var px = (a.x + b.x) / 2;
        var py = (a.y + b.y) / 2;

        do {
          if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
            inside = !inside;
          }

          p = p.next;
        } while (p !== a);

        return inside;
      }

      function splitPolygon(a, b) {
        var a2 = new Aim(a.i, a.x, a.y);
        var b2 = new Aim(b.i, b.x, b.y);
        var an = a.next;
        var bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }

      function insertNode(i, x, y, last) {
        var p = new Aim(i, x, y);

        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }

        return p;
      }

      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) {
          p.prevZ.nextZ = p.nextZ;
        }

        if (p.nextZ) {
          p.nextZ.prevZ = p.prevZ;
        }
      }

      function signedArea(datas, start, end, dim) {
        var sum = 0;

        for (var i = start, j = end - dim; i < end; i += dim) {
          sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]);
          j = i;
        }

        return sum;
      }

      function earcut(datas, holeIndices, dim) {
        dim = dim || 3;
        var hasHoles = holeIndices ? holeIndices.length : 0;
        var outerLen = hasHoles ? holeIndices[0] * dim : datas.length;
        var outerNode = linkedList(datas, 0, outerLen, dim, true);
        var triangles = [];

        if (!outerNode) {
          return triangles;
        }

        var minX = 0;
        var minY = 0;
        var maxX = 0;
        var maxY = 0;
        var x = 0;
        var y = 0;
        var size = 0;

        if (hasHoles) {
          outerNode = eliminateHoles(datas, holeIndices, outerNode, dim);
        }

        if (datas.length > 80 * dim) {
          minX = maxX = datas[0];
          minY = maxY = datas[1];

          for (var i = dim; i < outerLen; i += dim) {
            x = datas[i];
            y = datas[i + 1];

            if (x < minX) {
              minX = x;
            }

            if (y < minY) {
              minY = y;
            }

            if (x > maxX) {
              maxX = x;
            }

            if (y > maxY) {
              maxY = y;
            }
          }

          size = Math.max(maxX - minX, maxY - minY);
        }

        earcutLinked(outerNode, triangles, dim, minX, minY, size);
        return triangles;
      }

      var MAX_VERTEX = 65535;
      var MAX_INDICES = MAX_VERTEX * 2;
      var PI$1 = Math.PI;
      var min$1 = Math.min;
      var max$1 = Math.max;
      var ceil = Math.ceil;
      var acos = Math.acos;
      var cos$1 = Math.cos;
      var sin$1 = Math.sin;
      var atan2 = Math.atan2;
      var attrBytes = 8;
      var _renderData = null;
      var _impl = null;

      var _curColor = new Color();

      var vec3_temps = [];

      for (var i = 0; i < 4; i++) {
        vec3_temps.push(new Vec3());
      }

      function curveDivs(r, arc, tol) {
        var da = acos(r / (r + tol)) * 2.0;
        return max$1(2, ceil(arc / da));
      }

      function clamp(v, minNum, maxNum) {
        if (v < minNum) {
          return minNum;
        } else if (v > maxNum) {
          return maxNum;
        }

        return v;
      }

      var graphicsAssembler = {
        useModel: true,
        updateRenderData: function updateRenderData(graphics) {
        },
        fillBuffers: function fillBuffers(graphics, renderer) {},
        renderIA: function renderIA(graphics, renderer) {},
        getRenderData: function getRenderData(graphics, vertexCount) {
          if (!_impl) {
            return null;
          }

          var renderDataList = _impl.getRenderDataList();

          var renderData = renderDataList[_impl.dataOffset];

          if (!renderData) {
            return null;
          }

          var meshBuffer = renderData;
          var maxVertexCount = meshBuffer ? meshBuffer.vertexStart + vertexCount : 0;

          if (maxVertexCount > MAX_VERTEX || maxVertexCount * 3 > MAX_INDICES) {
            ++_impl.dataOffset;

            if (_impl.dataOffset < renderDataList.length) {
              renderData = renderDataList[_impl.dataOffset];
            } else {
              renderData = _impl.requestRenderData();
              renderDataList[_impl.dataOffset] = renderData;
            }

            meshBuffer = renderData;
          }

          if (meshBuffer && meshBuffer.vertexCount < maxVertexCount) {
            meshBuffer.request(vertexCount, vertexCount * 3);
          }

          return renderData;
        },
        stroke: function stroke(graphics) {
          Color.copy(_curColor, graphics.strokeColor);

          if (!graphics.impl) {
            return;
          }

          this._flattenPaths(graphics.impl);

          this._expandStroke(graphics);

          graphics.impl.updatePathOffset = true;
          this.end(graphics);
        },
        fill: function fill(graphics) {
          Color.copy(_curColor, graphics.fillColor);

          this._expandFill(graphics);

          if (graphics.impl) {
            graphics.impl.updatePathOffset = true;
          }

          this.end(graphics);
        },
        end: function end(graphics) {
          graphics.markForUpdateRenderData();
        },
        _expandStroke: function _expandStroke(graphics) {
          var w = graphics.lineWidth * 0.5;
          var lineCap = graphics.lineCap;
          var lineJoin = graphics.lineJoin;
          var miterLimit = graphics.miterLimit;
          _impl = graphics.impl;

          if (!_impl) {
            return;
          }

          var nCap = curveDivs(w, PI$1, _impl.tessTol);

          this._calculateJoins(_impl, w, lineJoin, miterLimit);

          var paths = _impl.paths;
          var vertexCount = 0;

          for (var _i = _impl.pathOffset, l = _impl.pathLength; _i < l; _i++) {
            var path = paths[_i];
            var pointsLength = path.points.length;

            if (lineJoin === LineJoin.ROUND) {
              vertexCount += (pointsLength + path.bevel * (nCap + 2) + 1) * 2;
            } else {
              vertexCount += (pointsLength + path.bevel * 5 + 1) * 2;
            }

            if (!path.closed) {
              if (lineCap === LineCap.ROUND) {
                vertexCount += (nCap * 2 + 2) * 2;
              } else {
                vertexCount += (3 + 3) * 2;
              }
            }
          }

          var meshBuffer = _renderData = this.getRenderData(graphics, vertexCount);

          if (!meshBuffer) {
            return;
          }

          var vData = meshBuffer.vData;
          var iData = meshBuffer.iData;

          for (var _i2 = _impl.pathOffset, _l = _impl.pathLength; _i2 < _l; _i2++) {
            var _path = paths[_i2];
            var pts = _path.points;
            var _pointsLength = pts.length;
            var offset = meshBuffer.vertexStart;
            var p0 = void 0;
            var p1 = void 0;
            var start = 0;
            var end = 0;
            var loop = _path.closed;

            if (loop) {
              p0 = pts[_pointsLength - 1];
              p1 = pts[0];
              start = 0;
              end = _pointsLength;
            } else {
              p0 = pts[0];
              p1 = pts[1];
              start = 1;
              end = _pointsLength - 1;
            }

            p1 = p1 || p0;

            if (!loop) {
              var dPos = new Point(p1.x, p1.y);
              dPos.subtract(p0);
              dPos.normalize();
              var dx = dPos.x;
              var dy = dPos.y;

              if (lineCap === LineCap.BUTT) {
                this._buttCapStart(p0, dx, dy, w, 0);
              } else if (lineCap === LineCap.SQUARE) {
                this._buttCapStart(p0, dx, dy, w, w);
              } else if (lineCap === LineCap.ROUND) {
                this._roundCapStart(p0, dx, dy, w, nCap);
              }
            }

            for (var j = start; j < end; ++j) {
              if (lineJoin === LineJoin.ROUND) {
                this._roundJoin(p0, p1, w, w, nCap);
              } else if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                this._bevelJoin(p0, p1, w, w);
              } else {
                this._vSet(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);

                this._vSet(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);
              }

              p0 = p1;
              p1 = pts[j + 1];
            }

            if (loop) {
              var vDataOffset = offset * attrBytes;

              this._vSet(vData[vDataOffset], vData[vDataOffset + 1], 1);

              this._vSet(vData[vDataOffset + attrBytes], vData[vDataOffset + attrBytes + 1], -1);
            } else {
              var _dPos = new Point(p1.x, p1.y);

              _dPos.subtract(p0);

              _dPos.normalize();

              var _dx = _dPos.x;
              var _dy = _dPos.y;

              if (lineCap === LineCap.BUTT) {
                this._buttCapEnd(p1, _dx, _dy, w, 0);
              } else if (lineCap === LineCap.SQUARE) {
                this._buttCapEnd(p1, _dx, _dy, w, w);
              } else if (lineCap === LineCap.ROUND) {
                this._roundCapEnd(p1, _dx, _dy, w, nCap);
              }
            }

            var indicesOffset = meshBuffer.indexStart;

            for (var begin = offset + 2, over = meshBuffer.vertexStart; begin < over; begin++) {
              iData[indicesOffset++] = begin - 2;
              iData[indicesOffset++] = begin - 1;
              iData[indicesOffset++] = begin;
            }

            meshBuffer.indexStart = indicesOffset;
          }

          _renderData = null;
          _impl = null;
        },
        _expandFill: function _expandFill(graphics) {
          _impl = graphics.impl;

          if (!_impl) {
            return;
          }

          var paths = _impl.paths;
          var vertexCount = 0;

          for (var _i3 = _impl.pathOffset, l = _impl.pathLength; _i3 < l; _i3++) {
            var path = paths[_i3];
            var pointsLength = path.points.length;
            vertexCount += pointsLength;
          }

          var renderData = _renderData = this.getRenderData(graphics, vertexCount);

          if (!renderData) {
            return;
          }

          var meshBuffer = renderData;
          var vData = meshBuffer.vData;
          var iData = meshBuffer.iData;

          for (var _i4 = _impl.pathOffset, _l2 = _impl.pathLength; _i4 < _l2; _i4++) {
            var _path2 = paths[_i4];
            var pts = _path2.points;
            var _pointsLength2 = pts.length;

            if (_pointsLength2 === 0) {
              continue;
            }

            var vertexOffset = renderData.vertexStart;

            for (var j = 0; j < _pointsLength2; ++j) {
              this._vSet(pts[j].x, pts[j].y);
            }

            var indicesOffset = renderData.indexStart;

            if (_path2.complex) {
              var earcutData = [];

              for (var _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                var vDataOffset = _j * attrBytes;
                earcutData.push(vData[vDataOffset++]);
                earcutData.push(vData[vDataOffset++]);
                earcutData.push(vData[vDataOffset++]);
              }

              var newIndices = earcut(earcutData, null, 3);

              if (!newIndices || newIndices.length === 0) {
                continue;
              }

              for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) {
                iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
              }
            } else {
              var first = vertexOffset;

              for (var start = vertexOffset + 2, _end = meshBuffer.vertexStart; start < _end; start++) {
                iData[indicesOffset++] = first;
                iData[indicesOffset++] = start - 1;
                iData[indicesOffset++] = start;
              }
            }

            meshBuffer.indexStart = indicesOffset;
          }

          _renderData = null;
          _impl = null;
        },
        _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
          var iw = 0.0;

          if (w > 0.0) {
            iw = 1 / w;
          }

          var paths = impl.paths;

          for (var _i5 = impl.pathOffset, l = impl.pathLength; _i5 < l; _i5++) {
            var path = paths[_i5];
            var pts = path.points;
            var ptsLength = pts.length;
            var p0 = pts[ptsLength - 1];
            var p1 = pts[0];
            path.bevel = 0;

            for (var j = 0; j < ptsLength; j++) {
              var dmr2 = 0;
              var cross = 0;
              var limit = 0;
              var dlx0 = p0.dy;
              var dly0 = -p0.dx;
              var dlx1 = p1.dy;
              var dly1 = -p1.dx;
              p1.dmx = (dlx0 + dlx1) * 0.5;
              p1.dmy = (dly0 + dly1) * 0.5;
              dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;

              if (dmr2 > 0.000001) {
                var scale = 1 / dmr2;

                if (scale > 600) {
                  scale = 600;
                }

                p1.dmx *= scale;
                p1.dmy *= scale;
              }

              cross = p1.dx * p0.dy - p0.dx * p1.dy;

              if (cross > 0) {
                p1.flags |= PointFlags.PT_LEFT;
              }

              limit = max$1(11, min$1(p0.len, p1.len) * iw);

              if (dmr2 * limit * limit < 1) {
                p1.flags |= PointFlags.PT_INNERBEVEL;
              }

              if (p1.flags & PointFlags.PT_CORNER) {
                if (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) {
                  p1.flags |= PointFlags.PT_BEVEL;
                }
              }

              if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                path.bevel++;
              }

              p0 = p1;
              p1 = pts[j + 1];
            }
          }
        },
        _flattenPaths: function _flattenPaths(impl) {
          var paths = impl.paths;

          for (var _i6 = impl.pathOffset, l = impl.pathLength; _i6 < l; _i6++) {
            var path = paths[_i6];
            var pts = path.points;
            var p0 = pts[pts.length - 1];
            var p1 = pts[0];

            if (pts.length > 2 && p0.equals(p1)) {
              path.closed = true;
              pts.pop();
              p0 = pts[pts.length - 1];
            }

            for (var j = 0, size = pts.length; j < size; j++) {
              var dPos = new Point(p1.x, p1.y);
              dPos.subtract(p0);
              p0.len = dPos.length();

              if (dPos.x || dPos.y) {
                dPos.normalize();
              }

              p0.dx = dPos.x;
              p0.dy = dPos.y;
              p0 = p1;
              p1 = pts[j + 1];
            }
          }
        },
        _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
          var x = p1.x;
          var y = p1.y;
          var x0 = 0;
          var y0 = 0;
          var x1 = 0;
          var y1 = 0;

          if (bevel !== 0) {
            x0 = x + p0.dy * w;
            y0 = y - p0.dx * w;
            x1 = x + p1.dy * w;
            y1 = y - p1.dx * w;
          } else {
            x0 = x1 = x + p1.dmx * w;
            y0 = y1 = y + p1.dmy * w;
          }

          return [x0, y0, x1, y1];
        },
        _buttCapStart: function _buttCapStart(p, dx, dy, w, d) {
          var px = p.x - dx * d;
          var py = p.y - dy * d;
          var dlx = dy;
          var dly = -dx;

          this._vSet(px + dlx * w, py + dly * w, 1);

          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _buttCapEnd: function _buttCapEnd(p, dx, dy, w, d) {
          var px = p.x + dx * d;
          var py = p.y + dy * d;
          var dlx = dy;
          var dly = -dx;

          this._vSet(px + dlx * w, py + dly * w, 1);

          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _roundCapStart: function _roundCapStart(p, dx, dy, w, nCap) {
          var px = p.x;
          var py = p.y;
          var dlx = dy;
          var dly = -dx;

          for (var _i7 = 0; _i7 < nCap; _i7++) {
            var a = _i7 / (nCap - 1) * PI$1;
            var ax = cos$1(a) * w;
            var ay = sin$1(a) * w;

            this._vSet(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);

            this._vSet(px, py, 0);
          }

          this._vSet(px + dlx * w, py + dly * w, 1);

          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _roundCapEnd: function _roundCapEnd(p, dx, dy, w, nCap) {
          var px = p.x;
          var py = p.y;
          var dlx = dy;
          var dly = -dx;

          this._vSet(px + dlx * w, py + dly * w, 1);

          this._vSet(px - dlx * w, py - dly * w, -1);

          for (var _i8 = 0; _i8 < nCap; _i8++) {
            var a = _i8 / (nCap - 1) * PI$1;
            var ax = cos$1(a) * w;
            var ay = sin$1(a) * w;

            this._vSet(px, py, 0);

            this._vSet(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);
          }
        },
        _roundJoin: function _roundJoin(p0, p1, lw, rw, nCap) {
          var dlx0 = p0.dy;
          var dly0 = -p0.dx;
          var dlx1 = p1.dy;
          var dly1 = -p1.dx;
          var p1x = p1.x;
          var p1y = p1.y;

          if ((p1.flags & PointFlags.PT_LEFT) !== 0) {
            var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

            var lx0 = out[0];
            var ly0 = out[1];
            var lx1 = out[2];
            var ly1 = out[3];
            var a0 = atan2(-dly0, -dlx0);
            var a1 = atan2(-dly1, -dlx1);

            if (a1 > a0) {
              a1 -= PI$1 * 2;
            }

            this._vSet(lx0, ly0, 1);

            this._vSet(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);

            var n = clamp(ceil((a0 - a1) / PI$1) * nCap, 2, nCap);

            for (var _i9 = 0; _i9 < n; _i9++) {
              var u = _i9 / (n - 1);
              var a = a0 + u * (a1 - a0);
              var rx = p1x + cos$1(a) * rw;
              var ry = p1y + sin$1(a) * rw;

              this._vSet(p1x, p1y, 0);

              this._vSet(rx, ry, -1);
            }

            this._vSet(lx1, ly1, 1);

            this._vSet(p1x - dlx1 * rw, p1y - dly1 * rw, -1);
          } else {
            var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

            var rx0 = _out[0];
            var ry0 = _out[1];
            var rx1 = _out[2];
            var ry1 = _out[3];

            var _a = atan2(dly0, dlx0);

            var _a2 = atan2(dly1, dlx1);

            if (_a2 < _a) {
              _a2 += PI$1 * 2;
            }

            this._vSet(p1x + dlx0 * rw, p1y + dly0 * rw, 1);

            this._vSet(rx0, ry0, -1);

            var _n = clamp(ceil((_a2 - _a) / PI$1) * nCap, 2, nCap);

            for (var _i10 = 0; _i10 < _n; _i10++) {
              var _u = _i10 / (_n - 1);

              var _a3 = _a + _u * (_a2 - _a);

              var lx = p1x + cos$1(_a3) * lw;
              var ly = p1y + sin$1(_a3) * lw;

              this._vSet(lx, ly, 1);

              this._vSet(p1x, p1y, 0);
            }

            this._vSet(p1x + dlx1 * rw, p1y + dly1 * rw, 1);

            this._vSet(rx1, ry1, -1);
          }
        },
        _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
          var rx0 = 0;
          var ry0 = 0;
          var rx1 = 0;
          var ry1 = 0;
          var lx0 = 0;
          var ly0 = 0;
          var lx1 = 0;
          var ly1 = 0;
          var dlx0 = p0.dy;
          var dly0 = -p0.dx;
          var dlx1 = p1.dy;
          var dly1 = -p1.dx;

          if (p1.flags & PointFlags.PT_LEFT) {
            var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

            lx0 = out[0];
            ly0 = out[1];
            lx1 = out[2];
            ly1 = out[3];

            this._vSet(lx0, ly0, 1);

            this._vSet(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);

            this._vSet(lx1, ly1, 1);

            this._vSet(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);
          } else {
            var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

            rx0 = _out2[0];
            ry0 = _out2[1];
            rx1 = _out2[2];
            ry1 = _out2[3];

            this._vSet(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);

            this._vSet(rx0, ry0, -1);

            this._vSet(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);

            this._vSet(rx1, ry1, -1);
          }
        },
        _vSet: function _vSet(x, y, distance) {
          if (distance === void 0) {
            distance = 0;
          }

          if (!_renderData) {
            return;
          }

          var meshBuffer = _renderData;
          var dataOffset = meshBuffer.vertexStart * attrBytes;
          var vData = meshBuffer.vData;
          vData[dataOffset++] = x;
          vData[dataOffset++] = y;
          vData[dataOffset++] = 0;
          Color.toArray(vData, _curColor, dataOffset);
          dataOffset += 4;
          vData[dataOffset++] = distance;
          meshBuffer.vertexStart++;
        }
      };

      var graphicsAssemblerManager = exports('graphicsAssembler', {
        getAssembler: function getAssembler(sprite) {
          return graphicsAssembler;
        }
      });
      Graphics.Assembler = graphicsAssemblerManager;

      var LetterInfo = function LetterInfo() {
        this["char"] = '';
        this.valid = true;
        this.x = 0;
        this.y = 0;
        this.line = 0;
        this.hash = '';
      };

      var _tmpRect = new Rect();

      var _defaultLetterAtlas = new LetterAtlas(64, 64);

      var _defaultFontAtlas = new FontAtlas(null);

      var _comp = null;
      var _uiTrans = null;
      var _horizontalKerning = [];
      var _lettersInfo = [];
      var _linesWidth = [];
      var _linesOffsetX = [];

      var _labelDimensions = new Size();

      var _contentSize = new Size();

      var letterPosition = new Vec2();
      var _lineSpacing = 0;
      var _fntConfig = null;
      var _numberOfLines = 0;
      var _textDesiredHeight = 0;
      var _letterOffsetY = 0;
      var _tailoredTopY = 0;
      var _tailoredBottomY = 0;
      var _bmfontScale = 1.0;
      var _spriteFrame = null;
      var _string = '';
      var _fontSize = 0;
      var _originFontSize = 0;
      var _hAlign = 0;
      var _vAlign = 0;
      var _spacingX = 0;
      var _lineHeight = 0;
      var _overflow = 0;
      var _isWrapText = false;
      var _labelWidth = 0;
      var _labelHeight = 0;
      var _maxLineWidth = 0;
      var QUAD_INDICES;
      var bmfontUtils = {
        updateRenderData: function updateRenderData(comp) {
          if (!comp.renderData) {
            return;
          }

          if (_comp === comp) {
            return;
          }

          if (comp.renderData.vertDirty) {
            _comp = comp;
            _uiTrans = _comp.node._uiProps.uiTransformComp;

            this._updateFontFamily(comp);

            this._updateProperties(comp);

            this._updateLabelInfo(comp);

            this._updateContent();

            _comp.actualFontSize = _fontSize;

            _uiTrans.setContentSize(_contentSize);

            this.updateUVs(comp);
            this.updateColor(comp);
            _comp.renderData.vertDirty = false;
            _comp = null;

            this._resetProperties();
          }

          if (comp.spriteFrame) {
            var renderData = comp.renderData;
            renderData.updateRenderData(comp, comp.spriteFrame);
          }
        },
        updateUVs: function updateUVs(label) {
          var renderData = label.renderData;
          var vData = renderData.chunk.vb;
          var vertexCount = renderData.vertexCount;
          var dataList = renderData.data;
          var vertexOffset = 3;

          for (var i = 0; i < vertexCount; i++) {
            var vert = dataList[i];
            vData[vertexOffset] = vert.u;
            vData[vertexOffset + 1] = vert.v;
            vertexOffset += 9;
          }
        },
        updateColor: function updateColor(label) {
        },
        _updateFontScale: function _updateFontScale() {
          _bmfontScale = _fontSize / _originFontSize;
        },
        _updateFontFamily: function _updateFontFamily(comp) {
          var fontAsset = comp.font;
          _spriteFrame = fontAsset.spriteFrame;
          _fntConfig = fontAsset.fntConfig;
          shareLabelInfo.fontAtlas = fontAsset.fontDefDictionary;

          if (!shareLabelInfo.fontAtlas) {
            if (comp.cacheMode === CacheMode.CHAR) {
              shareLabelInfo.fontAtlas = _defaultLetterAtlas;
            } else {
              shareLabelInfo.fontAtlas = _defaultFontAtlas;
            }
          }

          dynamicAtlasManager.packToDynamicAtlas(comp, _spriteFrame);
        },
        _updateLabelInfo: function _updateLabelInfo(comp) {
          shareLabelInfo.hash = '';
          shareLabelInfo.margin = 0;
        },
        _updateProperties: function _updateProperties(comp) {
          _string = comp.string.toString();
          _fontSize = comp.fontSize;
          _originFontSize = _fntConfig ? _fntConfig.fontSize : comp.fontSize;
          _hAlign = comp.horizontalAlign;
          _vAlign = comp.verticalAlign;
          _spacingX = comp.spacingX;
          _overflow = comp.overflow;
          _lineHeight = comp._lineHeight;
          var contentSize = _uiTrans.contentSize;
          _contentSize.width = contentSize.width;
          _contentSize.height = contentSize.height;

          if (_overflow === Overflow.NONE) {
            _isWrapText = false;
            _contentSize.width += shareLabelInfo.margin * 2;
            _contentSize.height += shareLabelInfo.margin * 2;
          } else if (_overflow === Overflow.RESIZE_HEIGHT) {
            _isWrapText = true;
            _contentSize.height += shareLabelInfo.margin * 2;
          } else {
            _isWrapText = comp.enableWrapText;
          }

          shareLabelInfo.lineHeight = _lineHeight;
          shareLabelInfo.fontSize = _fontSize;

          this._setupBMFontOverflowMetrics();
        },
        _resetProperties: function _resetProperties() {
          _fntConfig = null;
          _spriteFrame = null;
          shareLabelInfo.hash = '';
          shareLabelInfo.margin = 0;
        },
        _updateContent: function _updateContent() {
          this._updateFontScale();

          this._computeHorizontalKerningForText();

          this._alignText();
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
          var string = _string;
          var stringLen = string.length;
          var kerningDict = _fntConfig.kerningDict;
          var horizontalKerning = _horizontalKerning;

          if (!kerningDict) {
            return;
          }

          var prev = -1;

          for (var i = 0; i < stringLen; ++i) {
            var key = string.charCodeAt(i);
            var kerningAmount = kerningDict[prev << 16 | key & 0xffff] || 0;

            if (i < stringLen - 1) {
              horizontalKerning[i] = kerningAmount;
            } else {
              horizontalKerning[i] = 0;
            }

            prev = key;
          }
        },
        _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
          var textLen = _string.length;
          var lineIndex = 0;
          var nextTokenX = 0;
          var nextTokenY = 0;
          var longestLine = 0;
          var letterRight = 0;
          var highestY = 0;
          var lowestY = 0;
          var letterDef = null;

          for (var index = 0; index < textLen;) {
            var character = _string.charAt(index);

            if (character === '\n') {
              _linesWidth.push(letterRight);

              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;

              this._recordPlaceholderInfo(index, character);

              index++;
              continue;
            }

            var tokenLen = nextTokenFunc(_string, index, textLen);
            var tokenHighestY = highestY;
            var tokenLowestY = lowestY;
            var tokenRight = letterRight;
            var nextLetterX = nextTokenX;
            var newLine = false;

            for (var tmp = 0; tmp < tokenLen; ++tmp) {
              var letterIndex = index + tmp;
              character = _string.charAt(letterIndex);

              if (character === '\r') {
                this._recordPlaceholderInfo(letterIndex, character);

                continue;
              }

              letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

              if (!letterDef) {
                this._recordPlaceholderInfo(letterIndex, character);

                console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character);
                continue;
              }

              var letterX = nextLetterX + letterDef.offsetX * _bmfontScale - shareLabelInfo.margin;

              if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                _linesWidth.push(letterRight);

                letterRight = 0;
                lineIndex++;
                nextTokenX = 0;
                nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;
                newLine = true;
                break;
              } else {
                letterPosition.x = letterX;
              }

              letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale;

              this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);

              if (letterIndex + 1 < _horizontalKerning.length && letterIndex < textLen - 1) {
                nextLetterX += _horizontalKerning[letterIndex + 1];
              }

              nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;
              tokenRight = letterPosition.x + letterDef.w * _bmfontScale;

              if (tokenHighestY < letterPosition.y) {
                tokenHighestY = letterPosition.y;
              }

              if (tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale) {
                tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale;
              }
            }

            if (newLine) {
              continue;
            }

            nextTokenX = nextLetterX;
            letterRight = tokenRight;

            if (highestY < tokenHighestY) {
              highestY = tokenHighestY;
            }

            if (lowestY > tokenLowestY) {
              lowestY = tokenLowestY;
            }

            if (longestLine < letterRight) {
              longestLine = letterRight;
            }

            index += tokenLen;
          }

          _linesWidth.push(letterRight);

          _numberOfLines = lineIndex + 1;
          _textDesiredHeight = _numberOfLines * _lineHeight * this._getFontScale();

          if (_numberOfLines > 1) {
            _textDesiredHeight += (_numberOfLines - 1) * _lineSpacing;
          }

          _contentSize.width = _labelWidth;
          _contentSize.height = _labelHeight;

          if (_labelWidth <= 0) {
            _contentSize.width = parseFloat(longestLine.toFixed(2)) + shareLabelInfo.margin * 2;
          }

          if (_labelHeight <= 0) {
            _contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)) + shareLabelInfo.margin * 2;
          }

          _tailoredTopY = _contentSize.height;
          _tailoredBottomY = 0;

          if (highestY > 0) {
            _tailoredTopY = _contentSize.height + highestY;
          }

          if (lowestY < -_textDesiredHeight) {
            _tailoredBottomY = _textDesiredHeight + lowestY;
          }

          return true;
        },
        _getFirstCharLen: function _getFirstCharLen() {
          return 1;
        },
        _getFontScale: function _getFontScale() {
          return _overflow === Overflow.SHRINK ? _bmfontScale : 1;
        },
        _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
          var character = text.charAt(startIndex);

          if (isUnicodeCJK(character) || character === '\n' || isUnicodeSpace(character)) {
            return 1;
          }

          var len = 1;
          var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

          if (!letterDef) {
            return len;
          }

          var nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX;
          var letterX = 0;

          for (var index = startIndex + 1; index < textLen; ++index) {
            character = text.charAt(index);
            letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

            if (!letterDef) {
              break;
            }

            letterX = nextLetterX + letterDef.offsetX * _bmfontScale;

            if (letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && _maxLineWidth > 0) {
              return len;
            }

            nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;

            if (character === '\n' || isUnicodeSpace(character) || isUnicodeCJK(character)) {
              break;
            }

            len++;
          }

          return len;
        },
        _multilineTextWrapByWord: function _multilineTextWrapByWord() {
          return this._multilineTextWrap(this._getFirstWordLen);
        },
        _multilineTextWrapByChar: function _multilineTextWrapByChar() {
          return this._multilineTextWrap(this._getFirstCharLen);
        },
        _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char) {
          if (letterIndex >= _lettersInfo.length) {
            var tmpInfo = new LetterInfo();

            _lettersInfo.push(tmpInfo);
          }

          _lettersInfo[letterIndex]["char"] = _char;
          _lettersInfo[letterIndex].hash = "" + _char.charCodeAt(0) + shareLabelInfo.hash;
          _lettersInfo[letterIndex].valid = false;
        },
        _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
          if (letterIndex >= _lettersInfo.length) {
            var tmpInfo = new LetterInfo();

            _lettersInfo.push(tmpInfo);
          }

          var _char2 = character.charCodeAt(0);

          var key = "" + _char2 + shareLabelInfo.hash;
          _lettersInfo[letterIndex].line = lineIndex;
          _lettersInfo[letterIndex]["char"] = character;
          _lettersInfo[letterIndex].hash = key;
          _lettersInfo[letterIndex].valid = shareLabelInfo.fontAtlas.getLetter(key).valid;
          _lettersInfo[letterIndex].x = letterPosition.x;
          _lettersInfo[letterIndex].y = letterPosition.y;
        },
        _alignText: function _alignText() {
          _textDesiredHeight = 0;
          _linesWidth.length = 0;

          {
            this._multilineTextWrapByWord();
          }

          this._computeAlignmentOffset();

          if (_overflow === Overflow.SHRINK) {
            if (_fontSize > 0 && this._isVerticalClamp()) {
              this._shrinkLabelToContentSize(this._isVerticalClamp);
            }
          }

          if (!this._updateQuads()) {
            if (_overflow === Overflow.SHRINK) {
              this._shrinkLabelToContentSize(this._isHorizontalClamp);
            }
          }
        },
        _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
          var shouldUpdateContent = true;

          if (!fontSize) {
            fontSize = 0.1;
            shouldUpdateContent = false;
          }

          _fontSize = fontSize;

          if (shouldUpdateContent) {
            this._updateContent();
          }
        },
        _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
          var fontSize = _fontSize;
          var left = 0;
          var right = fontSize | 0;
          var mid = 0;

          while (left < right) {
            mid = left + right + 1 >> 1;
            var newFontSize = mid;

            if (newFontSize <= 0) {
              break;
            }

            _bmfontScale = newFontSize / _originFontSize;

            {
              this._multilineTextWrapByWord();
            }

            this._computeAlignmentOffset();

            if (lambda()) {
              right = mid - 1;
            } else {
              left = mid;
            }
          }

          if (left >= 0) {
            this._scaleFontSizeDown(left);
          }
        },
        _isVerticalClamp: function _isVerticalClamp() {
          if (_textDesiredHeight > _contentSize.height) {
            return true;
          } else {
            return false;
          }
        },
        _isHorizontalClamp: function _isHorizontalClamp() {
          var letterClamp = false;

          for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
            var letterInfo = _lettersInfo[ctr];

            if (letterInfo.valid) {
              var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(letterInfo["char"], shareLabelInfo);

              if (!letterDef) {
                continue;
              }

              var px = letterInfo.x + letterDef.w * _bmfontScale;
              var lineIndex = letterInfo.line;

              if (_labelWidth > 0) {
                if (!_isWrapText) {
                  if (px > _contentSize.width) {
                    letterClamp = true;
                    break;
                  }
                } else {
                  var wordWidth = _linesWidth[lineIndex];

                  if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                    letterClamp = true;
                    break;
                  }
                }
              }
            }
          }

          return letterClamp;
        },
        _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
          var wordWidth = _linesWidth[lineIndex];
          var letterOverClamp = px > _contentSize.width || px < 0;

          if (!_isWrapText) {
            return letterOverClamp;
          } else {
            return wordWidth > _contentSize.width && letterOverClamp;
          }
        },
        _updateQuads: function _updateQuads() {
          if (!_comp) {
            return false;
          }

          var texture = _spriteFrame ? _spriteFrame.texture : shareLabelInfo.fontAtlas.getTexture();
          var renderData = _comp.renderData;
          renderData.dataLength = 0;
          renderData.resize(0, 0);
          var anchorPoint = _uiTrans.anchorPoint;
          var contentSize = _contentSize;
          var appX = anchorPoint.x * contentSize.width;
          var appY = anchorPoint.y * contentSize.height;
          var ret = true;

          for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
            var letterInfo = _lettersInfo[ctr];

            if (!letterInfo.valid) {
              continue;
            }

            var letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);

            if (!letterDef) {
              console.warn('Can\'t find letter in this bitmap-font');
              continue;
            }

            _tmpRect.height = letterDef.h;
            _tmpRect.width = letterDef.w;
            _tmpRect.x = letterDef.u;
            _tmpRect.y = letterDef.v;
            var py = letterInfo.y + _letterOffsetY;

            if (_labelHeight > 0) {
              if (py > _tailoredTopY) {
                var clipTop = py - _tailoredTopY;
                _tmpRect.y += clipTop;
                _tmpRect.height -= clipTop;
                py -= clipTop;
              }

              if (py - _tmpRect.height * _bmfontScale < _tailoredBottomY && _overflow === Overflow.CLAMP) {
                _tmpRect.height = py < _tailoredBottomY ? 0 : (py - _tailoredBottomY) / _bmfontScale;
              }
            }

            var lineIndex = letterInfo.line;
            var px = letterInfo.x + letterDef.w / 2 * _bmfontScale + _linesOffsetX[lineIndex];

            if (_labelWidth > 0) {
              if (this._isHorizontalClamped(px, lineIndex)) {
                if (_overflow === Overflow.CLAMP) {
                  _tmpRect.width = 0;
                } else if (_overflow === Overflow.SHRINK) {
                  if (_contentSize.width > letterDef.w) {
                    ret = false;
                    break;
                  } else {
                    _tmpRect.width = 0;
                  }
                }
              }
            }

            if (_tmpRect.height > 0 && _tmpRect.width > 0) {
              var isRotated = this._determineRect();

              var letterPositionX = letterInfo.x + _linesOffsetX[letterInfo.line];
              this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appX, py - appY, _bmfontScale);
            }
          }

          var indexCount = renderData.indexCount;
          this.createQuadIndices(indexCount);
          renderData.chunk.setIndexBuffer(QUAD_INDICES);
          return ret;
        },
        createQuadIndices: function createQuadIndices(indexCount) {
          if (indexCount % 6 !== 0) {
            console.error('illegal index count!');
            return;
          }

          var quadCount = indexCount / 6;
          QUAD_INDICES = null;
          QUAD_INDICES = new Uint16Array(indexCount);
          var offset = 0;

          for (var i = 0; i < quadCount; i++) {
            QUAD_INDICES[offset++] = 0 + i * 4;
            QUAD_INDICES[offset++] = 1 + i * 4;
            QUAD_INDICES[offset++] = 2 + i * 4;
            QUAD_INDICES[offset++] = 1 + i * 4;
            QUAD_INDICES[offset++] = 3 + i * 4;
            QUAD_INDICES[offset++] = 2 + i * 4;
          }
        },
        appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {},
        _determineRect: function _determineRect() {
          var isRotated = _spriteFrame.isRotated();

          var originalSize = _spriteFrame.getOriginalSize();

          var rect = _spriteFrame.getRect();

          var offset = _spriteFrame.getOffset();

          var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
          var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;

          if (!isRotated) {
            _tmpRect.x += rect.x - trimmedLeft;
            _tmpRect.y += rect.y + trimmedTop;
          } else {
            var originalX = _tmpRect.x;
            _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop;
            _tmpRect.y = originalX + rect.y - trimmedLeft;

            if (_tmpRect.y < 0) {
              _tmpRect.height += trimmedTop;
            }
          }

          return isRotated;
        },
        _computeAlignmentOffset: function _computeAlignmentOffset() {
          _linesOffsetX.length = 0;

          switch (_hAlign) {
            case HorizontalTextAlignment.LEFT:
              for (var i = 0; i < _numberOfLines; ++i) {
                _linesOffsetX.push(0);
              }

              break;

            case HorizontalTextAlignment.CENTER:
              for (var _i = 0, l = _linesWidth.length; _i < l; _i++) {
                _linesOffsetX.push((_contentSize.width - _linesWidth[_i]) / 2);
              }

              break;

            case HorizontalTextAlignment.RIGHT:
              for (var _i2 = 0, _l = _linesWidth.length; _i2 < _l; _i2++) {
                _linesOffsetX.push(_contentSize.width - _linesWidth[_i2]);
              }

              break;
          }

          _letterOffsetY = _contentSize.height;

          if (_vAlign !== VerticalTextAlignment.TOP) {
            var blank = _contentSize.height - _textDesiredHeight + _lineHeight * this._getFontScale() - _originFontSize * _bmfontScale;

            if (_vAlign === VerticalTextAlignment.BOTTOM) {
              _letterOffsetY -= blank;
            } else {
              _letterOffsetY -= blank / 2;
            }
          }
        },
        _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
          var newWidth = _contentSize.width;
          var newHeight = _contentSize.height;

          if (_overflow === Overflow.RESIZE_HEIGHT) {
            newHeight = 0;
          }

          if (_overflow === Overflow.NONE) {
            newWidth = 0;
            newHeight = 0;
          }

          _labelWidth = newWidth;
          _labelHeight = newHeight;
          _labelDimensions.width = newWidth;
          _labelDimensions.height = newHeight;
          _maxLineWidth = newWidth;
        }
      };

      var tempColor$1 = new Color(255, 255, 255, 255);
      var bmfont = {
        createData: function createData(comp) {
          return comp.requestRenderData();
        },
        fillBuffers: function fillBuffers(comp, renderer) {
          var node = comp.node;
          tempColor$1.set(comp.color);
          tempColor$1.a = node._uiProps.opacity * 255;
          fillMeshVertices3D(node, renderer, comp.renderData, tempColor$1);
        },
        appendQuad: function appendQuad(comp, spriteFrame, rect, rotated, x, y, scale) {
          var renderData = comp.renderData;

          if (!renderData) {
            return;
          }

          var dataOffset = renderData.dataLength;
          renderData.dataLength += 4;
          renderData.resize(renderData.dataLength, renderData.dataLength / 2 * 3);
          var dataList = renderData.data;
          var texW = spriteFrame.width;
          var texH = spriteFrame.height;
          var rectWidth = rect.width;
          var rectHeight = rect.height;
          var l = 0;
          var b = 0;
          var t = 0;
          var r = 0;

          if (!rotated) {
            l = rect.x / texW;
            r = (rect.x + rectWidth) / texW;
            b = (rect.y + rectHeight) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = b;
            dataList[dataOffset + 1].u = r;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = l;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = t;
          } else {
            l = rect.x / texW;
            r = (rect.x + rectHeight) / texW;
            b = (rect.y + rectWidth) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = t;
            dataList[dataOffset + 1].u = l;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = r;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = b;
          }

          dataList[dataOffset].x = x;
          dataList[dataOffset].y = y - rectHeight * scale;
          dataList[dataOffset + 1].x = x + rectWidth * scale;
          dataList[dataOffset + 1].y = y - rectHeight * scale;
          dataList[dataOffset + 2].x = x;
          dataList[dataOffset + 2].y = y;
          dataList[dataOffset + 3].x = x + rectWidth * scale;
          dataList[dataOffset + 3].y = y;
        }
      };
      addon(bmfont, bmfontUtils);

      var _atlasWidth = 1024;
      var _atlasHeight = 1024;
      var _shareAtlas = null;
      var letterFont = mixin(bmfontUtils, {
        getAssemblerData: function getAssemblerData() {
          if (!_shareAtlas) {
            _shareAtlas = new LetterAtlas(_atlasWidth, _atlasHeight);
          }

          return _shareAtlas.getTexture();
        },
        _updateFontFamily: function _updateFontFamily(comp) {
          shareLabelInfo.fontAtlas = _shareAtlas;
          shareLabelInfo.fontFamily = this._getFontFamily(comp);
          var outline = comp.getComponent(LabelOutline);

          if (outline && outline.enabled) {
            shareLabelInfo.isOutlined = true;
            shareLabelInfo.margin = outline.width;
            shareLabelInfo.out = outline.color.clone();
            shareLabelInfo.out.a = outline.color.a * comp.color.a / 255.0;
          } else {
            shareLabelInfo.isOutlined = false;
            shareLabelInfo.margin = 0;
          }
        },
        _getFontFamily: function _getFontFamily(comp) {
          var fontFamily = 'Arial';

          if (!comp.useSystemFont) {
            if (comp.font) {
              fontFamily = comp.font._nativeAsset || 'Arial';
            }
          } else {
            fontFamily = comp.fontFamily || 'Arial';
          }

          return fontFamily;
        },
        _updateLabelInfo: function _updateLabelInfo(comp) {
          shareLabelInfo.fontDesc = this._getFontDesc();
          shareLabelInfo.color = comp.color;
          shareLabelInfo.hash = computeHash(shareLabelInfo);
        },
        _getFontDesc: function _getFontDesc() {
          var fontDesc = shareLabelInfo.fontSize.toString() + "px ";
          fontDesc += shareLabelInfo.fontFamily;

          return fontDesc;
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
        _determineRect: function _determineRect(tempRect) {
          return false;
        }
      });

      var tempColor$2 = new Color(255, 255, 255, 255);
      var letter = {
        createData: function createData(comp) {
          return comp.requestRenderData();
        },
        fillBuffers: function fillBuffers(comp, renderer) {
          if (!comp.renderData) {
            return;
          }

          var node = comp.node;
          tempColor$2.a = node._uiProps.opacity * 255;
          fillMeshVertices3D(node, renderer, comp.renderData, tempColor$2);
        },
        appendQuad: bmfont.appendQuad
      };
      addon(letter, letterFont);

      var Overflow$1 = Label.Overflow;
      var MAX_SIZE = 2048;

      var _BASELINE_OFFSET$1 = getBaselineOffset();

      var _invisibleAlpha = (1 / 255).toFixed(3);

      var _context = null;
      var _canvas = null;
      var _texture = null;
      var _fontDesc = '';
      var _string$1 = '';
      var _fontSize$1 = 0;
      var _drawFontsize = 0;
      var _splitStrings = [];

      var _canvasSize = new Size();

      var _lineHeight$1 = 0;
      var _hAlign$1 = 0;
      var _vAlign$1 = 0;

      var _color = new Color();

      var _alpha = 1;
      var _fontFamily = '';
      var _overflow$1 = Overflow$1.NONE;
      var _isWrapText$1 = false;
      var _outlineComp = null;

      var _outlineColor = Color.BLACK.clone();

      var _shadowComp = null;

      var _shadowColor = Color.BLACK.clone();

      var _canvasPadding = new Rect();

      var _contentSizeExtend = Size.ZERO.clone();

      var _nodeContentSize = Size.ZERO.clone();

      var _startPosition = Vec2.ZERO.clone();

      var _drawUnderlinePos = Vec2.ZERO.clone();

      var _drawUnderlineWidth = 0;
      var _underlineThickness = 0;
      var _isBold = false;
      var _isItalic = false;
      var _isUnderline = false;
      var Alignment = ['left', 'center', 'right'];
      var ttfUtils = {
        getAssemblerData: function getAssemblerData() {
          var sharedLabelData = Label._canvasPool.get();

          return sharedLabelData;
        },
        resetAssemblerData: function resetAssemblerData(assemblerData) {
          if (assemblerData) {
            Label._canvasPool.put(assemblerData);
          }
        },
        updateRenderData: function updateRenderData(comp) {
          if (!comp.renderData) {
            return;
          }

          if (comp.renderData.vertDirty) {
            var trans = comp.node._uiProps.uiTransformComp;

            this._updateFontFamily(comp);

            this._updateProperties(comp, trans);

            this._calculateLabelFont();

            this._updateLabelDimensions();

            this._updateTexture(comp);

            this._calDynamicAtlas(comp);

            comp.actualFontSize = _fontSize$1;
            trans.setContentSize(_canvasSize);
            this.updateVertexData(comp);
            this.updateUVs(comp);
            comp.renderData.vertDirty = false;
            comp.contentWidth = _nodeContentSize.width;
            _context = null;
            _canvas = null;
            _texture = null;
          }

          if (comp.spriteFrame) {
            var renderData = comp.renderData;
            renderData.updateRenderData(comp, comp.spriteFrame);
          }
        },
        updateVertexData: function updateVertexData(comp) {},
        updateUVs: function updateUVs(comp) {},
        _updateFontFamily: function _updateFontFamily(comp) {
          if (!comp.useSystemFont) {
            if (comp.font) {
              _fontFamily = comp.font._nativeAsset || 'Arial';
            } else {
              _fontFamily = 'Arial';
            }
          } else {
            _fontFamily = comp.fontFamily || 'Arial';
          }
        },
        _updateProperties: function _updateProperties(comp, trans) {
          var assemblerData = comp.assemblerData;

          if (!assemblerData) {
            return;
          }

          _context = assemblerData.context;
          _canvas = assemblerData.canvas;
          _texture = comp.spriteFrame;
          _string$1 = comp.string.toString();
          _fontSize$1 = comp.fontSize;
          _drawFontsize = _fontSize$1;
          _overflow$1 = comp.overflow;
          _nodeContentSize.width = _canvasSize.width = trans.width;
          _nodeContentSize.height = _canvasSize.height = trans.height;
          _underlineThickness = comp.underlineHeight;
          _lineHeight$1 = comp.lineHeight;
          _hAlign$1 = comp.horizontalAlign;
          _vAlign$1 = comp.verticalAlign;
          _color = comp.color;
          _alpha = comp.node._uiProps.opacity;
          _isBold = comp.isBold;
          _isItalic = comp.isItalic;
          _isUnderline = comp.isUnderline;

          if (_overflow$1 === Overflow$1.NONE) {
            _isWrapText$1 = false;
          } else if (_overflow$1 === Overflow$1.RESIZE_HEIGHT) {
            _isWrapText$1 = true;
          } else {
            _isWrapText$1 = comp.enableWrapText;
          }

          _outlineComp = LabelOutline && comp.getComponent(LabelOutline);
          _outlineComp = _outlineComp && _outlineComp.enabled && _outlineComp.width > 0 ? _outlineComp : null;

          if (_outlineComp) {
            _outlineColor.set(_outlineComp.color);
          }

          _shadowComp = LabelShadow && comp.getComponent(LabelShadow);
          _shadowComp = _shadowComp && _shadowComp.enabled ? _shadowComp : null;

          if (_shadowComp) {
            _shadowColor.set(_shadowComp.color);
          }

          this._updatePaddingRect();
        },
        _updatePaddingRect: function _updatePaddingRect() {
          var top = 0;
          var bottom = 0;
          var left = 0;
          var right = 0;
          var outlineWidth = 0;
          _contentSizeExtend.width = _contentSizeExtend.height = 0;

          if (_outlineComp) {
            outlineWidth = _outlineComp.width;
            top = bottom = left = right = outlineWidth;
            _contentSizeExtend.width = _contentSizeExtend.height = outlineWidth * 2;
          }

          if (_shadowComp) {
            var shadowWidth = _shadowComp.blur + outlineWidth;
            var offsetX = _shadowComp.offset.x;
            var offsetY = _shadowComp.offset.y;
            left = Math.max(left, -offsetX + shadowWidth);
            right = Math.max(right, offsetX + shadowWidth);
            top = Math.max(top, offsetY + shadowWidth);
            bottom = Math.max(bottom, -offsetY + shadowWidth);
          }

          if (_isItalic) {
            var offset = _drawFontsize * Math.tan(12 * 0.0174532925);

            right += offset;
            _contentSizeExtend.width += offset;
          }

          _canvasPadding.x = left;
          _canvasPadding.y = top;
          _canvasPadding.width = left + right;
          _canvasPadding.height = top + bottom;
        },
        _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
          var labelX = 0;

          if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
            labelX = _canvasSize.width - _canvasPadding.width;
          } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
            labelX = (_canvasSize.width - _canvasPadding.width) / 2;
          }

          var lineHeight = this._getLineHeight();

          var drawStartY = lineHeight * (_splitStrings.length - 1);
          var firstLinelabelY = _fontSize$1 * (1 - BASELINE_RATIO / 2);

          if (_vAlign$1 !== VerticalTextAlignment.TOP) {
            var blank = drawStartY + _canvasPadding.height + _fontSize$1 - _canvasSize.height;

            if (_vAlign$1 === VerticalTextAlignment.BOTTOM) {
              blank += BASELINE_RATIO / 2 * _fontSize$1;
              firstLinelabelY -= blank;
            } else {
              firstLinelabelY -= blank / 2;
            }
          }

          firstLinelabelY += _BASELINE_OFFSET$1 * _fontSize$1;

          _startPosition.set(labelX + _canvasPadding.x, firstLinelabelY + _canvasPadding.y);
        },
        _updateTexture: function _updateTexture(comp) {
          if (!_context || !_canvas) {
            return;
          }

          _context.clearRect(0, 0, _canvas.width, _canvas.height);

          _context.font = _fontDesc;

          this._calculateFillTextStartPosition();

          var lineHeight = this._getLineHeight();

          _context.lineJoin = 'round';

          if (_outlineComp) {
            _context.fillStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _invisibleAlpha + ")";

            _context.fillRect(0, 0, _canvas.width, _canvas.height);
          } else if (comp._srcBlendFactor === BlendFactor.SRC_ALPHA) {
            _context.fillStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", " + _invisibleAlpha + ")";

            _context.fillRect(0, 0, _canvas.width, _canvas.height);
          }

          _context.fillStyle = "rgb(" + _color.r + ", " + _color.g + ", " + _color.b + ")";
          var drawTextPosX = _startPosition.x;
          var drawTextPosY = 0;

          this._drawTextEffect(_startPosition, lineHeight);

          for (var i = 0; i < _splitStrings.length; ++i) {
            drawTextPosY = _startPosition.y + i * lineHeight;

            if (_outlineComp) {
              _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
            }

            _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
          }

          if (_shadowComp) {
            _context.shadowColor = 'transparent';
          }

          this._uploadTexture(comp);
        },
        _uploadTexture: function _uploadTexture(comp) {
          if (comp.cacheMode === Label.CacheMode.BITMAP) {
            var frame = comp.ttfSpriteFrame;
            dynamicAtlasManager.deleteAtlasSpriteFrame(frame);

            frame._resetDynamicAtlasFrame();
          }

          if (_texture && _canvas) {
            var tex;

            if (_texture instanceof SpriteFrame) {
              tex = _texture.texture;
            } else {
              tex = _texture;
            }

            var uploadAgain = _canvas.width !== 0 && _canvas.height !== 0;

            if (uploadAgain) {
              tex.reset({
                width: _canvas.width,
                height: _canvas.height,
                mipmapLevel: 1
              });
              tex.uploadData(_canvas);
              tex.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);

              if (_texture instanceof SpriteFrame) {
                _texture.rect = new Rect(0, 0, _canvas.width, _canvas.height);

                _texture._calculateUV();
              }

              if (comp.renderData) {
                comp.renderData.textureDirty = true;
              }

              if (legacyCC.director.root && legacyCC.director.root.batcher2D) {
                {
                  legacyCC.director.root.batcher2D._releaseDescriptorSetCache(tex.getHash());
                }
              }
            }
          }
        },
        _calDynamicAtlas: function _calDynamicAtlas(comp) {
          if (comp.cacheMode !== Label.CacheMode.BITMAP || !_canvas || _canvas.width <= 0 || _canvas.height <= 0) return;
          var frame = comp.ttfSpriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(comp, frame);
        },
        _setupOutline: function _setupOutline() {
          _context.strokeStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _outlineColor.a / 255 + ")";
          _context.lineWidth = _outlineComp.width * 2;
        },
        _setupShadow: function _setupShadow() {
          _context.shadowColor = "rgba(" + _shadowColor.r + ", " + _shadowColor.g + ", " + _shadowColor.b + ", " + _shadowColor.a / 255 + ")";
          _context.shadowBlur = _shadowComp.blur;
          _context.shadowOffsetX = _shadowComp.offset.x;
          _context.shadowOffsetY = -_shadowComp.offset.y;
        },
        _drawTextEffect: function _drawTextEffect(startPosition, lineHeight) {
          if (!_shadowComp && !_outlineComp && !_isUnderline) return;
          var isMultiple = _splitStrings.length > 1 && _shadowComp;

          var measureText = this._measureText(_context, _fontDesc);

          var drawTextPosX = 0;
          var drawTextPosY = 0;

          if (_shadowComp) {
            this._setupShadow();
          }

          if (_outlineComp) {
            this._setupOutline();
          }

          for (var i = 0; i < _splitStrings.length; ++i) {
            drawTextPosX = startPosition.x;
            drawTextPosY = startPosition.y + i * lineHeight;

            if (isMultiple) {
              if (_outlineComp) {
                _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
              }

              _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
            }

            if (_isUnderline) {
              _drawUnderlineWidth = measureText(_splitStrings[i]);

              if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
                _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth;
              } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
                _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2;
              } else {
                _drawUnderlinePos.x = startPosition.x;
              }

              _drawUnderlinePos.y = drawTextPosY + _drawFontsize / 8;

              _context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, _drawUnderlineWidth, _underlineThickness);
            }
          }

          if (isMultiple) {
            _context.shadowColor = 'transparent';
          }
        },
        _updateLabelDimensions: function _updateLabelDimensions() {
          _canvasSize.width = Math.min(_canvasSize.width, MAX_SIZE);
          _canvasSize.height = Math.min(_canvasSize.height, MAX_SIZE);
          var recreate = false;

          if (_canvas.width !== _canvasSize.width) {
            _canvas.width = _canvasSize.width;
            recreate = true;
          }

          if (_canvas.height !== _canvasSize.height) {
            _canvas.height = _canvasSize.height;
            recreate = true;
          }

          if (recreate) _context.font = _fontDesc;
          _context.textAlign = Alignment[_hAlign$1];
          _context.textBaseline = 'alphabetic';
        },
        _getFontDesc: function _getFontDesc() {
          var fontDesc = _fontSize$1.toString() + "px ";
          fontDesc += _fontFamily;

          if (_isBold) {
            fontDesc = "bold " + fontDesc;
          }

          if (_isItalic) {
            fontDesc = "italic " + fontDesc;
          }

          return fontDesc;
        },
        _getLineHeight: function _getLineHeight() {
          var nodeSpacingY = _lineHeight$1;

          if (nodeSpacingY === 0) {
            nodeSpacingY = _fontSize$1;
          } else {
            nodeSpacingY = nodeSpacingY * _fontSize$1 / _drawFontsize;
          }

          return nodeSpacingY | 0;
        },
        _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
          var paragraphLength = [];

          for (var _iterator = _createForOfIteratorHelperLoose(paragraphedStrings), _step; !(_step = _iterator()).done;) {
            var para = _step.value;
            var width = safeMeasureText(ctx, para, _fontDesc);
            paragraphLength.push(width);
          }

          return paragraphLength;
        },
        _measureText: function _measureText(ctx, fontDesc) {
          return function (string) {
            return safeMeasureText(ctx, string, fontDesc);
          };
        },
        _calculateShrinkFont: function _calculateShrinkFont(paragraphedStrings) {
          if (!_context) return;

          var paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);

          var i = 0;
          var totalHeight = 0;
          var maxLength = 0;

          if (_isWrapText$1) {
            var canvasWidthNoMargin = _nodeContentSize.width;
            var canvasHeightNoMargin = _nodeContentSize.height;

            if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
              return;
            }

            totalHeight = canvasHeightNoMargin + 1;
            var actualFontSize = _fontSize$1 + 1;
            var textFragment = [];
            var left = 0;
            var right = actualFontSize | 0;
            var mid = 0;

            while (left < right) {
              mid = left + right + 1 >> 1;

              if (mid <= 0) {
                logID(4003);
                break;
              }

              _fontSize$1 = mid;
              _fontDesc = this._getFontDesc();
              _context.font = _fontDesc;

              var lineHeight = this._getLineHeight();

              totalHeight = 0;

              for (i = 0; i < paragraphedStrings.length; ++i) {
                var allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
                totalHeight += textFragment.length * lineHeight;
              }

              if (totalHeight > canvasHeightNoMargin) {
                right = mid - 1;
              } else {
                left = mid;
              }
            }

            if (left === 0) {
              logID(4003);
            } else {
              _fontSize$1 = left;
              _fontDesc = this._getFontDesc();
              _context.font = _fontDesc;
            }
          } else {
            totalHeight = paragraphedStrings.length * this._getLineHeight();

            for (i = 0; i < paragraphedStrings.length; ++i) {
              if (maxLength < paragraphLength[i]) {
                maxLength = paragraphLength[i];
              }
            }

            var scaleX = (_canvasSize.width - _canvasPadding.width) / maxLength;
            var scaleY = _canvasSize.height / totalHeight;
            _fontSize$1 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0;
            _fontDesc = this._getFontDesc();
            _context.font = _fontDesc;
          }
        },
        _calculateWrapText: function _calculateWrapText(paragraphedStrings) {
          if (!_isWrapText$1 || !_context) return;
          _splitStrings = [];
          var canvasWidthNoMargin = _nodeContentSize.width;

          for (var i = 0; i < paragraphedStrings.length; ++i) {
            var allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
            var textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
            _splitStrings = _splitStrings.concat(textFragment);
          }
        },
        _calculateLabelFont: function _calculateLabelFont() {
          if (!_context) {
            return;
          }

          var paragraphedStrings = _string$1.split('\n');

          _splitStrings = paragraphedStrings;
          _fontDesc = this._getFontDesc();
          _context.font = _fontDesc;

          switch (_overflow$1) {
            case Overflow$1.NONE:
              {
                var canvasSizeX = 0;
                var canvasSizeY = 0;

                for (var i = 0; i < paragraphedStrings.length; ++i) {
                  var paraLength = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                  canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                }

                canvasSizeY = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();
                var rawWidth = parseFloat(canvasSizeX.toFixed(2));
                var rawHeight = parseFloat(canvasSizeY.toFixed(2));
                _canvasSize.width = rawWidth + _canvasPadding.width;
                _canvasSize.height = rawHeight + _canvasPadding.height;
                _nodeContentSize.width = rawWidth + _contentSizeExtend.width;
                _nodeContentSize.height = rawHeight + _contentSizeExtend.height;
                break;
              }

            case Overflow$1.SHRINK:
              {
                this._calculateShrinkFont(paragraphedStrings);

                this._calculateWrapText(paragraphedStrings);

                break;
              }

            case Overflow$1.CLAMP:
              {
                this._calculateWrapText(paragraphedStrings);

                break;
              }

            case Overflow$1.RESIZE_HEIGHT:
              {
                this._calculateWrapText(paragraphedStrings);

                var _rawHeight = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();

                _canvasSize.height = _rawHeight + _canvasPadding.height;
                _nodeContentSize.height = _rawHeight + _contentSizeExtend.height;
                break;
              }
          }
        }
      };

      var WHITE$1 = Color.WHITE.clone();
      var QUAD_INDICES$1 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      var ttf = {
        createData: function createData(comp) {
          var renderData = comp.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          var vData = renderData.chunk.vb;
          vData[3] = vData[21] = vData[22] = vData[31] = 0;
          vData[4] = vData[12] = vData[13] = vData[30] = 1;
          var offset = 5;

          for (var i = 0; i < 4; i++) {
            Color.toArray(vData, WHITE$1, offset);
            offset += 9;
          }

          renderData.vertexRow = 2;
          renderData.vertexCol = 2;
          renderData.chunk.setIndexBuffer(QUAD_INDICES$1);
          return renderData;
        },
        fillBuffers: function fillBuffers(comp, renderer) {
          var renderData = comp.renderData;
          var chunk = renderData.chunk;
          var dataList = renderData.data;
          var node = comp.node;
          var vData = chunk.vb;
          var m = node.worldMatrix;
          var stride = renderData.floatStride;
          var offset = 0;
          var length = dataList.length;

          for (var i = 0; i < length; i++) {
            var curData = dataList[i];
            var x = curData.x;
            var y = curData.y;
            var rhw = m.m03 * x + m.m07 * y + m.m15;
            rhw = rhw ? Math.abs(1 / rhw) : 1;
            offset = i * stride;
            vData[offset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
            vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
            vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
          }

          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.meshBuffer;
          var ib = chunk.meshBuffer.iData;
          var indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateVertexData: function updateVertexData(comp) {
          var renderData = comp.renderData;

          if (!renderData) {
            return;
          }

          var uiTrans = comp.node._uiProps.uiTransformComp;
          var width = uiTrans.width;
          var height = uiTrans.height;
          var appX = uiTrans.anchorX * width;
          var appY = uiTrans.anchorY * height;
          var data = renderData.data;
          data[0].x = -appX;
          data[0].y = -appY;
          data[1].x = width - appX;
          data[1].y = -appY;
          data[2].x = -appX;
          data[2].y = height - appY;
          data[3].x = width - appX;
          data[3].y = height - appY;
        },
        updateUVs: function updateUVs(comp) {
          var renderData = comp.renderData;

          if (!renderData || !comp.ttfSpriteFrame) {
            return;
          }

          var vData = renderData.chunk.vb;
          var uv = comp.ttfSpriteFrame.uv;
          vData[3] = uv[0];
          vData[4] = uv[1];
          vData[12] = uv[2];
          vData[13] = uv[3];
          vData[21] = uv[4];
          vData[22] = uv[5];
          vData[30] = uv[6];
          vData[31] = uv[7];
        },
        updateColor: function updateColor(comp) {}
      };
      addon(ttf, ttfUtils);

      var labelAssembler = exports('labelAssembler', {
        getAssembler: function getAssembler(comp) {
          var assembler = ttf;

          if (comp.font instanceof BitmapFont) {
            assembler = bmfont;
          } else if (comp.cacheMode === Label.CacheMode.CHAR) {
            assembler = letter;
          }

          return assembler;
        }
      });
      Label.Assembler = labelAssembler;

      var FillType$1 = Sprite.FillType;
      var m$1 = new Mat4();
      var QUAD_INDICES$2 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      var barFilled = {
        updateRenderData: function updateRenderData(sprite) {
          var frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          var renderData = sprite.renderData;

          if (renderData && frame) {
            var vertDirty = renderData.vertDirty;

            if (!vertDirty) {
              return;
            }

            var fillStart = sprite.fillStart;
            var fillRange = sprite.fillRange;

            if (fillRange < 0) {
              fillStart += fillRange;
              fillRange = -fillRange;
            }

            fillRange = fillStart + fillRange;
            fillStart = fillStart > 1.0 ? 1.0 : fillStart;
            fillStart = fillStart < 0.0 ? 0.0 : fillStart;
            fillRange = fillRange > 1.0 ? 1.0 : fillRange;
            fillRange = fillRange < 0.0 ? 0.0 : fillRange;
            fillRange -= fillStart;
            fillRange = fillRange < 0 ? 0 : fillRange;
            var fillEnd = fillStart + fillRange;
            fillEnd = fillEnd > 1 ? 1 : fillEnd;
            this.updateUVs(sprite, fillStart, fillEnd);
            this.updateVertexData(sprite, fillStart, fillEnd);
            renderData.updateRenderData(sprite, frame);
          }
        },
        updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
          var spriteFrame = sprite.spriteFrame;
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var atlasWidth = spriteFrame.width;
          var atlasHeight = spriteFrame.height;
          var textureRect = spriteFrame.rect;
          var ul = 0;
          var vb = 0;
          var ur = 0;
          var vt = 0;
          var quadUV0 = 0;
          var quadUV1 = 0;
          var quadUV2 = 0;
          var quadUV3 = 0;
          var quadUV4 = 0;
          var quadUV5 = 0;
          var quadUV6 = 0;
          var quadUV7 = 0;

          if (spriteFrame.isRotated()) {
            ul = textureRect.x / atlasWidth;
            vb = (textureRect.y + textureRect.width) / atlasHeight;
            ur = (textureRect.x + textureRect.height) / atlasWidth;
            vt = textureRect.y / atlasHeight;
            quadUV0 = quadUV2 = ul;
            quadUV4 = quadUV6 = ur;
            quadUV3 = quadUV7 = vb;
            quadUV1 = quadUV5 = vt;
          } else {
            ul = textureRect.x / atlasWidth;
            vb = (textureRect.y + textureRect.height) / atlasHeight;
            ur = (textureRect.x + textureRect.width) / atlasWidth;
            vt = textureRect.y / atlasHeight;
            quadUV0 = quadUV4 = ul;
            quadUV2 = quadUV6 = ur;
            quadUV1 = quadUV3 = vb;
            quadUV5 = quadUV7 = vt;
          }

          switch (sprite.fillType) {
            case FillType$1.HORIZONTAL:
              vData[3] = quadUV0 + (quadUV2 - quadUV0) * fillStart;
              vData[4] = quadUV1 + (quadUV3 - quadUV1) * fillStart;
              vData[12] = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
              vData[13] = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
              vData[21] = quadUV4 + (quadUV6 - quadUV4) * fillStart;
              vData[22] = quadUV5 + (quadUV7 - quadUV5) * fillStart;
              vData[30] = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
              vData[31] = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
              break;

            case FillType$1.VERTICAL:
              vData[3] = quadUV0 + (quadUV4 - quadUV0) * fillStart;
              vData[4] = quadUV1 + (quadUV5 - quadUV1) * fillStart;
              vData[12] = quadUV2 + (quadUV6 - quadUV2) * fillStart;
              vData[13] = quadUV3 + (quadUV7 - quadUV3) * fillStart;
              vData[21] = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
              vData[22] = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
              vData[30] = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
              vData[31] = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
              break;

            default:
              errorID(2626);
              break;
          }
        },
        updateVertexData: function updateVertexData(sprite, fillStart, fillEnd) {
          var renderData = sprite.renderData;
          var dataList = renderData.data;
          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var width = uiTrans.width;
          var height = uiTrans.height;
          var appX = uiTrans.anchorX * width;
          var appY = uiTrans.anchorY * height;
          var l = -appX;
          var b = -appY;
          var r = width - appX;
          var t = height - appY;
          var progressStart = 0;
          var progressEnd = 0;

          switch (sprite.fillType) {
            case FillType$1.HORIZONTAL:
              progressStart = l + (r - l) * fillStart;
              progressEnd = l + (r - l) * fillEnd;
              l = progressStart;
              r = progressEnd;
              break;

            case FillType$1.VERTICAL:
              progressStart = b + (t - b) * fillStart;
              progressEnd = b + (t - b) * fillEnd;
              b = progressStart;
              t = progressEnd;
              break;

            default:
              errorID(2626);
              break;
          }

          dataList[0].x = l;
          dataList[0].y = b;
          dataList[1].x = r;
          dataList[1].y = b;
          dataList[2].x = l;
          dataList[2].y = t;
          dataList[3].x = r;
          dataList[3].y = t;
        },
        createData: function createData(sprite) {
          var renderData = sprite.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          renderData.vertexRow = 2;
          renderData.vertexCol = 2;
          renderData.chunk.setIndexBuffer(QUAD_INDICES$2);
          var dataList = renderData.data;

          for (var _iterator = _createForOfIteratorHelperLoose(dataList), _step; !(_step = _iterator()).done;) {
            var data = _step.value;
            data.z = 0;
          }

          return renderData;
        },
        updateWorldVertexData: function updateWorldVertexData(sprite, chunk) {
          var node = sprite.node;
          node.getWorldMatrix(m$1);
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = sprite.renderData.data;
          var vData = chunk.vb;
          var offset = 0;

          for (var i = 0; i < 4; i++) {
            var local = dataList[i];
            var x = local.x;
            var y = local.y;
            var rhw = m$1.m03 * x + m$1.m07 * y + m$1.m15;
            rhw = rhw ? Math.abs(1 / rhw) : 1;
            offset = i * stride;
            vData[offset] = (m$1.m00 * x + m$1.m04 * y + m$1.m12) * rhw;
            vData[offset + 1] = (m$1.m01 * x + m$1.m05 * y + m$1.m13) * rhw;
            vData[offset + 2] = (m$1.m02 * x + m$1.m06 * y + m$1.m14) * rhw;
          }
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
          var renderData = sprite.renderData;
          var chunk = renderData.chunk;

          if (sprite.node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVertexData(sprite, chunk);
            renderData.vertDirty = false;
          }

          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.meshBuffer;
          var ib = chunk.meshBuffer.iData;
          var indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateColor: function updateColor(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = sprite.node._uiProps.opacity;

          for (var i = 0; i < 4; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        }
      };

      var PI_2 = Math.PI * 2;
      var EPSILON = 1e-6;
      var m$2 = new Mat4();
      var _vertPos = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

      var _vertices = new Array(4);

      var _uvs = new Array(8);

      var _intersectPoint_1 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      var _intersectPoint_2 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

      var _center = new Vec2();

      var _triangles = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      var QUAD_INDICES$3;

      function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
        var sinAngle = Math.sin(angle);
        sinAngle = Math.abs(sinAngle) > EPSILON ? sinAngle : 0;
        var cosAngle = Math.cos(angle);
        cosAngle = Math.abs(cosAngle) > EPSILON ? cosAngle : 0;
        var tanAngle = 0;
        var cotAngle = 0;

        if (cosAngle !== 0) {
          tanAngle = sinAngle / cosAngle;

          if ((left - center.x) * cosAngle > 0) {
            var yLeft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left;
            intersectPoints[0].y = yLeft;
          }

          if ((right - center.x) * cosAngle > 0) {
            var yRight = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right;
            intersectPoints[2].y = yRight;
          }
        }

        if (sinAngle !== 0) {
          cotAngle = cosAngle / sinAngle;

          if ((top - center.y) * sinAngle > 0) {
            var xTop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xTop;
            intersectPoints[3].y = top;
          }

          if ((bottom - center.y) * sinAngle > 0) {
            var xBottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xBottom;
            intersectPoints[1].y = bottom;
          }
        }
      }

      function _calculateVertices(sprite) {
        var uiTrans = sprite.node._uiProps.uiTransformComp;
        var width = uiTrans.width;
        var height = uiTrans.height;
        var appX = uiTrans.anchorX * width;
        var appY = uiTrans.anchorY * height;
        var l = -appX;
        var b = -appY;
        var r = width - appX;
        var t = height - appY;
        var vertices = _vertices;
        vertices[0] = l;
        vertices[1] = b;
        vertices[2] = r;
        vertices[3] = t;
        var fillCenter = sprite.fillCenter;
        var cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l;
        var cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
        _vertPos[0].x = _vertPos[3].x = l;
        _vertPos[1].x = _vertPos[2].x = r;
        _vertPos[0].y = _vertPos[1].y = b;
        _vertPos[2].y = _vertPos[3].y = t;

        for (var _iterator = _createForOfIteratorHelperLoose(_triangles), _step; !(_step = _iterator()).done;) {
          var num = _step.value;
          Vec2.set(num, 0, 0);
        }

        if (cx !== vertices[0]) {
          Vec2.set(_triangles[0], 3, 0);
        }

        if (cx !== vertices[2]) {
          Vec2.set(_triangles[2], 1, 2);
        }

        if (cy !== vertices[1]) {
          Vec2.set(_triangles[1], 0, 1);
        }

        if (cy !== vertices[3]) {
          Vec2.set(_triangles[3], 2, 3);
        }
      }

      function _calculateUVs(spriteFrame) {
        var atlasWidth = spriteFrame.width;
        var atlasHeight = spriteFrame.height;
        var textureRect = spriteFrame.getRect();
        var u0 = 0;
        var u1 = 0;
        var v0 = 0;
        var v1 = 0;
        var uvs = _uvs;

        if (spriteFrame.isRotated()) {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.height) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.width) / atlasHeight;
          uvs[0] = uvs[2] = u0;
          uvs[4] = uvs[6] = u1;
          uvs[3] = uvs[7] = v1;
          uvs[1] = uvs[5] = v0;
        } else {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.width) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.height) / atlasHeight;
          uvs[0] = uvs[4] = u0;
          uvs[2] = uvs[6] = u1;
          uvs[1] = uvs[3] = v1;
          uvs[5] = uvs[7] = v0;
        }
      }

      function _getVertAngle(start, end) {
        var placementX = end.x - start.x;
        var placementY = end.y - start.y;

        if (placementX === 0 && placementY === 0) {
          return 0;
        } else if (placementX === 0) {
          if (placementY > 0) {
            return Math.PI * 0.5;
          } else {
            return Math.PI * 1.5;
          }
        } else {
          var angle = Math.atan(placementY / placementX);

          if (placementX < 0) {
            angle += Math.PI;
          }

          return angle;
        }
      }

      function _generateTriangle(dataList, offset, vert0, vert1, vert2) {
        var vertices = _vertices;
        var v0x = vertices[0];
        var v0y = vertices[1];
        var v1x = vertices[2];
        var v1y = vertices[3];
        dataList[offset].x = vert0.x;
        dataList[offset].y = vert0.y;
        dataList[offset + 1].x = vert1.x;
        dataList[offset + 1].y = vert1.y;
        dataList[offset + 2].x = vert2.x;
        dataList[offset + 2].y = vert2.y;
        var progressX = 0;
        var progressY = 0;
        progressX = (vert0.x - v0x) / (v1x - v0x);
        progressY = (vert0.y - v0y) / (v1y - v0y);

        _generateUV(progressX, progressY, dataList, offset);

        progressX = (vert1.x - v0x) / (v1x - v0x);
        progressY = (vert1.y - v0y) / (v1y - v0y);

        _generateUV(progressX, progressY, dataList, offset + 1);

        progressX = (vert2.x - v0x) / (v1x - v0x);
        progressY = (vert2.y - v0y) / (v1y - v0y);

        _generateUV(progressX, progressY, dataList, offset + 2);
      }

      function _generateUV(progressX, progressY, data, offset) {
        var uvs = _uvs;
        var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
        var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
        var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
        var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
        var uv = data[offset];
        uv.u = px1 + (px2 - px1) * progressY;
        uv.v = py1 + (py2 - py1) * progressY;
      }

      var radialFilled = {
        useModel: false,
        createData: function createData(sprite) {
          return sprite.requestRenderData();
        },
        updateRenderData: function updateRenderData(sprite) {
          var frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          var renderData = sprite.renderData;

          if (renderData && frame) {
            if (!renderData.vertDirty) {
              return;
            }

            var dataList = renderData.data;
            var fillStart = sprite.fillStart;
            var fillRange = sprite.fillRange;

            if (fillRange < 0) {
              fillStart += fillRange;
              fillRange = -fillRange;
            }

            while (fillStart >= 1.0) {
              fillStart -= 1.0;
            }

            while (fillStart < 0.0) {
              fillStart += 1.0;
            }

            fillStart *= PI_2;
            fillRange *= PI_2;
            var fillEnd = fillStart + fillRange;

            _calculateVertices(sprite);

            _calculateUVs(frame);

            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);

            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);

            var offset = 0;

            for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
              var triangle = _triangles[triangleIndex];

              if (!triangle) {
                continue;
              }

              if (fillRange >= PI_2) {
                renderData.dataLength = offset + 3;

                _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);

                offset += 3;
                continue;
              }

              var startAngle = _getVertAngle(_center, _vertPos[triangle.x]);

              var endAngle = _getVertAngle(_center, _vertPos[triangle.y]);

              if (endAngle < startAngle) {
                endAngle += PI_2;
              }

              startAngle -= PI_2;
              endAngle -= PI_2;

              for (var testIndex = 0; testIndex < 3; ++testIndex) {
                if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
                  renderData.dataLength = offset + 3;

                  if (endAngle >= fillEnd) {
                    _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _intersectPoint_2[triangleIndex]);
                  } else {
                    _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                  }

                  offset += 3;
                } else if (endAngle > fillStart) {
                  if (endAngle <= fillEnd) {
                    renderData.dataLength = offset + 3;

                    _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]);

                    offset += 3;
                  } else {
                    renderData.dataLength = offset + 3;

                    _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);

                    offset += 3;
                  }
                }

                startAngle += PI_2;
                endAngle += PI_2;
              }
            }

            if (offset === 0) {
              renderData.dataLength = 0;
            }

            renderData.resize(offset, offset);

            renderData.updateRenderData(sprite, frame);
          }
        },
        createQuadIndices: function createQuadIndices(indexCount) {
          QUAD_INDICES$3 = null;
          QUAD_INDICES$3 = new Uint16Array(indexCount);
          var offset = 0;

          for (var i = 0; i < indexCount; i++) {
            QUAD_INDICES$3[offset++] = i;
          }
        },
        fillBuffers: function fillBuffers(comp, renderer) {
          var node = comp.node;
          var renderData = comp.renderData;
          var chunk = renderData.chunk;

          if (node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVertexAndUVData(comp, chunk);
            renderData.vertDirty = false;
          }

          this.updateColorLate(comp);
          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.meshBuffer;
          var ib = chunk.meshBuffer.iData;
          var indexOffset = meshBuffer.indexOffset;

          for (var i = 0; i < renderData.indexCount; i++) {
            ib[indexOffset + i] = vid + i;
          }

          meshBuffer.indexOffset += renderData.indexCount;
          meshBuffer.setDirty();
        },
        updateWorldUVData: function updateWorldUVData(sprite, chunk) {
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = renderData.data;
          var vData = renderData.chunk.vb;

          for (var i = 0; i < dataList.length; i++) {
            var offset = i * stride;
            vData[offset + 3] = dataList[i].u;
            vData[offset + 4] = dataList[i].v;
          }
        },
        updateWorldVertexAndUVData: function updateWorldVertexAndUVData(sprite, chunk) {
          var node = sprite.node;
          node.getWorldMatrix(m$2);
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = sprite.renderData.data;
          var vData = chunk.vb;
          var vertexCount = renderData.vertexCount;
          var vertexOffset = 0;

          for (var i = 0; i < vertexCount; i++) {
            var vert = dataList[i];
            var x = vert.x;
            var y = vert.y;
            var rhw = m$2.m03 * x + m$2.m07 * y + m$2.m15;
            rhw = rhw ? Math.abs(1 / rhw) : 1;
            vData[vertexOffset + 0] = (m$2.m00 * x + m$2.m04 * y + m$2.m12) * rhw;
            vData[vertexOffset + 1] = (m$2.m01 * x + m$2.m05 * y + m$2.m13) * rhw;
            vData[vertexOffset + 2] = (m$2.m02 * x + m$2.m06 * y + m$2.m14) * rhw;
            vData[vertexOffset + 3] = vert.u;
            vData[vertexOffset + 4] = vert.v;
            vertexOffset += stride;
          }
        },
        updateUVs: function updateUVs(sprite) {
          var renderData = sprite.renderData;
          renderData.vertDirty = true;
          sprite.markForUpdateRenderData();
        },
        updateColorLate: function updateColorLate(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var vertexCount = renderData.vertexCount;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = sprite.node._uiProps.opacity;

          for (var i = 0; i < vertexCount; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        },
        updateColor: function updateColor(sprite) {}
      };

      var QUAD_INDICES$4 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      var simple = {
        createData: function createData(sprite) {
          var renderData = sprite.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          renderData.vertexRow = 2;
          renderData.vertexCol = 2;
          renderData.chunk.setIndexBuffer(QUAD_INDICES$4);
          return renderData;
        },
        updateRenderData: function updateRenderData(sprite) {
          var frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          var renderData = sprite.renderData;

          if (renderData && frame) {
            if (renderData.vertDirty) {
              this.updateVertexData(sprite);
            }

            renderData.updateRenderData(sprite, frame);
          }
        },
        updateWorldVerts: function updateWorldVerts(sprite, chunk) {
          var renderData = sprite.renderData;
          var vData = chunk.vb;
          var dataList = renderData.data;
          var node = sprite.node;
          var m = node.worldMatrix;
          var stride = renderData.floatStride;
          var offset = 0;
          var length = dataList.length;

          for (var i = 0; i < length; i++) {
            var curData = dataList[i];
            var x = curData.x;
            var y = curData.y;
            var rhw = m.m03 * x + m.m07 * y + m.m15;
            rhw = rhw ? Math.abs(1 / rhw) : 1;
            offset = i * stride;
            vData[offset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
            vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
            vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
          }
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
          if (sprite === null) {
            return;
          }

          var renderData = sprite.renderData;
          var chunk = renderData.chunk;

          if (sprite.node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVerts(sprite, chunk);
            renderData.vertDirty = false;
          }

          var bid = chunk.bufferId;
          var vidOrigin = chunk.vertexOffset;
          var meshBuffer = chunk.meshBuffer;
          var ib = chunk.meshBuffer.iData;
          var indexOffset = meshBuffer.indexOffset;

          for (var curRow = 0; curRow < renderData.vertexRow - 1; curRow++) {
            for (var curCol = 0; curCol < renderData.vertexCol - 1; curCol++) {
              var vid = vidOrigin + curRow * renderData.vertexCol + curCol;
              ib[indexOffset++] = vid;
              ib[indexOffset++] = vid + 1;
              ib[indexOffset++] = vid + renderData.vertexCol;
              ib[indexOffset++] = vid + 1;
              ib[indexOffset++] = vid + 1 + renderData.vertexCol;
              ib[indexOffset++] = vid + renderData.vertexCol;
              meshBuffer.indexOffset += 6;
            }
          }
        },
        updateVertexData: function updateVertexData(sprite) {
          var renderData = sprite.renderData;

          if (!renderData) {
            return;
          }

          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var dataList = renderData.data;
          var cw = uiTrans.width;
          var ch = uiTrans.height;
          var appX = uiTrans.anchorX * cw;
          var appY = uiTrans.anchorY * ch;
          var l = 0;
          var b = 0;
          var r = 0;
          var t = 0;

          if (sprite.trim) {
            l = -appX;
            b = -appY;
            r = cw - appX;
            t = ch - appY;
          } else {
            var frame = sprite.spriteFrame;
            var originSize = frame.originalSize;
            var ow = originSize.width;
            var oh = originSize.height;
            var scaleX = cw / ow;
            var scaleY = ch / oh;
            var trimmedBorder = frame.trimmedBorder;
            l = trimmedBorder.x * scaleX - appX;
            b = trimmedBorder.z * scaleY - appY;
            r = cw + trimmedBorder.y * scaleX - appX;
            t = ch + trimmedBorder.w * scaleY - appY;
          }

          dataList[0].x = l;
          dataList[0].y = b;
          dataList[1].x = r;
          dataList[1].y = b;
          dataList[2].x = l;
          dataList[2].y = t;
          dataList[3].x = r;
          dataList[3].y = t;
          renderData.vertDirty = true;
        },
        updateUVs: function updateUVs(sprite) {
          if (!sprite.spriteFrame) return;
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var uv = sprite.spriteFrame.uv;
          vData[3] = uv[0];
          vData[4] = uv[1];
          vData[12] = uv[2];
          vData[13] = uv[3];
          vData[21] = uv[4];
          vData[22] = uv[5];
          vData[30] = uv[6];
          vData[31] = uv[7];
        },
        updateColor: function updateColor(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = color.a / 255;

          for (var i = 0; i < 4; i++, colorOffset += renderData.floatStride) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
          }
        }
      };

      var m$3 = new Mat4();
      var tempRenderData = [];

      for (var i$1 = 0; i$1 < 4; i$1++) {
        tempRenderData.push({
          x: 0,
          y: 0,
          z: 0,
          u: 0,
          v: 0,
          color: new Color()
        });
      }

      var sliced = {
        createData: function createData(sprite) {
          var renderData = sprite.requestRenderData();
          renderData.dataLength = 16;
          renderData.resize(16, 54);
          renderData.vertexRow = 4;
          renderData.vertexCol = 4;
          this.QUAD_INDICES = new Uint16Array(54);
          this.createQuadIndices(4, 4);
          renderData.chunk.setIndexBuffer(this.QUAD_INDICES);
          return renderData;
        },
        createQuadIndices: function createQuadIndices(vertexRow, vertexCol) {
          var offset = 0;

          for (var curRow = 0; curRow < vertexRow - 1; curRow++) {
            for (var curCol = 0; curCol < vertexCol - 1; curCol++) {
              var vid = curRow * vertexCol + curCol;
              this.QUAD_INDICES[offset++] = vid;
              this.QUAD_INDICES[offset++] = vid + 1;
              this.QUAD_INDICES[offset++] = vid + vertexCol;
              this.QUAD_INDICES[offset++] = vid + 1;
              this.QUAD_INDICES[offset++] = vid + 1 + vertexCol;
              this.QUAD_INDICES[offset++] = vid + vertexCol;
            }
          }
        },
        updateRenderData: function updateRenderData(sprite) {
          var frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          var renderData = sprite.renderData;

          if (renderData && frame) {
            var vertDirty = renderData.vertDirty;

            if (vertDirty) {
              this.updateVertexData(sprite);
            }

            renderData.updateRenderData(sprite, frame);
          }
        },
        updateVertexData: function updateVertexData(sprite) {
          var renderData = sprite.renderData;
          var dataList = renderData.data;
          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var width = uiTrans.width;
          var height = uiTrans.height;
          var appX = uiTrans.anchorX * width;
          var appY = uiTrans.anchorY * height;
          var frame = sprite.spriteFrame;
          var leftWidth = frame.insetLeft;
          var rightWidth = frame.insetRight;
          var topHeight = frame.insetTop;
          var bottomHeight = frame.insetBottom;
          var sizableWidth = width - leftWidth - rightWidth;
          var sizableHeight = height - topHeight - bottomHeight;
          var xScale = width / (leftWidth + rightWidth);
          var yScale = height / (topHeight + bottomHeight);
          xScale = Number.isNaN(xScale) || xScale > 1 ? 1 : xScale;
          yScale = Number.isNaN(yScale) || yScale > 1 ? 1 : yScale;
          sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
          sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
          tempRenderData[0].x = -appX;
          tempRenderData[0].y = -appY;
          tempRenderData[1].x = leftWidth * xScale - appX;
          tempRenderData[1].y = bottomHeight * yScale - appY;
          tempRenderData[2].x = tempRenderData[1].x + sizableWidth;
          tempRenderData[2].y = tempRenderData[1].y + sizableHeight;
          tempRenderData[3].x = width - appX;
          tempRenderData[3].y = height - appY;

          for (var curRow = 0; curRow < renderData.vertexRow; curRow++) {
            for (var curCol = 0; curCol < renderData.vertexCol; curCol++) {
              var curIndex = curRow * renderData.vertexCol + curCol;

              if (curIndex < renderData.dataLength && curRow < tempRenderData.length && curCol < tempRenderData.length) {
                dataList[curIndex].x = tempRenderData[curCol].x;
                dataList[curIndex].y = tempRenderData[curRow].y;
              }
            }
          }
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
          var renderData = sprite.renderData;
          var chunk = renderData.chunk;

          if (sprite.node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVertexData(sprite, chunk);
            renderData.vertDirty = false;
          }

          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.meshBuffer;
          var ib = chunk.meshBuffer.iData;
          var indexOffset = meshBuffer.indexOffset;

          for (var r = 0; r < 3; ++r) {
            for (var c = 0; c < 3; ++c) {
              var start = vid + r * 4 + c;
              ib[indexOffset++] = start;
              ib[indexOffset++] = start + 1;
              ib[indexOffset++] = start + 4;
              ib[indexOffset++] = start + 1;
              ib[indexOffset++] = start + 5;
              ib[indexOffset++] = start + 4;
            }
          }

          meshBuffer.indexOffset = indexOffset;
        },
        updateWorldVertexData: function updateWorldVertexData(sprite, chunk) {
          var node = sprite.node;
          node.getWorldMatrix(m$3);
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = renderData.data;
          var vData = chunk.vb;
          var offset = 0;

          for (var row = 0; row < 4; ++row) {
            var rowD = dataList[row * 4];

            for (var col = 0; col < 4; ++col) {
              var colD = dataList[col];
              var x = colD.x;
              var y = rowD.y;
              var rhw = m$3.m03 * x + m$3.m07 * y + m$3.m15;
              rhw = rhw ? Math.abs(1 / rhw) : 1;
              offset = (row * 4 + col) * stride;
              vData[offset + 0] = (m$3.m00 * x + m$3.m04 * y + m$3.m12) * rhw;
              vData[offset + 1] = (m$3.m01 * x + m$3.m05 * y + m$3.m13) * rhw;
              vData[offset + 2] = (m$3.m02 * x + m$3.m06 * y + m$3.m14) * rhw;
            }
          }
        },
        updateUVs: function updateUVs(sprite) {
          if (!sprite.spriteFrame) return;
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var uv = sprite.spriteFrame.uvSliced;
          var uvOffset = 3;

          for (var _i = 0; _i < 16; _i++) {
            vData[uvOffset] = uv[_i].u;
            vData[uvOffset + 1] = uv[_i].v;
            uvOffset += stride;
          }
        },
        updateColor: function updateColor(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = sprite.node._uiProps.opacity;

          for (var _i2 = 0; _i2 < 16; _i2++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        }
      };

      var m$4 = new Mat4();
      var origin;
      var leftInner;
      var rightInner;
      var rightOuter;
      var bottomInner;
      var topInner;
      var topOuter;
      var tempRenderDataLength = 0;
      var tempRenderData$1 = [];
      var QUAD_INDICES$5;

      function has9SlicedOffsetVertexCount(spriteFrame) {
        if (spriteFrame) {
          if (spriteFrame.insetTop > 0 || spriteFrame.insetBottom > 0 || spriteFrame.insetLeft > 0 || spriteFrame.insetRight > 0) {
            return 2;
          }
        }

        return 0;
      }

      var tiled = {
        createData: function createData(sprite) {
          return sprite.requestRenderData();
        },
        updateRenderData: function updateRenderData(sprite) {
          var renderData = sprite.renderData;
          var frame = sprite.spriteFrame;

          if (!frame || !renderData) {
            return;
          }

          if (!renderData.vertDirty) {
            return;
          }

          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var contentWidth = Math.abs(uiTrans.width);
          var contentHeight = Math.abs(uiTrans.height);
          var rect = frame.getRect();
          var leftWidth = frame.insetLeft;
          var rightWidth = frame.insetRight;
          var centerWidth = rect.width - leftWidth - rightWidth;
          var topHeight = frame.insetTop;
          var bottomHeight = frame.insetBottom;
          var centerHeight = rect.height - topHeight - bottomHeight;
          var sizableWidth = contentWidth - leftWidth - rightWidth;
          var sizableHeight = contentHeight - topHeight - bottomHeight;
          sizableWidth = sizableWidth > 0 ? sizableWidth : 0;
          sizableHeight = sizableHeight > 0 ? sizableHeight : 0;
          var hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
          var vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
          var offsetVertexCount = has9SlicedOffsetVertexCount(frame);
          var row = Math.ceil(vRepeat + offsetVertexCount);
          var col = Math.ceil(hRepeat + offsetVertexCount);
          renderData.dataLength = row * 2 * (col * 2);
          this.updateVerts(sprite, sizableWidth, sizableHeight, row, col);

          if (renderData.vertexCount !== row * col * 4) {
            sprite.renderEntity.colorDirty = true;
          }

          renderData.resize(row * col * 4, row * col * 6);

          renderData.updateRenderData(sprite, frame);
        },
        createQuadIndices: function createQuadIndices(indexCount) {
          if (indexCount % 6 !== 0) {
            console.error('illegal index count!');
            return;
          }

          var quadCount = indexCount / 6;
          QUAD_INDICES$5 = null;
          QUAD_INDICES$5 = new Uint16Array(indexCount);
          var offset = 0;

          for (var i = 0; i < quadCount; i++) {
            QUAD_INDICES$5[offset++] = 0 + i * 4;
            QUAD_INDICES$5[offset++] = 1 + i * 4;
            QUAD_INDICES$5[offset++] = 2 + i * 4;
            QUAD_INDICES$5[offset++] = 1 + i * 4;
            QUAD_INDICES$5[offset++] = 3 + i * 4;
            QUAD_INDICES$5[offset++] = 2 + i * 4;
          }
        },
        updateUVs: function updateUVs(sprite) {
          var renderData = sprite.renderData;
          renderData.vertDirty = true;
          sprite.markForUpdateRenderData();
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
          var node = sprite.node;
          var renderData = sprite.renderData;
          var chunk = renderData.chunk;

          if (node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVertexAndUVData(sprite, chunk);
            renderData.vertDirty = false;
          }

          this.updateColorLate(sprite);
          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.meshBuffer;
          var ib = chunk.meshBuffer.iData;
          var indexOffset = meshBuffer.indexOffset;

          for (var i = 0; i < renderData.indexCount; i += 6) {
            ib[indexOffset++] = vid;
            ib[indexOffset++] = vid + 1;
            ib[indexOffset++] = vid + 2;
            ib[indexOffset++] = vid + 1;
            ib[indexOffset++] = vid + 3;
            ib[indexOffset++] = vid + 2;
            vid += 4;
            meshBuffer.indexOffset += 6;
          }

          meshBuffer.setDirty();
        },
        updateWorldUVData: function updateWorldUVData(sprite) {
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = renderData.data;
          var vData = renderData.chunk.vb;

          for (var i = 0; i < dataList.length; i++) {
            var offset = i * stride;
            vData[offset + 3] = dataList[i].u;
            vData[offset + 4] = dataList[i].v;
          }
        },
        updateWorldVertexAndUVData: function updateWorldVertexAndUVData(sprite, chunk) {
          var node = sprite.node;
          node.getWorldMatrix(m$4);
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = renderData.data;
          var vData = chunk.vb;
          var length = dataList.length;

          for (var i = 0; i < length; i++) {
            var x = dataList[i].x;
            var y = dataList[i].y;
            var z = dataList[i].z;
            var rhw = m$4.m03 * x + m$4.m07 * y + m$4.m11 * z + m$4.m15;
            rhw = rhw ? Math.abs(1 / rhw) : 1;
            var offset = i * stride;
            vData[offset] = (m$4.m00 * x + m$4.m04 * y + m$4.m08 * z + m$4.m12) * rhw;
            vData[offset + 1] = (m$4.m01 * x + m$4.m05 * y + m$4.m09 * z + m$4.m13) * rhw;
            vData[offset + 2] = (m$4.m02 * x + m$4.m06 * y + m$4.m10 * z + m$4.m14) * rhw;
          }

          this.updateWorldUVData(sprite);
        },
        updateVerts: function updateVerts(sprite, sizableWidth, sizableHeight, row, col) {
          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var renderData = sprite.renderData;
          var dataList = renderData.data;
          var frame = sprite.spriteFrame;
          var rect = frame.rect;
          var contentWidth = Math.abs(uiTrans.width);
          var contentHeight = Math.abs(uiTrans.height);
          var appx = uiTrans.anchorX * contentWidth;
          var appy = uiTrans.anchorY * contentHeight;
          var leftWidth = frame.insetLeft;
          var rightWidth = frame.insetRight;
          var centerWidth = rect.width - leftWidth - rightWidth;
          var topHeight = frame.insetTop;
          var bottomHeight = frame.insetBottom;
          var centerHeight = rect.height - topHeight - bottomHeight;
          var xScale = uiTrans.width / (leftWidth + rightWidth) > 1 ? 1 : uiTrans.width / (leftWidth + rightWidth);
          var yScale = uiTrans.height / (topHeight + bottomHeight) > 1 ? 1 : uiTrans.height / (topHeight + bottomHeight);
          var offsetWidth = 0;
          var offsetHeight = 0;

          if (centerWidth > 0) {
            offsetWidth = Math.floor(sizableWidth * 1000) / 1000 % centerWidth === 0 ? centerWidth : sizableWidth % centerWidth;
          } else {
            offsetWidth = sizableWidth;
          }

          if (centerHeight > 0) {
            offsetHeight = Math.floor(sizableHeight * 1000) / 1000 % centerHeight === 0 ? centerHeight : sizableHeight % centerHeight;
          } else {
            offsetHeight = sizableHeight;
          }

          tempRenderDataLength = Math.max(row + 1, col + 1);

          for (var i = 0; i < tempRenderDataLength; i++) {
            tempRenderData$1.push({
              x: 0,
              y: 0,
              z: 0,
              u: 0,
              v: 0,
              color: new Color()
            });
          }

          var offsetVertexCount = has9SlicedOffsetVertexCount(frame);

          if (offsetVertexCount === 0) {
            for (var _i = 0; _i < tempRenderDataLength; _i++) {
              if (_i >= col) {
                tempRenderData$1[_i].x = contentWidth - appx;
              } else {
                tempRenderData$1[_i].x = -appx + _i * centerWidth;
              }

              if (_i >= row) {
                tempRenderData$1[_i].y = contentHeight - appy;
              } else {
                tempRenderData$1[_i].y = -appy + _i * centerHeight;
              }
            }
          } else {
            for (var _i2 = 0; _i2 < tempRenderDataLength; _i2++) {
              if (_i2 === 0) {
                tempRenderData$1[_i2].x = -appx;
              } else if (_i2 === 1) {
                tempRenderData$1[_i2].x = -appx + leftWidth * xScale;
              } else if (_i2 > 1 && _i2 < col - 1) {
                if (centerWidth > 0) {
                  tempRenderData$1[_i2].x = -appx + leftWidth * xScale + centerWidth * (_i2 - 1);
                } else {
                  tempRenderData$1[_i2].x = leftWidth + sizableWidth - appx;
                }
              } else if (_i2 === col - 1) {
                tempRenderData$1[_i2].x = -appx + leftWidth * xScale + offsetWidth + centerWidth * (_i2 - 2);
              } else if (_i2 >= col) {
                tempRenderData$1[_i2].x = Math.min(leftWidth + sizableWidth + rightWidth, contentWidth) - appx;
              }

              if (_i2 === 0) {
                tempRenderData$1[_i2].y = -appy;
              } else if (_i2 === 1) {
                tempRenderData$1[_i2].y = -appy + bottomHeight * yScale;
              } else if (_i2 > 1 && _i2 < row - 1) {
                if (centerHeight > 0) {
                  tempRenderData$1[_i2].y = -appy + bottomHeight * yScale + centerHeight * (_i2 - 1);
                } else {
                  tempRenderData$1[_i2].y = bottomHeight + sizableHeight - appy;
                }
              } else if (_i2 === row - 1) {
                tempRenderData$1[_i2].y = -appy + bottomHeight * yScale + offsetHeight + centerHeight * (_i2 - 2);
              } else if (_i2 >= row) {
                tempRenderData$1[_i2].y = Math.min(bottomHeight + sizableHeight + topHeight, contentHeight) - appy;
              }
            }
          }

          var x = 0;
          var x1 = 0;
          var y = 0;
          var y1 = 0;

          for (var yIndex = 0; yIndex < row; ++yIndex) {
            y = tempRenderData$1[yIndex].y;
            y1 = tempRenderData$1[yIndex + 1].y;

            for (var xIndex = 0; xIndex < col; ++xIndex) {
              x = tempRenderData$1[xIndex].x;
              x1 = tempRenderData$1[xIndex + 1].x;
              var curIndex = 4 * (yIndex * col + xIndex);
              dataList[curIndex].x = x;
              dataList[curIndex].y = y;
              dataList[curIndex + 1].x = x1;
              dataList[curIndex + 1].y = y;
              dataList[curIndex + 2].x = x;
              dataList[curIndex + 2].y = y1;
              dataList[curIndex + 3].x = x1;
              dataList[curIndex + 3].y = y1;
            }
          }

          var rotated = frame.rotated;
          var uv = frame.uv;
          var uvSliced = frame.uvSliced;
          origin = uvSliced[0];
          leftInner = uvSliced[1];
          rightInner = uvSliced[2];
          rightOuter = uvSliced[3];
          bottomInner = uvSliced[4];
          topInner = uvSliced[8];
          topOuter = uvSliced[12];
          var coefU = 0;
          var coefV = 0;
          var hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
          var vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
          var tempXVerts = [];
          var tempYVerts = [];

          for (var yIndexUV = 0; yIndexUV < row; ++yIndexUV) {
            if (sizableHeight > centerHeight) {
              var curYRectCount = offsetVertexCount > 0 ? yIndexUV : yIndexUV + 1;

              if (sizableHeight >= curYRectCount * centerHeight) {
                coefV = 1;
              } else {
                coefV = vRepeat % 1;
              }
            } else {
              coefV = vRepeat;
            }

            for (var xIndexUV = 0; xIndexUV < col; ++xIndexUV) {
              if (sizableWidth > centerWidth) {
                var curXRectCount = offsetVertexCount > 0 ? xIndexUV : xIndexUV + 1;

                if (sizableWidth >= curXRectCount * centerWidth) {
                  coefU = 1;
                } else {
                  coefU = hRepeat % 1;
                }
              } else {
                coefU = hRepeat;
              }

              if (rotated) {
                if (offsetVertexCount === 0) {
                  tempXVerts[0] = bottomInner.u;
                  tempXVerts[1] = bottomInner.u;
                  tempXVerts[2] = bottomInner.u + (topInner.u - bottomInner.u) * coefV;
                  tempYVerts[0] = leftInner.v;
                  tempYVerts[1] = leftInner.v + (rightInner.v - leftInner.v) * coefU;
                  tempYVerts[2] = leftInner.v;
                } else {
                  if (yIndexUV === 0) {
                    tempXVerts[0] = origin.u;
                    tempXVerts[1] = origin.u;
                    tempXVerts[2] = bottomInner.u;
                  } else if (yIndexUV < row - 1) {
                    tempXVerts[0] = bottomInner.u;
                    tempXVerts[1] = bottomInner.u;
                    tempXVerts[2] = bottomInner.u + (topInner.u - bottomInner.u) * coefV;
                  } else if (yIndexUV === row - 1) {
                    tempXVerts[0] = topInner.u;
                    tempXVerts[1] = topInner.u;
                    tempXVerts[2] = topOuter.u;
                  }

                  if (xIndexUV === 0) {
                    tempYVerts[0] = origin.v;
                    tempYVerts[1] = leftInner.v;
                    tempYVerts[2] = origin.v;
                  } else if (xIndexUV < col - 1) {
                    tempYVerts[0] = leftInner.v;
                    tempYVerts[1] = leftInner.v + (rightInner.v - leftInner.v) * coefU;
                    tempYVerts[2] = leftInner.v;
                  } else if (xIndexUV === col - 1) {
                    tempYVerts[0] = rightInner.v;
                    tempYVerts[1] = rightOuter.v;
                    tempYVerts[2] = rightInner.v;
                  }
                }

                tempXVerts[3] = tempXVerts[2];
                tempYVerts[3] = tempYVerts[1];
              } else {
                if (offsetVertexCount === 0) {
                  tempXVerts[0] = leftInner.u;
                  tempXVerts[1] = leftInner.u + (rightInner.u - leftInner.u) * coefU;
                  tempXVerts[2] = leftInner.u;
                  tempYVerts[0] = bottomInner.v;
                  tempYVerts[1] = bottomInner.v;
                  tempYVerts[2] = bottomInner.v + (topInner.v - bottomInner.v) * coefV;
                } else {
                  if (xIndexUV === 0) {
                    tempXVerts[0] = origin.u;
                    tempXVerts[1] = leftInner.u;
                    tempXVerts[2] = origin.u;
                  } else if (xIndexUV < col - 1) {
                    tempXVerts[0] = leftInner.u;
                    tempXVerts[1] = leftInner.u + (rightInner.u - leftInner.u) * coefU;
                    tempXVerts[2] = leftInner.u;
                  } else if (xIndexUV === col - 1) {
                    tempXVerts[0] = rightInner.u;
                    tempXVerts[1] = rightOuter.u;
                    tempXVerts[2] = rightInner.u;
                  }

                  if (yIndexUV === 0) {
                    tempYVerts[0] = origin.v;
                    tempYVerts[1] = origin.v;
                    tempYVerts[2] = bottomInner.v;
                  } else if (yIndexUV < row - 1) {
                    tempYVerts[0] = bottomInner.v;
                    tempYVerts[1] = bottomInner.v;
                    tempYVerts[2] = bottomInner.v + (topInner.v - bottomInner.v) * coefV;
                  } else if (yIndexUV === row - 1) {
                    tempYVerts[0] = topInner.v;
                    tempYVerts[1] = topInner.v;
                    tempYVerts[2] = topOuter.v;
                  }
                }

                tempXVerts[3] = tempXVerts[1];
                tempYVerts[3] = tempYVerts[2];
              }

              var _curIndex = 4 * (yIndexUV * col + xIndexUV);

              dataList[_curIndex].u = tempXVerts[0];
              dataList[_curIndex].v = tempYVerts[0];
              dataList[_curIndex + 1].u = tempXVerts[1];
              dataList[_curIndex + 1].v = tempYVerts[1];
              dataList[_curIndex + 2].u = tempXVerts[2];
              dataList[_curIndex + 2].v = tempYVerts[2];
              dataList[_curIndex + 3].u = tempXVerts[3];
              dataList[_curIndex + 3].v = tempYVerts[3];
            }
          }
        },
        updateColorLate: function updateColorLate(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var vertexCount = renderData.vertexCount;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = sprite.node._uiProps.opacity;

          for (var i = 0; i < vertexCount; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        },
        updateColor: function updateColor(sprite) {}
      };

      var SpriteType$1 = Sprite.Type;
      var FillType$2 = Sprite.FillType;
      var spriteAssembler = exports('spriteAssembler', {
        getAssembler: function getAssembler(spriteComp) {
          var util = simple;
          var comp = spriteComp;

          switch (comp.type) {
            case SpriteType$1.SLICED:
              util = sliced;
              break;

            case SpriteType$1.TILED:
              util = tiled;
              break;

            case SpriteType$1.FILLED:
              if (comp.fillType === FillType$2.RADIAL) {
                util = radialFilled;
              } else {
                util = barFilled;
              }

              break;
          }

          return util;
        }
      });
      Sprite.Assembler = spriteAssembler;

      var mouseEvents = [Input.EventType.MOUSE_DOWN, Input.EventType.MOUSE_MOVE, Input.EventType.MOUSE_UP, Input.EventType.MOUSE_WHEEL];
      var touchEvents = [Input.EventType.TOUCH_START, Input.EventType.TOUCH_MOVE, Input.EventType.TOUCH_END, Input.EventType.TOUCH_CANCEL];

      var PointerEventDispatcher = function () {
        function PointerEventDispatcher() {
          this.priority = EventDispatcherPriority.UI;
          this._isListDirty = false;
          this._inDispatchCount = 0;
          this._pointerEventProcessorList = [];
          this._processorListToAdd = [];
          this._processorListToRemove = [];

          input._registerEventDispatcher(this);

          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this.addPointerEventProcessor, this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this.removePointerEventProcessor, this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.MARK_LIST_DIRTY, this._markListDirty, this);
        }

        var _proto = PointerEventDispatcher.prototype;

        _proto.dispatchEvent = function dispatchEvent(event) {
          var eventType = event.type;

          if (touchEvents.includes(eventType)) {
            return this.dispatchEventTouch(event);
          } else if (mouseEvents.includes(eventType)) {
            return this.dispatchEventMouse(event);
          }

          return true;
        };

        _proto.addPointerEventProcessor = function addPointerEventProcessor(pointerEventProcessor) {
          if (this._inDispatchCount === 0) {
            if (!this._pointerEventProcessorList.includes(pointerEventProcessor)) {
              this._pointerEventProcessorList.push(pointerEventProcessor);

              this._isListDirty = true;
            }
          } else if (!this._processorListToAdd.includes(pointerEventProcessor)) {
            this._processorListToAdd.push(pointerEventProcessor);
          }

          js.array.remove(this._processorListToRemove, pointerEventProcessor);
        };

        _proto.removePointerEventProcessor = function removePointerEventProcessor(pointerEventProcessor) {
          if (this._inDispatchCount === 0) {
            js.array.remove(this._pointerEventProcessorList, pointerEventProcessor);
            this._isListDirty = true;
          } else if (!this._processorListToRemove.includes(pointerEventProcessor)) {
            this._processorListToRemove.push(pointerEventProcessor);
          }

          js.array.remove(this._processorListToAdd, pointerEventProcessor);
        };

        _proto.dispatchEventMouse = function dispatchEventMouse(eventMouse) {
          this._inDispatchCount++;

          this._sortPointerEventProcessorList();

          var pointerEventProcessorList = this._pointerEventProcessorList;
          var length = pointerEventProcessorList.length;
          var dispatchToNextEventDispatcher = true;

          for (var i = 0; i < length; ++i) {
            var pointerEventProcessor = pointerEventProcessorList[i];

            if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventMouse && pointerEventProcessor._handleEventMouse(eventMouse)) {
              dispatchToNextEventDispatcher = false;

              if (!eventMouse.preventSwallow) {
                break;
              } else {
                eventMouse.preventSwallow = false;
              }
            }
          }

          if (--this._inDispatchCount <= 0) {
            this._updatePointerEventProcessorList();
          }

          return dispatchToNextEventDispatcher;
        };

        _proto.dispatchEventTouch = function dispatchEventTouch(eventTouch) {
          this._inDispatchCount++;

          this._sortPointerEventProcessorList();

          var pointerEventProcessorList = this._pointerEventProcessorList;
          var length = pointerEventProcessorList.length;
          var touch = eventTouch.touch;
          var dispatchToNextEventDispatcher = true;

          for (var i = 0; i < length; ++i) {
            var pointerEventProcessor = pointerEventProcessorList[i];

            if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventTouch) {
              if (eventTouch.type === InputEventType.TOUCH_START) {
                if (pointerEventProcessor._handleEventTouch(eventTouch)) {
                  pointerEventProcessor.claimedTouchIdList.push(touch.getID());
                  dispatchToNextEventDispatcher = false;

                  if (!eventTouch.preventSwallow) {
                    break;
                  } else {
                    eventTouch.preventSwallow = false;
                  }
                }
              } else if (pointerEventProcessor.claimedTouchIdList.length > 0) {
                var index = pointerEventProcessor.claimedTouchIdList.indexOf(touch.getID());

                if (index !== -1) {
                  pointerEventProcessor._handleEventTouch(eventTouch);

                  if (eventTouch.type === InputEventType.TOUCH_END || eventTouch.type === InputEventType.TOUCH_CANCEL) {
                    js.array.removeAt(pointerEventProcessor.claimedTouchIdList, index);
                  }

                  dispatchToNextEventDispatcher = false;

                  if (!eventTouch.preventSwallow) {
                    break;
                  } else {
                    eventTouch.preventSwallow = false;
                  }
                }
              }
            }
          }

          if (--this._inDispatchCount <= 0) {
            this._updatePointerEventProcessorList();
          }

          return dispatchToNextEventDispatcher;
        };

        _proto._updatePointerEventProcessorList = function _updatePointerEventProcessorList() {
          var listToAdd = this._processorListToAdd;
          var addLength = listToAdd.length;

          for (var i = 0; i < addLength; ++i) {
            this.addPointerEventProcessor(listToAdd[i]);
          }

          listToAdd.length = 0;
          var listToRemove = this._processorListToRemove;
          var removeLength = listToRemove.length;

          for (var _i = 0; _i < removeLength; ++_i) {
            this.removePointerEventProcessor(listToRemove[_i]);
          }

          listToRemove.length = 0;
        };

        _proto._sortPointerEventProcessorList = function _sortPointerEventProcessorList() {
          if (!this._isListDirty) {
            return;
          }

          var pointerEventProcessorList = this._pointerEventProcessorList;
          var length = pointerEventProcessorList.length;

          for (var i = 0; i < length; ++i) {
            var pointerEventProcessor = pointerEventProcessorList[i];
            var node = pointerEventProcessor.node;

            if (node._uiProps) {
              var trans = node._uiProps.uiTransformComp;
              pointerEventProcessor.cachedCameraPriority = trans.cameraPriority;
            }
          }

          pointerEventProcessorList.sort(this._sortByPriority);
          this._isListDirty = false;
        };

        _proto._sortByPriority = function _sortByPriority(p1, p2) {
          var node1 = p1.node;
          var node2 = p2.node;

          if (!p2 || !node2 || !node2.activeInHierarchy || !node2._uiProps.uiTransformComp) {
            return -1;
          } else if (!p1 || !node1 || !node1.activeInHierarchy || !node1._uiProps.uiTransformComp) {
            return 1;
          }

          if (p1.cachedCameraPriority !== p2.cachedCameraPriority) {
            return p2.cachedCameraPriority - p1.cachedCameraPriority;
          }

          var n1 = node1;
          var n2 = node2;
          var ex = false;

          while (((_n1$parent = n1.parent) === null || _n1$parent === void 0 ? void 0 : _n1$parent._id) !== ((_n2$parent = n2.parent) === null || _n2$parent === void 0 ? void 0 : _n2$parent._id)) {
            var _n1$parent, _n2$parent, _n, _n$parent, _n2, _n2$parent2;

            n1 = ((_n = n1) === null || _n === void 0 ? void 0 : (_n$parent = _n.parent) === null || _n$parent === void 0 ? void 0 : _n$parent.parent) === null ? (ex = true) && node2 : n1 && n1.parent;
            n2 = ((_n2 = n2) === null || _n2 === void 0 ? void 0 : (_n2$parent2 = _n2.parent) === null || _n2$parent2 === void 0 ? void 0 : _n2$parent2.parent) === null ? (ex = true) && node1 : n2 && n2.parent;
          }

          if (n1._id === n2._id) {
            if (n1._id === node2._id) {
              return -1;
            }

            if (n1._id === node1._id) {
              return 1;
            }
          }

          var priority1 = n1 ? n1.getSiblingIndex() : 0;
          var priority2 = n2 ? n2.getSiblingIndex() : 0;
          return ex ? priority1 - priority2 : priority2 - priority1;
        };

        _proto._markListDirty = function _markListDirty() {
          this._isListDirty = true;
        };

        return PointerEventDispatcher;
      }();

      var pointerEventDispatcher = new PointerEventDispatcher();

      var _dsInfo = new DescriptorSetInfo(null);

      var m4_1 = new Mat4();
      var Batcher2D = exports('UI', function () {
        function Batcher2D(_root) {
          var _this = this;

          this.device = void 0;
          this._screens = [];
          this._staticVBBuffer = null;
          this._bufferAccessors = new Map();
          this._drawBatchPool = void 0;
          this._batches = void 0;
          this._currBID = -1;
          this._indexStart = 0;
          this._emptyMaterial = new Material();
          this._currRenderData = null;
          this._currMaterial = this._emptyMaterial;
          this._currTexture = null;
          this._currSampler = null;
          this._currStaticRoot = null;
          this._currComponent = null;
          this._currTransform = null;
          this._currTextureHash = 0;
          this._currSamplerHash = 0;
          this._currLayer = 0;
          this._currDepthStencilStateStage = null;
          this._currIsStatic = false;
          this._currHash = 0;
          this._pOpacity = 1;
          this._opacityDirty = 0;
          this._descriptorSetCache = new DescriptorSetCache();
          this._meshDataArray = [];
          this._maskClearModel = null;
          this._maskClearMtl = null;
          this._maskModelMesh = null;
          this._root = _root;
          this.device = _root.device;
          this._batches = new CachedArray(64);
          this._drawBatchPool = new Pool(function () {
            return new DrawBatch2D();
          }, 128, function (obj) {
            return obj.destroy(_this);
          });
        }

        var _proto = Batcher2D.prototype;

        _proto.initialize = function initialize() {
          return true;
        };

        _proto.destroy = function destroy() {
          for (var i = 0; i < this._batches.length; i++) {
            if (this._batches.array[i]) {
              this._batches.array[i].destroy(this);
            }
          }

          this._batches.destroy();

          this._bufferAccessors.forEach(function (accessor) {
            accessor.destroy();
          });

          this._bufferAccessors.clear();

          if (this._drawBatchPool) {
            this._drawBatchPool.destroy();
          }

          this._descriptorSetCache.destroy();

          StencilManager.sharedManager.destroy();

          if (this._maskClearModel && this._maskModelMesh) {
            legacyCC.director.root.destroyModel(this._maskClearModel);

            this._maskModelMesh.destroy();
          }

          if (this._maskClearMtl) {
            this._maskClearMtl.destroy();
          }
        };

        _proto.syncRootNodesToNative = function syncRootNodesToNative() {
        };

        _proto.addScreen = function addScreen(comp) {
          this._screens.push(comp);

          this._screens.sort(this._screenSort);
        };

        _proto.removeScreen = function removeScreen(comp) {
          var idx = this._screens.indexOf(comp);

          if (idx === -1) {
            return;
          }

          this._screens.splice(idx, 1);
        };

        _proto.sortScreens = function sortScreens() {
          this._screens.sort(this._screenSort);
        };

        _proto.getFirstRenderCamera = function getFirstRenderCamera(node) {
          if (node.scene && node.scene.renderScene) {
            var cameras = node.scene.renderScene.cameras;

            for (var i = 0; i < cameras.length; i++) {
              var camera = cameras[i];

              if (camera.visibility & node.layer) {
                return camera;
              }
            }
          }

          return null;
        };

        _proto.update = function update() {

          var screens = this._screens;
          var offset = 0;

          for (var i = 0; i < screens.length; ++i) {
            var screen = screens[i];

            var _scene = screen._getRenderScene();

            if (!screen.enabledInHierarchy || !_scene) {
              continue;
            }

            this._opacityDirty = 0;
            this._pOpacity = 1;
            this.walk(screen.node);
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
            var batchPriority = 0;

            if (this._batches.length > offset) {
              for (; offset < this._batches.length; ++offset) {
                var batch = this._batches.array[offset];

                if (batch.model) {
                  var subModels = batch.model.subModels;

                  for (var j = 0; j < subModels.length; j++) {
                    subModels[j].priority = batchPriority++;
                  }
                } else {
                  batch.descriptorSet = this._descriptorSetCache.getDescriptorSet(batch);
                }

                _scene.addBatch(batch);
              }
            }
          }
        };

        _proto.uploadBuffers = function uploadBuffers() {
          if (this._batches.length > 0) {
            this._meshDataArray.forEach(function (rd) {
              rd.uploadBuffers();
            });

            this._bufferAccessors.forEach(function (accessor) {
              accessor.uploadBuffers();
              accessor.reset();
            });

            this._descriptorSetCache.update();
          }
        };

        _proto.reset = function reset() {
          {
            for (var i = 0; i < this._batches.length; ++i) {
              var batch = this._batches.array[i];

              if (batch.isStatic) {
                continue;
              }

              batch.clear();

              this._drawBatchPool.free(batch);
            }

            this._bufferAccessors.forEach(function (accessor) {
              accessor.reset();
            });

            this._meshDataArray.forEach(function (rd) {
              rd.freeIAPool();
            });

            this._meshDataArray.length = 0;
            this._staticVBBuffer = null;
            this._currBID = -1;
            this._indexStart = 0;
            this._currHash = 0;
            this._currLayer = 0;
            this._currRenderData = null;
            this._currMaterial = this._emptyMaterial;
            this._currTexture = null;
            this._currSampler = null;
            this._currComponent = null;
            this._currTransform = null;

            this._batches.clear();

            StencilManager.sharedManager.reset();
          }
        };

        _proto.switchBufferAccessor = function switchBufferAccessor(attributes) {
          if (attributes === void 0) {
            attributes = vfmtPosUvColor;
          }

          var strideBytes = attributes === vfmtPosUvColor ? 36 : getAttributeStride(attributes);

          if (!this._staticVBBuffer || this._staticVBBuffer.vertexFormatBytes !== strideBytes) {
            var accessor = this._bufferAccessors.get(strideBytes);

            if (!accessor) {
              accessor = new StaticVBAccessor(this.device, attributes);

              this._bufferAccessors.set(strideBytes, accessor);
            }

            this._staticVBBuffer = accessor;
            this._currBID = -1;
          }

          return this._staticVBBuffer;
        };

        _proto.registerBufferAccessor = function registerBufferAccessor(key, accessor) {
          this._bufferAccessors.set(key, accessor);
        };

        _proto.updateBuffer = function updateBuffer(attributes, bid) {
          var accessor = this.switchBufferAccessor(attributes);

          if (this._currBID !== bid) {
            this._currBID = bid;
            this._indexStart = accessor.getMeshBuffer(bid).indexOffset;
          }
        };

        _proto.commitComp = function commitComp(comp, renderData, frame, assembler, transform) {
          var dataHash = 0;
          var mat;
          var bufferID = -1;

          if (renderData && renderData.chunk) {
            if (!renderData.isValid()) return;
            dataHash = renderData.dataHash;
            mat = renderData.material;
            bufferID = renderData.chunk.bufferId;
          }

          if (comp.stencilStage === Stage.ENTER_LEVEL || comp.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
            this._insertMaskBatch(comp);
          } else {
            comp.stencilStage = StencilManager.sharedManager.stage;
          }

          var depthStencilStateStage = comp.stencilStage;

          if (this._currHash !== dataHash || dataHash === 0 || this._currMaterial !== mat || this._currDepthStencilStateStage !== depthStencilStateStage) {
            this.autoMergeBatches(this._currComponent);

            if (renderData && !renderData._isMeshBuffer) {
              this.updateBuffer(renderData.vertexFormat, bufferID);
            }

            this._currRenderData = renderData;
            this._currHash = renderData ? renderData.dataHash : 0;
            this._currComponent = comp;
            this._currTransform = transform;
            this._currMaterial = comp.getRenderMaterial(0);
            this._currDepthStencilStateStage = depthStencilStateStage;
            this._currLayer = comp.node.layer;

            if (frame) {
              this._currTexture = frame.getGFXTexture();
              this._currSampler = frame.getGFXSampler();
              this._currTextureHash = frame.getHash();
              this._currSamplerHash = this._currSampler.hash;
            } else {
              this._currTexture = null;
              this._currSampler = null;
              this._currTextureHash = 0;
              this._currSamplerHash = 0;
            }
          }

          assembler.fillBuffers(comp, this);
        };

        _proto.commitIA = function commitIA(renderComp, ia, tex, mat, transform) {
          if (this._currMaterial !== this._emptyMaterial) {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
          }

          var depthStencil;
          var dssHash = 0;

          if (renderComp) {
            renderComp.stencilStage = StencilManager.sharedManager.stage;

            if (renderComp.customMaterial !== null) {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
            } else {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
            }

            dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          }

          var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = renderComp.node.layer;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = transform || null;

          if (tex) {
            curDrawBatch.texture = tex.getGFXTexture();
            curDrawBatch.sampler = tex.getGFXSampler();
            curDrawBatch.textureHash = tex.getHash();
            curDrawBatch.samplerHash = curDrawBatch.sampler.hash;
          }

          curDrawBatch.fillPasses(mat || null, depthStencil, dssHash, null);

          this._batches.push(curDrawBatch);
        };

        _proto.commitModel = function commitModel(comp, model, mat) {
          if (this._currMaterial !== this._emptyMaterial) {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
          }

          var depthStencil;
          var dssHash = 0;

          if (mat) {
            if (comp.stencilStage === Stage.ENTER_LEVEL || comp.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
              this._insertMaskBatch(comp);
            } else {
              comp.stencilStage = StencilManager.sharedManager.stage;
            }

            depthStencil = StencilManager.sharedManager.getStencilStage(comp.stencilStage, mat);
            dssHash = StencilManager.sharedManager.getStencilHash(comp.stencilStage);
          }

          var stamp = legacyCC.director.getTotalFrames();

          if (model) {
            model.updateTransform(stamp);
            model.updateUBOs(stamp);
          }

          for (var i = 0; i < model.subModels.length; i++) {
            var curDrawBatch = this._drawBatchPool.alloc();

            var subModel = model.subModels[i];
            curDrawBatch.visFlags = comp.node.layer;
            curDrawBatch.model = model;
            curDrawBatch.texture = null;
            curDrawBatch.sampler = null;
            curDrawBatch.useLocalData = null;

            if (!depthStencil) {
              depthStencil = null;
            }

            curDrawBatch.fillPasses(mat, depthStencil, dssHash, subModel.patches);
            curDrawBatch.inputAssembler = subModel.inputAssembler;
            curDrawBatch.model.visFlags = curDrawBatch.visFlags;
            curDrawBatch.descriptorSet = subModel.descriptorSet;

            this._batches.push(curDrawBatch);
          }
        };

        _proto.setupStaticBatch = function setupStaticBatch(staticComp, bufferAccessor) {
          this.finishMergeBatches();
          this._staticVBBuffer = bufferAccessor;
          this.currStaticRoot = staticComp;
        };

        _proto.endStaticBatch = function endStaticBatch() {
          this.finishMergeBatches();
          this.currStaticRoot = null;
          this._staticVBBuffer = null;
          this.switchBufferAccessor();
        };

        _proto.commitStaticBatch = function commitStaticBatch(comp) {
          this._batches.concat(comp.drawBatchList);

          this.finishMergeBatches();
        };

        _proto.autoMergeBatches = function autoMergeBatches(renderComp) {
          var mat = this._currMaterial;

          if (!mat) {
            return;
          }

          var ia;
          var rd = this._currRenderData;
          var accessor = this._staticVBBuffer;

          if (rd && rd._isMeshBuffer) {
            ia = rd.requestIA(this.device);

            if (this._meshDataArray.indexOf(rd) === -1) {
              this._meshDataArray.push(rd);
            }
          } else if (accessor) {
            var bid = this._currBID;
            var buf = accessor.getMeshBuffer(bid);

            if (!buf) {
              return;
            }

            var indexCount = buf.indexOffset - this._indexStart;
            if (indexCount <= 0) return;
            assertIsTrue(this._indexStart < buf.indexOffset);
            buf.setDirty();
            ia = buf.requireFreeIA(this.device);
            ia.firstIndex = this._indexStart;
            ia.indexCount = indexCount;
            this._indexStart = buf.indexOffset;
          }

          this._currBID = -1;

          if (!ia) {
            return;
          }

          var depthStencil;
          var dssHash = 0;

          if (renderComp) {
            if (renderComp.customMaterial !== null) {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
            } else {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
            }

            dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          }

          var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = this._currLayer;
          curDrawBatch.texture = this._currTexture;
          curDrawBatch.sampler = this._currSampler;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = this._currTransform;
          curDrawBatch.textureHash = this._currTextureHash;
          curDrawBatch.samplerHash = this._currSamplerHash;
          curDrawBatch.fillPasses(mat, depthStencil, dssHash, null);

          this._batches.push(curDrawBatch);
        };

        _proto.forceMergeBatches = function forceMergeBatches(material, frame, renderComp) {
          this._currMaterial = material;

          if (frame) {
            this._currTexture = frame.getGFXTexture();
            this._currSampler = frame.getGFXSampler();
            this._currTextureHash = frame.getHash();
            this._currSamplerHash = this._currSampler.hash;
          } else {
            this._currTexture = this._currSampler = null;
            this._currTextureHash = this._currSamplerHash = 0;
          }

          this._currLayer = renderComp.node.layer;
          this.autoMergeBatches(renderComp);
        };

        _proto.resetRenderStates = function resetRenderStates() {
          this._currMaterial = this._emptyMaterial;
          this._currRenderData = null;
          this._currTexture = null;
          this._currComponent = null;
          this._currTransform = null;
          this._currTextureHash = 0;
          this._currSamplerHash = 0;
          this._currLayer = 0;
        };

        _proto.finishMergeBatches = function finishMergeBatches() {
          this.autoMergeBatches();
          this.resetRenderStates();
        };

        _proto.flushMaterial = function flushMaterial(mat) {
          this._currMaterial = mat;
        };

        _proto.walk = function walk(node, level) {
          if (level === void 0) {
            level = 0;
          }

          if (!node.activeInHierarchy) {
            return;
          }

          var children = node.children;
          var uiProps = node._uiProps;
          var render = uiProps.uiComp;
          var parentOpacity = this._pOpacity;
          var opacity = parentOpacity;
          var selfOpacity = render && render.color ? render.color.a / 255 : 1;
          this._pOpacity = opacity *= selfOpacity * uiProps.localOpacity;
          uiProps._opacity = opacity;

          if (uiProps.colorDirty) {
            this._opacityDirty++;
          }

          if (render && render.enabledInHierarchy) {
            render.fillBuffers(this);
          }

          if (this._opacityDirty && render && !render.useVertexOpacity && render.renderData && render.renderData.vertexCount > 0) {
            updateOpacity(render.renderData, opacity);
            var buffer = render.renderData.getMeshBuffer();

            if (buffer) {
              buffer.setDirty();
            }
          }

          if (children.length > 0 && !node._static) {
            for (var i = 0; i < children.length; ++i) {
              var child = children[i];
              this.walk(child, level);
            }
          }

          if (uiProps.colorDirty) {
            this._opacityDirty--;
            uiProps.colorDirty = false;
          }

          this._pOpacity = parentOpacity;

          if (render && render.enabledInHierarchy) {
            render.postUpdateAssembler(this);

            if ((render.stencilStage === Stage.ENTER_LEVEL || render.stencilStage === Stage.ENTER_LEVEL_INVERTED) && StencilManager.sharedManager.getMaskStackSize() > 0) {
              this.autoMergeBatches(this._currComponent);
              this.resetRenderStates();
              StencilManager.sharedManager.exitMask();
            }
          }

          level += 1;
        };

        _proto._screenSort = function _screenSort(a, b) {
          return a.node.getSiblingIndex() - b.node.getSiblingIndex();
        };

        _proto._releaseDescriptorSetCache = function _releaseDescriptorSetCache(textureHash, sampler) {

          {
            this._descriptorSetCache.releaseDescriptorSetCache(textureHash);
          }
        };

        _proto._createClearModel = function _createClearModel() {
          if (!this._maskClearModel) {
            this._maskClearMtl = builtinResMgr.get('default-clear-stencil');
            this._maskClearModel = legacyCC.director.root.createModel(Model);
            var stride = getAttributeStride(vfmt);
            var gfxDevice = deviceManager.gfxDevice;
            var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 4 * stride, stride));
            var vb = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
            vertexBuffer.update(vb);
            var indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
            var ib = new Uint16Array([0, 1, 2, 2, 1, 3]);
            indexBuffer.update(ib);
            this._maskModelMesh = new RenderingSubMesh([vertexBuffer], vfmt, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
            this._maskModelMesh.subMeshIdx = 0;

            this._maskClearModel.initSubModel(0, this._maskModelMesh, this._maskClearMtl);
          }
        };

        _proto._insertMaskBatch = function _insertMaskBatch(comp) {
          this.autoMergeBatches(this._currComponent);
          this.resetRenderStates();

          this._createClearModel();

          this._maskClearModel.node = this._maskClearModel.transform = comp.node;
          var _stencilManager = StencilManager.sharedManager;

          _stencilManager.pushMask(1);

          var stage = _stencilManager.clear(comp);

          var depthStencil;
          var dssHash = 0;
          var mat = this._maskClearMtl;

          if (mat) {
            depthStencil = _stencilManager.getStencilStage(stage, mat);
            dssHash = _stencilManager.getStencilHash(stage);
          }

          var model = this._maskClearModel;
          var stamp = legacyCC.director.getTotalFrames();

          if (model) {
            model.updateTransform(stamp);
            model.updateUBOs(stamp);
          }

          for (var i = 0; i < model.subModels.length; i++) {
            var curDrawBatch = this._drawBatchPool.alloc();

            var subModel = model.subModels[i];
            curDrawBatch.visFlags = comp.node.layer;
            curDrawBatch.model = model;
            curDrawBatch.texture = null;
            curDrawBatch.sampler = null;
            curDrawBatch.useLocalData = null;

            if (!depthStencil) {
              depthStencil = null;
            }

            curDrawBatch.fillPasses(mat, depthStencil, dssHash, subModel.patches);
            curDrawBatch.inputAssembler = subModel.inputAssembler;
            curDrawBatch.model.visFlags = curDrawBatch.visFlags;
            curDrawBatch.descriptorSet = subModel.descriptorSet;

            this._batches.push(curDrawBatch);
          }

          _stencilManager.enableMask();
        };

        _proto.syncMeshBuffersToNative = function syncMeshBuffersToNative(accId, buffers) {
        };

        _createClass(Batcher2D, [{
          key: "nativeObj",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "currBufferAccessor",
          get: function get() {
            if (this._staticVBBuffer) return this._staticVBBuffer;
            this._staticVBBuffer = this.switchBufferAccessor();
            return this._staticVBBuffer;
          }
        }, {
          key: "batches",
          get: function get() {
            return this._batches;
          }
        }, {
          key: "currStaticRoot",
          set: function set(value) {
            this._currStaticRoot = value;
          }
        }, {
          key: "currIsStatic",
          set: function set(value) {
            this._currIsStatic = value;
          }
        }]);

        return Batcher2D;
      }());

      var LocalDescriptorSet = function () {
        function LocalDescriptorSet() {
          this._descriptorSet = null;
          this._transform = null;
          this._textureHash = 0;
          this._samplerHash = 0;
          this._localBuffer = null;
          this._transformUpdate = true;
          var device = deviceManager.gfxDevice;
          this._localData = new Float32Array(UBOLocal.COUNT);
          this._localBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));
        }

        var _proto2 = LocalDescriptorSet.prototype;

        _proto2.initialize = function initialize(batch) {
          var device = deviceManager.gfxDevice;
          this._transform = batch.useLocalData;
          this._textureHash = batch.textureHash;
          this._samplerHash = batch.samplerHash;
          _dsInfo.layout = batch.passes[0].localSetLayout;
          this._descriptorSet = device.createDescriptorSet(_dsInfo);

          this._descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);

          var binding = ModelLocalBindings.SAMPLER_SPRITE;

          this._descriptorSet.bindTexture(binding, batch.texture);

          this._descriptorSet.bindSampler(binding, batch.sampler);

          this._descriptorSet.update();

          this._transformUpdate = true;
        };

        _proto2.updateTransform = function updateTransform(transform) {
          if (transform === this._transform) return;
          this._transform = transform;
          this._transformUpdate = true;
          this.uploadLocalData();
        };

        _proto2.equals = function equals(transform, textureHash, samplerHash) {
          return this._transform === transform && this._textureHash === textureHash && this._samplerHash === samplerHash;
        };

        _proto2.reset = function reset() {
          this._transform = null;
          this._textureHash = 0;
          this._samplerHash = 0;
        };

        _proto2.destroy = function destroy() {
          if (this._localBuffer) {
            this._localBuffer.destroy();

            this._localBuffer = null;
          }

          if (this._descriptorSet) {
            this._descriptorSet.destroy();

            this._descriptorSet = null;
          }

          this._localData = null;
        };

        _proto2.isValid = function isValid() {
          return this._transform && this._transform.isValid;
        };

        _proto2.uploadLocalData = function uploadLocalData() {
          var node = this._transform;

          if (node.hasChangedFlags || node._dirtyFlags) {
            node.updateWorldTransform();
            this._transformUpdate = true;
          }

          if (this._transformUpdate) {
            var worldMatrix = node.worldMatrix;
            Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
            Mat4.inverseTranspose(m4_1, worldMatrix);

            {
              var det = Mat4.determinant(m4_1);
              var factor = 1.0 / Math.sqrt(det);
              Mat4.multiplyScalar(m4_1, m4_1, factor);
            }

            Mat4.toArray(this._localData, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET);

            this._localBuffer.update(this._localData);

            this._transformUpdate = false;
          }
        };

        _createClass(LocalDescriptorSet, [{
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          }
        }]);

        return LocalDescriptorSet;
      }();

      var DescriptorSetCache = function () {
        function DescriptorSetCache() {
          this._descriptorSetCache = new Map();
          this._dsCacheHashByTexture = new Map();
          this._localDescriptorSetCache = [];
          this._localCachePool = void 0;
          this._localCachePool = new Pool(function () {
            return new LocalDescriptorSet();
          }, 16, function (obj) {
            return obj.destroy();
          });
        }

        var _proto3 = DescriptorSetCache.prototype;

        _proto3.getDescriptorSet = function getDescriptorSet(batch) {
          var root = legacyCC.director.root;
          var hash;

          if (batch.useLocalData) {
            var caches = this._localDescriptorSetCache;

            for (var i = 0, len = caches.length; i < len; i++) {
              var cache = caches[i];

              if (cache.equals(batch.useLocalData, batch.textureHash, batch.samplerHash)) {
                return cache.descriptorSet;
              }
            }

            var localDs = this._localCachePool.alloc();

            localDs.initialize(batch);

            this._localDescriptorSetCache.push(localDs);

            return localDs.descriptorSet;
          } else {
            hash = batch.textureHash ^ batch.samplerHash;

            if (this._descriptorSetCache.has(hash)) {
              return this._descriptorSetCache.get(hash);
            } else {
              _dsInfo.layout = batch.passes[0].localSetLayout;
              var descriptorSet = deviceManager.gfxDevice.createDescriptorSet(_dsInfo);
              var binding = ModelLocalBindings.SAMPLER_SPRITE;
              descriptorSet.bindTexture(binding, batch.texture);
              descriptorSet.bindSampler(binding, batch.sampler);
              descriptorSet.update();

              this._descriptorSetCache.set(hash, descriptorSet);

              this._dsCacheHashByTexture.set(batch.textureHash, hash);

              return descriptorSet;
            }
          }
        };

        _proto3.update = function update() {
          var caches = this._localDescriptorSetCache;
          var uselessArray = [];
          caches.forEach(function (value) {
            if (value.isValid()) {
              value.uploadLocalData();
            } else {
              value.reset();
              var pos = caches.indexOf(value);
              uselessArray.push(pos);
            }
          });

          for (var i = uselessArray.length - 1; i >= 0; i--) {
            caches.splice(uselessArray[i], 1);
          }
        };

        _proto3.reset = function reset() {
          var _this2 = this;

          var caches = this._localDescriptorSetCache;
          caches.forEach(function (value) {
            _this2._localCachePool.free(value);
          });
          this._localDescriptorSetCache.length = 0;
        };

        _proto3.releaseDescriptorSetCache = function releaseDescriptorSetCache(textureHash) {
          var key = this._dsCacheHashByTexture.get(textureHash);

          if (key && this._descriptorSetCache.has(key)) {
            this._descriptorSetCache.get(key).destroy();

            this._descriptorSetCache["delete"](key);

            this._dsCacheHashByTexture["delete"](textureHash);
          }
        };

        _proto3.destroy = function destroy() {
          this._descriptorSetCache.forEach(function (value, key, map) {
            value.destroy();
          });

          this._descriptorSetCache.clear();

          this._dsCacheHashByTexture.clear();

          this._localDescriptorSetCache.length = 0;

          this._localCachePool.destroy();
        };

        return DescriptorSetCache;
      }();

      legacyCC.internal.Batcher2D = Batcher2D;

      var UIDrawBatch = exports('UIDrawBatch', function (_DrawBatch2D) {
        _inheritsLoose(UIDrawBatch, _DrawBatch2D);

        function UIDrawBatch() {
          return _DrawBatch2D.apply(this, arguments) || this;
        }

        return UIDrawBatch;
      }(DrawBatch2D));

      markAsWarning(MeshBuffer.prototype, 'MeshBuffer', ['byteStart', 'vertexStart', 'indicesStart', 'request'].map(function (item) {
        return {
          name: item,
          suggest: "please use meshBuffer.accessor." + item + " instead"
        };
      }));
      replaceProperty(MeshBuffer.prototype, 'MeshBuffer', [{
        name: 'indicesOffset',
        newName: 'indexOffset'
      }]);
      removeProperty(MeshBuffer.prototype, 'MeshBuffer', [{
        name: 'vertexBuffers'
      }, {
        name: 'indexBuffer'
      }]);
      replaceProperty(Batcher2D.prototype, 'Batcher2D', [{
        name: 'currBufferBatch',
        newName: 'currBufferAccessor'
      }, {
        name: 'acquireBufferBatch',
        newName: 'switchBufferAccessor'
      }]);
      removeProperty(MeshRenderData.prototype, 'MeshRenderData', [{
        name: 'formatByte'
      }, {
        name: 'byteStart'
      }, {
        name: 'byteCount'
      }]);
      replaceProperty(MeshRenderData.prototype, 'MeshRenderData', [{
        name: 'indicesStart',
        newName: 'indexStart'
      }]);
      var QuadRenderData = exports('QuadRenderData', function (_MeshRenderData) {
        _inheritsLoose(QuadRenderData, _MeshRenderData);

        function QuadRenderData(vertexFormat) {
          var _this;

          _this = _MeshRenderData.call(this, vertexFormat) || this;
          warnID(9006);
          return _this;
        }

        return QuadRenderData;
      }(MeshRenderData));

      var _canvasContext = null;

      var _intervalId = -1;

      var _testString = "BES bswy:->@123\u4E01\u3041\u1101";

      var _fontFaces = Object.create(null);

      var _loadingFonts = [];
      var _timeout = 3000;

      var useNativeCheck = function () {
        var nativeCheck;
        return function () {
          if (nativeCheck === undefined) {
            if ('FontFace' in window) {
              var match = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent);
              var safari10Match = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);

              if (match) {
                nativeCheck = parseInt(match[1], 10) > 42;
              } else if (safari10Match) {
                nativeCheck = false;
              } else {
                nativeCheck = true;
              }
            } else {
              nativeCheck = false;
            }
          }

          return nativeCheck;
        };
      }();

      function checkFontLoaded() {
        var allFontsLoaded = true;
        var now = Date.now();

        for (var i = _loadingFonts.length - 1; i >= 0; i--) {
          var fontLoadHandle = _loadingFonts[i];
          var fontFamily = fontLoadHandle.fontFamilyName;

          if (now - fontLoadHandle.startTime > _timeout) {
            warnID(4933, fontFamily);
            fontLoadHandle.onComplete(null, fontFamily);

            _loadingFonts.splice(i, 1);

            continue;
          }

          var oldWidth = fontLoadHandle.refWidth;
          var fontDesc = "40px " + fontFamily;
          _canvasContext.font = fontDesc;
          var newWidth = safeMeasureText(_canvasContext, _testString, fontDesc);

          if (oldWidth !== newWidth) {
            _loadingFonts.splice(i, 1);

            fontLoadHandle.onComplete(null, fontFamily);
          } else {
            allFontsLoaded = false;
          }
        }

        if (allFontsLoaded) {
          clearInterval(_intervalId);
          _intervalId = -1;
        }
      }

      function nativeCheckFontLoaded(start, font, callback) {
        var loader = new Promise(function (resolve, reject) {
          var check = function check() {
            var now = Date.now();

            if (now - start >= _timeout) {
              reject();
            } else {
              document.fonts.load("40px " + font).then(function (fonts) {
                if (fonts.length >= 1) {
                  resolve();
                } else {
                  setTimeout(check, 100);
                }
              }, function () {
                reject();
              });
            }
          };

          check();
        });
        var timeoutId = null;
        var timer = new Promise(function (resolve, reject) {
          timeoutId = setTimeout(reject, _timeout);
        });
        Promise.race([timer, loader]).then(function () {
          if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }

          callback(null, font);
        }, function () {
          warnID(4933, font);
          callback(null, font);
        });
      }

      function loadFont(url, options, onComplete) {
        var fontFamilyName = getFontFamily(url);

        if (_fontFaces[fontFamilyName]) {
          onComplete(null, fontFamilyName);
          return;
        }

        if (!_canvasContext) {
          var labelCanvas = document.createElement('canvas');
          labelCanvas.width = 100;
          labelCanvas.height = 100;
          _canvasContext = labelCanvas.getContext('2d');
        }

        var fontDesc = "40px " + fontFamilyName;
        var refWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
        var fontStyle = document.createElement('style');
        fontStyle.type = 'text/css';
        var fontStr = '';

        if (Number.isNaN(fontFamilyName)) {
          fontStr += "@font-face { font-family:" + fontFamilyName + "; src:";
        } else {
          fontStr += "@font-face { font-family:\"" + fontFamilyName + "\"; src:";
        }

        fontStr += "url(\"" + url + "\");";
        fontStyle.textContent = fontStr + "}";
        document.body.appendChild(fontStyle);
        var preloadDiv = document.createElement('div');
        var divStyle = preloadDiv.style;
        divStyle.fontFamily = fontFamilyName;
        preloadDiv.innerHTML = '.';
        divStyle.position = 'absolute';
        divStyle.left = '-100px';
        divStyle.top = '-100px';
        document.body.appendChild(preloadDiv);

        if (useNativeCheck()) {
          nativeCheckFontLoaded(Date.now(), fontFamilyName, onComplete);
        } else {
          var fontLoadHandle = {
            fontFamilyName: fontFamilyName,
            refWidth: refWidth,
            onComplete: onComplete,
            startTime: Date.now()
          };

          _loadingFonts.push(fontLoadHandle);

          if (_intervalId === -1) {
            _intervalId = setInterval(checkFontLoaded, 100);
          }
        }

        _fontFaces[fontFamilyName] = fontStyle;
      }
      function getFontFamily(fontHandle) {
        var ttfIndex = fontHandle.lastIndexOf('.ttf');

        if (ttfIndex === -1) {
          return fontHandle;
        }

        var slashPos = fontHandle.lastIndexOf('/');
        var fontFamilyName;

        if (slashPos === -1) {
          fontFamilyName = fontHandle.substring(0, ttfIndex) + "_LABEL";
        } else {
          fontFamilyName = fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
        }

        if (fontFamilyName.indexOf(' ') !== -1) {
          fontFamilyName = "\"" + fontFamilyName + "\"";
        }

        return fontFamilyName;
      }

      function createFont(id, data, options, onComplete) {
        var out = new TTFFont();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }

      downloader.register({
        '.font': loadFont,
        '.eot': loadFont,
        '.ttf': loadFont,
        '.woff': loadFont,
        '.svg': loadFont,
        '.ttc': loadFont
      });
      factory.register({
        '.font': createFont,
        '.eot': createFont,
        '.ttf': createFont,
        '.woff': createFont,
        '.svg': createFont,
        '.ttc': createFont
      });

      legacyCC.UI = {
        MeshBuffer: MeshBuffer,
        spriteAssembler: spriteAssembler,
        graphicsAssembler: graphicsAssemblerManager,
        labelAssembler: labelAssembler,
        RenderData: RenderData,
        MeshRenderData: MeshRenderData
      };

      var MorphModel = function (_Model) {
        _inheritsLoose(MorphModel, _Model);

        function MorphModel() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Model.call.apply(_Model, [this].concat(args)) || this;
          _this._morphRenderingInstance = null;
          _this._usedMaterials = new Set();
          return _this;
        }

        var _proto = MorphModel.prototype;

        _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
          var superMacroPatches = _Model.prototype.getMacroPatches.call(this, subModelIndex);

          if (this._morphRenderingInstance) {
            var morphInstanceMacroPatches = this._morphRenderingInstance.requiredPatches(subModelIndex);

            if (morphInstanceMacroPatches) {
              return morphInstanceMacroPatches.concat(superMacroPatches !== null && superMacroPatches !== void 0 ? superMacroPatches : []);
            }
          }

          return superMacroPatches;
        };

        _proto.initSubModel = function initSubModel(subModelIndex, subMeshData, material) {
          return _Model.prototype.initSubModel.call(this, subModelIndex, subMeshData, this._launderMaterial(material));
        };

        _proto.destroy = function destroy() {
          _Model.prototype.destroy.call(this);

          this._morphRenderingInstance = null;
        };

        _proto.setSubModelMaterial = function setSubModelMaterial(subModelIndex, material) {
          return _Model.prototype.setSubModelMaterial.call(this, subModelIndex, this._launderMaterial(material));
        };

        _proto.setMorphRendering = function setMorphRendering(morphRendering) {
          this._morphRenderingInstance = morphRendering;
        };

        _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
          _Model.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);

          if (this._morphRenderingInstance) {
            this._morphRenderingInstance.adaptPipelineState(submodelIdx, descriptorSet);
          }
        };

        _proto._launderMaterial = function _launderMaterial(material) {
          return material;
        };

        return MorphModel;
      }(Model);

      var _dec$n, _dec2$h, _class$n, _class2$i, _descriptor$g, _descriptor2$d, _descriptor3$a, _descriptor4$8, _descriptor5$6, _descriptor6$5, _temp$k, _dec3$g, _dec4$f, _dec5$d, _dec6$b, _dec7$a, _dec8$9, _dec9$6, _dec10$6, _dec11$5, _dec12$4, _dec13$4, _dec14$3, _dec15$3, _dec16$3, _dec17$3, _dec18$3, _dec19$3, _dec20$3, _dec21$3, _class4, _class5, _descriptor7$3, _descriptor8$3, _descriptor9$3, _descriptor10$3, _descriptor11$2, _descriptor12$2, _descriptor13$2, _class6, _temp2;
      var ModelShadowCastingMode = Enum({
        OFF: 0,
        ON: 1
      });
      var ModelShadowReceivingMode = Enum({
        OFF: 0,
        ON: 1
      });
      var ModelLightmapSettings = (_dec$n = ccclass('cc.ModelLightmapSettings'), _dec2$h = formerlySerializedAs('_recieveShadow'), _dec$n(_class$n = (_class2$i = (_temp$k = function () {
        function ModelLightmapSettings() {
          _initializerDefineProperty(this, "texture", _descriptor$g, this);

          _initializerDefineProperty(this, "uvParam", _descriptor2$d, this);

          _initializerDefineProperty(this, "_bakeable", _descriptor3$a, this);

          _initializerDefineProperty(this, "_castShadow", _descriptor4$8, this);

          _initializerDefineProperty(this, "_receiveShadow", _descriptor5$6, this);

          _initializerDefineProperty(this, "_lightmapSize", _descriptor6$5, this);
        }

        _createClass(ModelLightmapSettings, [{
          key: "bakeable",
          get: function get() {
            return this._bakeable;
          },
          set: function set(val) {
            this._bakeable = val;
          }
        }, {
          key: "castShadow",
          get: function get() {
            return this._castShadow;
          },
          set: function set(val) {
            this._castShadow = val;
          }
        }, {
          key: "receiveShadow",
          get: function get() {
            return this._receiveShadow;
          },
          set: function set(val) {
            this._receiveShadow = val;
          }
        }, {
          key: "lightmapSize",
          get: function get() {
            return this._lightmapSize;
          },
          set: function set(val) {
            this._lightmapSize = val;
          }
        }]);

        return ModelLightmapSettings;
      }(), _temp$k), (_descriptor$g = _applyDecoratedDescriptor(_class2$i.prototype, "texture", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$d = _applyDecoratedDescriptor(_class2$i.prototype, "uvParam", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec4();
        }
      }), _descriptor3$a = _applyDecoratedDescriptor(_class2$i.prototype, "_bakeable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor4$8 = _applyDecoratedDescriptor(_class2$i.prototype, "_castShadow", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor5$6 = _applyDecoratedDescriptor(_class2$i.prototype, "_receiveShadow", [_dec2$h], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor6$5 = _applyDecoratedDescriptor(_class2$i.prototype, "_lightmapSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 64;
        }
      }), _applyDecoratedDescriptor(_class2$i.prototype, "bakeable", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "bakeable"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "castShadow", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "castShadow"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "receiveShadow", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "receiveShadow"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "lightmapSize", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "lightmapSize"), _class2$i.prototype)), _class2$i)) || _class$n);
      var MeshRenderer = function (v) { return exports({ MeshRenderer: v, ModelComponent: v }), v; }((_dec3$g = ccclass('cc.MeshRenderer'), _dec4$f = help(), _dec5$d = executionOrder(100), _dec6$b = menu(), _dec7$a = type(CCFloat), _dec8$9 = tooltip(), _dec9$6 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 0
        }
      }), _dec10$6 = type(CCFloat), _dec11$5 = tooltip(), _dec12$4 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 1
        }
      }), _dec13$4 = type(ModelShadowCastingMode), _dec14$3 = tooltip(), _dec15$3 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 2
        }
      }), _dec16$3 = type(ModelShadowReceivingMode), _dec17$3 = tooltip(), _dec18$3 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 3
        }
      }), _dec19$3 = type(Mesh), _dec20$3 = tooltip(), _dec21$3 = visible(), _dec3$g(_class4 = _dec4$f(_class4 = _dec5$d(_class4 = _dec6$b(_class4 = executeInEditMode(_class4 = (_class5 = (_temp2 = _class6 = function (_ModelRenderer) {
        _inheritsLoose(MeshRenderer, _ModelRenderer);

        function MeshRenderer() {
          var _this;

          _this = _ModelRenderer.call(this) || this;

          _initializerDefineProperty(_this, "lightmapSettings", _descriptor7$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mesh", _descriptor8$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowCastingMode", _descriptor9$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowReceivingMode", _descriptor10$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowBias", _descriptor11$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowNormalBias", _descriptor12$2, _assertThisInitialized(_this));

          _this._subMeshShapesWeights = [];
          _this._modelType = void 0;
          _this._model = null;
          _this._morphInstance = null;

          _initializerDefineProperty(_this, "_enableMorph", _descriptor13$2, _assertThisInitialized(_this));

          _this._modelType = Model;
          return _this;
        }

        var _proto = MeshRenderer.prototype;

        _proto.onLoad = function onLoad() {
          if (this._mesh) {
            this._mesh.initialize();
          }

          if (!this._validateShapeWeights()) {
            this._initSubMeshShapesWeights();
          }

          this._watchMorphInMesh();

          this._updateModels();

          this._updateCastShadow();

          this._updateReceiveShadow();

          this._updateShadowBias();

          this._updateShadowNormalBias();
        };

        _proto.onRestore = function onRestore() {
          this._updateModels();

          if (this.enabledInHierarchy) {
            this._attachToScene();
          }

          this._updateCastShadow();

          this._updateReceiveShadow();

          this._updateShadowBias();

          this._updateShadowNormalBias();
        };

        _proto.onEnable = function onEnable() {
          _ModelRenderer.prototype.onEnable.call(this);

          if (!this._model) {
            this._updateModels();
          }

          this._updateCastShadow();

          this._updateReceiveShadow();

          this._updateShadowBias();

          this._updateShadowNormalBias();

          this._onUpdateLocalShadowBias();

          this._attachToScene();
        };

        _proto.onDisable = function onDisable() {
          if (this._model) {
            this._detachFromScene();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
            this._models.length = 0;
          }

          if (this._morphInstance) {
            this._morphInstance.destroy();
          }
        };

        _proto.onGeometryChanged = function onGeometryChanged() {
          if (this._model && this._mesh) {
            var meshStruct = this._mesh.struct;

            this._model.createBoundingShape(meshStruct.minPosition, meshStruct.maxPosition);

            this._model.updateWorldBound();

            this._model.onGeometryChanged();
          }
        };

        _proto.getWeight = function getWeight(subMeshIndex, shapeIndex) {
          var subMeshShapesWeights = this._subMeshShapesWeights;
          assertIsTrue(subMeshIndex < subMeshShapesWeights.length);
          var shapeWeights = this._subMeshShapesWeights[subMeshIndex];
          assertIsTrue(shapeIndex < shapeWeights.length);
          return shapeWeights[shapeIndex];
        };

        _proto.setWeights = function setWeights(weights, subMeshIndex) {
          var subMeshShapesWeights = this._subMeshShapesWeights;

          if (subMeshIndex >= subMeshShapesWeights.length) {
            return;
          }

          var shapeWeights = subMeshShapesWeights[subMeshIndex];

          if (shapeWeights.length !== weights.length) {
            return;
          }

          subMeshShapesWeights[subMeshIndex] = weights.slice(0);

          this._uploadSubMeshShapesWeights(subMeshIndex);
        };

        _proto.setWeight = function setWeight(weight, subMeshIndex, shapeIndex) {
          var subMeshShapesWeights = this._subMeshShapesWeights;

          if (subMeshIndex >= subMeshShapesWeights.length) {
            return;
          }

          var shapeWeights = subMeshShapesWeights[subMeshIndex];

          if (shapeIndex >= shapeWeights.length) {
            return;
          }

          shapeWeights[shapeIndex] = weight;

          this._uploadSubMeshShapesWeights(subMeshIndex);
        };

        _proto.setInstancedAttribute = function setInstancedAttribute(name, value) {
          if (!this.model) {
            return;
          }

          {
            var _this$model$instanced = this.model.instancedAttributes,
                attributes = _this$model$instanced.attributes,
                views = _this$model$instanced.views;

            for (var i = 0; i < attributes.length; i++) {
              if (attributes[i].name === name) {
                views[i].set(value);
                break;
              }
            }
          }
        };

        _proto._updateLightmap = function _updateLightmap(lightmap, uOff, vOff, scale, lum) {
          this.lightmapSettings.texture = lightmap;
          this.lightmapSettings.uvParam.x = uOff;
          this.lightmapSettings.uvParam.y = vOff;
          this.lightmapSettings.uvParam.z = scale;
          this.lightmapSettings.uvParam.w = lum;

          this._onUpdateLightingmap();
        };

        _proto._updateModels = function _updateModels() {
          if (!this.enabledInHierarchy) {
            return;
          }

          var model = this._model;

          if (model) {
            model.destroy();
            model.initialize();
            model.node = model.transform = this.node;
          } else {
            this._createModel();
          }

          if (this._model) {
            if (this._mesh) {
              var meshStruct = this._mesh.struct;

              this._model.createBoundingShape(meshStruct.minPosition, meshStruct.maxPosition);
            }

            this._model.initLightingmap(this.lightmapSettings.texture, this.lightmapSettings.uvParam);

            this._updateModelParams();

            this._onUpdateLightingmap();

            this._onUpdateLocalShadowBias();
          }
        };

        _proto._createModel = function _createModel() {
          var preferMorphOverPlain = !!this._morphInstance;
          var modelType = preferMorphOverPlain && this._modelType === Model ? MorphModel : this._modelType;
          var model = this._model = legacyCC.director.root.createModel(modelType);
          model.visFlags = this.visibility;
          model.node = model.transform = this.node;
          this._models.length = 0;

          this._models.push(this._model);

          if (this._morphInstance && model instanceof MorphModel) {
            model.setMorphRendering(this._morphInstance);
          }
        };

        _proto._attachToScene = function _attachToScene() {
          if (!this.node.scene || !this._model) {
            return;
          }

          var renderScene = this._getRenderScene();

          if (this._model.scene !== null) {
            this._detachFromScene();
          }

          renderScene.addModel(this._model);
        };

        _proto._detachFromScene = function _detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        };

        _proto._updateModelParams = function _updateModelParams() {
          if (!this._mesh || !this._model) {
            return;
          }

          this.node.hasChangedFlags |= TransformBit.POSITION;
          this._model.transform.hasChangedFlags |= TransformBit.POSITION;
          this._model.isDynamicBatching = this._isBatchingEnabled();
          var meshCount = this._mesh ? this._mesh.renderingSubMeshes.length : 0;
          var renderingMesh = this._mesh.renderingSubMeshes;

          if (renderingMesh) {
            for (var i = 0; i < meshCount; ++i) {
              var material = this.getRenderMaterial(i);

              if (material && !material.isValid) {
                material = null;
              }

              var subMeshData = renderingMesh[i];

              if (subMeshData) {
                this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
              }
            }
          }

          this._model.enabled = true;
        };

        _proto._onUpdateLightingmap = function _onUpdateLightingmap() {
          if (this.model !== null) {
            this.model.updateLightingmap(this.lightmapSettings.texture, this.lightmapSettings.uvParam);
          }

          this.setInstancedAttribute('a_lightingMapUVParam', [this.lightmapSettings.uvParam.x, this.lightmapSettings.uvParam.y, this.lightmapSettings.uvParam.z, this.lightmapSettings.uvParam.w]);
        };

        _proto._onUpdateLocalShadowBias = function _onUpdateLocalShadowBias() {
          if (this.model !== null) {
            this.model.updateLocalShadowBias();
          }

          this.setInstancedAttribute('a_localShadowBias', [this._shadowBias, this._shadowNormalBias]);
        };

        _proto._onMaterialModified = function _onMaterialModified(idx, material) {
          if (!this._model || !this._model.inited) {
            return;
          }

          this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
        };

        _proto._onRebuildPSO = function _onRebuildPSO(idx, material) {
          if (!this._model || !this._model.inited) {
            return;
          }

          this._model.isDynamicBatching = this._isBatchingEnabled();

          this._model.setSubModelMaterial(idx, material);

          this._onUpdateLightingmap();

          this._onUpdateLocalShadowBias();
        };

        _proto._onMeshChanged = function _onMeshChanged(old) {};

        _proto._clearMaterials = function _clearMaterials() {
          if (!this._model) {
            return;
          }

          var subModels = this._model.subModels;

          for (var i = 0; i < subModels.length; ++i) {
            this._onMaterialModified(i, null);
          }
        };

        _proto._getBuiltinMaterial = function _getBuiltinMaterial() {
          return builtinResMgr.get('missing-material');
        };

        _proto._onVisibilityChange = function _onVisibilityChange(val) {
          if (!this._model) {
            return;
          }

          this._model.visFlags = val;
        };

        _proto._updateShadowBias = function _updateShadowBias() {
          if (!this._model) {
            return;
          }

          this._model.shadowBias = this._shadowBias;
        };

        _proto._updateShadowNormalBias = function _updateShadowNormalBias() {
          if (!this._model) {
            return;
          }

          this._model.shadowNormalBias = this._shadowNormalBias;
        };

        _proto._updateCastShadow = function _updateCastShadow() {
          if (!this._model) {
            return;
          }

          if (this._shadowCastingMode === ModelShadowCastingMode.OFF) {
            this._model.castShadow = false;
          } else {
            assertIsTrue(this._shadowCastingMode === ModelShadowCastingMode.ON, "ShadowCastingMode " + this._shadowCastingMode + " is not supported.");
            this._model.castShadow = true;
          }
        };

        _proto._updateReceiveShadow = function _updateReceiveShadow() {
          if (!this._model) {
            return;
          }

          if (this._shadowReceivingMode === ModelShadowReceivingMode.OFF) {
            this._model.receiveShadow = false;
          } else {
            this._model.receiveShadow = true;
          }
        };

        _proto._isBatchingEnabled = function _isBatchingEnabled() {
          for (var i = 0; i < this._materials.length; ++i) {
            var mat = this._materials[i];

            if (!mat) {
              continue;
            }

            for (var p = 0; p < mat.passes.length; ++p) {
              var pass = mat.passes[p];

              if (pass.batchingScheme) {
                return true;
              }
            }
          }

          return false;
        };

        _proto._watchMorphInMesh = function _watchMorphInMesh() {
          if (this._morphInstance) {
            this._morphInstance.destroy();

            this._morphInstance = null;
          }

          if (!this._enableMorph) {
            return;
          }

          if (!this._mesh || !this._mesh.struct.morph || !this._mesh.morphRendering) {
            return;
          }

          this._morphInstance = this._mesh.morphRendering.createInstance();
          var nSubMeshes = this._mesh.struct.primitives.length;

          for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
            this._uploadSubMeshShapesWeights(iSubMesh);
          }

          if (this._model && this._model instanceof MorphModel) {
            this._model.setMorphRendering(this._morphInstance);
          }
        };

        _proto._initSubMeshShapesWeights = function _initSubMeshShapesWeights() {
          var mesh = this._mesh;
          this._subMeshShapesWeights.length = 0;

          if (!mesh) {
            return;
          }

          var morph = mesh.struct.morph;

          if (!morph) {
            return;
          }

          var commonWeights = morph.weights;
          this._subMeshShapesWeights = morph.subMeshMorphs.map(function (subMeshMorph) {
            if (!subMeshMorph) {
              return [];
            } else if (subMeshMorph.weights) {
              return subMeshMorph.weights.slice(0);
            } else if (commonWeights) {
              assertIsTrue(commonWeights.length === subMeshMorph.targets.length);
              return commonWeights.slice(0);
            } else {
              return new Array(subMeshMorph.targets.length).fill(0.0);
            }
          });
        };

        _proto._validateShapeWeights = function _validateShapeWeights() {
          var mesh = this._mesh,
              subMeshShapesWeights = this._subMeshShapesWeights;

          if (!mesh || !mesh.struct.morph) {
            return subMeshShapesWeights.length === 0;
          }

          var morph = mesh.struct.morph;

          if (morph.subMeshMorphs.length !== subMeshShapesWeights.length) {
            return false;
          }

          return subMeshShapesWeights.every(function (_ref, subMeshIndex) {
            var _morph$subMeshMorphs$, _morph$subMeshMorphs$2;

            var shapeCount = _ref.length;
            return ((_morph$subMeshMorphs$ = (_morph$subMeshMorphs$2 = morph.subMeshMorphs[subMeshIndex]) === null || _morph$subMeshMorphs$2 === void 0 ? void 0 : _morph$subMeshMorphs$2.targets.length) !== null && _morph$subMeshMorphs$ !== void 0 ? _morph$subMeshMorphs$ : 0) === shapeCount;
          });
        };

        _proto._uploadSubMeshShapesWeights = function _uploadSubMeshShapesWeights(subMeshIndex) {
          var _this$_morphInstance;

          (_this$_morphInstance = this._morphInstance) === null || _this$_morphInstance === void 0 ? void 0 : _this$_morphInstance.setWeights(subMeshIndex, this._subMeshShapesWeights[subMeshIndex]);
        };

        _createClass(MeshRenderer, [{
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(val) {
            this._shadowBias = val;

            this._updateShadowBias();

            this._onUpdateLocalShadowBias();
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(val) {
            this._shadowNormalBias = val;

            this._updateShadowNormalBias();

            this._onUpdateLocalShadowBias();
          }
        }, {
          key: "shadowCastingMode",
          get: function get() {
            return this._shadowCastingMode;
          },
          set: function set(val) {
            this._shadowCastingMode = val;

            this._updateCastShadow();
          }
        }, {
          key: "receiveShadow",
          get: function get() {
            return this._shadowReceivingMode;
          },
          set: function set(val) {
            this._shadowReceivingMode = val;

            this._updateReceiveShadow();
          }
        }, {
          key: "mesh",
          get: function get() {
            return this._mesh;
          },
          set: function set(val) {
            var old = this._mesh;
            var mesh = this._mesh = val;
            mesh === null || mesh === void 0 ? void 0 : mesh.initialize();

            this._initSubMeshShapesWeights();

            this._watchMorphInMesh();

            this._onMeshChanged(old);

            this._updateModels();

            if (this.enabledInHierarchy) {
              this._attachToScene();
            }

            this._updateCastShadow();

            this._updateReceiveShadow();
          }
        }, {
          key: "model",
          get: function get() {
            return this._model;
          }
        }, {
          key: "enableMorph",
          get: function get() {
            return this._enableMorph;
          },
          set: function set(value) {
            this._enableMorph = value;
          }
        }]);

        return MeshRenderer;
      }(ModelRenderer), _class6.ShadowCastingMode = ModelShadowCastingMode, _class6.ShadowReceivingMode = ModelShadowReceivingMode, _temp2), (_descriptor7$3 = _applyDecoratedDescriptor(_class5.prototype, "lightmapSettings", [serializable, editable, disallowAnimation], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new ModelLightmapSettings();
        }
      }), _descriptor8$3 = _applyDecoratedDescriptor(_class5.prototype, "_mesh", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9$3 = _applyDecoratedDescriptor(_class5.prototype, "_shadowCastingMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ModelShadowCastingMode.OFF;
        }
      }), _descriptor10$3 = _applyDecoratedDescriptor(_class5.prototype, "_shadowReceivingMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ModelShadowReceivingMode.ON;
        }
      }), _descriptor11$2 = _applyDecoratedDescriptor(_class5.prototype, "_shadowBias", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor12$2 = _applyDecoratedDescriptor(_class5.prototype, "_shadowNormalBias", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class5.prototype, "shadowBias", [_dec7$a, _dec8$9, _dec9$6, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "shadowBias"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "shadowNormalBias", [_dec10$6, _dec11$5, _dec12$4, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "shadowNormalBias"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "shadowCastingMode", [_dec13$4, _dec14$3, _dec15$3, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "shadowCastingMode"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "receiveShadow", [_dec16$3, _dec17$3, _dec18$3, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "receiveShadow"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "mesh", [_dec19$3, _dec20$3], Object.getOwnPropertyDescriptor(_class5.prototype, "mesh"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "enableMorph", [_dec21$3, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "enableMorph"), _class5.prototype), _descriptor13$2 = _applyDecoratedDescriptor(_class5.prototype, "_enableMorph", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class5)) || _class4) || _class4) || _class4) || _class4) || _class4));

      function checkMaterialisSame(comp1, comp2) {
        var matNum = comp1.sharedMaterials.length;

        if (matNum !== comp2.sharedMaterials.length) {
          return false;
        }

        for (var i = 0; i < matNum; i++) {
          if (comp1.getRenderMaterial(i) !== comp2.getRenderMaterial(i)) {
            return false;
          }
        }

        return true;
      }

      var BatchingUtility = exports('BatchingUtility', function () {
        function BatchingUtility() {}

        BatchingUtility.batchStaticModel = function batchStaticModel(staticModelRoot, batchedRoot) {
          var models = staticModelRoot.getComponentsInChildren(MeshRenderer);

          if (models.length < 2) {
            console.error('the number of static models to batch is less than 2,it needn\'t batch.');
            return false;
          }

          for (var i = 1; i < models.length; i++) {
            if (!models[0].mesh.validateMergingMesh(models[i].mesh)) {
              console.error("the meshes of " + models[0].node.name + " and " + models[i].node.name + " can't be merged");
              return false;
            }

            if (!checkMaterialisSame(models[0], models[i])) {
              console.error("the materials of " + models[0].node.name + " and " + models[i].node.name + " can't be merged");
              return false;
            }
          }

          var batchedMesh = new Mesh();
          var worldMat = new Mat4();
          var rootWorldMatInv = new Mat4();
          staticModelRoot.getWorldMatrix(rootWorldMatInv);
          Mat4.invert(rootWorldMatInv, rootWorldMatInv);

          for (var _i = 0; _i < models.length; _i++) {
            var comp = models[_i];
            comp.node.getWorldMatrix(worldMat);
            Mat4.multiply(worldMat, rootWorldMatInv, worldMat);
            batchedMesh.merge(models[_i].mesh, worldMat);
            comp.enabled = false;
          }

          var batchedModel = batchedRoot.addComponent(MeshRenderer);
          batchedModel.mesh = batchedMesh;
          batchedModel.sharedMaterials = models[0].sharedMaterials;
          return true;
        };

        BatchingUtility.unbatchStaticModel = function unbatchStaticModel(staticModelRoot, batchedRoot) {
          var models = staticModelRoot.getComponentsInChildren(MeshRenderer);

          for (var i = 0; i < models.length; i++) {
            var comp = models[i];
            comp.enabled = true;
          }

          var batchedModel = batchedRoot.getComponent(MeshRenderer);

          if (batchedModel) {
            if (batchedModel.mesh) {
              batchedModel.mesh.destroyRenderingMesh();
            }

            batchedModel.destroy();
          }

          return true;
        };

        return BatchingUtility;
      }());

      replaceProperty(Mesh.prototype, 'Mesh.prototype', [{
        name: 'renderingMesh',
        newName: 'renderingSubMeshes'
      }]);
      removeProperty(Mesh.prototype, 'Mesh.prototype', [{
        name: 'hasFlatBuffers'
      }, {
        name: 'destroyFlatBuffers'
      }]);

      var _dec$o, _dec2$i, _dec3$h, _class$o, _class2$j, _descriptor$h, _descriptor2$e, _descriptor3$b, _temp$l;
      var Skeleton = exports('Skeleton', (_dec$o = ccclass('cc.Skeleton'), _dec2$i = type([CCString]), _dec3$h = type([Mat4]), _dec$o(_class$o = (_class2$j = (_temp$l = function (_Asset) {
        _inheritsLoose(Skeleton, _Asset);

        function Skeleton() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_joints", _descriptor$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_bindposes", _descriptor2$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_hash", _descriptor3$b, _assertThisInitialized(_this));

          _this._invBindposes = null;
          return _this;
        }

        var _proto = Skeleton.prototype;

        _proto.destroy = function destroy() {
          var _ref, _legacyCC$director$ro;

          (_ref = (_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.dataPoolManager) === null || _ref === void 0 ? void 0 : _ref.releaseSkeleton(this);
          return _Asset.prototype.destroy.call(this);
        };

        _proto.validate = function validate() {
          return this.joints.length > 0 && this.bindposes.length > 0;
        };

        _createClass(Skeleton, [{
          key: "joints",
          get: function get() {
            return this._joints;
          },
          set: function set(value) {
            this._joints = value;
          }
        }, {
          key: "bindposes",
          get: function get() {
            return this._bindposes;
          },
          set: function set(value) {
            this._bindposes = value;
          }
        }, {
          key: "inverseBindposes",
          get: function get() {
            if (!this._invBindposes) {
              this._invBindposes = [];

              for (var i = 0; i < this._bindposes.length; i++) {
                var inv = new Mat4();
                Mat4.invert(inv, this._bindposes[i]);

                this._invBindposes.push(inv);
              }
            }

            return this._invBindposes;
          }
        }, {
          key: "hash",
          get: function get() {
            if (!this._hash) {
              var str = '';

              for (var i = 0; i < this._bindposes.length; i++) {
                var ibm = this._bindposes[i];
                str += ibm.m00.toPrecision(2) + " " + ibm.m01.toPrecision(2) + " " + ibm.m02.toPrecision(2) + " " + ibm.m03.toPrecision(2) + " " + ibm.m04.toPrecision(2) + " " + ibm.m05.toPrecision(2) + " " + ibm.m06.toPrecision(2) + " " + ibm.m07.toPrecision(2) + " " + ibm.m08.toPrecision(2) + " " + ibm.m09.toPrecision(2) + " " + ibm.m10.toPrecision(2) + " " + ibm.m11.toPrecision(2) + " " + ibm.m12.toPrecision(2) + " " + ibm.m13.toPrecision(2) + " " + ibm.m14.toPrecision(2) + " " + ibm.m15.toPrecision(2) + "\n";
              }

              this._hash = murmurhash2_32_gc(str, 666);
            }

            return this._hash;
          }
        }]);

        return Skeleton;
      }(Asset), _temp$l), (_descriptor$h = _applyDecoratedDescriptor(_class2$j.prototype, "_joints", [_dec2$i], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$e = _applyDecoratedDescriptor(_class2$j.prototype, "_bindposes", [_dec3$h], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3$b = _applyDecoratedDescriptor(_class2$j.prototype, "_hash", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$j)) || _class$o));
      legacyCC.Skeleton = Skeleton;

      removeProperty(MeshRenderer.prototype, 'MeshRenderer.prototype', [{
        name: 'enableDynamicBatching'
      }, {
        name: 'recieveShadows'
      }]);
      legacyCC.ModelComponent = MeshRenderer;
      js.setClassAlias(MeshRenderer, 'cc.ModelComponent');

      var _dec$p, _class$p, _class2$k, _descriptor$i, _descriptor2$f, _descriptor3$c, _descriptor4$9, _temp$m, _dec2$j, _dec3$i, _dec4$g, _dec5$e, _dec6$c, _dec7$b, _dec8$a, _class4$1, _class5$1, _descriptor5$7, _descriptor6$6, _descriptor7$4, _descriptor8$4, _class6$1, _temp2$1;

      var _color_tmp = new Vec3();

      var PhotometricTerm = Enum({
        LUMINOUS_FLUX: 0,
        LUMINANCE: 1
      });
      var StaticLightSettings = (_dec$p = ccclass('cc.StaticLightSettings'), _dec$p(_class$p = (_class2$k = (_temp$m = function () {
        function StaticLightSettings() {
          _initializerDefineProperty(this, "_baked", _descriptor$i, this);

          _initializerDefineProperty(this, "_editorOnly", _descriptor2$f, this);

          _initializerDefineProperty(this, "_bakeable", _descriptor3$c, this);

          _initializerDefineProperty(this, "_castShadow", _descriptor4$9, this);
        }

        _createClass(StaticLightSettings, [{
          key: "editorOnly",
          get: function get() {
            return this._editorOnly;
          },
          set: function set(val) {
            this._editorOnly = val;
          }
        }, {
          key: "baked",
          get: function get() {
            return this._baked;
          },
          set: function set(val) {
            this._baked = val;
          }
        }, {
          key: "bakeable",
          get: function get() {
            return this._bakeable;
          },
          set: function set(val) {
            this._bakeable = val;
          }
        }, {
          key: "castShadow",
          get: function get() {
            return this._castShadow;
          },
          set: function set(val) {
            this._castShadow = val;
          }
        }]);

        return StaticLightSettings;
      }(), _temp$m), (_descriptor$i = _applyDecoratedDescriptor(_class2$k.prototype, "_baked", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor2$f = _applyDecoratedDescriptor(_class2$k.prototype, "_editorOnly", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor3$c = _applyDecoratedDescriptor(_class2$k.prototype, "_bakeable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor4$9 = _applyDecoratedDescriptor(_class2$k.prototype, "_castShadow", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$k.prototype, "editorOnly", [editable], Object.getOwnPropertyDescriptor(_class2$k.prototype, "editorOnly"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "bakeable", [editable], Object.getOwnPropertyDescriptor(_class2$k.prototype, "bakeable"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "castShadow", [editable], Object.getOwnPropertyDescriptor(_class2$k.prototype, "castShadow"), _class2$k.prototype)), _class2$k)) || _class$p);
      var Light = function (v) { return exports({ Light: v, LightComponent: v }), v; }((_dec2$j = ccclass('cc.Light'), _dec3$i = tooltip(), _dec4$g = tooltip(), _dec5$e = range(), _dec6$c = tooltip(), _dec7$b = type(StaticLightSettings), _dec8$a = displayOrder(), _dec2$j(_class4$1 = (_class5$1 = (_temp2$1 = _class6$1 = function (_Component) {
        _inheritsLoose(Light, _Component);

        function Light() {
          var _this;

          _this = _Component.call(this) || this;

          _initializerDefineProperty(_this, "_color", _descriptor5$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_useColorTemperature", _descriptor6$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_colorTemperature", _descriptor7$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_staticSettings", _descriptor8$4, _assertThisInitialized(_this));

          _this._type = LightType.UNKNOWN;
          _this._lightType = void 0;
          _this._light = null;
          _this._lightType = Light$1;
          return _this;
        }

        var _proto = Light.prototype;

        _proto.onLoad = function onLoad() {
          this._createLight();
        };

        _proto.onEnable = function onEnable() {
          this._attachToScene();
        };

        _proto.onDisable = function onDisable() {
          this._detachFromScene();
        };

        _proto.onDestroy = function onDestroy() {
          this._destroyLight();
        };

        _proto._createLight = function _createLight() {
          if (!this._light) {
            this._light = legacyCC.director.root.createLight(this._lightType);
          }

          this.color = this._color;
          this.useColorTemperature = this._useColorTemperature;
          this.colorTemperature = this._colorTemperature;
          this._light.node = this.node;
          this._light.baked = this.baked;
        };

        _proto._destroyLight = function _destroyLight() {
          if (this._light) {
            legacyCC.director.root.recycleLight(this._light);
            this._light = null;
          }
        };

        _proto._attachToScene = function _attachToScene() {
          this._detachFromScene();

          if (this._light && !this._light.scene && this.node.scene) {
            var renderScene = this._getRenderScene();

            switch (this._type) {
              case LightType.DIRECTIONAL:
                renderScene.addDirectionalLight(this._light);
                renderScene.setMainLight(this._light);
                break;

              case LightType.SPHERE:
                renderScene.addSphereLight(this._light);
                break;

              case LightType.SPOT:
                renderScene.addSpotLight(this._light);
                break;
            }
          }
        };

        _proto._detachFromScene = function _detachFromScene() {
          if (this._light && this._light.scene) {
            var renderScene = this._light.scene;

            switch (this._type) {
              case LightType.DIRECTIONAL:
                renderScene.removeDirectionalLight(this._light);
                renderScene.unsetMainLight(this._light);
                break;

              case LightType.SPHERE:
                renderScene.removeSphereLight(this._light);
                break;

              case LightType.SPOT:
                renderScene.removeSpotLight(this._light);
                break;
            }
          }
        };

        _createClass(Light, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(val) {
            this._color = val;

            if (this._light) {
              _color_tmp.x = val.r / 255.0;
              _color_tmp.y = val.g / 255.0;
              _color_tmp.z = val.b / 255.0;
              this._light.color = _color_tmp;
            }
          }
        }, {
          key: "useColorTemperature",
          get: function get() {
            return this._useColorTemperature;
          },
          set: function set(enable) {
            this._useColorTemperature = enable;

            if (this._light) {
              this._light.useColorTemperature = enable;
            }
          }
        }, {
          key: "colorTemperature",
          get: function get() {
            return this._colorTemperature;
          },
          set: function set(val) {
            this._colorTemperature = val;

            if (this._light) {
              this._light.colorTemperature = val;
            }
          }
        }, {
          key: "staticSettings",
          get: function get() {
            return this._staticSettings;
          },
          set: function set(val) {
            this._staticSettings = val;
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          }
        }, {
          key: "baked",
          get: function get() {
            return this.staticSettings.baked;
          },
          set: function set(val) {
            this.staticSettings.baked = val;

            if (this._light !== null) {
              this._light.baked = val;
            }
          }
        }]);

        return Light;
      }(Component), _class6$1.Type = LightType, _class6$1.PhotometricTerm = PhotometricTerm, _temp2$1), (_descriptor5$7 = _applyDecoratedDescriptor(_class5$1.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor6$6 = _applyDecoratedDescriptor(_class5$1.prototype, "_useColorTemperature", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor7$4 = _applyDecoratedDescriptor(_class5$1.prototype, "_colorTemperature", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 6550;
        }
      }), _descriptor8$4 = _applyDecoratedDescriptor(_class5$1.prototype, "_staticSettings", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new StaticLightSettings();
        }
      }), _applyDecoratedDescriptor(_class5$1.prototype, "color", [_dec3$i], Object.getOwnPropertyDescriptor(_class5$1.prototype, "color"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "useColorTemperature", [_dec4$g], Object.getOwnPropertyDescriptor(_class5$1.prototype, "useColorTemperature"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "colorTemperature", [slide, _dec5$e, _dec6$c], Object.getOwnPropertyDescriptor(_class5$1.prototype, "colorTemperature"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "staticSettings", [_dec7$b, _dec8$a], Object.getOwnPropertyDescriptor(_class5$1.prototype, "staticSettings"), _class5$1.prototype)), _class5$1)) || _class4$1));

      var _dec$q, _dec2$k, _dec3$j, _dec4$h, _dec5$f, _dec6$d, _dec7$c, _dec8$b, _dec9$7, _dec10$7, _dec11$6, _dec12$5, _dec13$5, _dec14$4, _dec15$4, _dec16$4, _dec17$4, _dec18$4, _dec19$4, _dec20$4, _dec21$4, _dec22$3, _dec23$2, _dec24$2, _dec25$2, _dec26$2, _dec27$2, _dec28$2, _dec29$2, _dec30$2, _dec31$2, _dec32$2, _dec33$1, _dec34$1, _dec35$1, _dec36$1, _dec37$1, _dec38$1, _dec39$1, _dec40$1, _dec41$1, _dec42$1, _dec43$1, _dec44$1, _dec45$1, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _class$q, _class2$l, _descriptor$j, _descriptor2$g, _descriptor3$d, _descriptor4$a, _descriptor5$8, _descriptor6$7, _descriptor7$5, _descriptor8$5, _descriptor9$4, _descriptor10$4, _descriptor11$3, _descriptor12$3, _descriptor13$3, _descriptor14$1, _descriptor15$1, _descriptor16$1, _temp$n;
      var DirectionalLight = function (v) { return exports({ DirectionalLight: v, DirectionalLightComponent: v }), v; }((_dec$q = ccclass('cc.DirectionalLight'), _dec2$k = help(), _dec3$j = menu(), _dec4$h = formerlySerializedAs('_illuminance'), _dec5$f = tooltip(), _dec6$d = visible(), _dec7$c = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 1
        }
      }), _dec8$b = type(CCBoolean), _dec9$7 = visible(), _dec10$7 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 5
        }
      }), _dec11$6 = type(PCFType), _dec12$5 = visible(), _dec13$5 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 6
        }
      }), _dec14$4 = type(CCFloat), _dec15$4 = visible(), _dec16$4 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 7
        }
      }), _dec17$4 = type(CCFloat), _dec18$4 = visible(), _dec19$4 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 8
        }
      }), _dec20$4 = range(), _dec21$4 = type(CCFloat), _dec22$3 = visible(), _dec23$2 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 9
        }
      }), _dec24$2 = tooltip(), _dec25$2 = range(), _dec26$2 = type(CCFloat), _dec27$2 = visible(), _dec28$2 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 10
        }
      }), _dec29$2 = tooltip(), _dec30$2 = range(), _dec31$2 = type(CCFloat), _dec32$2 = visible(), _dec33$1 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 11
        }
      }), _dec34$1 = tooltip(), _dec35$1 = type(CSMLevel), _dec36$1 = visible(), _dec37$1 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 12
        }
      }), _dec38$1 = tooltip(), _dec39$1 = type(CCBoolean), _dec40$1 = visible(), _dec41$1 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 13
        }
      }), _dec42$1 = tooltip(), _dec43$1 = range(), _dec44$1 = type(CCFloat), _dec45$1 = visible(), _dec46 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 14
        }
      }), _dec47 = tooltip(), _dec48 = type(CSMOptimizationMode), _dec49 = visible(), _dec50 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 15
        }
      }), _dec51 = type(CCBoolean), _dec52 = visible(), _dec53 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 16
        }
      }), _dec54 = type(CCFloat), _dec55 = visible(), _dec56 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 17
        }
      }), _dec57 = type(CCFloat), _dec58 = visible(), _dec59 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 18
        }
      }), _dec60 = type(CCFloat), _dec$q(_class$q = _dec2$k(_class$q = _dec3$j(_class$q = executeInEditMode(_class$q = (_class2$l = (_temp$n = function (_Light) {
        _inheritsLoose(DirectionalLight, _Light);

        function DirectionalLight() {
          var _this;

          _this = _Light.call(this) || this;

          _initializerDefineProperty(_this, "_illuminanceHDR", _descriptor$j, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_illuminanceLDR", _descriptor2$g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowEnabled", _descriptor3$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowPcf", _descriptor4$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowBias", _descriptor5$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowNormalBias", _descriptor6$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowSaturation", _descriptor7$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowDistance", _descriptor8$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowInvisibleOcclusionRange", _descriptor9$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_csmLevel", _descriptor10$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_csmLayerLambda", _descriptor11$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_csmOptimizationMode", _descriptor12$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowFixedArea", _descriptor13$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowNear", _descriptor14$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowFar", _descriptor15$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowOrthoSize", _descriptor16$1, _assertThisInitialized(_this));

          _this._type = LightType.DIRECTIONAL;
          _this._light = null;
          _this._lightType = DirectionalLight$1;
          return _this;
        }

        var _proto = DirectionalLight.prototype;

        _proto._createLight = function _createLight() {
          _Light.prototype._createLight.call(this);

          if (this._light) {
            this._light.illuminanceHDR = this._illuminanceHDR;
            this._light.illuminanceLDR = this._illuminanceLDR;
            this._light.shadowEnabled = this._shadowEnabled;
            this._light.shadowPcf = this._shadowPcf;
            this._light.shadowBias = this._shadowBias;
            this._light.shadowNormalBias = this._shadowNormalBias;
            this._light.shadowSaturation = this._shadowSaturation;
            this._light.shadowDistance = this._shadowDistance;
            this._light.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange;
            this._light.shadowFixedArea = this._shadowFixedArea;
            this._light.shadowNear = this._shadowNear;
            this._light.shadowFar = this._shadowFar;
            this._light.shadowOrthoSize = this._shadowOrthoSize;
            this._light.csmLevel = this._csmLevel;
            this._light.csmLayerLambda = this._csmLayerLambda;
            this._light.csmOptimizationMode = this._csmOptimizationMode;
          }
        };

        _createClass(DirectionalLight, [{
          key: "illuminance",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._illuminanceHDR;
            } else {
              return this._illuminanceLDR;
            }
          },
          set: function set(val) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this._illuminanceHDR = val;
              this._light && (this._light.illuminanceHDR = this._illuminanceHDR);
            } else {
              this._illuminanceLDR = val;
              this._light && (this._light.illuminanceLDR = this._illuminanceLDR);
            }
          }
        }, {
          key: "shadowEnabled",
          get: function get() {
            return this._shadowEnabled;
          },
          set: function set(val) {
            this._shadowEnabled = val;

            if (this._light) {
              this._light.shadowEnabled = this._shadowEnabled;
            }
          }
        }, {
          key: "shadowPcf",
          get: function get() {
            return this._shadowPcf;
          },
          set: function set(val) {
            this._shadowPcf = val;

            if (this._light) {
              this._light.shadowPcf = this._shadowPcf;
            }
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(val) {
            this._shadowBias = val;

            if (this._light) {
              this._light.shadowBias = this._shadowBias;
            }
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(val) {
            this._shadowNormalBias = val;

            if (this._light) {
              this._light.shadowNormalBias = this._shadowNormalBias;
            }
          }
        }, {
          key: "shadowSaturation",
          get: function get() {
            return this._shadowSaturation;
          },
          set: function set(val) {
            this._shadowSaturation = clamp$1(val, 0.0, 1.0);

            if (this._light) {
              this._light.shadowSaturation = this._shadowSaturation;
            }
          }
        }, {
          key: "shadowDistance",
          get: function get() {
            return this._shadowDistance;
          },
          set: function set(val) {
            this._shadowDistance = Math.min(val, Shadows.MAX_FAR);

            if (this._shadowDistance / 0.1 < 10.0) {
              warnID(15003, this._shadowDistance);
            }

            if (this._light) {
              this._light.shadowDistance = this._shadowDistance;
              this._light.csmNeedUpdate = true;
            }
          }
        }, {
          key: "shadowInvisibleOcclusionRange",
          get: function get() {
            return this._shadowInvisibleOcclusionRange;
          },
          set: function set(val) {
            this._shadowInvisibleOcclusionRange = Math.min(val, Shadows.MAX_FAR);

            if (this._light) {
              this._light.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange;
            }
          }
        }, {
          key: "csmLevel",
          get: function get() {
            return this._csmLevel;
          },
          set: function set(val) {
            this._csmLevel = val;

            if (this._light) {
              this._light.csmLevel = this._csmLevel;
              this._light.csmNeedUpdate = true;
            }
          }
        }, {
          key: "enableCSM",
          get: function get() {
            return this._csmLevel > CSMLevel.LEVEL_1;
          },
          set: function set(val) {
            this._csmLevel = val ? CSMLevel.LEVEL_4 : CSMLevel.LEVEL_1;

            if (this._light) {
              this._light.csmLevel = this._csmLevel;
              this._light.csmNeedUpdate = true;
            }
          }
        }, {
          key: "csmLayerLambda",
          get: function get() {
            return this._csmLayerLambda;
          },
          set: function set(val) {
            this._csmLayerLambda = val;

            if (this._light) {
              this._light.csmLayerLambda = this._csmLayerLambda;
              this._light.csmNeedUpdate = true;
            }
          }
        }, {
          key: "csmOptimizationMode",
          get: function get() {
            return this._csmOptimizationMode;
          },
          set: function set(val) {
            this._csmOptimizationMode = val;

            if (this._light) {
              this._light.csmOptimizationMode = this._csmOptimizationMode;
            }
          }
        }, {
          key: "shadowFixedArea",
          get: function get() {
            return this._shadowFixedArea;
          },
          set: function set(val) {
            this._shadowFixedArea = val;

            if (this._light) {
              this._light.shadowFixedArea = this._shadowFixedArea;
            }
          }
        }, {
          key: "shadowNear",
          get: function get() {
            return this._shadowNear;
          },
          set: function set(val) {
            this._shadowNear = val;

            if (this._light) {
              this._light.shadowNear = this._shadowNear;
            }
          }
        }, {
          key: "shadowFar",
          get: function get() {
            return this._shadowFar;
          },
          set: function set(val) {
            this._shadowFar = Math.min(val, Shadows.MAX_FAR);

            if (this._light) {
              this._light.shadowFar = this._shadowFar;
            }
          }
        }, {
          key: "shadowOrthoSize",
          get: function get() {
            return this._shadowOrthoSize;
          },
          set: function set(val) {
            this._shadowOrthoSize = val;

            if (this._light) {
              this._light.shadowOrthoSize = this._shadowOrthoSize;
            }
          }
        }]);

        return DirectionalLight;
      }(Light), _temp$n), (_descriptor$j = _applyDecoratedDescriptor(_class2$l.prototype, "_illuminanceHDR", [property, _dec4$h], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 65000;
        }
      }), _descriptor2$g = _applyDecoratedDescriptor(_class2$l.prototype, "_illuminanceLDR", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 65000 * Camera.standardExposureValue;
        }
      }), _descriptor3$d = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowEnabled", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor4$a = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowPcf", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PCFType.HARD;
        }
      }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowBias", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.00001;
        }
      }), _descriptor6$7 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowNormalBias", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _descriptor7$5 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowSaturation", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      }), _descriptor8$5 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowDistance", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 50;
        }
      }), _descriptor9$4 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowInvisibleOcclusionRange", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 200;
        }
      }), _descriptor10$4 = _applyDecoratedDescriptor(_class2$l.prototype, "_csmLevel", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return CSMLevel.LEVEL_4;
        }
      }), _descriptor11$3 = _applyDecoratedDescriptor(_class2$l.prototype, "_csmLayerLambda", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.75;
        }
      }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$l.prototype, "_csmOptimizationMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return CSMOptimizationMode.RemoveDuplicates;
        }
      }), _descriptor13$3 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowFixedArea", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor14$1 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowNear", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor15$1 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowFar", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10.0;
        }
      }), _descriptor16$1 = _applyDecoratedDescriptor(_class2$l.prototype, "_shadowOrthoSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 5;
        }
      }), _applyDecoratedDescriptor(_class2$l.prototype, "illuminance", [_dec5$f], Object.getOwnPropertyDescriptor(_class2$l.prototype, "illuminance"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowEnabled", [_dec6$d, _dec7$c, editable, _dec8$b], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowEnabled"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowPcf", [_dec9$7, _dec10$7, editable, _dec11$6], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowPcf"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowBias", [_dec12$5, _dec13$5, editable, _dec14$4], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowBias"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowNormalBias", [_dec15$4, _dec16$4, editable, _dec17$4], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowNormalBias"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowSaturation", [_dec18$4, _dec19$4, editable, _dec20$4, slide, _dec21$4], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowSaturation"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowDistance", [_dec22$3, _dec23$2, editable, _dec24$2, _dec25$2, slide, _dec26$2], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowDistance"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowInvisibleOcclusionRange", [_dec27$2, _dec28$2, editable, _dec29$2, _dec30$2, slide, _dec31$2], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowInvisibleOcclusionRange"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "csmLevel", [_dec32$2, _dec33$1, editable, _dec34$1, slide, _dec35$1], Object.getOwnPropertyDescriptor(_class2$l.prototype, "csmLevel"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "enableCSM", [_dec36$1, _dec37$1, editable, _dec38$1, slide, _dec39$1], Object.getOwnPropertyDescriptor(_class2$l.prototype, "enableCSM"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "csmLayerLambda", [_dec40$1, _dec41$1, editable, _dec42$1, _dec43$1, slide, _dec44$1], Object.getOwnPropertyDescriptor(_class2$l.prototype, "csmLayerLambda"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "csmOptimizationMode", [_dec45$1, _dec46, editable, _dec47, slide, _dec48], Object.getOwnPropertyDescriptor(_class2$l.prototype, "csmOptimizationMode"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowFixedArea", [_dec49, _dec50, editable, _dec51], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowFixedArea"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowNear", [_dec52, _dec53, editable, _dec54], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowNear"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowFar", [_dec55, _dec56, editable, _dec57], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowFar"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "shadowOrthoSize", [_dec58, _dec59, _dec60], Object.getOwnPropertyDescriptor(_class2$l.prototype, "shadowOrthoSize"), _class2$l.prototype)), _class2$l)) || _class$q) || _class$q) || _class$q) || _class$q));

      var _dec$r, _dec2$l, _dec3$k, _dec4$i, _dec5$g, _dec6$e, _dec7$d, _dec8$c, _dec9$8, _dec10$8, _dec11$7, _dec12$6, _dec13$6, _class$r, _class2$m, _descriptor$k, _descriptor2$h, _descriptor3$e, _descriptor4$b, _descriptor5$9, _temp$o;
      var SphereLight = function (v) { return exports({ SphereLight: v, SphereLightComponent: v }), v; }((_dec$r = ccclass('cc.SphereLight'), _dec2$l = help(), _dec3$k = menu(), _dec4$i = formerlySerializedAs('_luminance'), _dec5$g = displayOrder(), _dec6$e = tooltip(), _dec7$d = displayOrder(), _dec8$c = tooltip(), _dec9$8 = type(PhotometricTerm), _dec10$8 = displayOrder(), _dec11$7 = tooltip(), _dec12$6 = tooltip(), _dec13$6 = tooltip(), _dec$r(_class$r = _dec2$l(_class$r = _dec3$k(_class$r = executeInEditMode(_class$r = (_class2$m = (_temp$o = function (_Light) {
        _inheritsLoose(SphereLight, _Light);

        function SphereLight() {
          var _this;

          _this = _Light.call(this) || this;

          _initializerDefineProperty(_this, "_size", _descriptor$k, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_luminanceHDR", _descriptor2$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_luminanceLDR", _descriptor3$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_term", _descriptor4$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_range", _descriptor5$9, _assertThisInitialized(_this));

          _this._type = LightType.SPHERE;
          _this._light = null;
          _this._lightType = SphereLight$1;
          return _this;
        }

        var _proto = SphereLight.prototype;

        _proto._createLight = function _createLight() {
          _Light.prototype._createLight.call(this);

          this.size = this._size;
          this.range = this._range;

          if (this._light) {
            this._light.luminanceHDR = this._luminanceHDR;
            this._light.luminanceLDR = this._luminanceLDR;
          }
        };

        _createClass(SphereLight, [{
          key: "luminousFlux",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._luminanceHDR * nt2lm(this._size);
            } else {
              return this._luminanceLDR;
            }
          },
          set: function set(val) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
            var result = 0;

            if (isHDR) {
              this._luminanceHDR = val / nt2lm(this._size);
              result = this._luminanceHDR;
            } else {
              this._luminanceLDR = val;
              result = this._luminanceLDR;
            }

            this._light && (this._light.luminance = result);
          }
        }, {
          key: "luminance",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._luminanceHDR;
            } else {
              return this._luminanceLDR;
            }
          },
          set: function set(val) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this._luminanceHDR = val;
              this._light && (this._light.luminanceHDR = this._luminanceHDR);
            } else {
              this._luminanceLDR = val;
              this._light && (this._light.luminanceLDR = this._luminanceLDR);
            }
          }
        }, {
          key: "term",
          get: function get() {
            return this._term;
          },
          set: function set(val) {
            this._term = val;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(val) {
            this._size = val;

            if (this._light) {
              this._light.size = val;
            }
          }
        }, {
          key: "range",
          get: function get() {
            return this._range;
          },
          set: function set(val) {
            this._range = val;

            if (this._light) {
              this._light.range = val;
            }
          }
        }]);

        return SphereLight;
      }(Light), _temp$o), (_descriptor$k = _applyDecoratedDescriptor(_class2$m.prototype, "_size", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.15;
        }
      }), _descriptor2$h = _applyDecoratedDescriptor(_class2$m.prototype, "_luminanceHDR", [serializable, _dec4$i], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1700 / nt2lm(0.15);
        }
      }), _descriptor3$e = _applyDecoratedDescriptor(_class2$m.prototype, "_luminanceLDR", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1700 / nt2lm(0.15) * Camera.standardExposureValue * Camera.standardLightMeterScale;
        }
      }), _descriptor4$b = _applyDecoratedDescriptor(_class2$m.prototype, "_term", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PhotometricTerm.LUMINOUS_FLUX;
        }
      }), _descriptor5$9 = _applyDecoratedDescriptor(_class2$m.prototype, "_range", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _applyDecoratedDescriptor(_class2$m.prototype, "luminousFlux", [_dec5$g, _dec6$e], Object.getOwnPropertyDescriptor(_class2$m.prototype, "luminousFlux"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "luminance", [_dec7$d, _dec8$c], Object.getOwnPropertyDescriptor(_class2$m.prototype, "luminance"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "term", [_dec9$8, _dec10$8, _dec11$7], Object.getOwnPropertyDescriptor(_class2$m.prototype, "term"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "size", [_dec12$6], Object.getOwnPropertyDescriptor(_class2$m.prototype, "size"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "range", [_dec13$6], Object.getOwnPropertyDescriptor(_class2$m.prototype, "range"), _class2$m.prototype)), _class2$m)) || _class$r) || _class$r) || _class$r) || _class$r));

      var _dec$s, _dec2$m, _dec3$l, _dec4$j, _dec5$h, _dec6$f, _dec7$e, _dec8$d, _dec9$9, _dec10$9, _dec11$8, _dec12$7, _dec13$7, _dec14$5, _dec15$5, _dec16$5, _dec17$5, _dec18$5, _dec19$5, _dec20$5, _dec21$5, _dec22$4, _dec23$3, _dec24$3, _dec25$3, _dec26$3, _dec27$3, _class$s, _class2$n, _descriptor$l, _descriptor2$i, _descriptor3$f, _descriptor4$c, _descriptor5$a, _descriptor6$8, _descriptor7$6, _descriptor8$6, _descriptor9$5, _descriptor10$5, _temp$p;
      var SpotLight = function (v) { return exports({ SpotLight: v, SpotLightComponent: v }), v; }((_dec$s = ccclass('cc.SpotLight'), _dec2$m = help(), _dec3$l = menu(), _dec4$j = formerlySerializedAs('_luminance'), _dec5$h = tooltip(), _dec6$f = displayOrder(), _dec7$e = tooltip(), _dec8$d = displayOrder(), _dec9$9 = type(PhotometricTerm), _dec10$9 = displayOrder(), _dec11$8 = tooltip(), _dec12$7 = tooltip(), _dec13$7 = tooltip(), _dec14$5 = range(), _dec15$5 = tooltip(), _dec16$5 = visible(), _dec17$5 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 1
        }
      }), _dec18$5 = type(CCBoolean), _dec19$5 = visible(), _dec20$5 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 2
        }
      }), _dec21$5 = type(PCFType), _dec22$4 = visible(), _dec23$3 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 3
        }
      }), _dec24$3 = type(CCFloat), _dec25$3 = visible(), _dec26$3 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 4
        }
      }), _dec27$3 = type(CCFloat), _dec$s(_class$s = _dec2$m(_class$s = _dec3$l(_class$s = executeInEditMode(_class$s = (_class2$n = (_temp$p = function (_Light) {
        _inheritsLoose(SpotLight, _Light);

        function SpotLight() {
          var _this;

          _this = _Light.call(this) || this;

          _initializerDefineProperty(_this, "_size", _descriptor$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_luminanceHDR", _descriptor2$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_luminanceLDR", _descriptor3$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_term", _descriptor4$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_range", _descriptor5$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spotAngle", _descriptor6$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowEnabled", _descriptor7$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowPcf", _descriptor8$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowBias", _descriptor9$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shadowNormalBias", _descriptor10$5, _assertThisInitialized(_this));

          _this._type = LightType.SPOT;
          _this._light = null;
          _this._lightType = SpotLight$1;
          return _this;
        }

        var _proto = SpotLight.prototype;

        _proto._createLight = function _createLight() {
          _Light.prototype._createLight.call(this);

          this.size = this._size;
          this.range = this._range;
          this.spotAngle = this._spotAngle;

          if (this._light) {
            this._light.luminanceHDR = this._luminanceHDR;
            this._light.luminanceLDR = this._luminanceLDR;
            this._light.shadowEnabled = this._shadowEnabled;
            this._light.shadowPcf = this._shadowPcf;
            this._light.shadowBias = this._shadowBias;
            this._light.shadowNormalBias = this._shadowNormalBias;
          }
        };

        _createClass(SpotLight, [{
          key: "luminousFlux",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._luminanceHDR * nt2lm(this._size);
            } else {
              return this._luminanceLDR;
            }
          },
          set: function set(val) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
            var result = 0;

            if (isHDR) {
              this._luminanceHDR = val / nt2lm(this._size);
              result = this._luminanceHDR;
            } else {
              this._luminanceLDR = val;
              result = this._luminanceLDR;
            }

            this._light && (this._light.luminance = result);
          }
        }, {
          key: "luminance",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._luminanceHDR;
            } else {
              return this._luminanceLDR;
            }
          },
          set: function set(val) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this._luminanceHDR = val;
              this._light && (this._light.luminanceHDR = this._luminanceHDR);
            } else {
              this._luminanceLDR = val;
              this._light && (this._light.luminanceLDR = this._luminanceLDR);
            }
          }
        }, {
          key: "term",
          get: function get() {
            return this._term;
          },
          set: function set(val) {
            this._term = val;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(val) {
            this._size = val;

            if (this._light) {
              this._light.size = val;
            }
          }
        }, {
          key: "range",
          get: function get() {
            return this._range;
          },
          set: function set(val) {
            this._range = val;

            if (this._light) {
              this._light.range = val;
            }
          }
        }, {
          key: "spotAngle",
          get: function get() {
            return this._spotAngle;
          },
          set: function set(val) {
            this._spotAngle = val;

            if (this._light) {
              this._light.spotAngle = toRadian(val);
            }
          }
        }, {
          key: "shadowEnabled",
          get: function get() {
            return this._shadowEnabled;
          },
          set: function set(val) {
            this._shadowEnabled = val;

            if (this._light) {
              this._light.shadowEnabled = val;
            }
          }
        }, {
          key: "shadowPcf",
          get: function get() {
            return this._shadowPcf;
          },
          set: function set(val) {
            this._shadowPcf = val;

            if (this._light) {
              this._light.shadowPcf = val;
            }
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(val) {
            this._shadowBias = val;

            if (this._light) {
              this._light.shadowBias = val;
            }
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(val) {
            this._shadowNormalBias = val;

            if (this._light) {
              this._light.shadowNormalBias = val;
            }
          }
        }]);

        return SpotLight;
      }(Light), _temp$p), (_descriptor$l = _applyDecoratedDescriptor(_class2$n.prototype, "_size", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.15;
        }
      }), _descriptor2$i = _applyDecoratedDescriptor(_class2$n.prototype, "_luminanceHDR", [serializable, _dec4$j], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1700 / nt2lm(0.15);
        }
      }), _descriptor3$f = _applyDecoratedDescriptor(_class2$n.prototype, "_luminanceLDR", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1700 / nt2lm(0.15) * Camera.standardExposureValue * Camera.standardLightMeterScale;
        }
      }), _descriptor4$c = _applyDecoratedDescriptor(_class2$n.prototype, "_term", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PhotometricTerm.LUMINOUS_FLUX;
        }
      }), _descriptor5$a = _applyDecoratedDescriptor(_class2$n.prototype, "_range", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor6$8 = _applyDecoratedDescriptor(_class2$n.prototype, "_spotAngle", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 60;
        }
      }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$n.prototype, "_shadowEnabled", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$n.prototype, "_shadowPcf", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PCFType.HARD;
        }
      }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$n.prototype, "_shadowBias", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.00001;
        }
      }), _descriptor10$5 = _applyDecoratedDescriptor(_class2$n.prototype, "_shadowNormalBias", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _applyDecoratedDescriptor(_class2$n.prototype, "luminousFlux", [_dec5$h, _dec6$f], Object.getOwnPropertyDescriptor(_class2$n.prototype, "luminousFlux"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "luminance", [_dec7$e, _dec8$d], Object.getOwnPropertyDescriptor(_class2$n.prototype, "luminance"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "term", [_dec9$9, _dec10$9, _dec11$8], Object.getOwnPropertyDescriptor(_class2$n.prototype, "term"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "size", [_dec12$7], Object.getOwnPropertyDescriptor(_class2$n.prototype, "size"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "range", [_dec13$7], Object.getOwnPropertyDescriptor(_class2$n.prototype, "range"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "spotAngle", [slide, _dec14$5, _dec15$5], Object.getOwnPropertyDescriptor(_class2$n.prototype, "spotAngle"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "shadowEnabled", [_dec16$5, _dec17$5, editable, _dec18$5], Object.getOwnPropertyDescriptor(_class2$n.prototype, "shadowEnabled"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "shadowPcf", [_dec19$5, _dec20$5, editable, _dec21$5], Object.getOwnPropertyDescriptor(_class2$n.prototype, "shadowPcf"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "shadowBias", [_dec22$4, _dec23$3, editable, _dec24$3], Object.getOwnPropertyDescriptor(_class2$n.prototype, "shadowBias"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "shadowNormalBias", [_dec25$3, _dec26$3, editable, _dec27$3], Object.getOwnPropertyDescriptor(_class2$n.prototype, "shadowNormalBias"), _class2$n.prototype)), _class2$n)) || _class$s) || _class$s) || _class$s) || _class$s));

      legacyCC.LightComponent = Light;
      js.setClassAlias(Light, 'cc.LightComponent');
      legacyCC.DirectionalLightComponent = DirectionalLight;
      js.setClassAlias(DirectionalLight, 'cc.DirectionalLightComponent');
      legacyCC.SphereLightComponent = SphereLight;
      js.setClassAlias(SphereLight, 'cc.SphereLightComponent');
      legacyCC.SpotLightComponent = SpotLight;
      js.setClassAlias(SpotLight, 'cc.SpotLightComponent');
      replaceProperty(SpotLight.prototype, 'SpotLight.prototype', [{
        name: 'luminousPower',
        newName: 'luminousFlux',
        customGetter: function customGetter() {
          return this.luminousFlux;
        },
        customSetter: function customSetter(value) {
          this.luminousFlux = value;
        }
      }]);
      replaceProperty(SphereLight.prototype, 'SphereLight.prototype', [{
        name: 'luminousPower',
        newName: 'luminousFlux',
        customGetter: function customGetter() {
          return this.luminousFlux;
        },
        customSetter: function customSetter(value) {
          this.luminousFlux = value;
        }
      }]);
      replaceProperty(Light.PhotometricTerm, 'Light.PhotometricTerm', [{
        name: 'LUMINOUS_POWER',
        newName: 'LUMINOUS_FLUX'
      }]);

      var BAKE_SKELETON_CURVE_SYMBOL = Symbol('BakeNodeCurves');

      var SkelAnimDataHub = function () {
        function SkelAnimDataHub() {}

        SkelAnimDataHub.getOrExtract = function getOrExtract(clip) {
          var data = SkelAnimDataHub.pool.get(clip);

          if (!data || data.samples !== clip.sample) {
            if (data) {
              legacyCC.director.root.dataPoolManager.releaseAnimationClip(clip);
            }

            var frames = Math.ceil(clip.sample * clip.duration) + 1;
            var step = clip.sample;
            data = clip[BAKE_SKELETON_CURVE_SYMBOL](0, step, frames);
            SkelAnimDataHub.pool.set(clip, data);
          }

          return data;
        };

        SkelAnimDataHub.destroy = function destroy(clip) {
          SkelAnimDataHub.pool["delete"](clip);
        };

        return SkelAnimDataHub;
      }();
      SkelAnimDataHub.pool = new Map();

      var m4_1$1 = new Mat4();
      function getPathFromRoot(target, root) {
        var node = target;
        var path = '';

        while (node !== null && node !== root) {
          path = node.name + "/" + path;
          node = node.parent;
        }

        return path.slice(0, -1);
      }
      function getWorldTransformUntilRoot(target, root, outMatrix) {
        Mat4.identity(outMatrix);

        while (target !== root) {
          Mat4.fromRTS(m4_1$1, target.rotation, target.position, target.scale);
          Mat4.multiply(outMatrix, m4_1$1, outMatrix);
          target = target.parent;
        }

        return outMatrix;
      }

      var jointTextureSamplerInfo = new SamplerInfo(Filter.POINT, Filter.POINT, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);

      var uploadJointData = uploadJointDataLBS;
      var MINIMUM_JOINT_TEXTURE_SIZE =  480;
      function selectJointsMediumFormat(device) {
        if (device.getFormatFeatures(Format.RGBA32F) & FormatFeatureBit.SAMPLED_TEXTURE) {
          return Format.RGBA32F;
        }

        return Format.RGBA8;
      }

      function uploadJointDataLBS(out, base, mat, firstBone) {
        out[base + 0] = mat.m00;
        out[base + 1] = mat.m01;
        out[base + 2] = mat.m02;
        out[base + 3] = mat.m12;
        out[base + 4] = mat.m04;
        out[base + 5] = mat.m05;
        out[base + 6] = mat.m06;
        out[base + 7] = mat.m13;
        out[base + 8] = mat.m08;
        out[base + 9] = mat.m09;
        out[base + 10] = mat.m10;
        out[base + 11] = mat.m14;
      }

      var dq_0 = new Quat();
      var dq_1 = new Quat();
      var v3_1$2 = new Vec3();
      var qt_1 = new Quat();
      var v3_2$1 = new Vec3();

      function roundUpTextureSize(targetLength, formatSize) {
        var formatScale = 4 / Math.sqrt(formatSize);
        return Math.ceil(Math.max(MINIMUM_JOINT_TEXTURE_SIZE * formatScale, targetLength) / 12) * 12;
      }
      var v3_3 = new Vec3();
      var v3_4 = new Vec3();
      var v3_min = new Vec3();
      var v3_max = new Vec3();
      var m4_1$2 = new Mat4();
      var m4_2 = new Mat4();
      var ab_1 = new AABB();
      var Inf = Number.MAX_SAFE_INTEGER;
      var JointTexturePool = function () {
        function JointTexturePool(device) {
          this._device = void 0;
          this._pool = void 0;
          this._textureBuffers = new Map();
          this._formatSize = void 0;
          this._pixelsPerJoint = void 0;
          this._customPool = void 0;
          this._chunkIdxMap = new Map();
          this._device = device;
          var format = selectJointsMediumFormat(this._device);
          this._formatSize = FormatInfos[format].size;
          this._pixelsPerJoint = 48 / this._formatSize;
          this._pool = new TextureBufferPool(device);

          this._pool.initialize({
            format: format,
            roundUpFn: roundUpTextureSize
          });

          this._customPool = new TextureBufferPool(device);

          this._customPool.initialize({
            format: format,
            roundUpFn: roundUpTextureSize
          });
        }

        var _proto = JointTexturePool.prototype;

        _proto.clear = function clear() {
          this._pool.destroy();

          this._textureBuffers.clear();
        };

        _proto.registerCustomTextureLayouts = function registerCustomTextureLayouts(layouts) {
          for (var i = 0; i < layouts.length; i++) {
            var layout = layouts[i];

            var chunkIdx = this._customPool.createChunk(layout.textureLength);

            for (var j = 0; j < layout.contents.length; j++) {
              var content = layout.contents[j];
              var skeleton = content.skeleton;

              this._chunkIdxMap.set(skeleton, chunkIdx);

              for (var k = 0; k < content.clips.length; k++) {
                var clip = content.clips[k];

                this._chunkIdxMap.set(skeleton ^ clip, chunkIdx);
              }
            }
          }
        };

        _proto.getDefaultPoseTexture = function getDefaultPoseTexture(skeleton, mesh, skinningRoot) {
          var hash = skeleton.hash ^ 0;
          var texture = this._textureBuffers.get(hash) || null;

          if (texture && texture.bounds.has(mesh.hash)) {
            texture.refCount++;
            return texture;
          }

          var joints = skeleton.joints,
              bindposes = skeleton.bindposes;
          var textureBuffer = null;
          var buildTexture = false;
          var jointCount = joints.length;

          if (!texture) {
            var bufSize = jointCount * 12;

            var customChunkIdx = this._chunkIdxMap.get(hash);

            var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

            if (!handle) {
              return texture;
            }

            texture = {
              pixelOffset: handle.start / this._formatSize,
              refCount: 1,
              bounds: new Map(),
              skeletonHash: skeleton.hash,
              clipHash: 0,
              readyToBeDeleted: false,
              handle: handle
            };
            textureBuffer = new Float32Array(bufSize);
            buildTexture = true;
          } else {
            texture.refCount++;
          }

          Vec3.set(v3_min, Inf, Inf, Inf);
          Vec3.set(v3_max, -Inf, -Inf, -Inf);
          var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);

          for (var j = 0, offset = 0; j < jointCount; j++, offset += 12) {
            var node = skinningRoot.getChildByPath(joints[j]);
            var mat = node ? getWorldTransformUntilRoot(node, skinningRoot, m4_1$2) : skeleton.inverseBindposes[j];
            var bound = boneSpaceBounds[j];

            if (bound) {
              AABB.transform(ab_1, bound, mat);
              ab_1.getBoundary(v3_3, v3_4);
              Vec3.min(v3_min, v3_min, v3_3);
              Vec3.max(v3_max, v3_max, v3_4);
            }

            if (buildTexture) {
              if (node) {
                Mat4.multiply(mat, mat, bindposes[j]);
              }

              uploadJointData(textureBuffer, offset, node ? mat : Mat4.IDENTITY);
            }
          }

          var bounds = [new AABB()];
          texture.bounds.set(mesh.hash, bounds);
          AABB.fromPoints(bounds[0], v3_min, v3_max);

          if (buildTexture) {
            this._pool.update(texture.handle, textureBuffer.buffer);

            this._textureBuffers.set(hash, texture);
          }

          return texture;
        };

        _proto.getSequencePoseTexture = function getSequencePoseTexture(skeleton, clip, mesh, skinningRoot) {
          var hash = skeleton.hash ^ clip.hash;
          var texture = this._textureBuffers.get(hash) || null;

          if (texture && texture.bounds.has(mesh.hash)) {
            texture.refCount++;
            return texture;
          }

          var joints = skeleton.joints,
              bindposes = skeleton.bindposes;
          var clipData = SkelAnimDataHub.getOrExtract(clip);
          var frames = clipData.frames;
          var textureBuffer = null;
          var buildTexture = false;
          var jointCount = joints.length;

          if (!texture) {
            var bufSize = jointCount * 12 * frames;

            var customChunkIdx = this._chunkIdxMap.get(hash);

            var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

            if (!handle) {
              return null;
            }

            var animInfos = this._createAnimInfos(skeleton, clip, skinningRoot);

            texture = {
              pixelOffset: handle.start / this._formatSize,
              refCount: 1,
              bounds: new Map(),
              skeletonHash: skeleton.hash,
              clipHash: clip.hash,
              readyToBeDeleted: false,
              handle: handle,
              animInfos: animInfos
            };
            textureBuffer = new Float32Array(bufSize);
            buildTexture = true;
          } else {
            texture.refCount++;
          }

          var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
          var bounds = [];
          texture.bounds.set(mesh.hash, bounds);

          for (var f = 0; f < frames; f++) {
            bounds.push(new AABB(Inf, Inf, Inf, -Inf, -Inf, -Inf));
          }

          for (var _f = 0, offset = 0; _f < frames; _f++) {
            var bound = bounds[_f];

            for (var j = 0; j < jointCount; j++, offset += 12) {
              var _j = texture.animInfos[j],
                  curveData = _j.curveData,
                  downstream = _j.downstream,
                  bindposeIdx = _j.bindposeIdx,
                  bindposeCorrection = _j.bindposeCorrection;
              var mat = void 0;
              var transformValid = true;

              if (curveData && downstream) {
                mat = Mat4.multiply(m4_1$2, curveData[_f], downstream);
              } else if (curveData) {
                mat = curveData[_f];
              } else if (downstream) {
                mat = downstream;
              } else {
                mat = skeleton.inverseBindposes[bindposeIdx];
                transformValid = false;
              }

              var boneSpaceBound = boneSpaceBounds[j];

              if (boneSpaceBound) {
                var transform = bindposeCorrection ? Mat4.multiply(m4_2, mat, bindposeCorrection) : mat;
                AABB.transform(ab_1, boneSpaceBound, transform);
                ab_1.getBoundary(v3_3, v3_4);
                Vec3.min(bound.center, bound.center, v3_3);
                Vec3.max(bound.halfExtents, bound.halfExtents, v3_4);
              }

              if (buildTexture) {
                if (transformValid) {
                  Mat4.multiply(m4_1$2, mat, bindposes[bindposeIdx]);
                }

                uploadJointData(textureBuffer, offset, transformValid ? m4_1$2 : Mat4.IDENTITY);
              }
            }

            AABB.fromPoints(bound, bound.center, bound.halfExtents);
          }

          if (buildTexture) {
            this._pool.update(texture.handle, textureBuffer.buffer);

            this._textureBuffers.set(hash, texture);
          }

          return texture;
        };

        _proto.releaseHandle = function releaseHandle(handle) {
          if (handle.refCount > 0) {
            handle.refCount--;
          }

          if (!handle.refCount && handle.readyToBeDeleted) {
            var hash = handle.skeletonHash ^ handle.clipHash;

            var customChunkIdx = this._chunkIdxMap.get(hash);

            (customChunkIdx !== undefined ? this._customPool : this._pool).free(handle.handle);

            if (this._textureBuffers.get(hash) === handle) {
              this._textureBuffers["delete"](hash);
            }
          }
        };

        _proto.releaseSkeleton = function releaseSkeleton(skeleton) {
          var it = this._textureBuffers.values();

          var res = it.next();

          while (!res.done) {
            var handle = res.value;

            if (handle.skeletonHash === skeleton.hash) {
              handle.readyToBeDeleted = true;

              if (handle.refCount) {
                this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
              } else {
                this.releaseHandle(handle);
              }
            }

            res = it.next();
          }
        };

        _proto.releaseAnimationClip = function releaseAnimationClip(clip) {
          var it = this._textureBuffers.values();

          var res = it.next();

          while (!res.done) {
            var handle = res.value;

            if (handle.clipHash === clip.hash) {
              handle.readyToBeDeleted = true;

              if (handle.refCount) {
                this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
              } else {
                this.releaseHandle(handle);
              }
            }

            res = it.next();
          }
        };

        _proto._createAnimInfos = function _createAnimInfos(skeleton, clip, skinningRoot) {
          var animInfos = [];
          var joints = skeleton.joints,
              bindposes = skeleton.bindposes;
          var jointCount = joints.length;
          var clipData = SkelAnimDataHub.getOrExtract(clip);

          for (var j = 0; j < jointCount; j++) {
            var animPath = joints[j];
            var source = clipData.joints[animPath];
            var animNode = skinningRoot.getChildByPath(animPath);
            var downstream = void 0;
            var correctionPath = void 0;

            while (!source) {
              var idx = animPath.lastIndexOf('/');
              animPath = animPath.substring(0, idx);
              source = clipData.joints[animPath];

              if (animNode) {
                if (!downstream) {
                  downstream = new Mat4();
                }

                Mat4.fromRTS(m4_1$2, animNode.rotation, animNode.position, animNode.scale);
                Mat4.multiply(downstream, m4_1$2, downstream);
                animNode = animNode.parent;
              } else {
                correctionPath = animPath;
              }

              if (idx < 0) {
                break;
              }
            }

            var bindposeIdx = j;
            var bindposeCorrection = void 0;

            if (correctionPath !== undefined && source) {
              bindposeIdx = j - 1;

              for (var t = 0; t < jointCount; t++) {
                if (joints[t] === correctionPath) {
                  bindposeIdx = t;
                  bindposeCorrection = new Mat4();
                  Mat4.multiply(bindposeCorrection, bindposes[t], skeleton.inverseBindposes[j]);
                  break;
                }
              }
            }

            animInfos.push({
              curveData: source && source.transforms,
              downstream: downstream,
              bindposeIdx: bindposeIdx,
              bindposeCorrection: bindposeCorrection
            });
          }

          return animInfos;
        };

        _createClass(JointTexturePool, [{
          key: "pixelsPerJoint",
          get: function get() {
            return this._pixelsPerJoint;
          }
        }]);

        return JointTexturePool;
      }();

      var stack = [];
      var pool$1 = new Map();
      function getWorldMatrix(transform, stamp) {
        var i = 0;
        var res = Mat4.IDENTITY;

        while (transform) {
          if (transform.stamp === stamp || transform.stamp + 1 === stamp && !transform.node.hasChangedFlags) {
            res = transform.world;
            transform.stamp = stamp;
            break;
          }

          transform.stamp = stamp;
          stack[i++] = transform;
          transform = transform.parent;
        }

        while (i > 0) {
          transform = stack[--i];
          stack[i] = null;
          var node = transform.node;
          Mat4.fromRTS(transform.local, node.rotation, node.position, node.scale);
          res = Mat4.multiply(transform.world, res, transform.local);
        }

        return res;
      }
      function getTransform(node, root) {
        var joint = null;
        var i = 0;

        while (node !== root) {
          var id = node.uuid;

          if (pool$1.has(id)) {
            joint = pool$1.get(id);
            break;
          } else {
            joint = {
              node: node,
              local: new Mat4(),
              world: new Mat4(),
              stamp: -1,
              parent: null
            };
            pool$1.set(id, joint);
          }

          stack[i++] = joint;
          node = node.parent;
          joint = null;
        }

        var child;

        while (i > 0) {
          child = stack[--i];
          stack[i] = null;
          child.parent = joint;
          joint = child;
        }

        return joint;
      }
      function deleteTransform(node) {
        var transform = pool$1.get(node.uuid) || null;

        while (transform) {
          pool$1["delete"](transform.node.uuid);
          transform = transform.parent;
        }
      }

      var uniformPatches = [{
        name: 'CC_USE_SKINNING',
        value: true
      }, {
        name: 'CC_USE_REAL_TIME_JOINT_TEXTURE',
        value: false
      }];
      var texturePatches = [{
        name: 'CC_USE_SKINNING',
        value: true
      }, {
        name: 'CC_USE_REAL_TIME_JOINT_TEXTURE',
        value: true
      }];

      function getRelevantBuffers(outIndices, outBuffers, jointMaps, targetJoint) {
        for (var i = 0; i < jointMaps.length; i++) {
          var idxMap = jointMaps[i];
          var index = -1;

          for (var j = 0; j < idxMap.length; j++) {
            if (idxMap[j] === targetJoint) {
              index = j;
              break;
            }
          }

          if (index >= 0) {
            outBuffers.push(i);
            outIndices.push(index);
          }
        }
      }

      var v3_min$1 = new Vec3();
      var v3_max$1 = new Vec3();
      var v3_1$3 = new Vec3();
      var v3_2$2 = new Vec3();
      var m4_1$3 = new Mat4();
      var ab_1$1 = new AABB();

      var RealTimeJointTexture = function RealTimeJointTexture() {
        this._format = PixelFormat.RGBA32F;
        this._textures = [];
        this._buffers = [];
      };

      RealTimeJointTexture.WIDTH = 256;
      RealTimeJointTexture.HEIGHT = 3;
      var SkinningModel = function (_MorphModel) {
        _inheritsLoose(SkinningModel, _MorphModel);

        function SkinningModel() {
          var _this;

          _this = _MorphModel.call(this) || this;
          _this._buffers = [];
          _this._dataArray = [];
          _this._joints = [];
          _this._bufferIndices = null;
          _this._realTimeJointTexture = new RealTimeJointTexture();
          _this._realTimeTextureMode = false;
          _this.type = ModelType.SKINNING;
          return _this;
        }

        var _proto = SkinningModel.prototype;

        _proto.destroy = function destroy() {
          this.bindSkeleton();

          if (this._buffers.length) {
            for (var i = 0; i < this._buffers.length; i++) {
              this._buffers[i].destroy();
            }

            this._buffers.length = 0;
          }

          this._dataArray.length = 0;

          this._realTimeJointTexture._textures.forEach(function (tex) {
            tex.destroy();
          });

          this._realTimeJointTexture._textures.length = 0;
          this._realTimeJointTexture._buffers.length = 0;

          _MorphModel.prototype.destroy.call(this);
        };

        _proto.uploadAnimation = function uploadAnimation() {};

        _proto.bindSkeleton = function bindSkeleton(skeleton, skinningRoot, mesh) {
          if (skeleton === void 0) {
            skeleton = null;
          }

          if (skinningRoot === void 0) {
            skinningRoot = null;
          }

          if (mesh === void 0) {
            mesh = null;
          }

          for (var i = 0; i < this._joints.length; i++) {
            deleteTransform(this._joints[i].target);
          }

          this._bufferIndices = null;
          this._joints.length = 0;

          if (!skeleton || !skinningRoot || !mesh) {
            return;
          }

          this._realTimeTextureMode = false;

          if (UBOSkinning.JOINT_UNIFORM_CAPACITY < skeleton.joints.length) {
            this._realTimeTextureMode = true;
          }

          this.transform = skinningRoot;
          var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
          var jointMaps = mesh.struct.jointMaps;

          this._ensureEnoughBuffers(jointMaps && jointMaps.length || 1);

          this._bufferIndices = mesh.jointBufferIndices;

          this._initRealTimeJointTexture();

          for (var index = 0; index < skeleton.joints.length; index++) {
            var bound = boneSpaceBounds[index];
            var target = skinningRoot.getChildByPath(skeleton.joints[index]);

            if (!bound || !target) {
              continue;
            }

            var transform = getTransform(target, skinningRoot);
            var bindpose = skeleton.bindposes[index];
            var indices = [];
            var buffers = [];

            if (!jointMaps) {
              indices.push(index);
              buffers.push(0);
            } else {
              getRelevantBuffers(indices, buffers, jointMaps, index);
            }

            this._joints.push({
              indices: indices,
              buffers: buffers,
              bound: bound,
              target: target,
              bindpose: bindpose,
              transform: transform
            });
          }
        };

        _proto.updateTransform = function updateTransform(stamp) {
          var root = this.transform;

          if (root.hasChangedFlags || root._dirtyFlags) {
            root.updateWorldTransform();
            this._localDataUpdated = true;
          }

          Vec3.set(v3_min$1, Infinity, Infinity, Infinity);
          Vec3.set(v3_max$1, -Infinity, -Infinity, -Infinity);

          for (var i = 0; i < this._joints.length; i++) {
            var _this$_joints$i = this._joints[i],
                bound = _this$_joints$i.bound,
                transform = _this$_joints$i.transform;
            var worldMatrix = getWorldMatrix(transform, stamp);
            AABB.transform(ab_1$1, bound, worldMatrix);
            ab_1$1.getBoundary(v3_1$3, v3_2$2);
            Vec3.min(v3_min$1, v3_min$1, v3_1$3);
            Vec3.max(v3_max$1, v3_max$1, v3_2$2);
          }

          var worldBounds = this._worldBounds;

          if (this._modelBounds && worldBounds) {
            AABB.fromPoints(this._modelBounds, v3_min$1, v3_max$1);

            this._modelBounds.transform(root._mat, root._pos, root._rot, root._scale, this._worldBounds);
          }
        };

        _proto.updateUBOs = function updateUBOs(stamp) {
          _MorphModel.prototype.updateUBOs.call(this, stamp);

          for (var i = 0; i < this._joints.length; i++) {
            var _this$_joints$i2 = this._joints[i],
                indices = _this$_joints$i2.indices,
                buffers = _this$_joints$i2.buffers,
                transform = _this$_joints$i2.transform,
                bindpose = _this$_joints$i2.bindpose;
            Mat4.multiply(m4_1$3, transform.world, bindpose);

            for (var b = 0; b < buffers.length; b++) {
              uploadJointData(this._dataArray[buffers[b]], indices[b] * 12, m4_1$3);
            }
          }

          if (this._realTimeTextureMode) {
            this._updateRealTimeJointTextureBuffer();
          } else {
            for (var _b = 0; _b < this._buffers.length; _b++) {
              this._buffers[_b].update(this._dataArray[_b]);
            }
          }

          return true;
        };

        _proto.initSubModel = function initSubModel(idx, subMeshData, mat) {
          var original = subMeshData.vertexBuffers;
          var iaInfo = subMeshData.iaInfo;
          iaInfo.vertexBuffers = subMeshData.jointMappedBuffers;

          _MorphModel.prototype.initSubModel.call(this, idx, subMeshData, mat);

          iaInfo.vertexBuffers = original;
        };

        _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
          var superMacroPatches = _MorphModel.prototype.getMacroPatches.call(this, subModelIndex);

          var myPatches = uniformPatches;

          if (this._realTimeTextureMode) {
            myPatches = texturePatches;
          }

          if (superMacroPatches) {
            return myPatches.concat(superMacroPatches);
          }

          return myPatches;
        };

        _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
          _MorphModel.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);

          var idx = this._bufferIndices[submodelIdx];

          if (this._realTimeTextureMode) {
            this._bindRealTimeJointTexture(idx, descriptorSet);
          } else {
            var buffer = this._buffers[idx];

            if (buffer) {
              descriptorSet.bindBuffer(UBOSkinning.BINDING, buffer);
            }
          }
        };

        _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, pass) {
          if (pass.batchingScheme !== BatchingSchemes.NONE) {
            warnID(3936, this.node.getPathInHierarchy());
          }

          _MorphModel.prototype._updateInstancedAttributes.call(this, attributes, pass);
        };

        _proto._ensureEnoughBuffers = function _ensureEnoughBuffers(count) {
          if (this._buffers.length) {
            for (var i = 0; i < this._buffers.length; i++) {
              this._buffers[i].destroy();
            }

            this._buffers.length = 0;
          }

          if (this._dataArray.length) this._dataArray.length = 0;

          if (!this._realTimeTextureMode) {
            for (var _i = 0; _i < count; _i++) {
              this._buffers[_i] = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOSkinning.SIZE, UBOSkinning.SIZE));
              var maxJoints = UBOSkinning.JOINT_UNIFORM_CAPACITY;
              this._dataArray[_i] = new Float32Array(12 * maxJoints);
            }
          } else {
            for (var _i2 = 0; _i2 < count; _i2++) {
              var _maxJoints = RealTimeJointTexture.WIDTH;
              this._dataArray[_i2] = new Float32Array(12 * _maxJoints);
            }
          }
        };

        _proto._initRealTimeJointTexture = function _initRealTimeJointTexture() {
          if (this._realTimeJointTexture._textures.length) {
            this._realTimeJointTexture._textures.forEach(function (tex) {
              tex.destroy();
            });

            this._realTimeJointTexture._textures.length = 0;
          }

          this._realTimeJointTexture._buffers.length = 0;
          if (!this._realTimeTextureMode) return;
          var gfxDevice = director.root.device;
          var width = RealTimeJointTexture.WIDTH;
          var height = RealTimeJointTexture.HEIGHT;
          var hasFeatureFloatTexture = gfxDevice.getFormatFeatures(Format.RGBA32F) & FormatFeatureBit.SAMPLED_TEXTURE;

          if (hasFeatureFloatTexture === 0) {
            this._realTimeJointTexture._format = PixelFormat.RGBA8888;
            width = 4 * RealTimeJointTexture.WIDTH;
          }

          var textures = this._realTimeJointTexture._textures;
          var buffers = this._realTimeJointTexture._buffers;
          var pixelFormat = this._realTimeJointTexture._format;

          for (var i = 0; i < this._dataArray.length; i++) {
            buffers[i] = new Float32Array(4 * RealTimeJointTexture.HEIGHT * RealTimeJointTexture.WIDTH);
            var arrayBuffer = buffers[i];
            var updateView = pixelFormat === PixelFormat.RGBA32F ? arrayBuffer : new Uint8Array(arrayBuffer.buffer);
            var image = new ImageAsset({
              width: width,
              height: height,
              _data: updateView,
              _compressed: false,
              format: pixelFormat
            });
            var texture = new Texture2D();
            texture.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST);
            texture.setMipFilter(Texture2D.Filter.NONE);
            texture.setWrapMode(Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE);
            texture.image = image;
            textures[i] = texture;
          }
        };

        _proto._bindRealTimeJointTexture = function _bindRealTimeJointTexture(idx, descriptorSet) {
          if (!this._realTimeTextureMode) return;
          var jointTexture = this._realTimeJointTexture._textures[idx];

          if (jointTexture) {
            var gfxTexture = jointTexture.getGFXTexture();
            var sampler = jointTexture.getGFXSampler();
            descriptorSet.bindTexture(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, gfxTexture);
            descriptorSet.bindSampler(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, sampler);
          }
        };

        _proto._updateRealTimeJointTextureBuffer = function _updateRealTimeJointTextureBuffer() {
          if (!this._realTimeTextureMode) return;
          var textures = this._realTimeJointTexture._textures;
          var buffers = this._realTimeJointTexture._buffers;

          for (var idx = 0; idx < textures.length; idx++) {
            var arrayBuffer = buffers[idx];
            var src = this._dataArray[idx];
            var count = src.length / 12;
            var idxSrc = 0;
            var idxDst = 0;

            for (var i = 0; i < count; i++) {
              idxDst = 4 * i;
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
              idxDst = 4 * (i + RealTimeJointTexture.WIDTH);
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
              idxDst = 4 * (i + 2 * RealTimeJointTexture.WIDTH);
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
              arrayBuffer[idxDst++] = src[idxSrc++];
            }

            var pixelFormat = this._realTimeJointTexture._format;
            var updateView = pixelFormat === PixelFormat.RGBA32F ? arrayBuffer : new Uint8Array(arrayBuffer.buffer);
            textures[idx].uploadData(updateView);
          }
        };

        return SkinningModel;
      }(MorphModel);

      var myPatches = [{
        name: 'CC_USE_SKINNING',
        value: true
      }, {
        name: 'CC_USE_BAKED_ANIMATION',
        value: true
      }];
      var BakedSkinningModel = function (_MorphModel) {
        _inheritsLoose(BakedSkinningModel, _MorphModel);

        function BakedSkinningModel() {
          var _this;

          _this = _MorphModel.call(this) || this;
          _this.uploadedAnim = undefined;
          _this._jointsMedium = void 0;
          _this._skeleton = null;
          _this._mesh = null;
          _this._dataPoolManager = void 0;
          _this._instAnimInfoIdx = -1;
          _this.type = ModelType.BAKED_SKINNING;
          _this._dataPoolManager = legacyCC.director.root.dataPoolManager;
          var jointTextureInfo = new Float32Array(4);

          var animInfo = _this._dataPoolManager.jointAnimationInfo.getData();

          _this._jointsMedium = {
            buffer: null,
            jointTextureInfo: jointTextureInfo,
            animInfo: animInfo,
            texture: null,
            boundsInfo: null
          };
          return _this;
        }

        var _proto = BakedSkinningModel.prototype;

        _proto.destroy = function destroy() {
          this.uploadedAnim = undefined;
          this._jointsMedium.boundsInfo = null;

          if (this._jointsMedium.buffer) {
            this._jointsMedium.buffer.destroy();

            this._jointsMedium.buffer = null;
          }

          this._applyJointTexture();

          _MorphModel.prototype.destroy.call(this);
        };

        _proto.bindSkeleton = function bindSkeleton(skeleton, skinningRoot, mesh) {
          if (skeleton === void 0) {
            skeleton = null;
          }

          if (skinningRoot === void 0) {
            skinningRoot = null;
          }

          if (mesh === void 0) {
            mesh = null;
          }

          this._skeleton = skeleton;
          this._mesh = mesh;

          if (!skeleton || !skinningRoot || !mesh) {
            return;
          }

          this.transform = skinningRoot;
          var resMgr = this._dataPoolManager;
          this._jointsMedium.animInfo = resMgr.jointAnimationInfo.getData(skinningRoot.uuid);

          if (!this._jointsMedium.buffer) {
            this._jointsMedium.buffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOSkinningTexture.SIZE, UBOSkinningTexture.SIZE));
          }
        };

        _proto.updateTransform = function updateTransform(stamp) {
          _MorphModel.prototype.updateTransform.call(this, stamp);

          if (!this.uploadedAnim) {
            return;
          }

          var _this$_jointsMedium = this._jointsMedium,
              animInfo = _this$_jointsMedium.animInfo,
              boundsInfo = _this$_jointsMedium.boundsInfo;
          var skelBound = boundsInfo[animInfo.data[0]];
          var worldBounds = this._worldBounds;

          if (worldBounds && skelBound) {
            var node = this.transform;
            skelBound.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
          }
        };

        _proto.updateUBOs = function updateUBOs(stamp) {
          _MorphModel.prototype.updateUBOs.call(this, stamp);

          var info = this._jointsMedium.animInfo;
          var idx = this._instAnimInfoIdx;

          if (idx >= 0) {
            var view = this.instancedAttributes.views[idx];
            view[0] = info.data[0];
          } else if (info.dirty) {
            info.buffer.update(info.data);
            info.dirty = false;
          }

          return true;
        };

        _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
          var patches = _MorphModel.prototype.getMacroPatches.call(this, subModelIndex);

          return patches ? patches.concat(myPatches) : myPatches;
        };

        _proto.uploadAnimation = function uploadAnimation(anim) {
          if (!this._skeleton || !this._mesh || this.uploadedAnim === anim) {
            return;
          }

          this.uploadedAnim = anim;
          var resMgr = this._dataPoolManager;
          var texture = null;

          if (anim) {
            texture = resMgr.jointTexturePool.getSequencePoseTexture(this._skeleton, anim, this._mesh, this.transform);
            this._jointsMedium.boundsInfo = texture && texture.bounds.get(this._mesh.hash);
            this._modelBounds = null;
          } else {
            texture = resMgr.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform);
            this._jointsMedium.boundsInfo = null;
            this._modelBounds = texture && texture.bounds.get(this._mesh.hash)[0];
          }

          this._applyJointTexture(texture);
        };

        _proto._applyJointTexture = function _applyJointTexture(texture) {
          if (texture === void 0) {
            texture = null;
          }

          var oldTex = this._jointsMedium.texture;

          if (oldTex && oldTex !== texture) {
            this._dataPoolManager.jointTexturePool.releaseHandle(oldTex);
          }

          this._jointsMedium.texture = texture;

          if (!texture) {
            return;
          }

          var _this$_jointsMedium2 = this._jointsMedium,
              buffer = _this$_jointsMedium2.buffer,
              jointTextureInfo = _this$_jointsMedium2.jointTextureInfo;
          jointTextureInfo[0] = texture.handle.texture.width;
          jointTextureInfo[1] = this._skeleton.joints.length;
          jointTextureInfo[2] = texture.pixelOffset + 0.1;
          jointTextureInfo[3] = 1 / jointTextureInfo[0];
          this.updateInstancedJointTextureInfo();

          if (buffer) {
            buffer.update(jointTextureInfo);
          }

          var tex = texture.handle.texture;

          for (var i = 0; i < this._subModels.length; ++i) {
            var descriptorSet = this._subModels[i].descriptorSet;
            descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, tex);
          }
        };

        _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
          _MorphModel.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);

          var _this$_jointsMedium3 = this._jointsMedium,
              buffer = _this$_jointsMedium3.buffer,
              texture = _this$_jointsMedium3.texture,
              animInfo = _this$_jointsMedium3.animInfo;
          descriptorSet.bindBuffer(UBOSkinningTexture.BINDING, buffer);
          descriptorSet.bindBuffer(UBOSkinningAnimation.BINDING, animInfo.buffer);

          if (texture) {
            var sampler = this._device.getSampler(jointTextureSamplerInfo);

            descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, texture.handle.texture);
            descriptorSet.bindSampler(UNIFORM_JOINT_TEXTURE_BINDING, sampler);
          }
        };

        _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, pass) {
          _MorphModel.prototype._updateInstancedAttributes.call(this, attributes, pass);

          this._instAnimInfoIdx = this._getInstancedAttributeIndex(INST_JOINT_ANIM_INFO);
          this.updateInstancedJointTextureInfo();
        };

        _proto.updateInstancedJointTextureInfo = function updateInstancedJointTextureInfo() {
          var _this$_jointsMedium4 = this._jointsMedium,
              jointTextureInfo = _this$_jointsMedium4.jointTextureInfo,
              animInfo = _this$_jointsMedium4.animInfo;
          var idx = this._instAnimInfoIdx;

          if (idx >= 0) {
            var view = this.instancedAttributes.views[idx];
            view[0] = animInfo.data[0];
            view[1] = jointTextureInfo[1];
            view[2] = jointTextureInfo[2];
          }
        };

        return BakedSkinningModel;
      }(MorphModel);

      var _dec$t, _dec2$n, _dec3$m, _dec4$k, _dec5$i, _dec6$g, _dec7$f, _dec8$e, _dec9$a, _class$t, _class2$o, _descriptor$m, _descriptor2$j, _temp$q;
      var SkinnedMeshRenderer = function (v) { return exports({ SkinnedMeshRenderer: v, SkinningModelComponent: v }), v; }((_dec$t = ccclass('cc.SkinnedMeshRenderer'), _dec2$n = help(), _dec3$m = executionOrder(100), _dec4$k = menu(), _dec5$i = type(Skeleton), _dec6$g = type(Node), _dec7$f = type(Skeleton), _dec8$e = type(Node), _dec9$a = tooltip(), _dec$t(_class$t = _dec2$n(_class$t = _dec3$m(_class$t = executeInEditMode(_class$t = _dec4$k(_class$t = (_class2$o = (_temp$q = function (_MeshRenderer) {
        _inheritsLoose(SkinnedMeshRenderer, _MeshRenderer);

        function SkinnedMeshRenderer() {
          var _this;

          _this = _MeshRenderer.call(this) || this;

          _initializerDefineProperty(_this, "_skeleton", _descriptor$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_skinningRoot", _descriptor2$j, _assertThisInitialized(_this));

          _this._clip = null;
          _this.associatedAnimation = null;
          _this._modelType = BakedSkinningModel;
          return _this;
        }

        var _proto = SkinnedMeshRenderer.prototype;

        _proto.onLoad = function onLoad() {
          _MeshRenderer.prototype.onLoad.call(this);

          this._tryBindAnimation();
        };

        _proto.onDestroy = function onDestroy() {
          if (this.associatedAnimation) {
            this.associatedAnimation.notifySkinnedMeshRemoved(this);
            assertIsTrue(this.associatedAnimation === null);
          }

          _MeshRenderer.prototype.onDestroy.call(this);
        };

        _proto.uploadAnimation = function uploadAnimation(clip) {
          this._clip = clip;

          if (this.model && this.model.uploadAnimation) {
            this.model.uploadAnimation(clip);
          }
        };

        _proto.setUseBakedAnimation = function setUseBakedAnimation(val, force) {
          if (val === void 0) {
            val = true;
          }

          if (force === void 0) {
            force = false;
          }

          var modelType = val ? BakedSkinningModel : SkinningModel;

          if (!force && this._modelType === modelType) {
            return;
          }

          this._modelType = modelType;

          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
            this._models.length = 0;

            this._updateModels();

            this._updateCastShadow();

            this._updateReceiveShadow();

            if (this.enabledInHierarchy) {
              this._attachToScene();
            }
          }
        };

        _proto.setMaterial = function setMaterial(material, index) {
          _MeshRenderer.prototype.setMaterial.call(this, material, index);

          if (this._modelType === SkinningModel) {
            this.getMaterialInstance(index);
          }
        };

        _proto._updateModelParams = function _updateModelParams() {
          this._update();

          _MeshRenderer.prototype._updateModelParams.call(this);
        };

        _proto._tryBindAnimation = function _tryBindAnimation() {
          var skinningRoot = this._skinningRoot;

          if (!skinningRoot) {
            return;
          }

          var skinningRootIsParent = false;

          for (var current = this.node; current; current = current.parent) {
            if (current === skinningRoot) {
              skinningRootIsParent = true;
              break;
            }
          }

          if (!skinningRootIsParent) {
            return;
          }

          var animation = skinningRoot.getComponent('cc.SkeletalAnimation');

          if (animation) {
            animation.notifySkinnedMeshAdded(this);
          } else {
            this.setUseBakedAnimation(false);
          }
        };

        _proto._update = function _update() {
          if (this.model) {
            this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh);

            if (this.model.uploadAnimation) {
              this.model.uploadAnimation(this._clip);
            }
          }
        };

        _createClass(SkinnedMeshRenderer, [{
          key: "skeleton",
          get: function get() {
            return this._skeleton;
          },
          set: function set(val) {
            if (val === this._skeleton) {
              return;
            }

            this._skeleton = val;

            this._update();
          }
        }, {
          key: "skinningRoot",
          get: function get() {
            return this._skinningRoot;
          },
          set: function set(value) {
            this._skinningRoot = value;

            this._tryBindAnimation();

            if (value === this._skinningRoot) {
              return;
            }

            this._update();
          }
        }, {
          key: "model",
          get: function get() {
            return this._model;
          }
        }]);

        return SkinnedMeshRenderer;
      }(MeshRenderer), _temp$q), (_descriptor$m = _applyDecoratedDescriptor(_class2$o.prototype, "_skeleton", [_dec5$i], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$j = _applyDecoratedDescriptor(_class2$o.prototype, "_skinningRoot", [_dec6$g], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$o.prototype, "skeleton", [_dec7$f], Object.getOwnPropertyDescriptor(_class2$o.prototype, "skeleton"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "skinningRoot", [_dec8$e, _dec9$a], Object.getOwnPropertyDescriptor(_class2$o.prototype, "skinningRoot"), _class2$o.prototype)), _class2$o)) || _class$t) || _class$t) || _class$t) || _class$t) || _class$t));

      var _dec$u, _dec2$o, _dec3$n, _dec4$l, _dec5$j, _class$u, _class2$p, _descriptor$n, _descriptor2$k, _descriptor3$g, _descriptor4$d, _descriptor5$b, _descriptor6$9, _temp$r, _dec6$h, _dec7$g, _dec8$f, _dec9$b, _dec10$a, _dec11$9, _dec12$8, _dec13$8, _dec14$6, _dec15$6, _dec16$6, _class4$2, _class5$2, _descriptor7$7, _descriptor8$7, _descriptor9$6, _temp2$2;

      var repeat = function repeat(n) {
        return n - Math.floor(n);
      };

      var batch_id = new Attribute(AttributeName.ATTR_BATCH_ID, Format.R32F);
      var batch_uv = new Attribute(AttributeName.ATTR_BATCH_UV, Format.RG32F);
      var batch_extras_size = FormatInfos[batch_id.format].size + FormatInfos[batch_uv.format].size;
      var SkinnedMeshUnit = function (v) { return exports({ SkinnedMeshUnit: v, SkinningModelUnit: v }), v; }((_dec$u = ccclass('cc.SkinnedMeshUnit'), _dec2$o = type(Mesh), _dec3$n = type(Skeleton), _dec4$l = type(Material), _dec5$j = type(SkinnedMeshRenderer), _dec$u(_class$u = (_class2$p = (_temp$r = function () {
        function SkinnedMeshUnit() {
          _initializerDefineProperty(this, "mesh", _descriptor$n, this);

          _initializerDefineProperty(this, "skeleton", _descriptor2$k, this);

          _initializerDefineProperty(this, "material", _descriptor3$g, this);

          _initializerDefineProperty(this, "_localTransform", _descriptor4$d, this);

          _initializerDefineProperty(this, "_offset", _descriptor5$b, this);

          _initializerDefineProperty(this, "_size", _descriptor6$9, this);
        }

        _createClass(SkinnedMeshUnit, [{
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(offset) {
            Vec2.copy(this._offset, offset);
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(size) {
            Vec2.copy(this._size, size);
          }
        }, {
          key: "copyFrom",
          get: function get() {
            return null;
          },
          set: function set(comp) {
            if (!comp) {
              return;
            }

            this.mesh = comp.mesh;
            this.skeleton = comp.skeleton;
            this.material = comp.getMaterial(0);

            if (comp.skinningRoot) {
              getWorldTransformUntilRoot(comp.node, comp.skinningRoot, this._localTransform);
            }
          }
        }]);

        return SkinnedMeshUnit;
      }(), _temp$r), (_descriptor$n = _applyDecoratedDescriptor(_class2$p.prototype, "mesh", [_dec2$o], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$k = _applyDecoratedDescriptor(_class2$p.prototype, "skeleton", [_dec3$n], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$g = _applyDecoratedDescriptor(_class2$p.prototype, "material", [_dec4$l], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4$d = _applyDecoratedDescriptor(_class2$p.prototype, "_localTransform", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Mat4();
        }
      }), _descriptor5$b = _applyDecoratedDescriptor(_class2$p.prototype, "_offset", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(0, 0);
        }
      }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$p.prototype, "_size", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(1, 1);
        }
      }), _applyDecoratedDescriptor(_class2$p.prototype, "offset", [editable], Object.getOwnPropertyDescriptor(_class2$p.prototype, "offset"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "size", [editable], Object.getOwnPropertyDescriptor(_class2$p.prototype, "size"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "copyFrom", [_dec5$j], Object.getOwnPropertyDescriptor(_class2$p.prototype, "copyFrom"), _class2$p.prototype)), _class2$p)) || _class$u));
      var m4_local = new Mat4();
      var m4_1$4 = new Mat4();
      var v3_1$4 = new Vec3();
      var SkinnedMeshBatchRenderer = function (v) { return exports({ SkinnedMeshBatchRenderer: v, BatchedSkinningModelComponent: v }), v; }((_dec6$h = ccclass('cc.SkinnedMeshBatchRenderer'), _dec7$g = help(), _dec8$f = executionOrder(100), _dec9$b = menu(), _dec10$a = tooltip(), _dec11$9 = type([CCString]), _dec12$8 = tooltip(), _dec13$8 = type([SkinnedMeshUnit]), _dec14$6 = tooltip(), _dec15$6 = visible(), _dec16$6 = visible(), _dec6$h(_class4$2 = _dec7$g(_class4$2 = _dec8$f(_class4$2 = executeInEditMode(_class4$2 = _dec9$b(_class4$2 = (_class5$2 = (_temp2$2 = function (_SkinnedMeshRenderer) {
        _inheritsLoose(SkinnedMeshBatchRenderer, _SkinnedMeshRenderer);

        function SkinnedMeshBatchRenderer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _SkinnedMeshRenderer.call.apply(_SkinnedMeshRenderer, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "atlasSize", _descriptor7$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "batchableTextureNames", _descriptor8$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "units", _descriptor9$6, _assertThisInitialized(_this));

          _this._textures = {};
          _this._batchMaterial = null;
          return _this;
        }

        var _proto = SkinnedMeshBatchRenderer.prototype;

        _proto.onLoad = function onLoad() {
          _SkinnedMeshRenderer.prototype.onLoad.call(this);

          this.cook();
        };

        _proto.onDestroy = function onDestroy() {
          for (var tex in this._textures) {
            this._textures[tex].destroy();
          }

          this._textures = {};

          if (this._mesh) {
            this._mesh.destroy();

            this._mesh = null;
          }

          _SkinnedMeshRenderer.prototype.onDestroy.call(this);
        };

        _proto._onMaterialModified = function _onMaterialModified(idx, material) {
          this.cookMaterials();

          _SkinnedMeshRenderer.prototype._onMaterialModified.call(this, idx, this.getMaterialInstance(idx));
        };

        _proto.cook = function cook() {
          this.cookMaterials();
          this.cookSkeletons();
          this.cookMeshes();
        };

        _proto.cookMaterials = function cookMaterials() {
          var _this2 = this;

          if (!this._batchMaterial) {
            this._batchMaterial = this.getMaterial(0);
          }

          var mat = this.getMaterialInstance(0);

          if (!mat || !this._batchMaterial || !this._batchMaterial.effectAsset) {
            console.warn('incomplete batch material!');
            return;
          }

          mat.copy(this._batchMaterial);
          this.resizeAtlases();
          var tech = mat.effectAsset.techniques[mat.technique];

          var _loop = function _loop(i) {
            var pass = tech.passes[i];

            if (!pass.properties) {
              return "continue";
            }

            var _loop2 = function _loop2(prop) {
              if (pass.properties[prop].type >= Type$1.SAMPLER1D) {
                var tex = null;

                if (_this2.batchableTextureNames.find(function (n) {
                  return n === prop;
                })) {
                  tex = _this2._textures[prop];

                  if (!tex) {
                    tex = _this2.createTexture(prop);
                  }

                  _this2.cookTextures(tex, prop, i);
                } else {
                  _this2.units.some(function (u) {
                    return tex = u.material && u.material.getProperty(prop, i);
                  });
                }

                if (tex) {
                  mat.setProperty(prop, tex, i);
                }
              } else {
                var value = [];

                for (var u = 0; u < _this2.units.length; u++) {
                  var unit = _this2.units[u];

                  if (!unit.material) {
                    continue;
                  }

                  value.push(unit.material.getProperty(prop.slice(0, -3), i));
                }

                mat.setProperty(prop, value, i);
              }
            };

            for (var prop in pass.properties) {
              _loop2(prop);
            }
          };

          for (var i = 0; i < tech.passes.length; i++) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
          }
        };

        _proto.cookSkeletons = function cookSkeletons() {

          if (!this._skinningRoot) {
            console.warn('no skinning root specified!');
            return;
          }

          var joints = [];
          var bindposes = [];

          for (var u = 0; u < this.units.length; u++) {
            var unit = this.units[u];

            if (!unit || !unit.skeleton) {
              continue;
            }

            var partial = unit.skeleton;
            Mat4.invert(m4_local, unit._localTransform);

            var _loop3 = function _loop3(i) {
              var path = partial.joints[i];
              var idx = joints.findIndex(function (p) {
                return p === path;
              });

              if (idx >= 0) {

                return "continue";
              }

              joints.push(path);
              bindposes.push(Mat4.multiply(new Mat4(), partial.bindposes[i] || Mat4.IDENTITY, m4_local));
            };

            for (var i = 0; i < partial.joints.length; i++) {
              var _ret2 = _loop3(i);

              if (_ret2 === "continue") continue;
            }
          }

          var idxMap = Array.from(Array(joints.length).keys()).sort(function (a, b) {
            if (joints[a] > joints[b]) {
              return 1;
            }

            if (joints[a] < joints[b]) {
              return -1;
            }

            return 0;
          });
          var skeleton = new Skeleton();
          skeleton.joints = joints.map(function (_, idx, arr) {
            return arr[idxMap[idx]];
          });
          skeleton.bindposes = bindposes.map(function (_, idx, arr) {
            return arr[idxMap[idx]];
          });

          if (this._skeleton) {
            this._skeleton.destroy();
          }

          this.skeleton = skeleton;
        };

        _proto.cookMeshes = function cookMeshes() {
          var _this4 = this;

          var isValid = false;

          for (var u = 0; u < this.units.length; u++) {
            var unit = this.units[u];

            if (unit.mesh) {
              isValid = true;
              break;
            }
          }

          if (!isValid || !this._skinningRoot) {
            return;
          }

          if (this._mesh) {
            this._mesh.destroyRenderingMesh();
          } else {
            this._mesh = new Mesh();
          }

          var posOffset = 0;
          var posFormat = Format.UNKNOWN;
          var normalOffset = 0;
          var normalFormat = Format.UNKNOWN;
          var tangentOffset = 0;
          var tangentFormat = Format.UNKNOWN;
          var uvOffset = 0;
          var uvFormat = Format.UNKNOWN;
          var jointOffset = 0;
          var jointFormat = Format.UNKNOWN;
          var jointIndexMap = new Array(this.units.length);
          var unitLen = this.units.length;

          for (var i = 0; i < unitLen; i++) {
            var _unit = this.units[i];

            if (!_unit || !_unit.skeleton) {
              continue;
            }

            jointIndexMap[i] = _unit.skeleton.joints.map(function (j) {
              return _this4._skeleton.joints.findIndex(function (ref) {
                return j === ref;
              });
            });
          }

          var _loop4 = function _loop4(_i) {
            var unit = _this4.units[_i];

            if (!unit || !unit.mesh || !unit.mesh.data) {
              return "continue";
            }

            var newMesh = _this4._createUnitMesh(_i, unit.mesh);

            var dataView = new DataView(newMesh.data.buffer);
            Mat4.inverseTranspose(m4_local, unit._localTransform);
            var offset = unit.offset;
            var size = unit.size;

            var _loop5 = function _loop5(b) {
              var bundle = newMesh.struct.vertexBundles[b];
              posOffset = bundle.view.offset;
              posFormat = Format.UNKNOWN;

              for (var a = 0; a < bundle.attributes.length; a++) {
                var attr = bundle.attributes[a];

                if (attr.name === AttributeName.ATTR_POSITION) {
                  posFormat = attr.format;
                  break;
                }

                posOffset += FormatInfos[attr.format].size;
              }

              if (posFormat) {
                var pos = readBuffer(dataView, posFormat, posOffset, bundle.view.length, bundle.view.stride);

                for (var j = 0; j < pos.length; j += 3) {
                  Vec3.fromArray(v3_1$4, pos, j);
                  Vec3.transformMat4(v3_1$4, v3_1$4, unit._localTransform);
                  Vec3.toArray(pos, v3_1$4, j);
                }

                writeBuffer(dataView, pos, posFormat, posOffset, bundle.view.stride);
              }

              normalOffset = bundle.view.offset;
              normalFormat = Format.UNKNOWN;

              for (var _a = 0; _a < bundle.attributes.length; _a++) {
                var _attr = bundle.attributes[_a];

                if (_attr.name === AttributeName.ATTR_NORMAL) {
                  normalFormat = _attr.format;
                  break;
                }

                normalOffset += FormatInfos[_attr.format].size;
              }

              if (normalFormat) {
                var normal = readBuffer(dataView, normalFormat, normalOffset, bundle.view.length, bundle.view.stride);

                for (var _j = 0; _j < normal.length; _j += 3) {
                  Vec3.fromArray(v3_1$4, normal, _j);
                  Vec3.transformMat4Normal(v3_1$4, v3_1$4, m4_local);
                  Vec3.toArray(normal, v3_1$4, _j);
                }

                writeBuffer(dataView, normal, normalFormat, normalOffset, bundle.view.stride);
              }

              tangentOffset = bundle.view.offset;
              tangentFormat = Format.UNKNOWN;

              for (var _a2 = 0; _a2 < bundle.attributes.length; _a2++) {
                var _attr2 = bundle.attributes[_a2];

                if (_attr2.name === AttributeName.ATTR_TANGENT) {
                  tangentFormat = _attr2.format;
                  break;
                }

                tangentOffset += FormatInfos[_attr2.format].size;
              }

              if (tangentFormat) {
                var tangent = readBuffer(dataView, tangentFormat, tangentOffset, bundle.view.length, bundle.view.stride);

                for (var _j2 = 0; _j2 < tangent.length; _j2 += 3) {
                  Vec3.fromArray(v3_1$4, tangent, _j2);
                  Vec3.transformMat4Normal(v3_1$4, v3_1$4, m4_local);
                  Vec3.toArray(tangent, v3_1$4, _j2);
                }

                writeBuffer(dataView, tangent, tangentFormat, tangentOffset, bundle.view.stride);
              }

              uvOffset = bundle.view.offset;
              uvFormat = Format.UNKNOWN;

              for (var _a3 = 0; _a3 < bundle.attributes.length; _a3++) {
                var _attr3 = bundle.attributes[_a3];

                if (_attr3.name === AttributeName.ATTR_BATCH_UV) {
                  uvFormat = _attr3.format;
                  break;
                }

                uvOffset += FormatInfos[_attr3.format].size;
              }

              if (uvFormat) {
                mapBuffer(dataView, function (cur, idx) {
                  cur = repeat(cur);
                  var comp = idx === 0 ? 'x' : 'y';
                  return cur * size[comp] + offset[comp];
                }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
              }

              var idxMap = jointIndexMap[_i];

              if (!idxMap) {
                return "continue";
              }

              jointOffset = bundle.view.offset;
              jointFormat = Format.UNKNOWN;

              for (var _a4 = 0; _a4 < bundle.attributes.length; _a4++) {
                var _attr4 = bundle.attributes[_a4];

                if (_attr4.name === AttributeName.ATTR_JOINTS) {
                  jointFormat = _attr4.format;
                  break;
                }

                jointOffset += FormatInfos[_attr4.format].size;
              }

              if (jointFormat) {
                mapBuffer(dataView, function (cur) {
                  return idxMap[cur];
                }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
              }
            };

            for (var b = 0; b < newMesh.struct.vertexBundles.length; b++) {
              var _ret4 = _loop5(b);

              if (_ret4 === "continue") continue;
            }

            _this4._mesh.merge(newMesh);
          };

          for (var _i = 0; _i < unitLen; _i++) {
            var _ret3 = _loop4(_i);

            if (_ret3 === "continue") continue;
          }

          this._onMeshChanged(this._mesh);

          this._updateModels();
        };

        _proto.cookTextures = function cookTextures(target, prop, passIdx) {
          var texImages = [];
          var texImageRegions = [];
          var texBuffers = [];
          var texBufferRegions = [];

          for (var u = 0; u < this.units.length; u++) {
            var unit = this.units[u];

            if (!unit.material) {
              continue;
            }

            var partial = unit.material.getProperty(prop, passIdx);

            if (partial && partial.image && partial.image.data) {
              var region = new BufferTextureCopy();
              region.texOffset.x = unit.offset.x * this.atlasSize;
              region.texOffset.y = unit.offset.y * this.atlasSize;
              region.texExtent.width = unit.size.x * this.atlasSize;
              region.texExtent.height = unit.size.y * this.atlasSize;
              var data = partial.image.data;

              if (!ArrayBuffer.isView(data)) {
                texImages.push(data);
                texImageRegions.push(region);
              } else {
                texBuffers.push(data);
                texBufferRegions.push(region);
              }
            }
          }

          var gfxTex = target.getGFXTexture();
          var _ref = legacyCC.director.root,
              device = _ref.device;

          if (texBuffers.length > 0) {
            device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions);
          }

          if (texImages.length > 0) {
            device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
          }
        };

        _proto.createTexture = function createTexture(prop) {
          var tex = new Texture2D();
          tex.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);
          tex.setMipFilter(Filter$1.NEAREST);
          tex.reset({
            width: this.atlasSize,
            height: this.atlasSize,
            format: PixelFormat.RGBA8888
          });
          this._textures[prop] = tex;
          return tex;
        };

        _proto.resizeAtlases = function resizeAtlases() {
          for (var prop in this._textures) {
            var tex = this._textures[prop];
            tex.reset({
              width: this.atlasSize,
              height: this.atlasSize,
              format: PixelFormat.RGBA8888
            });
          }
        };

        _proto._createUnitMesh = function _createUnitMesh(unitIdx, mesh) {
          var newMeshStruct = JSON.parse(JSON.stringify(mesh.struct));
          var modifiedBundles = {};

          for (var p = 0; p < mesh.struct.primitives.length; p++) {
            var primitive = mesh.struct.primitives[p];
            var uvOffset = 0;
            var uvFormat = Format.UNKNOWN;
            var bundleIdx = 0;

            for (; bundleIdx < primitive.vertexBundelIndices.length; bundleIdx++) {
              var bundle = mesh.struct.vertexBundles[primitive.vertexBundelIndices[bundleIdx]];
              uvOffset = bundle.view.offset;
              uvFormat = Format.UNKNOWN;

              for (var a = 0; a < bundle.attributes.length; a++) {
                var attr = bundle.attributes[a];

                if (attr.name === AttributeName.ATTR_TEX_COORD) {
                  uvFormat = attr.format;
                  break;
                }

                uvOffset += FormatInfos[attr.format].size;
              }

              if (uvFormat) {
                break;
              }
            }

            if (modifiedBundles[bundleIdx] !== undefined) {
              continue;
            }

            modifiedBundles[bundleIdx] = [uvFormat, uvOffset];
            var newBundle = newMeshStruct.vertexBundles[bundleIdx];
            newBundle.attributes.push(batch_id);
            newBundle.attributes.push(batch_uv);
            newBundle.view.offset = 0;
            newBundle.view.length += newBundle.view.count * batch_extras_size;
            newBundle.view.stride += batch_extras_size;
          }

          var totalLength = 0;

          for (var b = 0; b < newMeshStruct.vertexBundles.length; b++) {
            totalLength += newMeshStruct.vertexBundles[b].view.length;
          }

          for (var _p = 0; _p < newMeshStruct.primitives.length; _p++) {
            var pm = newMeshStruct.primitives[_p];

            if (pm.indexView) {
              pm.indexView.offset = totalLength;
              totalLength += pm.indexView.length;
            }
          }

          var newMeshData = new Uint8Array(totalLength);
          var oldMeshData = mesh.data;
          var newDataView = new DataView(newMeshData.buffer);
          var oldDataView = new DataView(oldMeshData.buffer);
          var isLittleEndian = legacyCC.sys.isLittleEndian;

          for (var _b in modifiedBundles) {
            var _newBundle = newMeshStruct.vertexBundles[_b];
            var oldBundle = mesh.struct.vertexBundles[_b];
            var _modifiedBundles$_b = modifiedBundles[_b],
                _uvFormat = _modifiedBundles$_b[0],
                _uvOffset = _modifiedBundles$_b[1];
            var uvs = readBuffer(oldDataView, _uvFormat, _uvOffset, oldBundle.view.length, oldBundle.view.stride);
            var oldView = oldBundle.view;
            var newView = _newBundle.view;
            var oldStride = oldView.stride;
            var newStride = newView.stride;
            var oldOffset = oldView.offset;
            var newOffset = newView.offset;

            for (var j = 0; j < newView.count; j++) {
              var srcVertex = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
              newMeshData.set(srcVertex, newOffset);
              newDataView.setFloat32(newOffset + oldStride, unitIdx);
              newDataView.setFloat32(newOffset + oldStride + 4, uvs[j * 2], isLittleEndian);
              newDataView.setFloat32(newOffset + oldStride + 8, uvs[j * 2 + 1], isLittleEndian);
              newOffset += newStride;
              oldOffset += oldStride;
            }
          }

          for (var k = 0; k < newMeshStruct.primitives.length; k++) {
            var oldPrimitive = mesh.struct.primitives[k];
            var newPrimitive = newMeshStruct.primitives[k];

            if (oldPrimitive.indexView && newPrimitive.indexView) {
              var _oldStride = oldPrimitive.indexView.stride;
              var _newStride = newPrimitive.indexView.stride;
              var _oldOffset = oldPrimitive.indexView.offset;
              var _newOffset = newPrimitive.indexView.offset;

              for (var _j3 = 0; _j3 < newPrimitive.indexView.count; _j3++) {
                var srcIndices = oldMeshData.subarray(_oldOffset, _oldOffset + _oldStride);
                newMeshData.set(srcIndices, _newOffset);
                _newOffset += _newStride;
                _oldOffset += _oldStride;
              }
            }
          }

          var newMesh = new Mesh();
          newMesh.reset({
            struct: newMeshStruct,
            data: newMeshData
          });
          return newMesh;
        };

        _createClass(SkinnedMeshBatchRenderer, [{
          key: "mesh",
          get: function get() {
            return _SkinnedMeshRenderer.prototype.mesh;
          },
          set: function set(val) {
            this.mesh = val;
          }
        }, {
          key: "skeleton",
          get: function get() {
            return _SkinnedMeshRenderer.prototype.skeleton;
          },
          set: function set(val) {
            this.skeleton = val;
          }
        }]);

        return SkinnedMeshBatchRenderer;
      }(SkinnedMeshRenderer), _temp2$2), (_descriptor7$7 = _applyDecoratedDescriptor(_class5$2.prototype, "atlasSize", [serializable, _dec10$a], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1024;
        }
      }), _descriptor8$7 = _applyDecoratedDescriptor(_class5$2.prototype, "batchableTextureNames", [_dec11$9, serializable, _dec12$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor9$6 = _applyDecoratedDescriptor(_class5$2.prototype, "units", [_dec13$8, serializable, _dec14$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _applyDecoratedDescriptor(_class5$2.prototype, "mesh", [override, _dec15$6], Object.getOwnPropertyDescriptor(_class5$2.prototype, "mesh"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "skeleton", [override, _dec16$6], Object.getOwnPropertyDescriptor(_class5$2.prototype, "skeleton"), _class5$2.prototype)), _class5$2)) || _class4$2) || _class4$2) || _class4$2) || _class4$2) || _class4$2));

      legacyCC.SkinningModelComponent = SkinnedMeshRenderer;
      js.setClassAlias(SkinnedMeshRenderer, 'cc.SkinningModelComponent');
      legacyCC.SkinningModelUnit = SkinnedMeshUnit;
      js.setClassAlias(SkinnedMeshUnit, 'cc.SkinningModelUnit');
      legacyCC.BatchedSkinningModelComponent = SkinnedMeshBatchRenderer;
      js.setClassAlias(SkinnedMeshBatchRenderer, 'cc.BatchedSkinningModelComponent');

      legacyCC.utils = utils;

      var CLASS_NAME_PREFIX_ANIM = 'cc.animation.';
      var createEvalSymbol = Symbol('CreateEval');

      var _dec$v, _class$v, _class2$q, _descriptor$o, _descriptor2$l, _descriptor3$h, _descriptor4$e, _temp$s;
      var EmbeddedPlayer = (_dec$v = ccclass(CLASS_NAME_PREFIX_ANIM + "EmbeddedPlayer"), _dec$v(_class$v = (_class2$q = (_temp$s = function (_EditorExtendable) {
        _inheritsLoose(EmbeddedPlayer, _EditorExtendable);

        function EmbeddedPlayer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _EditorExtendable.call.apply(_EditorExtendable, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "begin", _descriptor$o, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "end", _descriptor2$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "reconciledSpeed", _descriptor3$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "playable", _descriptor4$e, _assertThisInitialized(_this));

          return _this;
        }

        return EmbeddedPlayer;
      }(EditorExtendable), _temp$s), (_descriptor$o = _applyDecoratedDescriptor(_class2$q.prototype, "begin", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _descriptor2$l = _applyDecoratedDescriptor(_class2$q.prototype, "end", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _descriptor3$h = _applyDecoratedDescriptor(_class2$q.prototype, "reconciledSpeed", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor4$e = _applyDecoratedDescriptor(_class2$q.prototype, "playable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$q)) || _class$v);
      var EmbeddedPlayable = function EmbeddedPlayable() {};
      var EmbeddedPlayableState = function () {
        function EmbeddedPlayableState(randomAccess) {
          this._randomAccess = randomAccess;
        }

        var _proto = EmbeddedPlayableState.prototype;

        _proto.setTime = function setTime(_time) {};

        _createClass(EmbeddedPlayableState, [{
          key: "randomAccess",
          get: function get() {
            return this._randomAccess;
          }
        }]);

        return EmbeddedPlayableState;
      }();

      var Playable = function () {
        function Playable() {
          this._isPlaying = false;
          this._isPaused = false;
          this._stepOnce = false;
        }

        var _proto = Playable.prototype;

        _proto.play = function play() {
          if (this._isPlaying) {
            if (this._isPaused) {
              this._isPaused = false;
              this.onResume();
            } else {
              this.onError(getError(3912));
            }
          } else {
            this._isPlaying = true;
            this.onPlay();
          }
        };

        _proto.stop = function stop() {
          if (this._isPlaying) {
            this._isPlaying = false;
            this.onStop();
            this._isPaused = false;
          }
        };

        _proto.pause = function pause() {
          if (this._isPlaying && !this._isPaused) {
            this._isPaused = true;
            this.onPause();
          }
        };

        _proto.resume = function resume() {
          if (this._isPlaying && this._isPaused) {
            this._isPaused = false;
            this.onResume();
          }
        };

        _proto.step = function step() {
          this.pause();
          this._stepOnce = true;

          if (!this._isPlaying) {
            this.play();
          }
        };

        _proto.update = function update(deltaTime) {};

        _proto.onPlay = function onPlay() {};

        _proto.onPause = function onPause() {};

        _proto.onResume = function onResume() {};

        _proto.onStop = function onStop() {};

        _proto.onError = function onError(message) {};

        _createClass(Playable, [{
          key: "isPlaying",
          get: function get() {
            return this._isPlaying;
          }
        }, {
          key: "isPaused",
          get: function get() {
            return this._isPaused;
          }
        }, {
          key: "isMotionless",
          get: function get() {
            return !this.isPlaying || this.isPaused;
          }
        }]);

        return Playable;
      }();

      var PoseOutput = function () {
        function PoseOutput(pose) {
          this.weight = 0.0;
          this._pose = void 0;
          this._blendStateWriters = [];
          this._pose = pose;
        }

        var _proto = PoseOutput.prototype;

        _proto.destroy = function destroy() {
          for (var iBlendStateWriter = 0; iBlendStateWriter < this._blendStateWriters.length; ++iBlendStateWriter) {
            this._pose.destroyWriter(this._blendStateWriters[iBlendStateWriter]);
          }

          this._blendStateWriters.length = 0;
        };

        _proto.createPoseWriter = function createPoseWriter(node, property, constants) {
          var writer = this._pose.createWriter(node, property, this, constants);

          this._blendStateWriters.push(writer);

          return writer;
        };

        return PoseOutput;
      }();

      function getGlobalAnimationManager() {
        var animationManager = legacyCC.director.getAnimationManager();
        return animationManager;
      }

      var EventType$1;

      (function (EventType) {
        EventType["PLAY"] = "play";
        EventType["STOP"] = "stop";
        EventType["PAUSE"] = "pause";
        EventType["RESUME"] = "resume";
        EventType["LASTFRAME"] = "lastframe";
        EventType["FINISHED"] = "finished";
      })(EventType$1 || (EventType$1 = {}));

      ccenum(EventType$1);
      var AnimationState = exports('AnimationState', function (_Playable) {
        _inheritsLoose(AnimationState, _Playable);

        function AnimationState(clip, name) {
          var _this;

          if (name === void 0) {
            name = '';
          }

          _this = _Playable.call(this) || this;
          _this.duration = 1.0;
          _this.time = 0.0;
          _this.frameRate = 0;
          _this._targetNode = null;
          _this._curveLoaded = false;
          _this._clip = void 0;
          _this._speed = 1.0;
          _this._useSimpleProcess = false;
          _this._target = null;
          _this._wrapMode = WrapMode$1.Normal;
          _this._repeatCount = 1;
          _this._delay = 0.0;
          _this._delayTime = 0.0;
          _this._currentFramePlayed = false;
          _this._name = void 0;
          _this._lastIterations = NaN;
          _this._lastWrapInfo = null;
          _this._wrappedInfo = new WrappedInfo();
          _this._allowLastFrame = false;
          _this._blendStateWriterHost = {
            weight: 0.0
          };
          _this._playbackDuration = 0.0;
          _this._invDuration = 1.0;
          _this._poseOutput = null;
          _this._weight = 1.0;
          _this._clipEval = void 0;
          _this._clipEventEval = void 0;
          _this._clipEmbeddedPlayerEval = void 0;
          _this._doNotCreateEval = false;
          _this._clip = clip;
          _this._name = name || clip && clip.name;
          _this._playbackRange = {
            min: 0.0,
            max: clip.duration
          };
          _this._playbackDuration = clip.duration;

          if (!clip.duration) {
            debug("Clip " + clip.name + " has zero duration.");
          }

          return _this;
        }

        var _proto = AnimationState.prototype;

        _proto.initialize = function initialize(root, blendStateBuffer, mask) {
          if (this._curveLoaded) {
            return;
          }

          this._curveLoaded = true;

          if (this._poseOutput) {
            this._poseOutput.destroy();

            this._poseOutput = null;
          }

          if (this._clipEval) {
            this._clipEval = undefined;
          }

          if (this._clipEventEval) {
            this._clipEventEval = undefined;
          }

          if (this._clipEmbeddedPlayerEval) {
            this._clipEmbeddedPlayerEval.destroy();

            this._clipEmbeddedPlayerEval = undefined;
          }

          this._targetNode = root;
          var clip = this._clip;
          this.duration = clip.duration;
          this._invDuration = 1.0 / this.duration;
          this._speed = clip.speed;
          this.wrapMode = clip.wrapMode;
          this.frameRate = clip.sample;
          this._playbackRange.min = 0.0;
          this._playbackRange.max = clip.duration;
          this._playbackDuration = clip.duration;

          if ((this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop) {
            this.repeatCount = Infinity;
          } else {
            this.repeatCount = 1;
          }

          if (!this._doNotCreateEval) {
            var _ref, _getGlobalAnimationMa, _this$_poseOutput;

            var pose = (_ref = blendStateBuffer !== null && blendStateBuffer !== void 0 ? blendStateBuffer : (_getGlobalAnimationMa = getGlobalAnimationManager()) === null || _getGlobalAnimationMa === void 0 ? void 0 : _getGlobalAnimationMa.blendState) !== null && _ref !== void 0 ? _ref : null;

            if (pose) {
              this._poseOutput = new PoseOutput(pose);
            }

            this._clipEval = clip.createEvaluator({
              target: root,
              pose: (_this$_poseOutput = this._poseOutput) !== null && _this$_poseOutput !== void 0 ? _this$_poseOutput : undefined,
              mask: mask
            });
          }

          {
            if (clip.containsAnyEvent()) {
              this._clipEventEval = clip.createEventEvaluator(this._targetNode);
            }
          }

          if (clip.containsAnyEmbeddedPlayer()) {
            this._clipEmbeddedPlayerEval = clip.createEmbeddedPlayerEvaluator(this._targetNode);

            this._clipEmbeddedPlayerEval.notifyHostSpeedChanged(this._speed);
          }
        };

        _proto.destroy = function destroy() {
          if (!this.isMotionless) {
            getGlobalAnimationManager().removeAnimation(this);
          }

          if (this._poseOutput) {
            this._poseOutput.destroy();

            this._poseOutput = null;
          }

          this._clipEval = undefined;
        };

        _proto.emit = function emit() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          getGlobalAnimationManager().pushDelayEvent(this._emit, this, args);
        };

        _proto.on = function on(type, callback, target) {
          if (this._target && this._target.isValid) {
            return this._target.on(type, callback, target);
          } else {
            return null;
          }
        };

        _proto.once = function once(type, callback, target) {
          if (this._target && this._target.isValid) {
            return this._target.once(type, callback, target);
          } else {
            return null;
          }
        };

        _proto.off = function off(type, callback, target) {
          if (this._target && this._target.isValid) {
            this._target.off(type, callback, target);
          }
        };

        _proto.allowLastFrameEvent = function allowLastFrameEvent(allowed) {
          this._allowLastFrame = allowed;
        };

        _proto._setEventTarget = function _setEventTarget(target) {
          this._target = target;
        };

        _proto.setTime = function setTime(time) {
          this._currentFramePlayed = false;
          this.time = time || 0.0;

          {
            var _this$_clipEventEval;

            var info = this.getWrappedInfo(time, this._wrappedInfo);
            (_this$_clipEventEval = this._clipEventEval) === null || _this$_clipEventEval === void 0 ? void 0 : _this$_clipEventEval.ignore(info.ratio, info.direction);
          }
        };

        _proto.update = function update(delta) {
          if (this._delayTime > 0.0) {
            this._delayTime -= delta;

            if (this._delayTime > 0.0) {
              return;
            }
          }

          if (this._currentFramePlayed) {
            this.time += delta * this._speed;
          } else {
            this._currentFramePlayed = true;
          }

          this._process();
        };

        _proto.sample = function sample() {
          var info = this.getWrappedInfo(this.time, this._wrappedInfo);

          this._sampleCurves(info.time);

          {
            this._sampleEvents(info);
          }

          this._sampleEmbeddedPlayers(info);

          return info;
        };

        _proto.onPlay = function onPlay() {
          var _this$_clipEmbeddedPl;

          this.setTime(this._getPlaybackStart());
          this._delayTime = this._delay;

          this._onReplayOrResume();

          this.emit(EventType$1.PLAY, this);
          (_this$_clipEmbeddedPl = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl === void 0 ? void 0 : _this$_clipEmbeddedPl.notifyHostPlay(this.current);
        };

        _proto.onStop = function onStop() {
          var _this$_clipEmbeddedPl2;

          if (!this.isPaused) {
            this._onPauseOrStop();
          }

          this.emit(EventType$1.STOP, this);
          (_this$_clipEmbeddedPl2 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl2 === void 0 ? void 0 : _this$_clipEmbeddedPl2.notifyHostStop();
        };

        _proto.onResume = function onResume() {
          var _this$_clipEmbeddedPl3;

          this._onReplayOrResume();

          this.emit(EventType$1.RESUME, this);
          (_this$_clipEmbeddedPl3 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl3 === void 0 ? void 0 : _this$_clipEmbeddedPl3.notifyHostPlay(this.current);
        };

        _proto.onPause = function onPause() {
          var _this$_clipEmbeddedPl4;

          this._onPauseOrStop();

          this.emit(EventType$1.PAUSE, this);
          (_this$_clipEmbeddedPl4 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl4 === void 0 ? void 0 : _this$_clipEmbeddedPl4.notifyHostPause(this.current);
        };

        _proto._sampleCurves = function _sampleCurves(time) {
          var poseOutput = this._poseOutput,
              clipEval = this._clipEval;

          if (poseOutput) {
            poseOutput.weight = this.weight;
          }

          if (clipEval) {
            clipEval.evaluate(time);
          }
        };

        _proto._process = function _process() {
          if (this._useSimpleProcess) {
            this.simpleProcess();
          } else {
            this.process();
          }
        };

        _proto.process = function process() {
          var info = this.sample();

          if (this._allowLastFrame) {
            var lastInfo;

            if (!this._lastWrapInfo) {
              lastInfo = this._lastWrapInfo = new WrappedInfo(info);
            } else {
              lastInfo = this._lastWrapInfo;
            }

            if (this.repeatCount > 1 && (info.iterations | 0) > (lastInfo.iterations | 0)) {
              this.emit(EventType$1.LASTFRAME, this);
            }

            lastInfo.set(info);
          }

          if (info.stopped) {
            this.stop();
            this.emit(EventType$1.FINISHED, this);
          }
        };

        _proto.simpleProcess = function simpleProcess() {
          var playbackStart = this._playbackRange.min;
          var playbackDuration = this._playbackDuration;
          var time = 0.0;
          var ratio = 0.0;

          if (playbackDuration !== 0.0) {
            time = this.time % playbackDuration;

            if (time < 0.0) {
              time += playbackDuration;
            }

            var realTime = playbackStart + time;
            ratio = realTime * this._invDuration;
          }

          this._sampleCurves(playbackStart + time);

          if (this._clipEventEval || this._clipEmbeddedPlayerEval) {
            var wrapInfo = this.getWrappedInfo(this.time, this._wrappedInfo);

            {
              this._sampleEvents(wrapInfo);
            }

            this._sampleEmbeddedPlayers(wrapInfo);
          }

          if (this._allowLastFrame) {
            if (Number.isNaN(this._lastIterations)) {
              this._lastIterations = ratio;
            }

            if (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) {
              this.emit(EventType$1.LASTFRAME, this);
            }

            this._lastIterations = ratio;
          }
        };

        _proto._needReverse = function _needReverse(currentIterations) {
          var wrapMode = this.wrapMode;
          var needReverse = false;

          if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
            var isEnd = currentIterations - (currentIterations | 0) === 0;

            if (isEnd && currentIterations > 0) {
              currentIterations -= 1;
            }

            var isOddIteration = currentIterations & 1;

            if (isOddIteration) {
              needReverse = !needReverse;
            }
          }

          if ((wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse) {
            needReverse = !needReverse;
          }

          return needReverse;
        };

        _proto.getWrappedInfo = function getWrappedInfo(time, info) {
          info = info || new WrappedInfo();
          var playbackStart = this._playbackRange.min,
              playbackDuration = this._playbackDuration;
          var repeatCount = this.repeatCount;

          if (playbackDuration === 0.0) {
            info.time = 0.0;
            info.ratio = 0.0;
            info.direction = 1.0;
            info.stopped = !!Number.isFinite(repeatCount);
            info.iterations = 0.0;
            return info;
          }

          var stopped = false;
          time -= playbackStart;
          var currentIterations = time > 0 ? time / playbackDuration : -(time / playbackDuration);

          if (currentIterations >= repeatCount) {
            currentIterations = repeatCount;
            stopped = true;
            var tempRatio = repeatCount - (repeatCount | 0);

            if (tempRatio === 0) {
              tempRatio = 1;
            }

            time = tempRatio * playbackDuration * (time > 0 ? 1 : -1);
          }

          if (time > playbackDuration) {
            var tempTime = time % playbackDuration;
            time = tempTime === 0 ? playbackDuration : tempTime;
          } else if (time < 0) {
            time %= playbackDuration;

            if (time !== 0) {
              time += playbackDuration;
            }
          }

          var needReverse = false;
          var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;

          if (shouldWrap) {
            needReverse = this._needReverse(currentIterations);
          }

          var direction = needReverse ? -1 : 1;

          if (this.speed < 0) {
            direction *= -1;
          }

          if (shouldWrap && needReverse) {
            time = playbackDuration - time;
          }

          info.time = playbackStart + time;
          info.ratio = info.time / this.duration;
          info.direction = direction;
          info.stopped = stopped;
          info.iterations = currentIterations;
          return info;
        };

        _proto._getPlaybackStart = function _getPlaybackStart() {
          return this._playbackRange.min;
        };

        _proto._sampleEvents = function _sampleEvents(wrapInfo) {
          var _this$_clipEventEval2;

          (_this$_clipEventEval2 = this._clipEventEval) === null || _this$_clipEventEval2 === void 0 ? void 0 : _this$_clipEventEval2.sample(wrapInfo.ratio, wrapInfo.direction, wrapInfo.iterations);
        };

        _proto._sampleEmbeddedPlayers = function _sampleEmbeddedPlayers(wrapInfo) {
          var _this$_clipEmbeddedPl5;

          (_this$_clipEmbeddedPl5 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl5 === void 0 ? void 0 : _this$_clipEmbeddedPl5.evaluate(wrapInfo.time, Math.trunc(wrapInfo.iterations));
        };

        _proto._emit = function _emit(type, state) {
          if (this._target && this._target.isValid) {
            this._target.emit(type, type, state);
          }
        };

        _proto._onReplayOrResume = function _onReplayOrResume() {
          getGlobalAnimationManager().addAnimation(this);
        };

        _proto._onPauseOrStop = function _onPauseOrStop() {
          getGlobalAnimationManager().removeAnimation(this);
        };

        _createClass(AnimationState, [{
          key: "clip",
          get: function get() {
            return this._clip;
          }
        }, {
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "length",
          get: function get() {
            return this.duration;
          }
        }, {
          key: "wrapMode",
          get: function get() {
            return this._wrapMode;
          },
          set: function set(value) {
            var _this$_clipEventEval3;

            this._wrapMode = value;
            this.time = 0;

            if (value & WrapModeMask.Loop) {
              this.repeatCount = Infinity;
            } else {
              this.repeatCount = 1;
            }

            (_this$_clipEventEval3 = this._clipEventEval) === null || _this$_clipEventEval3 === void 0 ? void 0 : _this$_clipEventEval3.setWrapMode(value);
          }
        }, {
          key: "repeatCount",
          get: function get() {
            return this._repeatCount;
          },
          set: function set(value) {
            this._repeatCount = value;
            var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
            var reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;

            if (value === Infinity && !shouldWrap && !reverse) {
              this._useSimpleProcess = true;
            } else {
              this._useSimpleProcess = false;
            }
          }
        }, {
          key: "delay",
          get: function get() {
            return this._delay;
          },
          set: function set(value) {
            this._delayTime = this._delay = value;
          }
        }, {
          key: "playbackRange",
          get: function get() {
            return this._playbackRange;
          },
          set: function set(value) {
            assertIsTrue(value.max > value.min);
            this._playbackRange.min = Math.max(value.min, 0);
            this._playbackRange.max = Math.min(value.max, this.duration);
            this._playbackDuration = this._playbackRange.max - this._playbackRange.min;
            this.setTime(0.0);
          }
        }, {
          key: "speed",
          get: function get() {
            return this._speed;
          },
          set: function set(value) {
            var _this$_clipEmbeddedPl6;

            this._speed = value;
            (_this$_clipEmbeddedPl6 = this._clipEmbeddedPlayerEval) === null || _this$_clipEmbeddedPl6 === void 0 ? void 0 : _this$_clipEmbeddedPl6.notifyHostSpeedChanged(value);
          }
        }, {
          key: "current",
          get: function get() {
            return this.getWrappedInfo(this.time).time;
          }
        }, {
          key: "ratio",
          get: function get() {
            return this.duration === 0.0 ? 0.0 : this.current / this.duration;
          }
        }, {
          key: "weight",
          get: function get() {
            return this._weight;
          },
          set: function set(value) {
            this._weight = value;

            if (this._poseOutput) {
              this._poseOutput.weight = value;
            }
          }
        }, {
          key: "curveLoaded",
          get: function get() {
            return this._curveLoaded;
          }
        }]);

        return AnimationState;
      }(Playable));
      legacyCC.AnimationState = AnimationState;

      var _dec$w, _class$w, _class2$r, _descriptor$p, _descriptor2$m, _temp$t;
      var EmbeddedAnimationClipPlayable = (_dec$w = ccclass(CLASS_NAME_PREFIX_ANIM + "EmbeddedAnimationClipPlayable"), _dec$w(_class$w = (_class2$r = (_temp$t = function (_EmbeddedPlayable) {
        _inheritsLoose(EmbeddedAnimationClipPlayable, _EmbeddedPlayable);

        function EmbeddedAnimationClipPlayable() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _EmbeddedPlayable.call.apply(_EmbeddedPlayable, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "path", _descriptor$p, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "clip", _descriptor2$m, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = EmbeddedAnimationClipPlayable.prototype;

        _proto.instantiate = function instantiate(root) {
          var clip = this.clip,
              path = this.path;

          if (!clip) {
            return null;
          }

          var clipRoot = root.getChildByPath(path);

          if (!clipRoot) {
            errorID(3938, path, root.getPathInHierarchy(), clip.name);
            return null;
          }

          var state = new AnimationState(clip);
          state.initialize(clipRoot);
          return new EmbeddedAnimationClipPlayableState(state);
        };

        return EmbeddedAnimationClipPlayable;
      }(EmbeddedPlayable), _temp$t), (_descriptor$p = _applyDecoratedDescriptor(_class2$r.prototype, "path", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor2$m = _applyDecoratedDescriptor(_class2$r.prototype, "clip", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$r)) || _class$w);

      var EmbeddedAnimationClipPlayableState = function (_EmbeddedPlayableStat) {
        _inheritsLoose(EmbeddedAnimationClipPlayableState, _EmbeddedPlayableStat);

        function EmbeddedAnimationClipPlayableState(animationState) {
          var _this2;

          _this2 = _EmbeddedPlayableStat.call(this, true) || this;
          _this2._animationState = void 0;
          _this2._animationState = animationState;
          return _this2;
        }

        var _proto2 = EmbeddedAnimationClipPlayableState.prototype;

        _proto2.destroy = function destroy() {
          this._animationState.destroy();
        };

        _proto2.play = function play() {
          this._animationState.play();
        };

        _proto2.pause = function pause() {
          this._animationState.pause();
        };

        _proto2.stop = function stop() {
          this._animationState.stop();
        };

        _proto2.setSpeed = function setSpeed(speed) {
          this._animationState.speed = speed;
        };

        _proto2.setTime = function setTime(time) {
          this._animationState.time = time;
        };

        return EmbeddedAnimationClipPlayableState;
      }(EmbeddedPlayableState);

      var _dec$x, _class$x, _class2$s, _descriptor$q, _temp$u;
      var EmbeddedParticleSystemPlayable = (_dec$x = ccclass(CLASS_NAME_PREFIX_ANIM + "EmbeddedParticleSystemPlayable"), _dec$x(_class$x = (_class2$s = (_temp$u = function (_EmbeddedPlayable) {
        _inheritsLoose(EmbeddedParticleSystemPlayable, _EmbeddedPlayable);

        function EmbeddedParticleSystemPlayable() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _EmbeddedPlayable.call.apply(_EmbeddedPlayable, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "path", _descriptor$q, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = EmbeddedParticleSystemPlayable.prototype;

        _proto.instantiate = function instantiate(root) {
          var node = root.getChildByPath(this.path);

          if (!node) {
            warn("Hierarchy path " + this.path + " does not exists.");
            return null;
          }

          var ParticleSystemConstructor = getClassByName("cc.ParticleSystem");

          if (!ParticleSystemConstructor) {
            warn("Particle system is required for embedded particle system player.");
            return null;
          }

          var particleSystem = node.getComponent(ParticleSystemConstructor);

          if (!particleSystem) {
            warn(this.path + " does not includes a particle system component.");
            return null;
          }

          return new EmbeddedParticleSystemPlayableState(particleSystem);
        };

        return EmbeddedParticleSystemPlayable;
      }(EmbeddedPlayable), _temp$u), (_descriptor$q = _applyDecoratedDescriptor(_class2$s.prototype, "path", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      })), _class2$s)) || _class$x);

      var EmbeddedParticleSystemPlayableState = function (_EmbeddedPlayableStat) {
        _inheritsLoose(EmbeddedParticleSystemPlayableState, _EmbeddedPlayableStat);

        function EmbeddedParticleSystemPlayableState(particleSystem) {
          var _this2;

          _this2 = _EmbeddedPlayableStat.call(this, false) || this;
          _this2._particleSystem = void 0;
          _this2._particleSystem = particleSystem;
          return _this2;
        }

        var _proto2 = EmbeddedParticleSystemPlayableState.prototype;

        _proto2.destroy = function destroy() {};

        _proto2.play = function play() {
          this._particleSystem.play();
        };

        _proto2.pause = function pause() {
          this._particleSystem.stopEmitting();
        };

        _proto2.stop = function stop() {
          this._particleSystem.stopEmitting();
        };

        _proto2.setSpeed = function setSpeed(speed) {
          this._particleSystem.simulationSpeed = speed;
        };

        return EmbeddedParticleSystemPlayableState;
      }(EmbeddedPlayableState);

      var _dec$y, _class$y, _class2$t, _descriptor$r, _temp$v, _dec2$p, _class4$3, _class5$3, _descriptor2$n, _temp2$3;
      function isPropertyPath(path) {
        return typeof path === 'string' || typeof path === 'number';
      }
      function isCustomPath(path, constructor) {
        return path instanceof constructor;
      }
      var HierarchyPath = (_dec$y = ccclass('cc.animation.HierarchyPath'), _dec$y(_class$y = (_class2$t = (_temp$v = function () {
        function HierarchyPath(path) {
          _initializerDefineProperty(this, "path", _descriptor$r, this);

          this.path = path || '';
        }

        var _proto = HierarchyPath.prototype;

        _proto.get = function get(target) {
          if (!(target instanceof Node)) {
            warnID(3925);
            return null;
          }

          var result = target.getChildByPath(this.path);

          if (!result) {
            warnID(3926, target.name, this.path);
            return null;
          }

          return result;
        };

        return HierarchyPath;
      }(), _temp$v), (_descriptor$r = _applyDecoratedDescriptor(_class2$t.prototype, "path", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      })), _class2$t)) || _class$y);
      var ComponentPath = (_dec2$p = ccclass('cc.animation.ComponentPath'), _dec2$p(_class4$3 = (_class5$3 = (_temp2$3 = function () {
        function ComponentPath(component) {
          _initializerDefineProperty(this, "component", _descriptor2$n, this);

          this.component = component || '';
        }

        var _proto2 = ComponentPath.prototype;

        _proto2.get = function get(target) {
          if (!(target instanceof Node)) {
            warnID(3927);
            return null;
          }

          var result = target.getComponent(this.component);

          if (!result) {
            warnID(3928, target.name, this.component);
            return null;
          }

          return result;
        };

        return ComponentPath;
      }(), _temp2$3), (_descriptor2$n = _applyDecoratedDescriptor(_class5$3.prototype, "component", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      })), _class5$3)) || _class4$3);

      var _dec$z, _class$z, _class2$u, _descriptor$s, _temp$w, _dec2$q, _class4$4, _class5$4, _descriptor2$o, _descriptor3$i, _class6$2, _temp2$4, _dec3$o, _class7, _class8, _descriptor4$f, _temp3, _dec4$m, _class10, _class11, _descriptor5$c, _temp4, _dec5$k, _class13, _class14, _descriptor6$a, _temp5;
      var normalizedFollowTag = Symbol('NormalizedFollow');
      var parseTrsPathTag = Symbol('ConvertAsTrsPath');
      var trackBindingTag = Symbol('TrackBinding');
      var TrackPath = (_dec$z = ccclass(CLASS_NAME_PREFIX_ANIM + "TrackPath"), _dec$z(_class$z = (_class2$u = (_temp$w = function () {
        function TrackPath() {
          _initializerDefineProperty(this, "_paths", _descriptor$s, this);
        }

        var _proto = TrackPath.prototype;

        _proto.toProperty = function toProperty(name) {
          this._paths.push(name);

          return this;
        };

        _proto.toElement = function toElement(index) {
          this._paths.push(index);

          return this;
        };

        _proto.toHierarchy = function toHierarchy(nodePath) {
          this._paths.push(new HierarchyPath(nodePath));

          return this;
        };

        _proto.toComponent = function toComponent(constructor) {
          var path = new ComponentPath(typeof constructor === 'string' ? constructor : js.getClassName(constructor));

          this._paths.push(path);

          return this;
        };

        _proto.toCustomized = function toCustomized(resolver) {
          this._paths.push(resolver);

          return this;
        };

        _proto.append = function append() {
          var _this$_paths;

          for (var _len = arguments.length, trackPaths = new Array(_len), _key = 0; _key < _len; _key++) {
            trackPaths[_key] = arguments[_key];
          }

          var paths = (_this$_paths = this._paths).concat.apply(_this$_paths, trackPaths.map(function (trackPath) {
            return trackPath._paths;
          }));

          this._paths = paths;
          return this;
        };

        _proto.isPropertyAt = function isPropertyAt(index) {
          return typeof this._paths[index] === 'string';
        };

        _proto.parsePropertyAt = function parsePropertyAt(index) {
          return this._paths[index];
        };

        _proto.isElementAt = function isElementAt(index) {
          return typeof this._paths[index] === 'number';
        };

        _proto.parseElementAt = function parseElementAt(index) {
          return this._paths[index];
        };

        _proto.isHierarchyAt = function isHierarchyAt(index) {
          return this._paths[index] instanceof HierarchyPath;
        };

        _proto.parseHierarchyAt = function parseHierarchyAt(index) {
          assertIsTrue(this.isHierarchyAt(index));
          return this._paths[index].path;
        };

        _proto.isComponentAt = function isComponentAt(index) {
          return this._paths[index] instanceof ComponentPath;
        };

        _proto.parseComponentAt = function parseComponentAt(index) {
          assertIsTrue(this.isComponentAt(index));
          return this._paths[index].component;
        };

        _proto.slice = function slice(beginIndex, endIndex) {
          var trackPath = new TrackPath();
          trackPath._paths = this._paths.slice(beginIndex, endIndex);
          return trackPath;
        };

        _proto.trace = function trace(object, beginIndex, endIndex) {
          var _beginIndex, _endIndex;

          (_beginIndex = beginIndex) !== null && _beginIndex !== void 0 ? _beginIndex : beginIndex = 0;
          (_endIndex = endIndex) !== null && _endIndex !== void 0 ? _endIndex : endIndex = this._paths.length;
          return this[normalizedFollowTag](object, beginIndex, endIndex);
        };

        _proto[parseTrsPathTag] = function () {
          var paths = this._paths;
          var nPaths = paths.length;
          var iPath = 0;
          var nodePath = '';

          for (; iPath < nPaths; ++iPath) {
            var path = paths[iPath];

            if (!(path instanceof HierarchyPath)) {
              break;
            } else if (!path.path) {
              continue;
            } else if (nodePath) {
              nodePath += "/" + path.path;
            } else {
              nodePath = path.path;
            }
          }

          if (iPath === nPaths) {
            return null;
          }

          var prs;

          if (iPath !== nPaths - 1) {
            return null;
          }

          switch (paths[iPath]) {
            case 'position':
            case 'scale':
            case 'rotation':
            case 'eulerAngles':
              prs = paths[iPath];
              break;

            default:
              return null;
          }

          return {
            node: nodePath,
            property: prs
          };
        };

        _proto[normalizedFollowTag] = function (root, beginIndex, endIndex) {
          var paths = this._paths;
          var result = root;

          for (var iPath = beginIndex; iPath < endIndex; ++iPath) {
            var path = paths[iPath];

            if (isPropertyPath(path)) {
              if (!(path in result)) {
                warnID(3929, path);
                return null;
              } else {
                result = result[path];
              }
            } else {
              result = path.get(result);
            }

            if (result === null) {
              break;
            }
          }

          return result;
        };

        _createClass(TrackPath, [{
          key: "length",
          get: function get() {
            return this._paths.length;
          }
        }]);

        return TrackPath;
      }(), _temp$w), (_descriptor$s = _applyDecoratedDescriptor(_class2$u.prototype, "_paths", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$u)) || _class$z);
      var TrackBinding = (_dec2$q = ccclass(CLASS_NAME_PREFIX_ANIM + "TrackBinding"), _dec2$q(_class4$4 = uniquelyReferenced(_class4$4 = (_class5$4 = (_temp2$4 = _class6$2 = function () {
        function TrackBinding() {
          _initializerDefineProperty(this, "path", _descriptor2$o, this);

          _initializerDefineProperty(this, "proxy", _descriptor3$i, this);
        }

        var _proto2 = TrackBinding.prototype;

        _proto2.parseTrsPath = function parseTrsPath() {
          if (this.proxy) {
            return null;
          } else {
            return this.path[parseTrsPathTag]();
          }
        };

        _proto2.createRuntimeBinding = function createRuntimeBinding(target, poseOutput, isConstant) {
          var path = this.path,
              proxy = this.proxy;
          var nPaths = path.length;
          var iLastPath = nPaths - 1;

          if (nPaths !== 0 && (path.isPropertyAt(iLastPath) || path.isElementAt(iLastPath)) && !proxy) {
            var lastPropertyKey = path.isPropertyAt(iLastPath) ? path.parsePropertyAt(iLastPath) : path.parseElementAt(iLastPath);
            var resultTarget = path[normalizedFollowTag](target, 0, nPaths - 1);

            if (resultTarget === null) {
              return null;
            }

            if (poseOutput && resultTarget instanceof Node && isTrsPropertyName(lastPropertyKey)) {
              var blendStateWriter = poseOutput.createPoseWriter(resultTarget, lastPropertyKey, isConstant);
              return blendStateWriter;
            }

            var _setValue;

            var _getValue;

            {
              var animationFunction = TrackBinding._animationFunctions.get(resultTarget.constructor);

              if (!animationFunction) {
                animationFunction = new Map();

                TrackBinding._animationFunctions.set(resultTarget.constructor, animationFunction);
              }

              var accessor = animationFunction.get(lastPropertyKey);

              if (!accessor) {
                accessor = {
                  setValue: Function('value', "this.target." + lastPropertyKey + " = value;"),
                  getValue: Function("return this.target." + lastPropertyKey + ";")
                };
                animationFunction.set(lastPropertyKey, accessor);
              }

              _setValue = accessor.setValue;
              _getValue = accessor.getValue;
            }

            return {
              target: resultTarget,
              setValue: _setValue,
              getValue: _getValue
            };
          } else if (!proxy) {
            errorID(3921);
            return null;
          } else {
            var _resultTarget = path[normalizedFollowTag](target, 0, nPaths);

            if (_resultTarget === null) {
              return null;
            }

            var runtimeProxy = proxy.forTarget(_resultTarget);
            var _binding = {
              setValue: function setValue(value) {
                runtimeProxy.set(value);
              }
            };
            var proxyGet = runtimeProxy.get;

            if (proxyGet) {
              _binding.getValue = function () {
                return proxyGet.call(runtimeProxy);
              };
            }

            return _binding;
          }
        };

        _proto2.isMaskedOff = function isMaskedOff(mask) {
          var trsPath = this.parseTrsPath();

          if (!trsPath) {
            return false;
          }

          var joints = mask.joints[Symbol.iterator]();

          for (var jointMaskInfoIter = joints.next(); !jointMaskInfoIter.done; jointMaskInfoIter = joints.next()) {
            var _jointMaskInfoIter = jointMaskInfoIter,
                jointMaskInfo = _jointMaskInfoIter.value;

            if (jointMaskInfo.path !== trsPath.node) {
              continue;
            }

            return !jointMaskInfo.enabled;
          }

          return false;
        };

        return TrackBinding;
      }(), _class6$2._animationFunctions = new WeakMap(), _temp2$4), (_descriptor2$o = _applyDecoratedDescriptor(_class5$4.prototype, "path", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new TrackPath();
        }
      }), _descriptor3$i = _applyDecoratedDescriptor(_class5$4.prototype, "proxy", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class5$4)) || _class4$4) || _class4$4);

      function isTrsPropertyName(name) {
        return name === 'position' || name === 'rotation' || name === 'scale' || name === 'eulerAngles';
      }
      var Track = (_dec3$o = ccclass(CLASS_NAME_PREFIX_ANIM + "Track"), _dec3$o(_class7 = (_class8 = (_temp3 = function () {
        function Track() {
          _initializerDefineProperty(this, "_binding", _descriptor4$f, this);
        }

        var _proto3 = Track.prototype;

        _proto3.channels = function channels() {
          return [];
        };

        _proto3.range = function range() {
          var range = {
            min: Infinity,
            max: -Infinity
          };

          for (var _iterator = _createForOfIteratorHelperLoose(this.channels()), _step; !(_step = _iterator()).done;) {
            var channel = _step.value;
            range.min = Math.min(range.min, channel.curve.rangeMin);
            range.max = Math.max(range.max, channel.curve.rangeMax);
          }

          return range;
        };

        _createClass(Track, [{
          key: "path",
          get: function get() {
            return this._binding.path;
          },
          set: function set(value) {
            this._binding.path = value;
          }
        }, {
          key: "proxy",
          get: function get() {
            return this._binding.proxy;
          },
          set: function set(value) {
            this._binding.proxy = value;
          }
        }, {
          key: trackBindingTag,
          get: function get() {
            return this._binding;
          }
        }]);

        return Track;
      }(), _temp3), (_descriptor4$f = _applyDecoratedDescriptor(_class8.prototype, "_binding", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new TrackBinding();
        }
      })), _class8)) || _class7);
      var Channel = (_dec4$m = ccclass(CLASS_NAME_PREFIX_ANIM + "Channel"), _dec4$m(_class10 = (_class11 = (_temp4 = function () {
        function Channel(curve) {
          this.name = '';

          _initializerDefineProperty(this, "_curve", _descriptor5$c, this);

          this._curve = curve;
        }

        _createClass(Channel, [{
          key: "curve",
          get: function get() {
            return this._curve;
          }
        }]);

        return Channel;
      }(), _temp4), (_descriptor5$c = _applyDecoratedDescriptor(_class11.prototype, "_curve", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class11)) || _class10);
      var SingleChannelTrack = (_dec5$k = ccclass(CLASS_NAME_PREFIX_ANIM + "SingleChannelTrack"), _dec5$k(_class13 = (_class14 = (_temp5 = function (_Track) {
        _inheritsLoose(SingleChannelTrack, _Track);

        function SingleChannelTrack() {
          var _this;

          _this = _Track.call(this) || this;

          _initializerDefineProperty(_this, "_channel", _descriptor6$a, _assertThisInitialized(_this));

          _this._channel = new Channel(_this.createCurve());
          return _this;
        }

        var _proto4 = SingleChannelTrack.prototype;

        _proto4.channels = function channels() {
          return [this._channel];
        };

        _proto4.createCurve = function createCurve() {
          throw new Error("Not impl");
        };

        _proto4[createEvalSymbol] = function (_runtimeBinding) {
          var curve = this._channel.curve;
          return new SingleChannelTrackEval(curve);
        };

        _createClass(SingleChannelTrack, [{
          key: "channel",
          get: function get() {
            return this._channel;
          }
        }]);

        return SingleChannelTrack;
      }(Track), _temp5), (_descriptor6$a = _applyDecoratedDescriptor(_class14.prototype, "_channel", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class14)) || _class13);

      var SingleChannelTrackEval = function () {
        function SingleChannelTrackEval(_curve) {
          this._curve = _curve;
        }

        var _proto5 = SingleChannelTrackEval.prototype;

        _proto5.evaluate = function evaluate(time) {
          return this._curve.evaluate(time);
        };

        return SingleChannelTrackEval;
      }();

      var _dec$A, _class$A, _class2$v, _descriptor$t, _temp$x;
      var RealArrayTrack = (_dec$A = ccclass(CLASS_NAME_PREFIX_ANIM + "RealArrayTrack"), _dec$A(_class$A = (_class2$v = (_temp$x = function (_Track) {
        _inheritsLoose(RealArrayTrack, _Track);

        function RealArrayTrack() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Track.call.apply(_Track, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_channels", _descriptor$t, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = RealArrayTrack.prototype;

        _proto.channels = function channels() {
          return this._channels;
        };

        _proto[createEvalSymbol] = function () {
          return new RealArrayTrackEval(this._channels.map(function (_ref) {
            var curve = _ref.curve;
            return curve;
          }));
        };

        _createClass(RealArrayTrack, [{
          key: "elementCount",
          get: function get() {
            return this._channels.length;
          },
          set: function set(value) {
            var channels = this._channels;
            var nChannels = channels.length;

            if (value < nChannels) {
              this._channels.splice(value);
            } else if (value > nChannels) {
              var _this$_channels;

              (_this$_channels = this._channels).push.apply(_this$_channels, Array.from({
                length: value - nChannels
              }, function () {
                return new Channel(new RealCurve());
              }));
            }
          }
        }]);

        return RealArrayTrack;
      }(Track), _temp$x), (_descriptor$t = _applyDecoratedDescriptor(_class2$v.prototype, "_channels", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$v)) || _class$A);
      var RealArrayTrackEval = function () {
        function RealArrayTrackEval(_curves) {
          this._curves = _curves;
          this._result = new Array(_curves.length).fill(0.0);
        }

        var _proto2 = RealArrayTrackEval.prototype;

        _proto2.evaluate = function evaluate(time, _runtimeBinding) {
          var result = this._result;
          var nElements = result.length;

          for (var iElement = 0; iElement < nElements; ++iElement) {
            result[iElement] = this._curves[iElement].evaluate(time);
          }

          return this._result;
        };

        return RealArrayTrackEval;
      }();

      var _dec$B, _class$B, _class2$w, _descriptor$u, _descriptor2$p, _descriptor3$j, _temp$y;
      var UniformProxyFactory = (_dec$B = ccclass('cc.animation.UniformProxyFactory'), _dec$B(_class$B = (_class2$w = (_temp$y = function () {
        function UniformProxyFactory(uniformName, passIndex) {
          _initializerDefineProperty(this, "passIndex", _descriptor$u, this);

          _initializerDefineProperty(this, "uniformName", _descriptor2$p, this);

          _initializerDefineProperty(this, "channelIndex", _descriptor3$j, this);

          this.passIndex = passIndex || 0;
          this.uniformName = uniformName || '';
        }

        var _proto = UniformProxyFactory.prototype;

        _proto.forTarget = function forTarget(target) {
          var pass = target.passes[this.passIndex];
          var handle = pass.getHandle(this.uniformName);

          if (!handle) {
            throw new Error("Material \"" + target.name + "\" has no uniform \"" + this.uniformName + "\"");
          }

          var type = Pass.getTypeFromHandle(handle);

          if (type < Type$1.SAMPLER1D) {
            var realHandle = this.channelIndex === undefined ? handle : pass.getHandle(this.uniformName, this.channelIndex, Type$1.FLOAT);

            if (!realHandle) {
              throw new Error("Uniform \"" + this.uniformName + " (in material " + target.name + ") has no channel " + this.channelIndex + "\"");
            }

            if (isUniformArray(pass, this.uniformName)) {
              return {
                set: function set(value) {
                  pass.setUniformArray(realHandle, value);
                }
              };
            }

            return {
              set: function set(value) {
                pass.setUniform(realHandle, value);
              }
            };
          } else {
            var binding = Pass.getBindingFromHandle(handle);
            var prop = pass.properties[this.uniformName];
            var texName = prop && prop.value ? "" + prop.value + getStringFromType(prop.type) : getDefaultFromType(prop.type);
            var dftTex = builtinResMgr.get(texName);

            if (!dftTex) {
              warn("Illegal texture default value: " + texName + ".");
              dftTex = builtinResMgr.get('default-texture');
            }

            return {
              set: function set(value) {
                if (!value) {
                  value = dftTex;
                }

                var texture = value.getGFXTexture();

                if (!texture || !texture.width || !texture.height) {
                  return;
                }

                pass.bindTexture(binding, texture);

                if (value instanceof TextureBase) {
                  pass.bindSampler(binding, deviceManager.gfxDevice.getSampler(value.getSamplerInfo()));
                }
              }
            };
          }
        };

        return UniformProxyFactory;
      }(), _temp$y), (_descriptor$u = _applyDecoratedDescriptor(_class2$w.prototype, "passIndex", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$p = _applyDecoratedDescriptor(_class2$w.prototype, "uniformName", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor3$j = _applyDecoratedDescriptor(_class2$w.prototype, "channelIndex", [_float], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return undefined;
        }
      })), _class2$w)) || _class$B);

      function isUniformArray(pass, name) {
        for (var _iterator = _createForOfIteratorHelperLoose(pass.shaderInfo.blocks), _step; !(_step = _iterator()).done;) {
          var block = _step.value;

          for (var _iterator2 = _createForOfIteratorHelperLoose(block.members), _step2; !(_step2 = _iterator2()).done;) {
            var uniform = _step2.value;

            if (uniform.name === name) {
              return uniform.count > 1;
            }
          }
        }

        return false;
      }

      var _dec$C, _class$C, _class2$x, _descriptor$v, _descriptor2$q, _temp$z, _dec2$r, _class4$5, _class5$5, _descriptor3$k, _temp2$5, _dec3$p, _class7$1;
      var MorphWeightValueProxy = (_dec$C = ccclass('cc.animation.MorphWeightValueProxy'), _dec$C(_class$C = (_class2$x = (_temp$z = function () {
        function MorphWeightValueProxy() {
          _initializerDefineProperty(this, "subMeshIndex", _descriptor$v, this);

          _initializerDefineProperty(this, "shapeIndex", _descriptor2$q, this);
        }

        var _proto = MorphWeightValueProxy.prototype;

        _proto.forTarget = function forTarget(target) {
          var _this = this;

          return {
            set: function set(value) {
              target.setWeight(value, _this.subMeshIndex, _this.shapeIndex);
            }
          };
        };

        return MorphWeightValueProxy;
      }(), _temp$z), (_descriptor$v = _applyDecoratedDescriptor(_class2$x.prototype, "subMeshIndex", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$q = _applyDecoratedDescriptor(_class2$x.prototype, "shapeIndex", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$x)) || _class$C);
      var MorphWeightsValueProxy = (_dec2$r = ccclass('cc.animation.MorphWeightsValueProxy'), _dec2$r(_class4$5 = (_class5$5 = (_temp2$5 = function () {
        function MorphWeightsValueProxy() {
          _initializerDefineProperty(this, "subMeshIndex", _descriptor3$k, this);
        }

        var _proto2 = MorphWeightsValueProxy.prototype;

        _proto2.forTarget = function forTarget(target) {
          var _this2 = this;

          return {
            set: function set(value) {
              target.setWeights(value, _this2.subMeshIndex);
            }
          };
        };

        return MorphWeightsValueProxy;
      }(), _temp2$5), (_descriptor3$k = _applyDecoratedDescriptor(_class5$5.prototype, "subMeshIndex", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class5$5)) || _class4$5);
      var MorphWeightsAllValueProxy = (_dec3$p = ccclass('cc.animation.MorphWeightsAllValueProxy'), _dec3$p(_class7$1 = function () {
        function MorphWeightsAllValueProxy() {}

        var _proto3 = MorphWeightsAllValueProxy.prototype;

        _proto3.forTarget = function forTarget(target) {
          return {
            set: function set(value) {
              var _target$mesh$struct$p, _target$mesh;

              var nSubMeshes = (_target$mesh$struct$p = (_target$mesh = target.mesh) === null || _target$mesh === void 0 ? void 0 : _target$mesh.struct.primitives.length) !== null && _target$mesh$struct$p !== void 0 ? _target$mesh$struct$p : 0;

              for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                target.setWeights(value, iSubMesh);
              }
            }
          };
        };

        return MorphWeightsAllValueProxy;
      }()) || _class7$1);

      var _dec2$s, _class4$6, _class5$6, _descriptor4$g, _descriptor5$d, _descriptor6$b, _temp2$6;

      function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
        var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;

        var tempValue = new constructorX();
        var m0 = new constructorX();
        var m1 = new constructorX();
        var CubicSplineValueClass = (_dec = ccclass(name), _dec(_class = (_class2 = (_temp = function () {
          function CubicSplineValueClass(dataPoint, inTangent, outTangent) {
            _initializerDefineProperty(this, "dataPoint", _descriptor, this);

            _initializerDefineProperty(this, "inTangent", _descriptor2, this);

            _initializerDefineProperty(this, "outTangent", _descriptor3, this);

            this.dataPoint = dataPoint || new constructorX();
            this.inTangent = inTangent || new constructorX();
            this.outTangent = outTangent || new constructorX();
          }

          var _proto = CubicSplineValueClass.prototype;

          _proto.lerp = function lerp(to, t, dt) {
            var p0 = this.dataPoint;
            var p1 = to.dataPoint;
            m0 = scaleFx(m0, this.inTangent, dt);
            m1 = scaleFx(m1, to.outTangent, dt);
            var t_3 = t * t * t;
            var t_2 = t * t;
            var f_0 = 2 * t_3 - 3 * t_2 + 1;
            var f_1 = t_3 - 2 * t_2 + t;
            var f_2 = -2 * t_3 + 3 * t_2;
            var f_3 = t_3 - t_2;
            tempValue = scaleFx(tempValue, p0, f_0);
            tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1);
            tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2);
            tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
            return tempValue;
          };

          _proto.getNoLerp = function getNoLerp() {
            return this.dataPoint;
          };

          return CubicSplineValueClass;
        }(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "dataPoint", [serializable], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function initializer() {
            return new constructorX();
          }
        }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "inTangent", [serializable], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function initializer() {
            return new constructorX();
          }
        }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "outTangent", [serializable], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function initializer() {
            return new constructorX();
          }
        })), _class2)) || _class);

        if (constructorX === Quat) {
          var _lerp = CubicSplineValueClass.prototype.lerp;

          CubicSplineValueClass.prototype.lerp = function (to, t, dt) {
            var result = _lerp.call(this, to, t, dt);

            Quat.normalize(result, result);
            return result;
          };
        }

        return CubicSplineValueClass;
      }

      var CubicSplineVec2Value = makeCubicSplineValueConstructor('cc.CubicSplineVec2Value', Vec2, Vec2.multiplyScalar, Vec2.scaleAndAdd);
      var CubicSplineVec3Value = makeCubicSplineValueConstructor('cc.CubicSplineVec3Value', Vec3, Vec3.multiplyScalar, Vec3.scaleAndAdd);
      var CubicSplineVec4Value = makeCubicSplineValueConstructor('cc.CubicSplineVec4Value', Vec4, Vec4.multiplyScalar, Vec4.scaleAndAdd);
      var CubicSplineQuatValue = makeCubicSplineValueConstructor('cc.CubicSplineQuatValue', Quat, Quat.multiplyScalar, Quat.scaleAndAdd);
      var CubicSplineNumberValue = (_dec2$s = ccclass('cc.CubicSplineNumberValue'), _dec2$s(_class4$6 = (_class5$6 = (_temp2$6 = function () {
        function CubicSplineNumberValue(dataPoint, inTangent, outTangent) {
          _initializerDefineProperty(this, "dataPoint", _descriptor4$g, this);

          _initializerDefineProperty(this, "inTangent", _descriptor5$d, this);

          _initializerDefineProperty(this, "outTangent", _descriptor6$b, this);

          this.dataPoint = dataPoint;
          this.inTangent = inTangent;
          this.outTangent = outTangent;
        }

        var _proto2 = CubicSplineNumberValue.prototype;

        _proto2.lerp = function lerp(to, t, dt) {
          var p0 = this.dataPoint;
          var p1 = to.dataPoint;
          var m0 = this.outTangent * dt;
          var m1 = to.inTangent * dt;
          var t_3 = t * t * t;
          var t_2 = t * t;
          var f_0 = 2 * t_3 - 3 * t_2 + 1;
          var f_1 = t_3 - 2 * t_2 + t;
          var f_2 = -2 * t_3 + 3 * t_2;
          var f_3 = t_3 - t_2;
          return p0 * f_0 + m0 * f_1 + p1 * f_2 + m1 * f_3;
        };

        _proto2.getNoLerp = function getNoLerp() {
          return this.dataPoint;
        };

        return CubicSplineNumberValue;
      }(), _temp2$6), (_descriptor4$g = _applyDecoratedDescriptor(_class5$6.prototype, "dataPoint", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor5$d = _applyDecoratedDescriptor(_class5$6.prototype, "inTangent", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor6$b = _applyDecoratedDescriptor(_class5$6.prototype, "outTangent", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class5$6)) || _class4$6);

      var _dec$D, _class$D;
      var RealTrack = (_dec$D = ccclass(CLASS_NAME_PREFIX_ANIM + "RealTrack"), _dec$D(_class$D = function (_SingleChannelTrack) {
        _inheritsLoose(RealTrack, _SingleChannelTrack);

        function RealTrack() {
          return _SingleChannelTrack.apply(this, arguments) || this;
        }

        var _proto = RealTrack.prototype;

        _proto.createCurve = function createCurve() {
          return new RealCurve();
        };

        return RealTrack;
      }(SingleChannelTrack)) || _class$D);

      function maskIfEmpty(curve) {
        return curve.keyFramesCount === 0 ? undefined : curve;
      }

      var _dec$E, _class$E, _class2$y, _descriptor$w, _descriptor2$r, _temp$A;
      var CHANNEL_NAMES = ['X', 'Y', 'Z', 'W'];
      var VectorTrack = (_dec$E = ccclass(CLASS_NAME_PREFIX_ANIM + "VectorTrack"), _dec$E(_class$E = (_class2$y = (_temp$A = function (_Track) {
        _inheritsLoose(VectorTrack, _Track);

        function VectorTrack() {
          var _this;

          _this = _Track.call(this) || this;

          _initializerDefineProperty(_this, "_channels", _descriptor$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_nComponents", _descriptor2$r, _assertThisInitialized(_this));

          _this._channels = new Array(4);

          for (var i = 0; i < _this._channels.length; ++i) {
            var channel = new Channel(new RealCurve());
            channel.name = CHANNEL_NAMES[i];
            _this._channels[i] = channel;
          }

          return _this;
        }

        var _proto = VectorTrack.prototype;

        _proto.channels = function channels() {
          return this._channels;
        };

        _proto[createEvalSymbol] = function () {
          switch (this._nComponents) {
            default:
            case 2:
              return new Vec2TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve));

            case 3:
              return new Vec3TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve));

            case 4:
              return new Vec4TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve), maskIfEmpty(this._channels[3].curve));
          }
        };

        _createClass(VectorTrack, [{
          key: "componentsCount",
          get: function get() {
            return this._nComponents;
          },
          set: function set(value) {
            this._nComponents = value;
          }
        }]);

        return VectorTrack;
      }(Track), _temp$A), (_descriptor$w = _applyDecoratedDescriptor(_class2$y.prototype, "_channels", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor2$r = _applyDecoratedDescriptor(_class2$y.prototype, "_nComponents", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 4;
        }
      })), _class2$y)) || _class$E);
      var Vec2TrackEval = function () {
        function Vec2TrackEval(_x, _y) {
          this._result = new Vec2();
          this._x = _x;
          this._y = _y;
        }

        var _proto2 = Vec2TrackEval.prototype;

        _proto2.evaluate = function evaluate(time, runtimeBinding) {
          if ((!this._x || !this._y) && runtimeBinding.getValue) {
            Vec2.copy(this._result, runtimeBinding.getValue());
          }

          if (this._x) {
            this._result.x = this._x.evaluate(time);
          }

          if (this._y) {
            this._result.y = this._y.evaluate(time);
          }

          return this._result;
        };

        return Vec2TrackEval;
      }();
      var Vec3TrackEval = function () {
        function Vec3TrackEval(_x, _y, _z) {
          this._result = new Vec3();
          this._x = _x;
          this._y = _y;
          this._z = _z;
        }

        var _proto3 = Vec3TrackEval.prototype;

        _proto3.evaluate = function evaluate(time, runtimeBinding) {
          if ((!this._x || !this._y || !this._z) && runtimeBinding.getValue) {
            Vec3.copy(this._result, runtimeBinding.getValue());
          }

          if (this._x) {
            this._result.x = this._x.evaluate(time);
          }

          if (this._y) {
            this._result.y = this._y.evaluate(time);
          }

          if (this._z) {
            this._result.z = this._z.evaluate(time);
          }

          return this._result;
        };

        return Vec3TrackEval;
      }();
      var Vec4TrackEval = function () {
        function Vec4TrackEval(_x, _y, _z, _w) {
          this._result = new Vec4();
          this._x = _x;
          this._y = _y;
          this._z = _z;
          this._w = _w;
        }

        var _proto4 = Vec4TrackEval.prototype;

        _proto4.evaluate = function evaluate(time, runtimeBinding) {
          if ((!this._x || !this._y || !this._z || !this._w) && runtimeBinding.getValue) {
            Vec4.copy(this._result, runtimeBinding.getValue());
          }

          if (this._x) {
            this._result.x = this._x.evaluate(time);
          }

          if (this._y) {
            this._result.y = this._y.evaluate(time);
          }

          if (this._z) {
            this._result.z = this._z.evaluate(time);
          }

          if (this._w) {
            this._result.w = this._w.evaluate(time);
          }

          return this._result;
        };

        return Vec4TrackEval;
      }();

      var _dec$F, _class$F;
      var QuatTrack = (_dec$F = ccclass(CLASS_NAME_PREFIX_ANIM + "QuatTrack"), _dec$F(_class$F = function (_SingleChannelTrack) {
        _inheritsLoose(QuatTrack, _SingleChannelTrack);

        function QuatTrack() {
          return _SingleChannelTrack.apply(this, arguments) || this;
        }

        var _proto = QuatTrack.prototype;

        _proto.createCurve = function createCurve() {
          return new QuatCurve();
        };

        _proto[createEvalSymbol] = function () {
          return new QuatTrackEval(this.channels()[0].curve);
        };

        return QuatTrack;
      }(SingleChannelTrack)) || _class$F);
      var QuatTrackEval = function () {
        function QuatTrackEval(_curve) {
          this._result = new Quat();
          this._curve = _curve;
        }

        var _proto2 = QuatTrackEval.prototype;

        _proto2.evaluate = function evaluate(time) {
          this._curve.evaluate(time, this._result);

          return this._result;
        };

        return QuatTrackEval;
      }();

      var _dec$G, _class$G, _class2$z, _descriptor$x, _temp$B;
      var CHANNEL_NAMES$1 = ['Red', 'Green', 'Blue', 'Alpha'];
      var ColorTrack = (_dec$G = ccclass(CLASS_NAME_PREFIX_ANIM + "ColorTrack"), _dec$G(_class$G = (_class2$z = (_temp$B = function (_Track) {
        _inheritsLoose(ColorTrack, _Track);

        function ColorTrack() {
          var _this;

          _this = _Track.call(this) || this;

          _initializerDefineProperty(_this, "_channels", _descriptor$x, _assertThisInitialized(_this));

          _this._channels = new Array(4);

          for (var i = 0; i < _this._channels.length; ++i) {
            var channel = new Channel(new RealCurve());
            channel.name = CHANNEL_NAMES$1[i];
            _this._channels[i] = channel;
          }

          return _this;
        }

        var _proto = ColorTrack.prototype;

        _proto.channels = function channels() {
          return this._channels;
        };

        _proto[createEvalSymbol] = function () {
          return new ColorTrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve), maskIfEmpty(this._channels[3].curve));
        };

        return ColorTrack;
      }(Track), _temp$B), (_descriptor$x = _applyDecoratedDescriptor(_class2$z.prototype, "_channels", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class2$z)) || _class$G);
      var ColorTrackEval = function () {
        function ColorTrackEval(_x, _y, _z, _w) {
          this._result = new Color();
          this._x = _x;
          this._y = _y;
          this._z = _z;
          this._w = _w;
        }

        var _proto2 = ColorTrackEval.prototype;

        _proto2.evaluate = function evaluate(time, runtimeBinding) {
          if ((!this._x || !this._y || !this._z || !this._w) && runtimeBinding.getValue) {
            Color.copy(this._result, runtimeBinding.getValue());
          }

          if (this._x) {
            this._result.r = this._x.evaluate(time);
          }

          if (this._y) {
            this._result.g = this._y.evaluate(time);
          }

          if (this._z) {
            this._result.b = this._z.evaluate(time);
          }

          if (this._w) {
            this._result.a = this._w.evaluate(time);
          }

          return this._result;
        };

        return ColorTrackEval;
      }();

      var _dec$H, _class$H, _class2$A, _descriptor$y, _temp$C;
      var CHANNEL_NAMES$2 = ['Width', 'Height'];
      var SizeTrack = (_dec$H = ccclass(CLASS_NAME_PREFIX_ANIM + "SizeTrack"), _dec$H(_class$H = (_class2$A = (_temp$C = function (_Track) {
        _inheritsLoose(SizeTrack, _Track);

        function SizeTrack() {
          var _this;

          _this = _Track.call(this) || this;

          _initializerDefineProperty(_this, "_channels", _descriptor$y, _assertThisInitialized(_this));

          _this._channels = new Array(2);

          for (var i = 0; i < _this._channels.length; ++i) {
            var channel = new Channel(new RealCurve());
            channel.name = CHANNEL_NAMES$2[i];
            _this._channels[i] = channel;
          }

          return _this;
        }

        var _proto = SizeTrack.prototype;

        _proto.channels = function channels() {
          return this._channels;
        };

        _proto[createEvalSymbol] = function () {
          return new SizeTrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve));
        };

        return SizeTrack;
      }(Track), _temp$C), (_descriptor$y = _applyDecoratedDescriptor(_class2$A.prototype, "_channels", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class2$A)) || _class$H);
      var SizeTrackEval = function () {
        function SizeTrackEval(_width, _height) {
          this._result = new Size();
          this._width = _width;
          this._height = _height;
        }

        var _proto2 = SizeTrackEval.prototype;

        _proto2.evaluate = function evaluate(time, runtimeBinding) {
          if ((!this._width || !this._height) && runtimeBinding.getValue) {
            var size = runtimeBinding.getValue();
            this._result.x = size.x;
            this._result.y = size.y;
          }

          if (this._width) {
            this._result.width = this._width.evaluate(time);
          }

          if (this._height) {
            this._result.height = this._height.evaluate(time);
          }

          return this._result;
        };

        return SizeTrackEval;
      }();

      var _dec$I, _class$I;
      var ObjectTrack = (_dec$I = ccclass(CLASS_NAME_PREFIX_ANIM + "ObjectTrack"), _dec$I(_class$I = function (_SingleChannelTrack) {
        _inheritsLoose(ObjectTrack, _SingleChannelTrack);

        function ObjectTrack() {
          return _SingleChannelTrack.apply(this, arguments) || this;
        }

        var _proto = ObjectTrack.prototype;

        _proto.createCurve = function createCurve() {
          return new ObjectCurve();
        };

        return ObjectTrack;
      }(SingleChannelTrack)) || _class$I);

      var animation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        UniformProxyFactory: UniformProxyFactory,
        MorphWeightValueProxy: MorphWeightValueProxy,
        MorphWeightsValueProxy: MorphWeightsValueProxy,
        MorphWeightsAllValueProxy: MorphWeightsAllValueProxy,
        Track: Track,
        TrackPath: TrackPath,
        RealTrack: RealTrack,
        VectorTrack: VectorTrack,
        QuatTrack: QuatTrack,
        ColorTrack: ColorTrack,
        SizeTrack: SizeTrack,
        ObjectTrack: ObjectTrack,
        isPropertyPath: isPropertyPath,
        isCustomPath: isCustomPath,
        HierarchyPath: HierarchyPath,
        ComponentPath: ComponentPath,
        CubicSplineVec2Value: CubicSplineVec2Value,
        CubicSplineVec3Value: CubicSplineVec3Value,
        CubicSplineVec4Value: CubicSplineVec4Value,
        CubicSplineQuatValue: CubicSplineQuatValue,
        CubicSplineNumberValue: CubicSplineNumberValue
      });
      exports('animation', animation);

      var RatioSampler = exports('RatioSampler', function () {
        function RatioSampler(ratios) {
          this.ratios = void 0;
          this._findRatio = void 0;
          this.ratios = ratios;
          var currRatioDif;
          var lastRatioDif;
          var canOptimize = true;
          var EPSILON = 1e-6;

          for (var i = 1, l = ratios.length; i < l; i++) {
            currRatioDif = ratios[i] - ratios[i - 1];

            if (i === 1) {
              lastRatioDif = currRatioDif;
            } else if (Math.abs(currRatioDif - lastRatioDif) > EPSILON) {
              canOptimize = false;
              break;
            }
          }

          this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon;
        }

        var _proto = RatioSampler.prototype;

        _proto.sample = function sample(ratio) {
          return this._findRatio(this.ratios, ratio);
        };

        return RatioSampler;
      }());
      legacyCC.RatioSampler = RatioSampler;
      var AnimCurve = exports('AnimCurve', function () {
        AnimCurve.Bezier = function Bezier(controlPoints) {
          return controlPoints;
        };

        function AnimCurve(propertyCurveData, duration) {
          this.types = undefined;
          this.type = null;
          this._values = [];
          this._lerp = undefined;
          this._duration = void 0;
          this._array = void 0;
          this._duration = duration;
          this._values = propertyCurveData.values;

          var getCurveType = function getCurveType(easingMethod) {
            if (typeof easingMethod === 'string') {
              return easingMethod;
            } else if (Array.isArray(easingMethod)) {
              if (easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3]) {
                return AnimCurve.Linear;
              } else {
                return AnimCurve.Bezier(easingMethod);
              }
            } else {
              return AnimCurve.Linear;
            }
          };

          if (propertyCurveData.easingMethod !== undefined) {
            this.type = getCurveType(propertyCurveData.easingMethod);
          } else if (Array.isArray(propertyCurveData.easingMethods)) {
            this.types = propertyCurveData.easingMethods.map(getCurveType);
          } else if (propertyCurveData.easingMethods !== undefined) {
            this.types = new Array(this._values.length).fill(null);

            for (var _i = 0, _Object$keys = Object.keys(propertyCurveData.easingMethods); _i < _Object$keys.length; _i++) {
              var index = _Object$keys[_i];
              this.types[index] = getCurveType(propertyCurveData.easingMethods[index]);
            }
          } else {
            this.type = null;
          }

          var firstValue = propertyCurveData.values[0];
          var interpolate = propertyCurveData.interpolate === undefined ? true : propertyCurveData.interpolate;

          if (interpolate) {
            this._lerp = selectLerpFx(firstValue);
          }

          if (propertyCurveData._arrayLength !== undefined) {
            this._array = new Array(propertyCurveData._arrayLength);
          }
        }

        var _proto2 = AnimCurve.prototype;

        _proto2.hasLerp = function hasLerp() {
          return !!this._lerp;
        };

        _proto2.valueAt = function valueAt(index) {
          if (this._array === undefined) {
            var value = this._values[index];

            if (value && value.getNoLerp) {
              return value.getNoLerp();
            } else {
              return value;
            }
          } else {
            for (var i = 0; i < this._array.length; ++i) {
              this._array[i] = this._values[this._array.length * index + i];
            }

            return this._array;
          }
        };

        _proto2.valueBetween = function valueBetween(ratio, from, fromRatio, to, toRatio) {
          if (this._lerp) {
            var type = this.types ? this.types[from] : this.type;
            var dRatio = toRatio - fromRatio;
            var ratioBetweenFrames = (ratio - fromRatio) / dRatio;

            if (type) {
              ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type);
            }

            if (this._array === undefined) {
              var fromVal = this._values[from];
              var toVal = this._values[to];

              var value = this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);

              return value;
            } else {
              for (var i = 0; i < this._array.length; ++i) {
                var _fromVal = this._values[this._array.length * from + i];
                var _toVal = this._values[this._array.length * to + i];
                this._array[i] = this._lerp(_fromVal, _toVal, ratioBetweenFrames, dRatio * this._duration);
              }

              return this._array;
            }
          } else if (this._array === undefined) {
            return this.valueAt(from);
          } else {
            for (var _i2 = 0; _i2 < this._array.length; ++_i2) {
              this._array[_i2] = this._values[this._array.length * from + _i2];
            }

            return this._array;
          }
        };

        _proto2.empty = function empty() {
          return this._values.length === 0;
        };

        _proto2.constant = function constant() {
          return this._values.length === 1;
        };

        return AnimCurve;
      }());
      AnimCurve.Linear = null;
      legacyCC.AnimCurve = AnimCurve;
      var EventInfo = exports('EventInfo', function () {
        function EventInfo() {
          this.events = [];
        }

        var _proto3 = EventInfo.prototype;

        _proto3.add = function add(func, params) {
          this.events.push({
            func: func || '',
            params: params || []
          });
        };

        return EventInfo;
      }());
      function sampleAnimationCurve(curve, sampler, ratio) {
        var index = sampler.sample(ratio);

        if (index < 0) {
          index = ~index;

          if (index <= 0) {
            index = 0;
          } else if (index >= sampler.ratios.length) {
            index = sampler.ratios.length - 1;
          } else {
            return curve.valueBetween(ratio, index - 1, sampler.ratios[index - 1], index, sampler.ratios[index]);
          }
        }

        return curve.valueAt(index);
      }
      legacyCC.sampleAnimationCurve = sampleAnimationCurve;
      function computeRatioByType(ratio, type) {
        if (typeof type === 'string') {
          var func = easing[type];

          if (func) {
            ratio = func(ratio);
          } else {
            errorID(3906, type);
          }
        } else if (Array.isArray(type)) {
          ratio = bezierByTime(type, ratio);
        }

        return ratio;
      }

      function quickFindIndex(ratios, ratio) {
        var length = ratios.length - 1;

        if (length === 0) {
          return 0;
        }

        var start = ratios[0];

        if (ratio < start) {
          return 0;
        }

        var end = ratios[length];

        if (ratio > end) {
          return length;
        }

        ratio = (ratio - start) / (end - start);
        var eachLength = 1 / length;
        var index = ratio / eachLength;
        var floorIndex = index | 0;
        var EPSILON = 1e-6;

        if (index - floorIndex < EPSILON) {
          return floorIndex;
        } else if (floorIndex + 1 - index < EPSILON) {
          return floorIndex + 1;
        }

        return ~(floorIndex + 1);
      }

      var selectLerpFx = function () {
        function makeValueTypeLerpFx(constructor) {
          var tempValue = new constructor();
          return function (from, to, ratio) {
            constructor.lerp(tempValue, from, to, ratio);
            return tempValue;
          };
        }

        function callLerpable(from, to, t, dt) {
          return from.lerp(to, t, dt);
        }

        function makeQuatSlerpFx() {
          var tempValue = new Quat();
          return function (from, to, t, dt) {
            return Quat.slerp(tempValue, from, to, t);
          };
        }

        return function (value) {
          if (value === null) {
            return undefined;
          }

          if (typeof value === 'number') {
            return lerp;
          } else if (typeof value === 'object' && value.constructor) {
            if (value instanceof Quat) {
              return makeQuatSlerpFx();
            } else if (value instanceof ValueType) {
              return makeValueTypeLerpFx(value.constructor);
            } else if (value.constructor === Number) {
              return lerp;
            } else if (isLerpable(value)) {
              return callLerpable;
            }
          }

          return undefined;
        };
      }();

      var _dec$J, _class$J, _class2$B, _descriptor$z, _temp$D, _dec2$t, _class4$7, _class5$7, _descriptor2$s, _temp2$7;
      var UntypedTrackChannel = (_dec$J = ccclass(CLASS_NAME_PREFIX_ANIM + "UntypedTrackChannel"), _dec$J(_class$J = (_class2$B = (_temp$D = function (_Channel) {
        _inheritsLoose(UntypedTrackChannel, _Channel);

        function UntypedTrackChannel() {
          var _this;

          _this = _Channel.call(this, new RealCurve()) || this;

          _initializerDefineProperty(_this, "property", _descriptor$z, _assertThisInitialized(_this));

          return _this;
        }

        return UntypedTrackChannel;
      }(Channel), _temp$D), (_descriptor$z = _applyDecoratedDescriptor(_class2$B.prototype, "property", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      })), _class2$B)) || _class$J);
      var UntypedTrack = (_dec2$t = ccclass(CLASS_NAME_PREFIX_ANIM + "UntypedTrack"), _dec2$t(_class4$7 = (_class5$7 = (_temp2$7 = function (_Track) {
        _inheritsLoose(UntypedTrack, _Track);

        function UntypedTrack() {
          var _this2;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this2 = _Track.call.apply(_Track, [this].concat(args)) || this;

          _initializerDefineProperty(_this2, "_channels", _descriptor2$s, _assertThisInitialized(_this2));

          return _this2;
        }

        var _proto = UntypedTrack.prototype;

        _proto.channels = function channels() {
          return this._channels;
        };

        _proto[createEvalSymbol] = function (runtimeBinding) {
          var _this3 = this;

          if (!runtimeBinding.getValue) {
            throw new Error(getError(3930));
          }

          var trySearchCurve = function trySearchCurve(property) {
            var _this3$_channels$find;

            return (_this3$_channels$find = _this3._channels.find(function (channel) {
              return channel.property === property;
            })) === null || _this3$_channels$find === void 0 ? void 0 : _this3$_channels$find.curve;
          };

          var value = runtimeBinding.getValue();

          switch (true) {
            default:
              throw new Error(getError(3931));

            case value instanceof Vec2:
              return new Vec2TrackEval(trySearchCurve('x'), trySearchCurve('y'));

            case value instanceof Vec3:
              return new Vec3TrackEval(trySearchCurve('x'), trySearchCurve('y'), trySearchCurve('z'));

            case value instanceof Vec4:
              return new Vec4TrackEval(trySearchCurve('x'), trySearchCurve('y'), trySearchCurve('z'), trySearchCurve('w'));

            case value instanceof Color:
              return new ColorTrackEval(trySearchCurve('r'), trySearchCurve('g'), trySearchCurve('b'), trySearchCurve('a'));

            case value instanceof Size:
              return new SizeTrackEval(trySearchCurve('width'), trySearchCurve('height'));
          }
        };

        _proto.addChannel = function addChannel(property) {
          var channel = new UntypedTrackChannel();
          channel.property = property;

          this._channels.push(channel);

          return channel;
        };

        _proto.upgrade = function upgrade(refine) {
          var _this4 = this;

          var trySearchChannel = function trySearchChannel(property, outChannel) {
            var untypedChannel = _this4.channels().find(function (channel) {
              return channel.property === property;
            });

            if (untypedChannel) {
              outChannel.name = untypedChannel.name;
              outChannel.curve.assignSorted(Array.from(untypedChannel.curve.times()), Array.from(untypedChannel.curve.values()));
            }
          };

          var kind = refine(this.path, this.proxy);

          switch (kind) {
            default:
              break;

            case 'vec2':
            case 'vec3':
            case 'vec4':
              {
                var track = new VectorTrack();
                track.path = this.path;
                track.proxy = this.proxy;
                track.componentsCount = kind === 'vec2' ? 2 : kind === 'vec3' ? 3 : 4;

                var _track$channels = track.channels(),
                    x = _track$channels[0],
                    y = _track$channels[1],
                    z = _track$channels[2],
                    w = _track$channels[3];

                switch (kind) {
                  case 'vec4':
                    trySearchChannel('w', w);

                  case 'vec3':
                    trySearchChannel('z', z);

                  default:
                  case 'vec2':
                    trySearchChannel('x', x);
                    trySearchChannel('y', y);
                }

                return track;
              }

            case 'color':
              {
                var _track = new ColorTrack();

                var _track$channels2 = _track.channels(),
                    r = _track$channels2[0],
                    g = _track$channels2[1],
                    b = _track$channels2[2],
                    a = _track$channels2[3];

                trySearchChannel('r', r);
                trySearchChannel('g', g);
                trySearchChannel('b', b);
                trySearchChannel('a', a);
                trySearchChannel('x', r);
                trySearchChannel('y', g);
                trySearchChannel('z', b);
                trySearchChannel('w', a);
                return _track;
              }

            case 'size':
              break;
          }

          return null;
        };

        return UntypedTrack;
      }(Track), _temp2$7), (_descriptor2$s = _applyDecoratedDescriptor(_class5$7.prototype, "_channels", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class5$7)) || _class4$7);

      var AnimationClipLegacyData = function () {
        function AnimationClipLegacyData(duration) {
          this._keys = [];
          this._curves = [];
          this._commonTargets = [];
          this._ratioSamplers = [];
          this._runtimeCurves = void 0;
          this._data = null;
          this._duration = void 0;
          this._duration = duration;
        }

        var _proto = AnimationClipLegacyData.prototype;

        _proto.getPropertyCurves = function getPropertyCurves() {
          if (!this._runtimeCurves) {
            this._createPropertyCurves();
          }

          return this._runtimeCurves;
        };

        _proto.toTracks = function toTracks() {
          var newTracks = [];
          var legacyKeys = this.keys,
              legacyCurves = this.curves,
              legacyCommonTargets = this.commonTargets;

          var convertTrackPath = function convertTrackPath(track, modifiers, valueAdapter) {
            var trackPath = new TrackPath();

            for (var _iterator = _createForOfIteratorHelperLoose(modifiers), _step; !(_step = _iterator()).done;) {
              var modifier = _step.value;

              if (typeof modifier === 'string') {
                trackPath.toProperty(modifier);
              } else if (typeof modifier === 'number') {
                trackPath.toElement(modifier);
              } else if (modifier instanceof HierarchyPath) {
                trackPath.toHierarchy(modifier.path);
              } else if (modifier instanceof ComponentPath) {
                trackPath.toComponent(modifier.component);
              } else {
                trackPath.toCustomized(modifier);
              }
            }

            track.path = trackPath;
            track.proxy = valueAdapter;
          };

          var untypedTracks = legacyCommonTargets.map(function (legacyCommonTarget) {
            var track = new UntypedTrack();
            convertTrackPath(track, legacyCommonTarget.modifiers, legacyCommonTarget.valueAdapter);
            newTracks.push(track);
            return track;
          });

          var _loop = function _loop() {
            var _legacyCurveData$inte;

            var legacyCurve = _step2.value;
            var legacyCurveData = legacyCurve.data;
            var legacyValues = legacyCurveData.values;

            if (legacyValues.length === 0) {
              return "continue";
            }

            var legacyKeysIndex = legacyCurveData.keys;
            var times = legacyKeysIndex < 0 ? [0.0] : legacyKeys[legacyCurveData.keys];
            var firstValue = legacyValues[0];
            var interpolate = (_legacyCurveData$inte = legacyCurveData.interpolate) !== null && _legacyCurveData$inte !== void 0 ? _legacyCurveData$inte : true;
            assertIsTrue(typeof legacyCurveData._arrayLength !== 'number' || typeof firstValue === 'number');
            var legacyEasingMethodConverter = new LegacyEasingMethodConverter(legacyCurveData, times.length);

            var installPathAndSetter = function installPathAndSetter(track) {
              convertTrackPath(track, legacyCurve.modifiers, legacyCurve.valueAdapter);
            };

            var legacyCommonTargetCurve = void 0;

            if (typeof legacyCurve.commonTarget === 'number') {
              if (!legacyValues.every(function (value) {
                return typeof value === 'number';
              })) {
                warnID(3932);
                return "continue";
              }

              if (legacyCurve.valueAdapter || legacyCurve.modifiers.length !== 1 || typeof legacyCurve.modifiers[0] !== 'string') {
                warnID(3933);
                return "continue";
              }

              var _propertyName = legacyCurve.modifiers[0];
              var untypedTrack = untypedTracks[legacyCurve.commonTarget];

              var _untypedTrack$addChan = untypedTrack.addChannel(_propertyName),
                  curve = _untypedTrack$addChan.curve;

              legacyCommonTargetCurve = curve;
            }

            var convertCurve = function convertCurve() {
              if (typeof firstValue === 'number') {
                if (!legacyValues.every(function (value) {
                  return typeof value === 'number';
                })) {
                  warnID(3934);
                  return;
                }

                var realCurve;

                if (legacyCommonTargetCurve) {
                  realCurve = legacyCommonTargetCurve;
                } else {
                  var track = new RealTrack();
                  installPathAndSetter(track);
                  newTracks.push(track);
                  realCurve = track.channel.curve;
                }

                var interpolationMethod = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;
                realCurve.assignSorted(times, legacyValues.map(function (value) {
                  return {
                    value: value,
                    interpolationMode: interpolationMethod
                  };
                }));
                legacyEasingMethodConverter.convert(realCurve);
                return;
              } else if (typeof firstValue === 'object') {
                switch (true) {
                  default:
                    break;

                  case everyInstanceOf(legacyValues, Vec2):
                  case everyInstanceOf(legacyValues, Vec3):
                  case everyInstanceOf(legacyValues, Vec4):
                    {
                      var components = firstValue instanceof Vec2 ? 2 : firstValue instanceof Vec3 ? 3 : 4;

                      var _track = new VectorTrack();

                      installPathAndSetter(_track);
                      _track.componentsCount = components;

                      var _track$channels = _track.channels(),
                          x = _track$channels[0].curve,
                          y = _track$channels[1].curve,
                          z = _track$channels[2].curve,
                          w = _track$channels[3].curve;

                      var interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                      var valueToFrame = function valueToFrame(value) {
                        return {
                          value: value,
                          interpolationMode: interpolationMode
                        };
                      };

                      switch (components) {
                        case 4:
                          w.assignSorted(times, legacyValues.map(function (value) {
                            return valueToFrame(value.w);
                          }));
                          legacyEasingMethodConverter.convert(w);

                        case 3:
                          z.assignSorted(times, legacyValues.map(function (value) {
                            return valueToFrame(value.z);
                          }));
                          legacyEasingMethodConverter.convert(z);

                        default:
                          x.assignSorted(times, legacyValues.map(function (value) {
                            return valueToFrame(value.x);
                          }));
                          legacyEasingMethodConverter.convert(x);
                          y.assignSorted(times, legacyValues.map(function (value) {
                            return valueToFrame(value.y);
                          }));
                          legacyEasingMethodConverter.convert(y);
                          break;
                      }

                      newTracks.push(_track);
                      return;
                    }

                  case everyInstanceOf(legacyValues, Quat):
                    {
                      var _track2 = new QuatTrack();

                      installPathAndSetter(_track2);

                      var _interpolationMode = interpolate ? QuatInterpolationMode.SLERP : QuatInterpolationMode.CONSTANT;

                      _track2.channel.curve.assignSorted(times, legacyValues.map(function (value) {
                        return {
                          value: Quat.clone(value),
                          interpolationMode: _interpolationMode
                        };
                      }));

                      legacyEasingMethodConverter.convertQuatCurve(_track2.channel.curve);
                      newTracks.push(_track2);
                      return;
                    }

                  case everyInstanceOf(legacyValues, Color):
                    {
                      var _track3 = new ColorTrack();

                      installPathAndSetter(_track3);

                      var _track3$channels = _track3.channels(),
                          r = _track3$channels[0].curve,
                          g = _track3$channels[1].curve,
                          b = _track3$channels[2].curve,
                          a = _track3$channels[3].curve;

                      var _interpolationMode2 = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                      var _valueToFrame = function _valueToFrame(value) {
                        return {
                          value: value,
                          interpolationMode: _interpolationMode2
                        };
                      };

                      r.assignSorted(times, legacyValues.map(function (value) {
                        return _valueToFrame(value.r);
                      }));
                      legacyEasingMethodConverter.convert(r);
                      g.assignSorted(times, legacyValues.map(function (value) {
                        return _valueToFrame(value.g);
                      }));
                      legacyEasingMethodConverter.convert(g);
                      b.assignSorted(times, legacyValues.map(function (value) {
                        return _valueToFrame(value.b);
                      }));
                      legacyEasingMethodConverter.convert(b);
                      a.assignSorted(times, legacyValues.map(function (value) {
                        return _valueToFrame(value.a);
                      }));
                      legacyEasingMethodConverter.convert(a);
                      newTracks.push(_track3);
                      return;
                    }

                  case everyInstanceOf(legacyValues, Size):
                    {
                      var _track4 = new SizeTrack();

                      installPathAndSetter(_track4);

                      var _track4$channels = _track4.channels(),
                          width = _track4$channels[0].curve,
                          height = _track4$channels[1].curve;

                      var _interpolationMode3 = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                      var _valueToFrame2 = function _valueToFrame2(value) {
                        return {
                          value: value,
                          interpolationMode: _interpolationMode3
                        };
                      };

                      width.assignSorted(times, legacyValues.map(function (value) {
                        return _valueToFrame2(value.width);
                      }));
                      legacyEasingMethodConverter.convert(width);
                      height.assignSorted(times, legacyValues.map(function (value) {
                        return _valueToFrame2(value.height);
                      }));
                      legacyEasingMethodConverter.convert(height);
                      newTracks.push(_track4);
                      return;
                    }

                  case everyInstanceOf(legacyValues, CubicSplineNumberValue):
                    {
                      assertIsTrue(legacyEasingMethodConverter.nil);

                      var _track5 = new RealTrack();

                      installPathAndSetter(_track5);

                      var _interpolationMode4 = interpolate ? RealInterpolationMode.CUBIC : RealInterpolationMode.CONSTANT;

                      _track5.channel.curve.assignSorted(times, legacyValues.map(function (value) {
                        return {
                          value: value.dataPoint,
                          leftTangent: value.inTangent,
                          rightTangent: value.outTangent,
                          interpolationMode: _interpolationMode4
                        };
                      }));

                      newTracks.push(_track5);
                      return;
                    }

                  case everyInstanceOf(legacyValues, CubicSplineVec2Value):
                  case everyInstanceOf(legacyValues, CubicSplineVec3Value):
                  case everyInstanceOf(legacyValues, CubicSplineVec4Value):
                    {
                      assertIsTrue(legacyEasingMethodConverter.nil);

                      var _components = firstValue instanceof CubicSplineVec2Value ? 2 : firstValue instanceof CubicSplineVec3Value ? 3 : 4;

                      var _track6 = new VectorTrack();

                      installPathAndSetter(_track6);
                      _track6.componentsCount = _components;

                      var _track6$channels = _track6.channels(),
                          _x = _track6$channels[0],
                          _y = _track6$channels[1],
                          _z = _track6$channels[2],
                          _w = _track6$channels[3];

                      var _interpolationMode5 = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                      var _valueToFrame3 = function _valueToFrame3(value, inTangent, outTangent) {
                        return {
                          value: value,
                          leftTangent: inTangent,
                          rightTangent: outTangent,
                          interpolationMode: _interpolationMode5
                        };
                      };

                      switch (_components) {
                        case 4:
                          _w.curve.assignSorted(times, legacyValues.map(function (value) {
                            return _valueToFrame3(value.dataPoint.w, value.inTangent.w, value.outTangent.w);
                          }));

                        case 3:
                          _z.curve.assignSorted(times, legacyValues.map(function (value) {
                            return _valueToFrame3(value.dataPoint.z, value.inTangent.z, value.outTangent.z);
                          }));

                        default:
                          _x.curve.assignSorted(times, legacyValues.map(function (value) {
                            return _valueToFrame3(value.dataPoint.y, value.inTangent.y, value.outTangent.y);
                          }));

                          _y.curve.assignSorted(times, legacyValues.map(function (value) {
                            return _valueToFrame3(value.dataPoint.x, value.inTangent.x, value.outTangent.x);
                          }));

                          break;
                      }

                      newTracks.push(_track6);
                      return;
                    }

                  case legacyValues.every(function (value) {
                    return value instanceof CubicSplineQuatValue;
                  }):
                    {
                      warnID(3935);
                      break;
                    }
                }
              }

              var objectTrack = new ObjectTrack();
              installPathAndSetter(objectTrack);
              objectTrack.channel.curve.assignSorted(times, legacyValues);
              newTracks.push(objectTrack);
            };

            convertCurve();
          };

          for (var _iterator2 = _createForOfIteratorHelperLoose(legacyCurves), _step2; !(_step2 = _iterator2()).done;) {
            var _ret = _loop();

            if (_ret === "continue") continue;
          }

          return newTracks;
        };

        _proto._createPropertyCurves = function _createPropertyCurves() {
          var _this = this;

          this._ratioSamplers = this._keys.map(function (keys) {
            return new RatioSampler(keys.map(function (key) {
              return key / _this._duration;
            }));
          });
          this._runtimeCurves = this._curves.map(function (targetCurve) {
            return {
              curve: new AnimCurve(targetCurve.data, _this._duration),
              modifiers: targetCurve.modifiers,
              valueAdapter: targetCurve.valueAdapter,
              sampler: _this._ratioSamplers[targetCurve.data.keys],
              commonTarget: targetCurve.commonTarget
            };
          });
        };

        _createClass(AnimationClipLegacyData, [{
          key: "keys",
          get: function get() {
            return this._keys;
          },
          set: function set(value) {
            this._keys = value;
          }
        }, {
          key: "curves",
          get: function get() {
            return this._curves;
          },
          set: function set(value) {
            this._curves = value;
            delete this._runtimeCurves;
          }
        }, {
          key: "commonTargets",
          get: function get() {
            return this._commonTargets;
          },
          set: function set(value) {
            this._commonTargets = value;
          }
        }, {
          key: "data",
          get: function get() {
            return this._data;
          }
        }]);

        return AnimationClipLegacyData;
      }();

      function everyInstanceOf(array, constructor) {
        return array.every(function (element) {
          return element instanceof constructor;
        });
      }

      var LegacyEasingMethodConverter = function () {
        function LegacyEasingMethodConverter(legacyCurveData, keyframesCount) {
          this._easingMethods = void 0;
          var easingMethods = legacyCurveData.easingMethods;

          if (Array.isArray(easingMethods)) {
            if (easingMethods.length === 0 && keyframesCount !== 0) {
              this._easingMethods = new Array(keyframesCount).fill(null);
            } else {
              this._easingMethods = easingMethods;
            }
          } else if (easingMethods === undefined) {
            this._easingMethods = new Array(keyframesCount).fill(legacyCurveData.easingMethod);
          } else {
            this._easingMethods = Array.from({
              length: keyframesCount
            }, function (_, index) {
              var _easingMethods$index;

              return (_easingMethods$index = easingMethods[index]) !== null && _easingMethods$index !== void 0 ? _easingMethods$index : null;
            });
          }
        }

        var _proto2 = LegacyEasingMethodConverter.prototype;

        _proto2.convert = function convert(curve) {
          var easingMethods = this._easingMethods;

          if (!easingMethods) {
            return;
          }

          var nKeyframes = curve.keyFramesCount;

          if (curve.keyFramesCount < 2) {
            return;
          }

          if (Array.isArray(easingMethods)) {
            assertIsTrue(nKeyframes === easingMethods.length);
          }

          var iLastKeyframe = nKeyframes - 1;

          for (var iKeyframe = 0; iKeyframe < iLastKeyframe; ++iKeyframe) {
            var easingMethod = easingMethods[iKeyframe];

            if (!easingMethod) {
              continue;
            }

            if (Array.isArray(easingMethod)) {
              timeBezierToTangents(easingMethod, curve.getKeyframeTime(iKeyframe), curve.getKeyframeValue(iKeyframe), curve.getKeyframeTime(iKeyframe + 1), curve.getKeyframeValue(iKeyframe + 1));
            } else {
              applyLegacyEasingMethodName(easingMethod, curve, iKeyframe);
            }
          }
        };

        _proto2.convertQuatCurve = function convertQuatCurve(curve) {
          var easingMethods = this._easingMethods;

          if (!easingMethods) {
            return;
          }

          var nKeyframes = curve.keyFramesCount;

          if (curve.keyFramesCount < 2) {
            return;
          }

          if (Array.isArray(easingMethods)) {
            assertIsTrue(nKeyframes === easingMethods.length);
          }

          var iLastKeyframe = nKeyframes - 1;

          for (var iKeyframe = 0; iKeyframe < iLastKeyframe; ++iKeyframe) {
            var easingMethod = easingMethods[iKeyframe];

            if (!easingMethod) {
              continue;
            }

            if (Array.isArray(easingMethod)) {
              curve.getKeyframeValue(iKeyframe).easingMethod = easingMethod.slice();
            } else {
              applyLegacyEasingMethodNameIntoQuatCurve(easingMethod, curve, iKeyframe);
            }
          }
        };

        _createClass(LegacyEasingMethodConverter, [{
          key: "nil",
          get: function get() {
            return !this._easingMethods || this._easingMethods.every(function (easingMethod) {
              return easingMethod === null || easingMethod === undefined;
            });
          }
        }]);

        return LegacyEasingMethodConverter;
      }();

      function applyLegacyEasingMethodName(easingMethodName, curve, keyframeIndex) {
        assertIsTrue(keyframeIndex !== curve.keyFramesCount - 1);
        assertIsTrue(easingMethodName in easingMethodNameMap);
        var keyframeValue = curve.getKeyframeValue(keyframeIndex);
        var easingMethod = easingMethodNameMap[easingMethodName];

        if (easingMethod === EasingMethod.CONSTANT) {
          keyframeValue.interpolationMode = RealInterpolationMode.CONSTANT;
        } else {
          keyframeValue.interpolationMode = RealInterpolationMode.LINEAR;
          keyframeValue.easingMethod = easingMethod;
        }
      }

      function applyLegacyEasingMethodNameIntoQuatCurve(easingMethodName, curve, keyframeIndex) {
        assertIsTrue(keyframeIndex !== curve.keyFramesCount - 1);
        assertIsTrue(easingMethodName in easingMethodNameMap);
        var keyframeValue = curve.getKeyframeValue(keyframeIndex);
        var easingMethod = easingMethodNameMap[easingMethodName];
        keyframeValue.easingMethod = easingMethod;
      }

      var easingMethodNameMap = {
        constant: EasingMethod.CONSTANT,
        linear: EasingMethod.LINEAR,
        quadIn: EasingMethod.QUAD_IN,
        quadOut: EasingMethod.QUAD_OUT,
        quadInOut: EasingMethod.QUAD_IN_OUT,
        quadOutIn: EasingMethod.QUAD_OUT_IN,
        cubicIn: EasingMethod.CUBIC_IN,
        cubicOut: EasingMethod.CUBIC_OUT,
        cubicInOut: EasingMethod.CUBIC_IN_OUT,
        cubicOutIn: EasingMethod.CUBIC_OUT_IN,
        quartIn: EasingMethod.QUART_IN,
        quartOut: EasingMethod.QUART_OUT,
        quartInOut: EasingMethod.QUART_IN_OUT,
        quartOutIn: EasingMethod.QUART_OUT_IN,
        quintIn: EasingMethod.QUINT_IN,
        quintOut: EasingMethod.QUINT_OUT,
        quintInOut: EasingMethod.QUINT_IN_OUT,
        quintOutIn: EasingMethod.QUINT_OUT_IN,
        sineIn: EasingMethod.SINE_IN,
        sineOut: EasingMethod.SINE_OUT,
        sineInOut: EasingMethod.SINE_IN_OUT,
        sineOutIn: EasingMethod.SINE_OUT_IN,
        expoIn: EasingMethod.EXPO_IN,
        expoOut: EasingMethod.EXPO_OUT,
        expoInOut: EasingMethod.EXPO_IN_OUT,
        expoOutIn: EasingMethod.EXPO_OUT_IN,
        circIn: EasingMethod.CIRC_IN,
        circOut: EasingMethod.CIRC_OUT,
        circInOut: EasingMethod.CIRC_IN_OUT,
        circOutIn: EasingMethod.CIRC_OUT_IN,
        elasticIn: EasingMethod.ELASTIC_IN,
        elasticOut: EasingMethod.ELASTIC_OUT,
        elasticInOut: EasingMethod.ELASTIC_IN_OUT,
        elasticOutIn: EasingMethod.ELASTIC_OUT_IN,
        backIn: EasingMethod.BACK_IN,
        backOut: EasingMethod.BACK_OUT,
        backInOut: EasingMethod.BACK_IN_OUT,
        backOutIn: EasingMethod.BACK_OUT_IN,
        bounceIn: EasingMethod.BOUNCE_IN,
        bounceOut: EasingMethod.BOUNCE_OUT,
        bounceInOut: EasingMethod.BOUNCE_IN_OUT,
        bounceOutIn: EasingMethod.BOUNCE_OUT_IN,
        smooth: EasingMethod.SMOOTH,
        fade: EasingMethod.FADE
      };
      function timeBezierToTangents(timeBezierPoints, previousTime, previousKeyframe, nextTime, nextKeyframe) {
        var p1X = timeBezierPoints[0],
            p1Y = timeBezierPoints[1],
            p2X = timeBezierPoints[2],
            p2Y = timeBezierPoints[3];
        var previousValue = previousKeyframe.value;
        var nextValue = nextKeyframe.value;
        var dValue = nextValue - previousValue;
        var dTime = nextTime - previousTime;
        var fx = 3 * dTime;
        var fy = 3 * dValue;
        var t1x = p1X * fx;
        var t1y = p1Y * fy;
        var t2x = (1.0 - p2X) * fx;
        var t2y = (1.0 - p2Y) * fy;
        var ONE_THIRD = 1.0 / 3.0;
        var previousTangent = t1y / t1x;
        var previousTangentWeight = Math.sqrt(t1x * t1x + t1y * t1y) * ONE_THIRD;
        var nextTangent = t2y / t2x;
        var nextTangentWeight = Math.sqrt(t2x * t2x + t2y * t2y) * ONE_THIRD;
        previousKeyframe.interpolationMode = RealInterpolationMode.CUBIC;
        previousKeyframe.tangentWeightMode = ensureRightTangentWeightMode(previousKeyframe.tangentWeightMode);
        previousKeyframe.rightTangent = previousTangent;
        previousKeyframe.rightTangentWeight = previousTangentWeight;
        nextKeyframe.tangentWeightMode = ensureLeftTangentWeightMode(nextKeyframe.tangentWeightMode);
        nextKeyframe.leftTangent = nextTangent;
        nextKeyframe.leftTangentWeight = nextTangentWeight;
      }

      function ensureLeftTangentWeightMode(tangentWeightMode) {
        if (tangentWeightMode === TangentWeightMode.NONE) {
          return TangentWeightMode.LEFT;
        } else if (tangentWeightMode === TangentWeightMode.RIGHT) {
          return TangentWeightMode.BOTH;
        } else {
          return tangentWeightMode;
        }
      }

      function ensureRightTangentWeightMode(tangentWeightMode) {
        if (tangentWeightMode === TangentWeightMode.NONE) {
          return TangentWeightMode.RIGHT;
        } else if (tangentWeightMode === TangentWeightMode.LEFT) {
          return TangentWeightMode.BOTH;
        } else {
          return tangentWeightMode;
        }
      }

      var _dec$K, _class$K, _class2$C, _descriptor$A, _temp$E, _dec2$u, _class4$8, _class5$8, _descriptor2$t, _descriptor3$l, _descriptor4$h, _descriptor5$e, _temp2$8, _dec3$q, _class7$2, _class8$1, _descriptor6$c, _descriptor7$8, _temp3$1, _dec4$n, _class10$1, _dec5$l, _class11$1, _dec6$i, _class12, _class13$1, _descriptor8$8, _descriptor9$7, _temp4$1, _dec7$h, _class15, _class16, _descriptor10$6, _descriptor11$4, _descriptor12$4, _descriptor13$4, _temp5$1;

      function throwIfSplitMethodIsNotValid() {
        throw new Error("split() only valid in Editor.");
      }

      var ExoticAnimation = (_dec$K = ccclass(CLASS_NAME_PREFIX_ANIM + "ExoticAnimation"), _dec$K(_class$K = (_class2$C = (_temp$E = function () {
        function ExoticAnimation() {
          _initializerDefineProperty(this, "_nodeAnimations", _descriptor$A, this);
        }

        var _proto = ExoticAnimation.prototype;

        _proto.createEvaluator = function createEvaluator(binder) {
          return new ExoticTrsAnimationEvaluator(this._nodeAnimations, binder);
        };

        _proto.addNodeAnimation = function addNodeAnimation(path) {
          var nodeAnimation = new ExoticNodeAnimation(path);

          this._nodeAnimations.push(nodeAnimation);

          return nodeAnimation;
        };

        _proto.collectAnimatedJoints = function collectAnimatedJoints() {
          return Array.from(new Set(this._nodeAnimations.map(function (_ref) {
            var path = _ref.path;
            return path;
          })));
        };

        _proto.split = function split(from, to) {
          {
            return throwIfSplitMethodIsNotValid();
          }
        };

        _proto.toHashString = function toHashString() {
          return this._nodeAnimations.map(function (nodeAnimation) {
            return nodeAnimation.toHashString();
          }).join('\n');
        };

        return ExoticAnimation;
      }(), _temp$E), (_descriptor$A = _applyDecoratedDescriptor(_class2$C.prototype, "_nodeAnimations", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$C)) || _class$K);
      var ExoticNodeAnimation = (_dec2$u = ccclass(CLASS_NAME_PREFIX_ANIM + "ExoticNodeAnimation"), _dec2$u(_class4$8 = (_class5$8 = (_temp2$8 = function () {
        function ExoticNodeAnimation(path) {
          _initializerDefineProperty(this, "_path", _descriptor2$t, this);

          _initializerDefineProperty(this, "_position", _descriptor3$l, this);

          _initializerDefineProperty(this, "_rotation", _descriptor4$h, this);

          _initializerDefineProperty(this, "_scale", _descriptor5$e, this);

          this._path = path;
        }

        var _proto2 = ExoticNodeAnimation.prototype;

        _proto2.createPosition = function createPosition(times, values) {
          this._position = new ExoticTrack(times, new ExoticVec3TrackValues(values));
        };

        _proto2.createRotation = function createRotation(times, values) {
          this._rotation = new ExoticTrack(times, new ExoticQuatTrackValues(values));
        };

        _proto2.createScale = function createScale(times, values) {
          this._scale = new ExoticTrack(times, new ExoticVec3TrackValues(values));
        };

        _proto2.createEvaluator = function createEvaluator(binder) {
          return new ExoticNodeAnimationEvaluator(this._path, this._position, this._rotation, this._scale, binder);
        };

        _proto2.split = function split(from, to, splitInfoCache) {
          {
            return throwIfSplitMethodIsNotValid();
          }
        };

        _proto2.toHashString = function toHashString() {
          var _this$_position$toHas, _this$_position, _this$_scale$toHashSt, _this$_scale, _this$_rotation$toHas, _this$_rotation;

          return this._path + "\n" + ((_this$_position$toHas = (_this$_position = this._position) === null || _this$_position === void 0 ? void 0 : _this$_position.toHashString()) !== null && _this$_position$toHas !== void 0 ? _this$_position$toHas : '') + ((_this$_scale$toHashSt = (_this$_scale = this._scale) === null || _this$_scale === void 0 ? void 0 : _this$_scale.toHashString()) !== null && _this$_scale$toHashSt !== void 0 ? _this$_scale$toHashSt : '') + ((_this$_rotation$toHas = (_this$_rotation = this._rotation) === null || _this$_rotation === void 0 ? void 0 : _this$_rotation.toHashString()) !== null && _this$_rotation$toHas !== void 0 ? _this$_rotation$toHas : '');
        };

        _createClass(ExoticNodeAnimation, [{
          key: "path",
          get: function get() {
            return this._path;
          }
        }]);

        return ExoticNodeAnimation;
      }(), _temp2$8), (_descriptor2$t = _applyDecoratedDescriptor(_class5$8.prototype, "_path", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor3$l = _applyDecoratedDescriptor(_class5$8.prototype, "_position", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4$h = _applyDecoratedDescriptor(_class5$8.prototype, "_rotation", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5$e = _applyDecoratedDescriptor(_class5$8.prototype, "_scale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class5$8)) || _class4$8);

      function floatToHashString(value) {
        return value.toPrecision(2);
      }

      function floatArrayToHashString(values) {
        return values.map(floatToHashString).join(' ');
      }

      var ExoticVectorLikeTrackValues = (_dec3$q = ccclass(CLASS_NAME_PREFIX_ANIM + "ExoticVectorLikeTrackValues"), _dec3$q(_class7$2 = (_class8$1 = (_temp3$1 = function () {
        function ExoticVectorLikeTrackValues(values) {
          _initializerDefineProperty(this, "_values", _descriptor6$c, this);

          _initializerDefineProperty(this, "_isQuantized", _descriptor7$8, this);

          this._values = values;
          this._isQuantized = false;
        }

        var _proto3 = ExoticVectorLikeTrackValues.prototype;

        _proto3.quantize = function quantize(type) {
          assertIsTrue(!this._isQuantized);
          this._values = _quantize(this._values, type);
          this._isQuantized = true;
        };

        _proto3.toHashString = function toHashString() {
          var isQuantized = this._isQuantized,
              values = this._values;
          return isQuantized + " " + (isQuantized ? values.toHashString() : floatArrayToHashString(values));
        };

        _createClass(ExoticVectorLikeTrackValues, [{
          key: "precision",
          get: function get() {
            return this._isQuantized ? this._values.originalPrecision : getFloatArrayPrecision(this._values);
          }
        }]);

        return ExoticVectorLikeTrackValues;
      }(), _temp3$1), (_descriptor6$c = _applyDecoratedDescriptor(_class8$1.prototype, "_values", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor7$8 = _applyDecoratedDescriptor(_class8$1.prototype, "_isQuantized", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class8$1)) || _class7$2);
      var ExoticVec3TrackValues = (_dec4$n = ccclass(CLASS_NAME_PREFIX_ANIM + "ExoticVec3TrackValues"), _dec4$n(_class10$1 = function (_ExoticVectorLikeTrac) {
        _inheritsLoose(ExoticVec3TrackValues, _ExoticVectorLikeTrac);

        function ExoticVec3TrackValues() {
          return _ExoticVectorLikeTrac.apply(this, arguments) || this;
        }

        ExoticVec3TrackValues.imitate = function imitate(values, model) {
          var trackValues = new ExoticVec3TrackValues(values);

          if (model._isQuantized) {
            trackValues.quantize(model._values.quantizationType);
          }

          return trackValues;
        };

        var _proto4 = ExoticVec3TrackValues.prototype;

        _proto4.get = function get(index, resultValue) {
          var values = this._values,
              isQuantized = this._isQuantized;

          if (isQuantized) {
            loadVec3FromQuantized(values, index, resultValue);
          } else {
            Vec3.fromArray(resultValue, values, index * 3);
          }
        };

        _proto4.lerp = function lerp(prevIndex, nextIndex, ratio, prevValue, nextValue, resultValue) {
          var values = this._values,
              isQuantized = this._isQuantized;

          if (isQuantized) {
            loadVec3FromQuantized(values, prevIndex, prevValue);
            loadVec3FromQuantized(values, nextIndex, nextValue);
          } else {
            Vec3.fromArray(prevValue, values, prevIndex * 3);
            Vec3.fromArray(nextValue, values, nextIndex * 3);
          }

          Vec3.lerp(resultValue, prevValue, nextValue, ratio);
        };

        return ExoticVec3TrackValues;
      }(ExoticVectorLikeTrackValues)) || _class10$1);
      var ExoticQuatTrackValues = (_dec5$l = ccclass(CLASS_NAME_PREFIX_ANIM + "ExoticQuatTrackValues"), _dec5$l(_class11$1 = function (_ExoticVectorLikeTrac2) {
        _inheritsLoose(ExoticQuatTrackValues, _ExoticVectorLikeTrac2);

        function ExoticQuatTrackValues() {
          return _ExoticVectorLikeTrac2.apply(this, arguments) || this;
        }

        ExoticQuatTrackValues.imitate = function imitate(values, model) {
          var trackValues = new ExoticQuatTrackValues(values);

          if (model._isQuantized) {
            trackValues.quantize(model._values.quantizationType);
          }

          return trackValues;
        };

        var _proto5 = ExoticQuatTrackValues.prototype;

        _proto5.get = function get(index, resultValue) {
          var values = this._values,
              isQuantized = this._isQuantized;

          if (isQuantized) {
            loadQuatFromQuantized(values, index, resultValue);
          } else {
            Quat.fromArray(resultValue, values, index * 4);
          }
        };

        _proto5.lerp = function lerp(prevIndex, nextIndex, ratio, prevValue, nextValue, resultValue) {
          var values = this._values,
              isQuantized = this._isQuantized;

          if (isQuantized) {
            loadQuatFromQuantized(values, prevIndex, prevValue);
            loadQuatFromQuantized(values, nextIndex, nextValue);
          } else {
            Quat.fromArray(prevValue, values, prevIndex * 4);
            Quat.fromArray(nextValue, values, nextIndex * 4);
          }

          Quat.slerp(resultValue, prevValue, nextValue, ratio);
        };

        return ExoticQuatTrackValues;
      }(ExoticVectorLikeTrackValues)) || _class11$1);
      var ExoticTrack = (_dec6$i = ccclass(CLASS_NAME_PREFIX_ANIM + "ExoticTrack"), _dec6$i(_class12 = (_class13$1 = (_temp4$1 = function () {
        function ExoticTrack(times, values) {
          _initializerDefineProperty(this, "times", _descriptor8$8, this);

          _initializerDefineProperty(this, "values", _descriptor9$7, this);

          this.times = times;
          this.values = values;
        }

        var _proto6 = ExoticTrack.prototype;

        _proto6.toHashString = function toHashString() {
          var times = this.times,
              values = this.values;
          return "times: " + floatArrayToHashString(times) + "; values: " + values.toHashString();
        };

        return ExoticTrack;
      }(), _temp4$1), (_descriptor8$8 = _applyDecoratedDescriptor(_class13$1.prototype, "times", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor9$7 = _applyDecoratedDescriptor(_class13$1.prototype, "values", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class13$1)) || _class12);

      var SplitInfo = function () {
        function SplitInfo() {
          this._reset();
        }

        var _proto7 = SplitInfo.prototype;

        _proto7.transformTime = function transformTime(input) {
          return input - this._timeOffset;
        };

        _proto7.calculate = function calculate(times, from, to) {
          this._reset();

          var nKeyframes = times.length;

          if (!nKeyframes) {
            return;
          }

          var firstTime = times[0];
          var lastTime = times[nKeyframes - 1];
          var fromClamped = clamp$1(from, firstTime, lastTime);
          var toClamped = clamp$1(to, firstTime, lastTime);
          this._timeOffset = fromClamped;

          var _searchRange = searchRange(times, fromClamped, toClamped),
              fromIndex = _searchRange.fromIndex,
              fromRatio = _searchRange.fromRatio,
              toIndex = _searchRange.toIndex,
              toRatio = _searchRange.toRatio;

          assertIsTrue(toIndex >= fromIndex);
          var fromJust = !fromRatio;
          var toJust = !toRatio;

          if (fromIndex === toIndex && fromRatio === toRatio) {
            if (!fromJust) {
              this.preLerpIndex = fromIndex;
              this.preLerpRatio = fromRatio;
            } else {
              this.directKeyframesBegin = fromIndex;
              this.directKeyframesEnd = fromIndex + 1;
            }

            return;
          }

          if (!fromJust) {
            this.preLerpIndex = fromIndex;
            this.preLerpRatio = fromRatio;
          }

          this.directKeyframesBegin = fromJust ? fromIndex : fromIndex + 1;
          this.directKeyframesEnd = toIndex + 1;

          if (!toJust) {
            this.postLerpIndex = toIndex;
            this.postLerpRatio = toRatio;
          }
        };

        _proto7._reset = function _reset() {
          this.preLerpIndex = -1;
          this.preLerpRatio = 0.0;
          this.directKeyframesBegin = 0;
          this.directKeyframesEnd = 0;
          this.postLerpIndex = -1;
          this.postLerpRatio = 0.0;
          this._timeOffset = 0.0;
        };

        _createClass(SplitInfo, [{
          key: "keyframesCount",
          get: function get() {
            var preLerpIndex = this.preLerpIndex,
                directKeyframesBegin = this.directKeyframesBegin,
                directKeyframesEnd = this.directKeyframesEnd,
                postLerpIndex = this.postLerpIndex;
            return 0 + (preLerpIndex < 0 ? 0 : 1) + (directKeyframesEnd - directKeyframesBegin) + (postLerpIndex < 0 ? 0 : 1);
          }
        }]);

        return SplitInfo;
      }();

      function searchRange(values, from, to) {
        var nValues = values.length;
        assertIsTrue(nValues !== 0);
        assertIsTrue(to >= from && from >= values[0] && to <= values[nValues - 1]);

        var _binarySearchRatio = binarySearchRatio(values, from),
            fromIndex = _binarySearchRatio.index,
            fromRatio = _binarySearchRatio.ratio;

        var _binarySearchRatio2 = binarySearchRatio(values, to),
            toIndex = _binarySearchRatio2.index,
            toRatio = _binarySearchRatio2.ratio;

        return {
          fromIndex: fromIndex,
          fromRatio: fromRatio,
          toIndex: toIndex,
          toRatio: toRatio
        };
      }

      function binarySearchRatio(values, value) {
        var nValues = values.length;
        assertIsTrue(values.length !== 0);
        var resultIndex = 0;
        var resultRatio = 0.0;
        var index0 = binarySearchEpsilon(values, value);

        if (index0 >= 0) {
          resultIndex = index0;
        } else {
          var iNext = ~index0;
          assertIsTrue(iNext !== 0 && iNext !== nValues && nValues > 1);
          var iPrev = iNext - 1;
          resultIndex = iPrev;
          var next = values[iNext];
          var prev = values[iPrev];
          resultRatio = (value - prev) / (next - prev);
        }

        return {
          index: resultIndex,
          ratio: resultRatio
        };
      }

      var ExoticTrsAnimationEvaluator = function () {
        function ExoticTrsAnimationEvaluator(nodeAnimations, binder) {
          this._nodeEvaluations = void 0;
          this._nodeEvaluations = nodeAnimations.map(function (nodeAnimation) {
            return nodeAnimation.createEvaluator(binder);
          });
        }

        var _proto8 = ExoticTrsAnimationEvaluator.prototype;

        _proto8.evaluate = function evaluate(time) {
          this._nodeEvaluations.forEach(function (nodeEvaluator) {
            nodeEvaluator.evaluate(time);
          });
        };

        return ExoticTrsAnimationEvaluator;
      }();

      var ExoticNodeAnimationEvaluator = function () {
        function ExoticNodeAnimationEvaluator(path, position, rotation, scale, binder) {
          this._position = null;
          this._rotation = null;
          this._scale = null;

          if (position) {
            this._position = createExoticTrackEvaluationRecord(position.times, position.values, Vec3, path, 'position', binder);
          }

          if (rotation) {
            this._rotation = createExoticTrackEvaluationRecord(rotation.times, rotation.values, Quat, path, 'rotation', binder);
          }

          if (scale) {
            this._scale = createExoticTrackEvaluationRecord(scale.times, scale.values, Vec3, path, 'scale', binder);
          }
        }

        var _proto9 = ExoticNodeAnimationEvaluator.prototype;

        _proto9.evaluate = function evaluate(time) {
          if (this._position) {
            var _value = this._position.evaluator.evaluate(time);

            this._position.runtimeBinding.setValue(_value);
          }

          if (this._rotation) {
            var _value2 = this._rotation.evaluator.evaluate(time);

            this._rotation.runtimeBinding.setValue(_value2);
          }

          if (this._scale) {
            var _value3 = this._scale.evaluator.evaluate(time);

            this._scale.runtimeBinding.setValue(_value3);
          }
        };

        return ExoticNodeAnimationEvaluator;
      }();

      var ExoticTrackEvaluator = function () {
        function ExoticTrackEvaluator(times, values, ValueConstructor) {
          this._times = void 0;
          this._inputSampleResultCache = {
            just: false,
            index: -1,
            nextIndex: -1,
            ratio: 0.0
          };
          this._values = void 0;
          this._prevValue = void 0;
          this._nextValue = void 0;
          this._resultValue = void 0;
          this._times = times;
          this._values = values;
          this._prevValue = new ValueConstructor();
          this._nextValue = new ValueConstructor();
          this._resultValue = new ValueConstructor();
        }

        var _proto10 = ExoticTrackEvaluator.prototype;

        _proto10.evaluate = function evaluate(time) {
          var times = this._times,
              values = this._values,
              resultValue = this._resultValue;
          var nFrames = times.length;

          if (nFrames === 0) {
            return resultValue;
          }

          var inputSampleResult = sampleInput(times, time, this._inputSampleResultCache);

          if (inputSampleResult.just) {
            values.get(inputSampleResult.index, resultValue);
          } else {
            values.lerp(inputSampleResult.index, inputSampleResult.nextIndex, inputSampleResult.ratio, this._prevValue, this._nextValue, resultValue);
          }

          return resultValue;
        };

        return ExoticTrackEvaluator;
      }();

      function sampleInput(values, time, result) {
        var nFrames = values.length;
        assertIsTrue(nFrames !== 0);
        var firstTime = values[0];
        var lastTime = values[nFrames - 1];

        if (time < firstTime) {
          result.just = true;
          result.index = 0;
        } else if (time > lastTime) {
          result.just = true;
          result.index = nFrames - 1;
        } else {
          var _index2 = binarySearchEpsilon(values, time);

          if (_index2 >= 0) {
            result.just = true;
            result.index = _index2;
          } else {
            var _nextIndex = ~_index2;

            assertIsTrue(_nextIndex !== 0 && _nextIndex !== nFrames && nFrames > 1);

            var _prevIndex = _nextIndex - 1;

            var prevTime = values[_prevIndex];
            var nextTime = values[_nextIndex];

            var _ratio = (time - values[_prevIndex]) / (nextTime - prevTime);

            result.just = false;
            result.index = _prevIndex;
            result.nextIndex = _nextIndex;
            result.ratio = _ratio;
          }
        }

        return result;
      }

      var QUANTIZATION_TYPE_TO_ARRAY_VIEW_CONSTRUCTOR_MAP = {
        uint8: Uint8Array,
        uint16: Uint16Array
      };
      var FloatPrecision;

      (function (FloatPrecision) {
        FloatPrecision[FloatPrecision["FLOAT_32"] = 0] = "FLOAT_32";
        FloatPrecision[FloatPrecision["FLOAT_64"] = 1] = "FLOAT_64";
      })(FloatPrecision || (FloatPrecision = {}));

      function getFloatArrayPrecision(array) {
        switch (array.BYTES_PER_ELEMENT) {
          default:
            assertIsTrue(false);

          case 4:
            return FloatPrecision.FLOAT_32;

          case 8:
            return FloatPrecision.FLOAT_64;
        }
      }

      var QuantizedFloatArray = (_dec7$h = ccclass(CLASS_NAME_PREFIX_ANIM + "QuantizedFloatArray"), _dec7$h(_class15 = (_class16 = (_temp5$1 = function () {
        function QuantizedFloatArray(originalPrecision, values, extent, min) {
          if (min === void 0) {
            min = 0.0;
          }

          _initializerDefineProperty(this, "originalPrecision", _descriptor10$6, this);

          _initializerDefineProperty(this, "min", _descriptor11$4, this);

          _initializerDefineProperty(this, "extent", _descriptor12$4, this);

          _initializerDefineProperty(this, "values", _descriptor13$4, this);

          this.originalPrecision = originalPrecision;
          this.values = values;
          this.extent = extent;
          this.min = min;
        }

        var _proto11 = QuantizedFloatArray.prototype;

        _proto11.toHashString = function toHashString() {
          var originalPrecision = this.originalPrecision,
              min = this.min,
              extent = this.extent,
              values = this.values;
          return originalPrecision + " " + floatToHashString(min) + " " + floatToHashString(extent) + " " + values.join(' ');
        };

        _createClass(QuantizedFloatArray, [{
          key: "quantizationType",
          get: function get() {
            switch (this.values.BYTES_PER_ELEMENT) {
              default:
              case 1:
                return 'uint8';

              case 2:
                return 'uint16';
            }
          }
        }]);

        return QuantizedFloatArray;
      }(), _temp5$1), (_descriptor10$6 = _applyDecoratedDescriptor(_class16.prototype, "originalPrecision", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor11$4 = _applyDecoratedDescriptor(_class16.prototype, "min", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor12$4 = _applyDecoratedDescriptor(_class16.prototype, "extent", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor13$4 = _applyDecoratedDescriptor(_class16.prototype, "values", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class16)) || _class15);

      function _quantize(values, type) {
        var TypedArrayViewConstructor = QUANTIZATION_TYPE_TO_ARRAY_VIEW_CONSTRUCTOR_MAP[type];
        var MAX = 1 << TypedArrayViewConstructor.BYTES_PER_ELEMENT;
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        values.forEach(function (value) {
          min = Math.min(value, min);
          max = Math.max(value, max);
        });
        var extent = max - min;
        var normalized = TypedArrayViewConstructor.from(values, function (value) {
          return (value - min) / extent * MAX;
        });
        return new QuantizedFloatArray(getFloatArrayPrecision(values), normalized, extent, min);
      }

      function indexQuantized(quantized, index) {
        var quantizedValue = quantized.values[index];
        var MAX_VALUE = 1 << quantized.values.BYTES_PER_ELEMENT;
        return quantizedValue / MAX_VALUE * quantized.extent + quantized.min;
      }

      function createExoticTrackEvaluationRecord(times, values, ValueConstructor, path, property, binder) {
        var trackBinding = new TrackBinding();
        trackBinding.path = new TrackPath().toHierarchy(path).toProperty(property);
        var runtimeBinding = binder(trackBinding);

        if (!runtimeBinding) {
          return null;
        }

        var evaluator = new ExoticTrackEvaluator(times, values, ValueConstructor);
        return {
          runtimeBinding: runtimeBinding,
          evaluator: evaluator
        };
      }

      function loadVec3FromQuantized(values, index, out) {
        Vec3.set(out, indexQuantized(values, 3 * index + 0), indexQuantized(values, 3 * index + 1), indexQuantized(values, 3 * index + 2));
      }

      function loadQuatFromQuantized(values, index, out) {
        Quat.set(out, indexQuantized(values, 4 * index + 0), indexQuantized(values, 4 * index + 1), indexQuantized(values, 4 * index + 2), indexQuantized(values, 4 * index + 3));
      }

      var _dec$L, _class$L, _class2$D, _descriptor$B, _descriptor2$u, _descriptor3$m, _descriptor4$i, _descriptor5$f, _descriptor6$d, _descriptor7$9, _descriptor8$9, _descriptor9$8, _descriptor10$7, _class3$7, _temp$F;
      var searchForRootBonePathSymbol = Symbol('SearchForRootBonePath');
      var exoticAnimationTag = Symbol('ExoticAnimation');
      var embeddedPlayerCountTag = Symbol('[[EmbeddedPlayerCount]]');
      var getEmbeddedPlayersTag = Symbol('[[GetEmbeddedPlayers]]');
      var addEmbeddedPlayerTag = Symbol('[[AddEmbeddedPlayer]]');
      var removeEmbeddedPlayerTag = Symbol('[[RemoveEmbeddedPlayer]]');
      var clearEmbeddedPlayersTag = Symbol('[[ClearEmbeddedPlayers]]');
      var AnimationClip = exports('AnimationClip', (_dec$L = ccclass('cc.AnimationClip'), _dec$L(_class$L = (_class2$D = (_temp$F = _class3$7 = function (_Asset) {
        _inheritsLoose(AnimationClip, _Asset);

        function AnimationClip() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "sample", _descriptor$B, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "speed", _descriptor2$u, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "wrapMode", _descriptor3$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "enableTrsBlending", _descriptor4$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_duration", _descriptor5$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_hash", _descriptor6$d, _assertThisInitialized(_this));

          _this.frameRate = 0;

          _initializerDefineProperty(_this, "_tracks", _descriptor7$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_exoticAnimation", _descriptor8$9, _assertThisInitialized(_this));

          _this._legacyData = undefined;
          _this._legacyDataDirty = false;

          _initializerDefineProperty(_this, "_events", _descriptor9$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_embeddedPlayers", _descriptor10$7, _assertThisInitialized(_this));

          _this._runtimeEvents = {
            ratios: [],
            eventGroups: []
          };
          return _this;
        }

        AnimationClip.createWithSpriteFrames = function createWithSpriteFrames(spriteFrames, sample) {
          var clip = new AnimationClip();
          clip.sample = sample || clip.sample;
          clip.duration = spriteFrames.length / clip.sample;
          var step = 1 / clip.sample;
          var track = new ObjectTrack();
          track.path = new TrackPath().toComponent('cc.Sprite').toProperty('spriteFrame');
          var curve = track.channels()[0].curve;
          curve.assignSorted(spriteFrames.map(function (spriteFrame, index) {
            return [step * index, spriteFrame];
          }));
          clip.addTrack(track);
          return clip;
        };

        var _proto = AnimationClip.prototype;

        _proto.onLoaded = function onLoaded() {
          this.frameRate = this.sample;
          this.events = this._events;
        };

        _proto.range = function range() {
          var range = {
            min: Infinity,
            max: -Infinity
          };
          var tracks = this._tracks;
          var nTracks = tracks.length;

          for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
            var track = tracks[iTrack];
            var trackRange = track.range();
            range.min = Math.min(range.min, trackRange.min);
            range.max = Math.max(range.max, trackRange.max);
          }

          return range;
        };

        _proto.getTrack = function getTrack(index) {
          return this._tracks[index];
        };

        _proto.addTrack = function addTrack(track) {
          var index = this._tracks.length;

          this._tracks.push(track);

          return index;
        };

        _proto.removeTrack = function removeTrack(index) {
          this._tracks.splice(index, 1);
        };

        _proto.clearTracks = function clearTracks() {
          this._tracks.length = 0;
        };

        _proto.containsAnyEvent = function containsAnyEvent() {
          return this._events.length !== 0;
        };

        _proto.createEventEvaluator = function createEventEvaluator(targetNode) {
          return new EventEvaluator(targetNode, this._runtimeEvents.ratios, this._runtimeEvents.eventGroups, this.wrapMode);
        };

        _proto.containsAnyEmbeddedPlayer = function containsAnyEmbeddedPlayer() {
          return this._embeddedPlayers.length !== 0;
        };

        _proto.createEmbeddedPlayerEvaluator = function createEmbeddedPlayerEvaluator(targetNode) {
          return new EmbeddedPlayerEvaluation(this._embeddedPlayers, targetNode);
        };

        _proto.createEvaluator = function createEvaluator(context) {
          var _this2 = this;

          var target = context.target;

          var binder = function binder(binding) {
            if (context.mask && binding.isMaskedOff(context.mask)) {
              return undefined;
            }

            var trackTarget = binding.createRuntimeBinding(target, _this2.enableTrsBlending ? context.pose : undefined, false);

            if ( !trackTarget) {
              warnID(3937, _this2.name, context.target instanceof Node ? context.target.name : context.target);
            }

            return trackTarget !== null && trackTarget !== void 0 ? trackTarget : undefined;
          };

          return this._createEvalWithBinder(target, binder, context.rootMotion);
        };

        _proto.destroy = function destroy() {
          var _legacyCC$director$ro;

          if ((_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.dataPoolManager) {
            legacyCC.director.root.dataPoolManager.releaseAnimationClip(this);
          }

          SkelAnimDataHub.destroy(this);
          return _Asset.prototype.destroy.call(this);
        };

        _proto[BAKE_SKELETON_CURVE_SYMBOL] = function (start, samples, frames) {
          var step = 1.0 / samples;

          var animatedJoints = this._collectAnimatedJoints();

          var nAnimatedJoints = animatedJoints.length;
          var jointsBakeInfo = {};

          for (var iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
            var joint = animatedJoints[iAnimatedJoint];
            jointsBakeInfo[joint] = {
              transforms: Array.from({
                length: frames
              }, function () {
                return new Mat4();
              })
            };
          }

          var skeletonFrames = animatedJoints.reduce(function (result, joint) {
            result[joint] = new BoneGlobalTransform();
            return result;
          }, {});

          for (var _joint in skeletonFrames) {
            var skeletonFrame = skeletonFrames[_joint];

            var parentJoint = _joint.lastIndexOf('/');

            if (parentJoint >= 0) {
              var parentJointName = _joint.substring(0, parentJoint);

              var parentJointFrame = skeletonFrames[parentJointName];

              if (parentJointFrame) {
                skeletonFrame.parent = parentJointFrame;
              }
            }
          }

          var binder = function binder(binding) {
            var trsPath = binding.parseTrsPath();

            if (!trsPath) {
              return undefined;
            }

            var jointFrame = skeletonFrames[trsPath.node];

            if (!jointFrame) {
              return undefined;
            }

            return createBoneTransformBinding(jointFrame, trsPath.property);
          };

          var evaluator = this._createEvalWithBinder(undefined, binder, undefined);

          for (var iFrame = 0; iFrame < frames; ++iFrame) {
            var time = start + step * iFrame;
            evaluator.evaluate(time);

            for (var _iAnimatedJoint = 0; _iAnimatedJoint < nAnimatedJoints; ++_iAnimatedJoint) {
              var _joint2 = animatedJoints[_iAnimatedJoint];
              Mat4.copy(jointsBakeInfo[_joint2].transforms[iFrame], skeletonFrames[_joint2].globalTransform);
            }

            for (var _iAnimatedJoint2 = 0; _iAnimatedJoint2 < nAnimatedJoints; ++_iAnimatedJoint2) {
              var _joint3 = animatedJoints[_iAnimatedJoint2];

              skeletonFrames[_joint3].invalidate();
            }
          }

          return {
            samples: samples,
            frames: frames,
            joints: jointsBakeInfo
          };
        };

        _proto.upgradeUntypedTracks = function upgradeUntypedTracks(refine) {
          var newTracks = [];
          var removals = [];
          var tracks = this._tracks;
          var nTracks = tracks.length;

          for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
            var track = tracks[iTrack];

            if (!(track instanceof UntypedTrack)) {
              continue;
            }

            var newTrack = track.upgrade(refine);

            if (newTrack) {
              newTracks.push(newTrack);
              removals.push(track);
            }
          }

          var nRemovalTracks = removals.length;

          for (var iRemovalTrack = 0; iRemovalTrack < nRemovalTracks; ++iRemovalTrack) {
            array.remove(tracks, removals[iRemovalTrack]);
          }

          tracks.push.apply(tracks, newTracks);
        };

        _proto[searchForRootBonePathSymbol] = function () {
          return this._searchForRootBonePath();
        };

        _proto.getPropertyCurves = function getPropertyCurves() {
          return this._getLegacyData().getPropertyCurves();
        };

        _proto.updateEventDatas = function updateEventDatas() {
          this.events = this._events;
        };

        _proto.hasEvents = function hasEvents() {
          return this.events.length !== 0;
        };

        _proto.syncLegacyData = function syncLegacyData() {
          if (this._legacyData) {
            this._fromLegacy(this._legacyData);

            this._legacyData = undefined;
          }
        };

        _proto[getEmbeddedPlayersTag] = function () {
          return this._embeddedPlayers;
        };

        _proto[addEmbeddedPlayerTag] = function (embeddedPlayer) {
          this._embeddedPlayers.push(embeddedPlayer);
        };

        _proto[removeEmbeddedPlayerTag] = function (embeddedPlayer) {
          var iEmbeddedPlayer = this._embeddedPlayers.indexOf(embeddedPlayer);

          if (iEmbeddedPlayer >= 0) {
            this._embeddedPlayers.splice(iEmbeddedPlayer, 1);
          }
        };

        _proto[clearEmbeddedPlayersTag] = function () {
          this._embeddedPlayers.length = 0;
        };

        _proto._createEvalWithBinder = function _createEvalWithBinder(target, binder, rootMotionOptions) {
          if (this._legacyDataDirty) {
            this._legacyDataDirty = false;
            this.syncLegacyData();
          }

          var rootMotionTrackExcludes = [];
          var rootMotionEvaluation;

          if (rootMotionOptions) {
            rootMotionEvaluation = this._createRootMotionEvaluation(target, rootMotionOptions, rootMotionTrackExcludes);
          }

          var trackEvalStatues = [];
          var exoticAnimationEvaluator;
          var tracks = this._tracks;
          var nTracks = tracks.length;

          for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
            var track = tracks[iTrack];

            if (rootMotionTrackExcludes.includes(track)) {
              continue;
            }

            if (Array.from(track.channels()).every(function (_ref) {
              var curve = _ref.curve;
              return curve.keyFramesCount === 0;
            })) {
              continue;
            }

            var trackTarget = binder(track[trackBindingTag]);

            if (!trackTarget) {
              continue;
            }

            var trackEval = track[createEvalSymbol](trackTarget);
            trackEvalStatues.push({
              binding: trackTarget,
              trackEval: trackEval
            });
          }

          if (this._exoticAnimation) {
            exoticAnimationEvaluator = this._exoticAnimation.createEvaluator(binder);
          }

          var evaluation = new AnimationClipEvaluation(trackEvalStatues, exoticAnimationEvaluator, rootMotionEvaluation);
          return evaluation;
        };

        _proto._createRootMotionEvaluation = function _createRootMotionEvaluation(target, rootMotionOptions, rootMotionTrackExcludes) {
          if (!(target instanceof Node)) {
            errorID(3920);
            return undefined;
          }

          var rootBonePath = this._searchForRootBonePath();

          if (!rootBonePath) {
            warnID(3923);
            return undefined;
          }

          var rootBone = target.getChildByPath(rootBonePath);

          if (!rootBone) {
            warnID(3924);
            return undefined;
          }

          var boneTransform = new BoneTransform();
          var rootMotionsTrackEvaluations = [];
          var tracks = this._tracks;
          var nTracks = tracks.length;

          for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
            var track = tracks[iTrack];
            var trackBinding = track[trackBindingTag];
            var trsPath = trackBinding.parseTrsPath();

            if (!trsPath) {
              continue;
            }

            var bonePath = trsPath.node;

            if (bonePath !== rootBonePath) {
              continue;
            }

            rootMotionTrackExcludes.push(track);
            var property = trsPath.property;
            var trackTarget = createBoneTransformBinding(boneTransform, property);

            if (!trackTarget) {
              continue;
            }

            var trackEval = track[createEvalSymbol](trackTarget);
            rootMotionsTrackEvaluations.push({
              binding: trackTarget,
              trackEval: trackEval
            });
          }

          var rootMotionEvaluation = new RootMotionEvaluation(rootBone, this._duration, boneTransform, rootMotionsTrackEvaluations);
          return rootMotionEvaluation;
        };

        _proto._searchForRootBonePath = function _searchForRootBonePath() {
          var paths = this._tracks.map(function (track) {
            var trsPath = track[trackBindingTag].parseTrsPath();

            if (trsPath) {
              var nodePath = trsPath.node;
              return {
                path: nodePath,
                rank: nodePath.split('/').length
              };
            } else {
              return {
                path: '',
                rank: 0
              };
            }
          });

          paths.sort(function (a, b) {
            return a.rank - b.rank;
          });
          var iNonEmptyPath = paths.findIndex(function (p) {
            return p.rank !== 0;
          });

          if (iNonEmptyPath < 0) {
            return '';
          }

          var nPaths = paths.length;
          var firstPath = paths[iNonEmptyPath];
          var highestPathsAreSame = true;

          for (var iPath = iNonEmptyPath + 1; iPath < nPaths; ++iPath) {
            var path = paths[iPath];

            if (path.rank !== firstPath.rank) {
              break;
            }

            if (path.path !== firstPath.path) {
              highestPathsAreSame = false;
              break;
            }
          }

          return highestPathsAreSame ? firstPath.path : '';
        };

        _proto._getLegacyData = function _getLegacyData() {
          if (!this._legacyData) {
            this._legacyData = this._toLegacy();
          }

          return this._legacyData;
        };

        _proto._toLegacy = function _toLegacy() {
          var keys = [];
          var legacyCurves = [];
          var commonTargets = [];
          var legacyClipData = new AnimationClipLegacyData(this._duration);
          legacyClipData.keys = keys;
          legacyClipData.curves = legacyCurves;
          legacyClipData.commonTargets = commonTargets;
          return legacyClipData;
        };

        _proto._fromLegacy = function _fromLegacy(legacyData) {
          var newTracks = legacyData.toTracks();
          var nNewTracks = newTracks.length;

          for (var iNewTrack = 0; iNewTrack < nNewTracks; ++iNewTrack) {
            this.addTrack(newTracks[iNewTrack]);
          }
        };

        _proto._collectAnimatedJoints = function _collectAnimatedJoints() {
          var joints = new Set();
          var tracks = this._tracks;
          var nTracks = tracks.length;

          for (var iTrack = 0; iTrack < nTracks; ++iTrack) {
            var track = tracks[iTrack];
            var trsPath = track[trackBindingTag].parseTrsPath();

            if (trsPath) {
              joints.add(trsPath.node);
            }
          }

          if (this._exoticAnimation) {
            var animatedJoints = this._exoticAnimation.collectAnimatedJoints();

            var nAnimatedJoints = animatedJoints.length;

            for (var iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
              joints.add(animatedJoints[iAnimatedJoint]);
            }
          }

          return Array.from(joints);
        };

        _createClass(AnimationClip, [{
          key: "duration",
          get: function get() {
            return this._duration;
          },
          set: function set(value) {
            this._duration = value;
          }
        }, {
          key: "tracksCount",
          get: function get() {
            return this._tracks.length;
          }
        }, {
          key: "tracks",
          get: function get() {
            return this._tracks;
          }
        }, {
          key: "hash",
          get: function get() {
            var _this$_exoticAnimatio, _this$_exoticAnimatio2;

            if (this._hash) {
              return this._hash;
            }

            var hashString = "Exotic:" + ((_this$_exoticAnimatio = (_this$_exoticAnimatio2 = this._exoticAnimation) === null || _this$_exoticAnimatio2 === void 0 ? void 0 : _this$_exoticAnimatio2.toHashString()) !== null && _this$_exoticAnimatio !== void 0 ? _this$_exoticAnimatio : '');
            return this._hash = murmurhash2_32_gc(hashString, 666);
          }
        }, {
          key: "events",
          get: function get() {
            return this._events;
          },
          set: function set(value) {
            var _this3 = this;

            this._events = value;
            var ratios = [];
            var eventGroups = [];
            var events = this.events.sort(function (a, b) {
              return a.frame - b.frame;
            });
            var nEvents = events.length;

            var _loop = function _loop(iEvent) {
              var eventData = events[iEvent];
              var ratio = eventData.frame / _this3._duration;
              var i = ratios.findIndex(function (r) {
                return r === ratio;
              });

              if (i < 0) {
                i = ratios.length;
                ratios.push(ratio);
                eventGroups.push({
                  events: []
                });
              }

              eventGroups[i].events.push({
                functionName: eventData.func,
                parameters: eventData.params
              });
            };

            for (var iEvent = 0; iEvent < nEvents; ++iEvent) {
              _loop(iEvent);
            }

            this._runtimeEvents = {
              ratios: ratios,
              eventGroups: eventGroups
            };
          }
        }, {
          key: exoticAnimationTag,
          get: function get() {
            return this._exoticAnimation;
          }
        }, {
          key: exoticAnimationTag,
          set: function set(value) {
            this._exoticAnimation = value;
          }
        }, {
          key: "keys",
          get: function get() {
            return this._getLegacyData().keys;
          }
        }, {
          key: "keys",
          set: function set(value) {
            this._legacyDataDirty = true;
            this._getLegacyData().keys = value;
          }
        }, {
          key: "curves",
          get: function get() {
            this._legacyDataDirty = true;
            return this._getLegacyData().curves;
          }
        }, {
          key: "curves",
          set: function set(value) {
            this._getLegacyData().curves = value;
          }
        }, {
          key: "commonTargets",
          get: function get() {
            return this._getLegacyData().commonTargets;
          }
        }, {
          key: "commonTargets",
          set: function set(value) {
            this._legacyDataDirty = true;
            this._getLegacyData().commonTargets = value;
          }
        }, {
          key: "data",
          get: function get() {
            return this._getLegacyData().data;
          }
        }, {
          key: "eventGroups",
          get: function get() {
            return this._runtimeEvents.eventGroups;
          }
        }, {
          key: embeddedPlayerCountTag,
          get: function get() {
            return this._embeddedPlayers.length;
          }
        }]);

        return AnimationClip;
      }(Asset), _class3$7.WrapMode = WrapMode$1, _temp$F), (_descriptor$B = _applyDecoratedDescriptor(_class2$D.prototype, "sample", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 60;
        }
      }), _descriptor2$u = _applyDecoratedDescriptor(_class2$D.prototype, "speed", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor3$m = _applyDecoratedDescriptor(_class2$D.prototype, "wrapMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return WrapMode$1.Normal;
        }
      }), _descriptor4$i = _applyDecoratedDescriptor(_class2$D.prototype, "enableTrsBlending", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor5$f = _applyDecoratedDescriptor(_class2$D.prototype, "_duration", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor6$d = _applyDecoratedDescriptor(_class2$D.prototype, "_hash", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$9 = _applyDecoratedDescriptor(_class2$D.prototype, "_tracks", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor8$9 = _applyDecoratedDescriptor(_class2$D.prototype, "_exoticAnimation", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9$8 = _applyDecoratedDescriptor(_class2$D.prototype, "_events", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor10$7 = _applyDecoratedDescriptor(_class2$D.prototype, "_embeddedPlayers", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$D)) || _class$L));
      legacyCC.AnimationClip = AnimationClip;

      var EmbeddedPlayerEvaluation = function () {
        function EmbeddedPlayerEvaluation(embeddedPlayers, rootNode) {
          this._embeddedPlayers = embeddedPlayers;
          this._embeddedPlayerEvaluationInfos = embeddedPlayers.map(function (embeddedPlayer) {
            var player = embeddedPlayer.playable;

            if (!player) {
              return null;
            }

            var instantiatedPlayer = player.instantiate(rootNode);

            if (!instantiatedPlayer) {
              return null;
            }

            return {
              instantiatedPlayer: instantiatedPlayer,
              entered: false,
              hostPauseTime: 0.0,
              lastIterations: 0
            };
          });
        }

        var _proto2 = EmbeddedPlayerEvaluation.prototype;

        _proto2.destroy = function destroy() {
          var embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
          var nEmbeddedPlayers = embeddedPlayerEvaluationInfos.length;

          for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
            var _embeddedPlayerEvalua;

            (_embeddedPlayerEvalua = embeddedPlayerEvaluationInfos[iEmbeddedPlayer]) === null || _embeddedPlayerEvalua === void 0 ? void 0 : _embeddedPlayerEvalua.instantiatedPlayer.destroy();
          }

          this._embeddedPlayerEvaluationInfos.length = 0;
        };

        _proto2.evaluate = function evaluate(time, iterations) {
          assertIsTrue(Number.isInteger(iterations));
          var embeddedPlayers = this._embeddedPlayers,
              embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
          var nEmbeddedPlayers = embeddedPlayers.length;

          for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
            var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

            if (!embeddedPlayerEvaluationInfo) {
              continue;
            }

            var entered = embeddedPlayerEvaluationInfo.entered,
                instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer,
                lastIterations = embeddedPlayerEvaluationInfo.lastIterations;
            var _embeddedPlayers$iEmb = embeddedPlayers[iEmbeddedPlayer],
                begin = _embeddedPlayers$iEmb.begin,
                end = _embeddedPlayers$iEmb.end;
            var withinEmbeddedPlayer = time >= begin && time <= end;

            if (withinEmbeddedPlayer) {
              if (!entered) {
                instantiatedPlayer.play();
                embeddedPlayerEvaluationInfo.entered = true;
              } else if (iterations !== lastIterations) {
                instantiatedPlayer.stop();
                instantiatedPlayer.play();
                embeddedPlayerEvaluationInfo.entered = true;
              }
            } else if (entered) {
              instantiatedPlayer.stop();
              embeddedPlayerEvaluationInfo.entered = false;
            }

            embeddedPlayerEvaluationInfo.lastIterations = iterations;

            if (embeddedPlayerEvaluationInfo.entered) {
              var playerTime = time - begin;
              embeddedPlayerEvaluationInfo.instantiatedPlayer.setTime(playerTime);
            }
          }
        };

        _proto2.notifyHostSpeedChanged = function notifyHostSpeedChanged(speed) {
          var embeddedPlayers = this._embeddedPlayers,
              embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
          var nEmbeddedPlayers = embeddedPlayers.length;

          for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
            var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

            if (!embeddedPlayerEvaluationInfo) {
              continue;
            }

            var instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer;
            var reconciledSpeed = embeddedPlayers[iEmbeddedPlayer].reconciledSpeed;

            if (reconciledSpeed) {
              instantiatedPlayer.setSpeed(speed);
            }
          }
        };

        _proto2.notifyHostPlay = function notifyHostPlay(time) {
          var embeddedPlayers = this._embeddedPlayers,
              embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
          var nEmbeddedPlayers = embeddedPlayers.length;

          for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
            var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

            if (!embeddedPlayerEvaluationInfo) {
              continue;
            }

            var _embeddedPlayers$iEmb2 = embeddedPlayers[iEmbeddedPlayer],
                begin = _embeddedPlayers$iEmb2.begin,
                end = _embeddedPlayers$iEmb2.end;
            var instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer,
                entered = embeddedPlayerEvaluationInfo.entered;

            if (entered) {
              var hostPauseTime = embeddedPlayerEvaluationInfo.hostPauseTime;

              if (instantiatedPlayer.randomAccess || approx(hostPauseTime, time, 1e-5)) {
                var startTime = clamp$1(time, begin, end);
                instantiatedPlayer.play();
                instantiatedPlayer.setTime(startTime - begin);
              } else {
                instantiatedPlayer.stop();
              }
            }
          }
        };

        _proto2.notifyHostPause = function notifyHostPause(time) {
          var embeddedPlayers = this._embeddedPlayers,
              embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
          var nEmbeddedPlayers = embeddedPlayers.length;

          for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
            var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

            if (!embeddedPlayerEvaluationInfo) {
              continue;
            }

            var instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer,
                entered = embeddedPlayerEvaluationInfo.entered;

            if (entered) {
              instantiatedPlayer.pause();
              embeddedPlayerEvaluationInfo.hostPauseTime = time;
            }
          }
        };

        _proto2.notifyHostStop = function notifyHostStop() {
          var embeddedPlayers = this._embeddedPlayers,
              embeddedPlayerEvaluationInfos = this._embeddedPlayerEvaluationInfos;
          var nEmbeddedPlayers = embeddedPlayers.length;

          for (var iEmbeddedPlayer = 0; iEmbeddedPlayer < nEmbeddedPlayers; ++iEmbeddedPlayer) {
            var embeddedPlayerEvaluationInfo = embeddedPlayerEvaluationInfos[iEmbeddedPlayer];

            if (!embeddedPlayerEvaluationInfo) {
              continue;
            }

            var instantiatedPlayer = embeddedPlayerEvaluationInfo.instantiatedPlayer,
                entered = embeddedPlayerEvaluationInfo.entered;

            if (entered) {
              embeddedPlayerEvaluationInfo.entered = false;
              instantiatedPlayer.stop();
            }
          }
        };

        return EmbeddedPlayerEvaluation;
      }();

      var AnimationClipEvaluation = function () {
        function AnimationClipEvaluation(trackEvalStatuses, exoticAnimationEvaluator, rootMotionEvaluation) {
          this._exoticAnimationEvaluator = void 0;
          this._trackEvalStatues = [];
          this._rootMotionEvaluation = undefined;
          this._trackEvalStatues = trackEvalStatuses;
          this._exoticAnimationEvaluator = exoticAnimationEvaluator;
          this._rootMotionEvaluation = rootMotionEvaluation;
        }

        var _proto3 = AnimationClipEvaluation.prototype;

        _proto3.evaluate = function evaluate(time) {
          var trackEvalStatuses = this._trackEvalStatues,
              exoticAnimationEvaluator = this._exoticAnimationEvaluator;
          var nTrackEvalStatuses = trackEvalStatuses.length;

          for (var iTrackEvalStatus = 0; iTrackEvalStatus < nTrackEvalStatuses; ++iTrackEvalStatus) {
            var _trackEvalStatuses$iT = trackEvalStatuses[iTrackEvalStatus],
                trackEval = _trackEvalStatuses$iT.trackEval,
                binding = _trackEvalStatuses$iT.binding;
            var value = trackEval.evaluate(time, binding);
            binding.setValue(value);
          }

          if (exoticAnimationEvaluator) {
            exoticAnimationEvaluator.evaluate(time);
          }
        };

        _proto3.evaluateRootMotion = function evaluateRootMotion(time, motionLength) {
          var rootMotionEvaluation = this._rootMotionEvaluation;

          if (rootMotionEvaluation) {
            rootMotionEvaluation.evaluate(time, motionLength);
          }
        };

        return AnimationClipEvaluation;
      }();

      var BoneTransform = function () {
        function BoneTransform() {
          this.position = new Vec3();
          this.scale = new Vec3(1.0, 1.0, 1.0);
          this.rotation = new Quat();
          this.eulerAngles = new Vec3();
        }

        var _proto4 = BoneTransform.prototype;

        _proto4.getTransform = function getTransform(out) {
          Mat4.fromRTS(out, this.rotation, this.position, this.scale);
        };

        return BoneTransform;
      }();

      var BoneGlobalTransform = function (_BoneTransform) {
        _inheritsLoose(BoneGlobalTransform, _BoneTransform);

        function BoneGlobalTransform() {
          var _this4;

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          _this4 = _BoneTransform.call.apply(_BoneTransform, [this].concat(args)) || this;
          _this4.parent = null;
          _this4._dirty = true;
          _this4._transform = new Mat4();
          return _this4;
        }

        var _proto5 = BoneGlobalTransform.prototype;

        _proto5.invalidate = function invalidate() {
          this._dirty = true;
        };

        _createClass(BoneGlobalTransform, [{
          key: "globalTransform",
          get: function get() {
            var transform = this._transform;

            if (this._dirty) {
              this._dirty = false;
              Mat4.fromRTS(transform, this.rotation, this.position, this.scale);

              if (this.parent) {
                Mat4.multiply(transform, this.parent.globalTransform, transform);
              }
            }

            return this._transform;
          }
        }]);

        return BoneGlobalTransform;
      }(BoneTransform);

      var motionTransformCache = new Mat4();

      var RootMotionEvaluation = function () {
        function RootMotionEvaluation(_rootBone, _duration, _boneTransform, _trackEvalStatuses) {
          this._initialTransformCache = new Mat4();
          this._clipEndTransformCache = new Mat4();
          this._startTransformCache = new Mat4();
          this._endTransformCache = new Mat4();
          this._motionTransformCache = new Mat4();
          this._translationMotionCache = new Vec3();
          this._rotationMotionCache = new Quat();
          this._scaleMotionCache = new Vec3();
          this._rootBone = _rootBone;
          this._duration = _duration;
          this._boneTransform = _boneTransform;
          this._trackEvalStatuses = _trackEvalStatuses;
        }

        var _proto6 = RootMotionEvaluation.prototype;

        _proto6.evaluate = function evaluate(time, motionLength) {
          var motionTransform = this._calcMotionTransform(time, motionLength, this._motionTransformCache);

          var translationMotion = this._translationMotionCache,
              rotationMotion = this._rotationMotionCache,
              scaleMotion = this._scaleMotionCache,
              rootBone = this._rootBone;
          Mat4.toRTS(motionTransform, rotationMotion, translationMotion, scaleMotion);
          Vec3.add(translationMotion, translationMotion, rootBone.position);
          rootBone.setPosition(translationMotion);
          Quat.multiply(rotationMotion, rotationMotion, rootBone.rotation);
          rootBone.setRotation(rotationMotion);
          Vec3.multiply(scaleMotion, scaleMotion, rootBone.scale);
          rootBone.setScale(scaleMotion);
        };

        _proto6._calcMotionTransform = function _calcMotionTransform(time, motionLength, outTransform) {
          var duration = this._duration;
          var remainLength = duration - time;
          assertIsTrue(remainLength >= 0);

          var startTransform = this._evaluateAt(time, this._startTransformCache);

          if (motionLength < remainLength) {
            var endTransform = this._evaluateAt(time + motionLength, this._endTransformCache);

            relativeTransform(outTransform, startTransform, endTransform);
          } else {
            Mat4.identity(outTransform);

            var accumulateMotionTransform = function accumulateMotionTransform(from, to) {
              relativeTransform(motionTransformCache, from, to);
              Mat4.multiply(outTransform, outTransform, motionTransformCache);
            };

            var diff = motionLength - remainLength;
            var repeatCount = Math.floor(diff / duration);
            var lastRemainTime = diff - repeatCount * duration;

            var clipStartTransform = this._evaluateAt(0, this._initialTransformCache);

            var clipEndTransform = this._evaluateAt(duration, this._clipEndTransformCache);

            var _endTransform = this._evaluateAt(lastRemainTime, this._endTransformCache);

            accumulateMotionTransform(startTransform, clipEndTransform);
            relativeTransform(motionTransformCache, clipStartTransform, clipEndTransform);

            for (var i = 0; i < repeatCount; ++i) {
              Mat4.multiply(outTransform, outTransform, motionTransformCache);
            }

            accumulateMotionTransform(clipStartTransform, _endTransform);
          }

          return outTransform;
        };

        _proto6._evaluateAt = function _evaluateAt(time, outTransform) {
          var trackEvalStatuses = this._trackEvalStatuses;
          var nTrackEvalStatuses = trackEvalStatuses.length;

          for (var iTrackEvalStatus = 0; iTrackEvalStatus < nTrackEvalStatuses; ++iTrackEvalStatus) {
            var _trackEvalStatuses$iT2 = trackEvalStatuses[iTrackEvalStatus],
                trackEval = _trackEvalStatuses$iT2.trackEval,
                binding = _trackEvalStatuses$iT2.binding;
            var value = trackEval.evaluate(time, binding);
            binding.setValue(value);
          }

          this._boneTransform.getTransform(outTransform);

          return outTransform;
        };

        return RootMotionEvaluation;
      }();

      function relativeTransform(out, from, to) {
        Mat4.invert(out, from);
        Mat4.multiply(out, to, out);
      }

      function createBoneTransformBinding(boneTransform, property) {
        switch (property) {
          default:
            return undefined;

          case 'position':
            return {
              setValue: function setValue(value) {
                Vec3.copy(boneTransform.position, value);
              }
            };

          case 'rotation':
            return {
              setValue: function setValue(value) {
                Quat.copy(boneTransform.rotation, value);
              }
            };

          case 'scale':
            return {
              setValue: function setValue(value) {
                Vec3.copy(boneTransform.scale, value);
              }
            };

          case 'eulerAngles':
            return {
              setValue: function setValue(value) {
                Vec3.copy(boneTransform.eulerAngles, value);
              }
            };
        }
      }

      var InvalidIndex = -1;

      var EventEvaluator = function () {
        function EventEvaluator(_targetNode, _ratios, _eventGroups, _wrapMode) {
          this._lastFrameIndex = -1;
          this._lastIterations = 0.0;
          this._lastDirection = 0;
          this._ignoreIndex = InvalidIndex;
          this._sampled = false;
          this._targetNode = _targetNode;
          this._ratios = _ratios;
          this._eventGroups = _eventGroups;
          this._wrapMode = _wrapMode;
        }

        var _proto7 = EventEvaluator.prototype;

        _proto7.setWrapMode = function setWrapMode(wrapMode) {
          this._wrapMode = wrapMode;
        };

        _proto7.ignore = function ignore(ratio, direction) {
          this._ignoreIndex = InvalidIndex;
          this._sampled = false;
          var frameIndex = getEventGroupIndexAtRatio(ratio, this._ratios);

          if (frameIndex < 0) {
            frameIndex = ~frameIndex - 1;

            if (direction < 0) {
              frameIndex += 1;
            }

            this._ignoreIndex = frameIndex;
          }
        };

        _proto7.sample = function sample(ratio, direction, iterations) {
          var length = this._eventGroups.length;
          var eventIndex = getEventGroupIndexAtRatio(ratio, this._ratios);

          if (eventIndex < 0) {
            eventIndex = ~eventIndex - 1;

            if (direction < 0) {
              eventIndex += 1;
            }
          }

          if (this._ignoreIndex !== eventIndex) {
            this._ignoreIndex = InvalidIndex;
          }

          if (!this._sampled) {
            this._sampled = true;

            this._doFire(eventIndex, false);

            this._lastFrameIndex = eventIndex;
            this._lastIterations = iterations;
            this._lastDirection = direction;
            return;
          }

          var wrapMode = this._wrapMode;
          var currentIterations = wrapIterations(iterations);
          var lastIterations = wrapIterations(this._lastIterations);
          var lastIndex = this._lastFrameIndex;
          var lastDirection = this._lastDirection;
          var iterationsChanged = lastIterations !== -1 && currentIterations !== lastIterations;

          if (lastIndex === eventIndex && iterationsChanged && length === 1) {
            this._doFire(0, false);
          } else if (lastIndex !== eventIndex || iterationsChanged) {
            direction = lastDirection;

            do {
              if (lastIndex !== eventIndex) {
                if (direction === -1 && lastIndex === 0 && eventIndex > 0) {
                  if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                    direction *= -1;
                  } else {
                    lastIndex = length;
                  }

                  lastIterations++;
                } else if (direction === 1 && lastIndex === length - 1 && eventIndex < length - 1) {
                  if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                    direction *= -1;
                  } else {
                    lastIndex = -1;
                  }

                  lastIterations++;
                }

                if (lastIndex === eventIndex) {
                  break;
                }

                if (lastIterations > currentIterations) {
                  break;
                }
              }

              lastIndex += direction;

              this._doFire(lastIndex, true);
            } while (lastIndex !== eventIndex && lastIndex > -1 && lastIndex < length);
          }

          this._lastFrameIndex = eventIndex;
          this._lastIterations = iterations;
          this._lastDirection = direction;
        };

        _proto7._doFire = function _doFire(eventIndex, delay) {
          if (delay) {
            getGlobalAnimationManager().pushDelayEvent(this._checkAndFire, this, [eventIndex]);
          } else {
            this._checkAndFire(eventIndex);
          }
        };

        _proto7._checkAndFire = function _checkAndFire(eventIndex) {
          if (!this._targetNode || !this._targetNode.isValid) {
            return;
          }

          var eventGroups = this._eventGroups;

          if (eventIndex < 0 || eventIndex >= eventGroups.length || this._ignoreIndex === eventIndex) {
            return;
          }

          var eventGroup = eventGroups[eventIndex];
          var components = this._targetNode.components;
          var nEvents = eventGroup.events.length;

          for (var iEvent = 0; iEvent < nEvents; ++iEvent) {
            var event = eventGroup.events[iEvent];
            var functionName = event.functionName;
            var nComponents = components.length;

            for (var iComponent = 0; iComponent < nComponents; ++iComponent) {
              var component = components[iComponent];
              var fx = component[functionName];

              if (typeof fx === 'function') {
                fx.apply(component, event.parameters);
              }
            }
          }
        };

        return EventEvaluator;
      }();

      function wrapIterations(iterations) {
        if (iterations - (iterations | 0) === 0) {
          iterations -= 1;
        }

        return iterations | 0;
      }

      function getEventGroupIndexAtRatio(ratio, ratios) {
        var result = binarySearchEpsilon(ratios, ratio);
        return result;
      }

      var MAX_ANIMATION_LAYER = 32;

      var BlendStateBuffer = function () {
        function BlendStateBuffer() {
          this._nodeBlendStates = new Map();
        }

        var _proto = BlendStateBuffer.prototype;

        _proto.createWriter = function createWriter(node, property, host, constants) {
          var propertyBlendState = this.ref(node, property);
          return new BlendStateWriterInternal(node, property, propertyBlendState, host, constants);
        };

        _proto.destroyWriter = function destroyWriter(writer) {
          var internal = writer;
          this.deRef(internal.node, internal.property);
        };

        _proto.ref = function ref(node, property) {
          var nodeBlendState = this._nodeBlendStates.get(node);

          if (!nodeBlendState) {
            nodeBlendState = this.createNodeBlendState();

            this._nodeBlendStates.set(node, nodeBlendState);
          }

          var propertyBlendState = nodeBlendState.refProperty(node, property);
          return propertyBlendState;
        };

        _proto.deRef = function deRef(node, property) {
          var nodeBlendState = this._nodeBlendStates.get(node);

          if (!nodeBlendState) {
            return;
          }

          nodeBlendState.deRefProperty(property);

          if (nodeBlendState.empty) {
            this._nodeBlendStates["delete"](node);
          }
        };

        _proto.apply = function apply() {
          this._nodeBlendStates.forEach(function (nodeBlendState, node) {
            nodeBlendState.apply(node);
          });
        };

        return BlendStateBuffer;
      }();

      var BlendStateWriterInternal = function () {
        function BlendStateWriterInternal(_node, _property, _propertyBlendState, _host, _constants) {
          this._node = _node;
          this._property = _property;
          this._propertyBlendState = _propertyBlendState;
          this._host = _host;
          this._constants = _constants;
        }

        var _proto2 = BlendStateWriterInternal.prototype;

        _proto2.getValue = function getValue() {
          return this._node[this._property];
        };

        _proto2.setValue = function setValue(value) {
          var propertyBlendState = this._propertyBlendState,
              host = this._host;
          var weight = host.weight;
          propertyBlendState.blend(value, weight);
        };

        _createClass(BlendStateWriterInternal, [{
          key: "node",
          get: function get() {
            return this._node;
          }
        }, {
          key: "property",
          get: function get() {
            return this._property;
          }
        }]);

        return BlendStateWriterInternal;
      }();

      var TransformApplyFlag;

      (function (TransformApplyFlag) {
        TransformApplyFlag[TransformApplyFlag["POSITION"] = 1] = "POSITION";
        TransformApplyFlag[TransformApplyFlag["ROTATION"] = 2] = "ROTATION";
        TransformApplyFlag[TransformApplyFlag["SCALE"] = 4] = "SCALE";
        TransformApplyFlag[TransformApplyFlag["EULER_ANGLES"] = 8] = "EULER_ANGLES";
      })(TransformApplyFlag || (TransformApplyFlag = {}));

      var TRANSFORM_APPLY_FLAGS_ALL = TransformApplyFlag.POSITION | TransformApplyFlag.ROTATION | TransformApplyFlag.SCALE | TransformApplyFlag.EULER_ANGLES;

      var LegacyVec3PropertyBlendState = function () {
        function LegacyVec3PropertyBlendState() {
          this.refCount = 0;
          this.accumulatedWeight = 0.0;
          this.result = new Vec3();
        }

        var _proto3 = LegacyVec3PropertyBlendState.prototype;

        _proto3.blend = function blend(value, weight) {
          this.accumulatedWeight = mixAveragedVec3(this.result, this.result, this.accumulatedWeight, value, weight);
        };

        _proto3.reset = function reset() {
          this.accumulatedWeight = 0.0;
          Vec3.zero(this.result);
        };

        return LegacyVec3PropertyBlendState;
      }();

      var LegacyQuatPropertyBlendState = function () {
        function LegacyQuatPropertyBlendState() {
          this.refCount = 0;
          this.accumulatedWeight = 0.0;
          this.result = new Quat();
        }

        var _proto4 = LegacyQuatPropertyBlendState.prototype;

        _proto4.blend = function blend(value, weight) {
          this.accumulatedWeight = mixAveragedQuat(this.result, this.result, this.accumulatedWeight, value, weight);
        };

        _proto4.reset = function reset() {
          this.accumulatedWeight = 0.0;
          Quat.identity(this.result);
        };

        return LegacyQuatPropertyBlendState;
      }();

      var NodeBlendState = function () {
        function NodeBlendState() {
          this._transformApplyFlags = 0;
          this._properties = {};
        }

        var _proto5 = NodeBlendState.prototype;

        _proto5.refProperty = function refProperty(node, property) {
          var _properties$property, _properties$property2;

          var properties = this._properties;
          var propertyBlendState;

          switch (property) {
            default:
            case 'position':
            case 'scale':
            case 'eulerAngles':
              propertyBlendState = (_properties$property = properties[property]) !== null && _properties$property !== void 0 ? _properties$property : properties[property] = this._createVec3BlendState(node[property]);
              break;

            case 'rotation':
              propertyBlendState = (_properties$property2 = properties[property]) !== null && _properties$property2 !== void 0 ? _properties$property2 : properties[property] = this._createQuatBlendState(node.rotation);
              break;
          }

          ++propertyBlendState.refCount;
          return propertyBlendState;
        };

        _proto5.deRefProperty = function deRefProperty(property) {
          var properties = this._properties;
          var propertyBlendState = properties[property];

          if (!propertyBlendState) {
            return;
          }

          --propertyBlendState.refCount;

          if (propertyBlendState.refCount > 0) {
            return;
          }

          delete properties[property];
        };

        _proto5.apply = function apply(node) {
          var transformApplyFlags = this._transformApplyFlags,
              _this$_properties = this._properties,
              position = _this$_properties.position,
              scale = _this$_properties.scale,
              rotation = _this$_properties.rotation,
              eulerAngles = _this$_properties.eulerAngles;

          if (!transformApplyFlags) {
            return;
          }

          var t;
          var s;
          var r;

          if (position && transformApplyFlags & TransformApplyFlag.POSITION) {
            t = position.result;
          }

          if (scale && transformApplyFlags & TransformApplyFlag.SCALE) {
            s = scale.result;
          }

          if (eulerAngles && transformApplyFlags & TransformApplyFlag.EULER_ANGLES) {
            r = eulerAngles.result;
          }

          if (rotation && transformApplyFlags & TransformApplyFlag.ROTATION) {
            r = rotation.result;
          }

          if (r || t || s) {
            node.setRTS(r, t, s);
          }

          this._transformApplyFlags = 0;
        };

        _createClass(NodeBlendState, [{
          key: "empty",
          get: function get() {
            var properties = this._properties;
            return !properties.position && !properties.rotation && !properties.eulerAngles && !properties.scale;
          }
        }]);

        return NodeBlendState;
      }();

      var LegacyNodeBlendState = function (_NodeBlendState) {
        _inheritsLoose(LegacyNodeBlendState, _NodeBlendState);

        function LegacyNodeBlendState() {
          return _NodeBlendState.apply(this, arguments) || this;
        }

        var _proto6 = LegacyNodeBlendState.prototype;

        _proto6.apply = function apply(node) {
          var _this$_properties2 = this._properties,
              position = _this$_properties2.position,
              scale = _this$_properties2.scale,
              rotation = _this$_properties2.rotation,
              eulerAngles = _this$_properties2.eulerAngles;

          if (position && position.accumulatedWeight) {
            this._transformApplyFlags |= TransformApplyFlag.POSITION;

            if (position.accumulatedWeight < 1.0) {
              position.blend(node.position, 1.0 - position.accumulatedWeight);
            }
          }

          if (scale && scale.accumulatedWeight) {
            this._transformApplyFlags |= TransformApplyFlag.SCALE;

            if (scale.accumulatedWeight < 1.0) {
              scale.blend(node.scale, 1.0 - scale.accumulatedWeight);
            }
          }

          if (eulerAngles && eulerAngles.accumulatedWeight) {
            this._transformApplyFlags |= TransformApplyFlag.EULER_ANGLES;

            if (eulerAngles.accumulatedWeight < 1.0) {
              eulerAngles.blend(node.eulerAngles, 1.0 - eulerAngles.accumulatedWeight);
            }
          }

          if (rotation && rotation.accumulatedWeight) {
            this._transformApplyFlags |= TransformApplyFlag.ROTATION;

            if (rotation.accumulatedWeight < 1.0) {
              rotation.blend(node.rotation, 1.0 - rotation.accumulatedWeight);
            }
          }

          _NodeBlendState.prototype.apply.call(this, node);

          position === null || position === void 0 ? void 0 : position.reset();
          scale === null || scale === void 0 ? void 0 : scale.reset();
          rotation === null || rotation === void 0 ? void 0 : rotation.reset();
          eulerAngles === null || eulerAngles === void 0 ? void 0 : eulerAngles.reset();
        };

        _proto6._createVec3BlendState = function _createVec3BlendState(_currentValue) {
          return new LegacyVec3PropertyBlendState();
        };

        _proto6._createQuatBlendState = function _createQuatBlendState(_currentValue) {
          return new LegacyQuatPropertyBlendState();
        };

        return LegacyNodeBlendState;
      }(NodeBlendState);

      var LegacyBlendStateBuffer = function (_BlendStateBuffer) {
        _inheritsLoose(LegacyBlendStateBuffer, _BlendStateBuffer);

        function LegacyBlendStateBuffer() {
          return _BlendStateBuffer.apply(this, arguments) || this;
        }

        var _proto7 = LegacyBlendStateBuffer.prototype;

        _proto7.createNodeBlendState = function createNodeBlendState() {
          return new LegacyNodeBlendState();
        };

        return LegacyBlendStateBuffer;
      }(BlendStateBuffer);

      var LayeredVec3PropertyBlendState = function () {
        function LayeredVec3PropertyBlendState(defaultValue) {
          this.refCount = 0;
          this.result = new Vec3();
          this._defaultValue = new Vec3();
          this._clipBlendResult = new Vec3();
          this._accumulatedWeight = 0.0;
          Vec3.copy(this._defaultValue, defaultValue);
          Vec3.copy(this.result, defaultValue);
        }

        var _proto8 = LayeredVec3PropertyBlendState.prototype;

        _proto8.blend = function blend(value, weight) {
          this._accumulatedWeight = mixAveragedVec3(this._clipBlendResult, this._clipBlendResult, this._accumulatedWeight, value, weight);
        };

        _proto8.commitLayerChange = function commitLayerChange(weight) {
          var result = this.result,
              clipBlendResult = this._clipBlendResult,
              accumulatedWeight = this._accumulatedWeight;

          if (accumulatedWeight < 1.0) {
            this.blend(this._defaultValue, 1.0 - accumulatedWeight);
          }

          Vec3.lerp(result, result, clipBlendResult, weight);
          Vec3.zero(this._clipBlendResult);
          this._accumulatedWeight = 0.0;
        };

        _proto8.reset = function reset() {
          Vec3.copy(this.result, this._defaultValue);
        };

        return LayeredVec3PropertyBlendState;
      }();

      var LayeredQuatPropertyBlendState = function () {
        function LayeredQuatPropertyBlendState(defaultValue) {
          this.refCount = 0;
          this.result = new Quat();
          this._defaultValue = new Quat();
          this._clipBlendResult = new Quat();
          this._accumulatedWeight = 0.0;
          Quat.copy(this._defaultValue, defaultValue);
          Quat.copy(this.result, defaultValue);
        }

        var _proto9 = LayeredQuatPropertyBlendState.prototype;

        _proto9.blend = function blend(value, weight) {
          this._accumulatedWeight = mixAveragedQuat(this._clipBlendResult, this._clipBlendResult, this._accumulatedWeight, value, weight);
        };

        _proto9.commitLayerChange = function commitLayerChange(weight) {
          var result = this.result,
              clipBlendResult = this._clipBlendResult,
              accumulatedWeight = this._accumulatedWeight;

          if (accumulatedWeight < 1.0) {
            this.blend(this._defaultValue, 1.0 - accumulatedWeight);
          }

          Quat.slerp(result, result, clipBlendResult, weight);
          Quat.identity(this._clipBlendResult);
          this._accumulatedWeight = 0.0;
        };

        _proto9.reset = function reset() {
          Quat.copy(this.result, this._defaultValue);
        };

        return LayeredQuatPropertyBlendState;
      }();

      var LayeredNodeBlendState = function (_NodeBlendState2) {
        _inheritsLoose(LayeredNodeBlendState, _NodeBlendState2);

        function LayeredNodeBlendState() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _NodeBlendState2.call.apply(_NodeBlendState2, [this].concat(args)) || this;
          _this._layerMask = ~0 >>> 0;
          return _this;
        }

        var _proto10 = LayeredNodeBlendState.prototype;

        _proto10.setLayerMask = function setLayerMask(layerIndex) {
          this._layerMask &= ~(1 << layerIndex);
        };

        _proto10.commitLayerChanges = function commitLayerChanges(layerIndex, weight) {
          if (!(this._layerMask & 1 << layerIndex)) {
            return;
          }

          var _this$_properties3 = this._properties,
              position = _this$_properties3.position,
              scale = _this$_properties3.scale,
              rotation = _this$_properties3.rotation,
              eulerAngles = _this$_properties3.eulerAngles;

          if (position) {
            position.commitLayerChange(weight);
          }

          if (scale) {
            scale.commitLayerChange(weight);
          }

          if (rotation) {
            rotation.commitLayerChange(weight);
          }

          if (eulerAngles) {
            eulerAngles.commitLayerChange(weight);
          }
        };

        _proto10.apply = function apply(node) {
          this._transformApplyFlags = TRANSFORM_APPLY_FLAGS_ALL;

          _NodeBlendState2.prototype.apply.call(this, node);

          var _this$_properties4 = this._properties,
              position = _this$_properties4.position,
              scale = _this$_properties4.scale,
              rotation = _this$_properties4.rotation,
              eulerAngles = _this$_properties4.eulerAngles;
          position === null || position === void 0 ? void 0 : position.reset();
          scale === null || scale === void 0 ? void 0 : scale.reset();
          rotation === null || rotation === void 0 ? void 0 : rotation.reset();
          eulerAngles === null || eulerAngles === void 0 ? void 0 : eulerAngles.reset();
        };

        _proto10._createVec3BlendState = function _createVec3BlendState(currentValue) {
          return new LayeredVec3PropertyBlendState(currentValue);
        };

        _proto10._createQuatBlendState = function _createQuatBlendState(currentValue) {
          return new LayeredQuatPropertyBlendState(currentValue);
        };

        return LayeredNodeBlendState;
      }(NodeBlendState);

      var LayeredBlendStateBuffer = function (_BlendStateBuffer2) {
        _inheritsLoose(LayeredBlendStateBuffer, _BlendStateBuffer2);

        function LayeredBlendStateBuffer() {
          return _BlendStateBuffer2.apply(this, arguments) || this;
        }

        var _proto11 = LayeredBlendStateBuffer.prototype;

        _proto11.setMask = function setMask(layerIndex, excludeNodes) {
          {
            checkLayerIndex(layerIndex);
          }

          this._nodeBlendStates.forEach(function (nodeBlendState, node) {
            if (excludeNodes.has(node)) {
              nodeBlendState.setLayerMask(layerIndex);
            }
          });
        };

        _proto11.commitLayerChanges = function commitLayerChanges(layerIndex, weight) {
          {
            checkLayerIndex(layerIndex);
          }

          this._nodeBlendStates.forEach(function (nodeBlendState, node) {
            nodeBlendState.commitLayerChanges(layerIndex, weight);
          });
        };

        _proto11.createNodeBlendState = function createNodeBlendState() {
          return new LayeredNodeBlendState();
        };

        return LayeredBlendStateBuffer;
      }(BlendStateBuffer);

      function checkLayerIndex(layerIndex) {
        assertIsTrue(layerIndex < MAX_ANIMATION_LAYER);
      }

      function mixAveragedVec3(result, previous, accumulatedWeight, input, weight) {
        var newSum = accumulatedWeight + weight;

        if (weight === 1.0 && !accumulatedWeight) {
          Vec3.copy(result, input);
        } else if (newSum) {
          var t = weight / newSum;
          Vec3.lerp(result, result, input, t);
        }

        return newSum;
      }

      function mixAveragedQuat(result, previous, accumulatedWeight, input, weight) {
        var newSum = accumulatedWeight + weight;

        if (weight === 1.0 && !accumulatedWeight) {
          Quat.copy(result, input);
        } else if (newSum) {
          var t = weight / newSum;
          Quat.slerp(result, previous, input, t);
        }

        return newSum;
      }

      var _class$M, _class2$E, _temp$G;
      var AnimationManager = exports('AnimationManager', ccclass(_class$M = (_temp$G = _class2$E = function (_System) {
        _inheritsLoose(AnimationManager, _System);

        function AnimationManager() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _System.call.apply(_System, [this].concat(args)) || this;
          _this._anims = new MutableForwardIterator([]);
          _this._crossFades = new MutableForwardIterator([]);
          _this._delayEvents = [];
          _this._blendStateBuffer = new LegacyBlendStateBuffer();
          _this._sockets = [];
          return _this;
        }

        var _proto = AnimationManager.prototype;

        _proto.addCrossFade = function addCrossFade(crossFade) {
          var index = this._crossFades.array.indexOf(crossFade);

          if (index === -1) {
            this._crossFades.push(crossFade);
          }
        };

        _proto.removeCrossFade = function removeCrossFade(crossFade) {
          var index = this._crossFades.array.indexOf(crossFade);

          if (index >= 0) {
            this._crossFades.fastRemoveAt(index);
          } else {
            errorID(3907);
          }
        };

        _proto.update = function update(dt) {
          var _delayEvents = this._delayEvents,
              crossFadesIter = this._crossFades,
              _sockets = this._sockets;
          {
            var crossFades = crossFadesIter.array;

            for (crossFadesIter.i = 0; crossFadesIter.i < crossFades.length; ++crossFadesIter.i) {
              var crossFade = crossFades[crossFadesIter.i];
              crossFade.update(dt);
            }
          }
          var iterator = this._anims;
          var array = iterator.array;

          for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var anim = array[iterator.i];

            if (!anim.isMotionless) {
              anim.update(dt);
            }
          }

          this._blendStateBuffer.apply();

          var stamp = legacyCC.director.getTotalFrames();

          for (var i = 0, l = _sockets.length; i < l; i++) {
            var _sockets$i = _sockets[i],
                target = _sockets$i.target,
                transform = _sockets$i.transform;
            target.matrix = getWorldMatrix(transform, stamp);
          }

          for (var _i = 0, _l = _delayEvents.length; _i < _l; _i++) {
            var event = _delayEvents[_i];
            event.fn.apply(event.thisArg, event.args);
          }

          _delayEvents.length = 0;
        };

        _proto.destruct = function destruct() {};

        _proto.addAnimation = function addAnimation(anim) {
          var index = this._anims.array.indexOf(anim);

          if (index === -1) {
            this._anims.push(anim);
          }
        };

        _proto.removeAnimation = function removeAnimation(anim) {
          var index = this._anims.array.indexOf(anim);

          if (index >= 0) {
            this._anims.fastRemoveAt(index);
          } else {
            errorID(3907);
          }
        };

        _proto.pushDelayEvent = function pushDelayEvent(fn, thisArg, args) {
          this._delayEvents.push({
            fn: fn,
            thisArg: thisArg,
            args: args
          });
        };

        _proto.addSockets = function addSockets(root, sockets) {
          var _this2 = this;

          var _loop = function _loop(i) {
            var socket = sockets[i];

            if (_this2._sockets.find(function (s) {
              return s.target === socket.target;
            })) {
              return "continue";
            }

            var targetNode = root.getChildByPath(socket.path);
            var transform = socket.target && targetNode && getTransform(targetNode, root);

            if (transform) {
              _this2._sockets.push({
                target: socket.target,
                transform: transform
              });
            }
          };

          for (var i = 0; i < sockets.length; ++i) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
          }
        };

        _proto.removeSockets = function removeSockets(root, sockets) {
          for (var i = 0; i < sockets.length; ++i) {
            var socketToRemove = sockets[i];

            for (var j = 0; j < this._sockets.length; ++j) {
              var socket = this._sockets[j];

              if (socket.target === socketToRemove.target) {
                deleteTransform(socket.transform.node);
                this._sockets[j] = this._sockets[this._sockets.length - 1];
                this._sockets.length--;
                break;
              }
            }
          }
        };

        _createClass(AnimationManager, [{
          key: "blendState",
          get: function get() {
            return this._blendStateBuffer;
          }
        }]);

        return AnimationManager;
      }(System), _class2$E.ID = 'animation', _temp$G)) || _class$M);
      director.on(Director.EVENT_INIT, function () {
        var animationManager = new AnimationManager();
        director.registerSystem(AnimationManager.ID, animationManager, System.Priority.HIGH);
      });
      legacyCC.AnimationManager = AnimationManager;

      var CrossFade = function (_Playable) {
        _inheritsLoose(CrossFade, _Playable);

        function CrossFade(scheduler) {
          var _this;

          _this = _Playable.call(this) || this;
          _this._managedStates = [];
          _this._fadings = [];
          _this._scheduled = false;
          _this._scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : getGlobalAnimationManager();
          return _this;
        }

        var _proto = CrossFade.prototype;

        _proto.update = function update(deltaTime) {
          if (this.isMotionless) {
            return;
          }

          var managedStates = this._managedStates;
          var fadings = this._fadings;

          if (managedStates.length === 1 && fadings.length === 1) {
            var state = managedStates[0].state;

            if (state) {
              state.weight = 1.0;
            }
          } else {
            this._calculateWeights(deltaTime);
          }

          if (managedStates.length === 1 && fadings.length === 1) {
            this._unscheduleThis();
          }
        };

        _proto.crossFade = function crossFade(state, duration) {
          var _target$state;

          if (this._managedStates.length === 0) {
            duration = 0;
          }

          if (duration === 0) {
            this.clear();
          }

          var target = this._managedStates.find(function (weightedState) {
            return weightedState.state === state;
          });

          if (!target) {
            target = {
              state: state,
              reference: 0
            };

            if (state) {
              state.play();
            }

            this._managedStates.push(target);
          } else if ((_target$state = target.state) === null || _target$state === void 0 ? void 0 : _target$state.isMotionless) {
            target.state.play();
          }

          ++target.reference;

          this._fadings.unshift({
            easeDuration: duration,
            easeTime: 0,
            target: target
          });

          if (!this.isMotionless) {
            this._scheduleThis();
          }
        };

        _proto.clear = function clear() {
          for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
            var state = this._managedStates[iManagedState].state;

            if (state) {
              state.stop();
            }
          }

          this._managedStates.length = 0;
          this._fadings.length = 0;
        };

        _proto.onPlay = function onPlay() {
          _Playable.prototype.onPlay.call(this);

          this._scheduleThis();
        };

        _proto.onPause = function onPause() {
          _Playable.prototype.onPause.call(this);

          for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
            var state = this._managedStates[iManagedState].state;

            if (state) {
              state.pause();
            }
          }

          this._unscheduleThis();
        };

        _proto.onResume = function onResume() {
          _Playable.prototype.onResume.call(this);

          for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
            var state = this._managedStates[iManagedState].state;

            if (state) {
              state.resume();
            }
          }

          this._scheduleThis();
        };

        _proto.onStop = function onStop() {
          _Playable.prototype.onStop.call(this);

          this.clear();
        };

        _proto._calculateWeights = function _calculateWeights(deltaTime) {
          var managedStates = this._managedStates;
          var fadings = this._fadings;

          for (var iManagedState = 0; iManagedState < managedStates.length; ++iManagedState) {
            var state = managedStates[iManagedState].state;

            if (state) {
              state.weight = 0;
            }
          }

          var absoluteWeight = 1.0;
          var deadFadingBegin = fadings.length;

          for (var iFading = 0; iFading < fadings.length; ++iFading) {
            var fading = fadings[iFading];
            fading.easeTime += deltaTime;
            var relativeWeight = fading.easeDuration === 0 ? 1 : clamp01(fading.easeTime / fading.easeDuration);
            var weight = relativeWeight * absoluteWeight;
            absoluteWeight *= 1.0 - relativeWeight;

            if (fading.target.state) {
              fading.target.state.weight += weight;
            }

            if (fading.easeTime >= fading.easeDuration) {
              deadFadingBegin = iFading + 1;
              fading.easeTime = fading.easeDuration;
              break;
            }
          }

          if (deadFadingBegin !== fadings.length) {
            for (var iDeadFading = deadFadingBegin; iDeadFading < fadings.length; ++iDeadFading) {
              var deadFading = fadings[iDeadFading];
              --deadFading.target.reference;

              if (deadFading.target.reference <= 0) {
                if (deadFading.target.state) {
                  deadFading.target.state.stop();
                }

                remove(this._managedStates, deadFading.target);
              }
            }

            fadings.splice(deadFadingBegin);
          }
        };

        _proto._scheduleThis = function _scheduleThis() {
          if (!this._scheduled) {
            this._scheduler.addCrossFade(this);

            this._scheduled = true;
          }
        };

        _proto._unscheduleThis = function _unscheduleThis() {
          if (this._scheduled) {
            this._scheduler.removeCrossFade(this);

            this._scheduled = false;
          }
        };

        return CrossFade;
      }(Playable);

      var _dec$M, _dec2$v, _dec3$r, _dec4$o, _dec5$m, _dec6$j, _dec7$i, _dec8$g, _dec9$c, _dec10$b, _class$N, _class2$F, _descriptor$C, _descriptor2$v, _descriptor3$n, _class3$8, _temp$H;
      var Animation = function (v) { return exports({ Animation: v, AnimationComponent: v }), v; }((_dec$M = ccclass('cc.Animation'), _dec2$v = help(), _dec3$r = executionOrder(99), _dec4$o = menu(), _dec5$m = type([AnimationClip]), _dec6$j = tooltip(), _dec7$i = type(AnimationClip), _dec8$g = tooltip(), _dec9$c = tooltip(), _dec10$b = type([AnimationClip]), _dec$M(_class$N = _dec2$v(_class$N = _dec3$r(_class$N = executeInEditMode(_class$N = _dec4$o(_class$N = (_class2$F = (_temp$H = _class3$8 = function (_Eventify) {
        _inheritsLoose(Animation, _Eventify);

        function Animation() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Eventify.call.apply(_Eventify, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "playOnLoad", _descriptor$C, _assertThisInitialized(_this));

          _this._crossFade = new CrossFade();
          _this._nameToState = createMap(true);

          _initializerDefineProperty(_this, "_clips", _descriptor2$v, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_defaultClip", _descriptor3$n, _assertThisInitialized(_this));

          _this._hasBeenPlayed = false;
          return _this;
        }

        var _proto = Animation.prototype;

        _proto.onLoad = function onLoad() {
          this.clips = this._clips;

          for (var stateName in this._nameToState) {
            var state = this._nameToState[stateName];
            state.initialize(this.node);
          }
        };

        _proto.start = function start() {
          if ( this.playOnLoad && !this._hasBeenPlayed && this._defaultClip) {
            this.crossFade(this._defaultClip.name, 0);
          }
        };

        _proto.onEnable = function onEnable() {
          this._crossFade.resume();
        };

        _proto.onDisable = function onDisable() {
          this._crossFade.pause();
        };

        _proto.onDestroy = function onDestroy() {
          this._crossFade.stop();

          for (var name in this._nameToState) {
            var state = this._nameToState[name];
            state.destroy();
          }

          this._nameToState = createMap(true);
        };

        _proto.play = function play(name) {
          this._hasBeenPlayed = true;

          if (!name) {
            if (!this._defaultClip) {
              return;
            }

            name = this._defaultClip.name;
          }

          this.crossFade(name, 0);
        };

        _proto.crossFade = function crossFade(name, duration) {
          if (duration === void 0) {
            duration = 0.3;
          }

          this._hasBeenPlayed = true;
          var state = this._nameToState[name];

          if (state) {
            this.doPlayOrCrossFade(state, duration);
          }
        };

        _proto.pause = function pause() {
          this._crossFade.pause();
        };

        _proto.resume = function resume() {
          this._crossFade.resume();
        };

        _proto.stop = function stop() {
          this._crossFade.stop();
        };

        _proto.getState = function getState(name) {
          var state = this._nameToState[name];

          if (state && !state.curveLoaded) {
            state.initialize(this.node);
          }

          return state || null;
        };

        _proto.createState = function createState(clip, name) {
          name = name || clip.name;
          this.removeState(name);
          return this._doCreateState(clip, name);
        };

        _proto.removeState = function removeState(name) {
          var state = this._nameToState[name];

          if (state) {
            state.allowLastFrameEvent(false);
            state.stop();
            delete this._nameToState[name];
          }
        };

        _proto.addClip = function addClip(clip, name) {
          if (!contains$1(this._clips, clip)) {
            this._clips.push(clip);
          }

          return this.createState(clip, name);
        };

        _proto.removeClip = function removeClip(clip, force) {
          var removalState;

          for (var name in this._nameToState) {
            var state = this._nameToState[name];
            var stateClip = state.clip;

            if (stateClip === clip) {
              removalState = state;
              break;
            }
          }

          if (clip === this._defaultClip) {
            if (force) {
              this._defaultClip = null;
            } else {
              {
                warnID(3902);
              }

              return;
            }
          }

          if (removalState && removalState.isPlaying) {
            if (force) {
              removalState.stop();
            } else {
              {
                warnID(3903);
              }

              return;
            }
          }

          this._clips = this._clips.filter(function (item) {
            return item !== clip;
          });

          if (removalState) {
            delete this._nameToState[removalState.name];
          }
        };

        _proto.on = function on(type, callback, thisArg, once) {
          var ret = _Eventify.prototype.on.call(this, type, callback, thisArg, once);

          if (type === EventType$1.LASTFRAME) {
            this._syncAllowLastFrameEvent();
          }

          return ret;
        };

        _proto.once = function once(type, callback, thisArg) {
          var ret = _Eventify.prototype.once.call(this, type, callback, thisArg);

          if (type === EventType$1.LASTFRAME) {
            this._syncAllowLastFrameEvent();
          }

          return ret;
        };

        _proto.off = function off(type, callback, thisArg) {
          _Eventify.prototype.off.call(this, type, callback, thisArg);

          if (type === EventType$1.LASTFRAME) {
            this._syncDisallowLastFrameEvent();
          }
        };

        _proto._createState = function _createState(clip, name) {
          return new AnimationState(clip, name);
        };

        _proto._doCreateState = function _doCreateState(clip, name) {
          var state = this._createState(clip, name);

          state._setEventTarget(this);

          state.allowLastFrameEvent(this.hasEventListener(EventType$1.LASTFRAME));

          if (this.node) {
            state.initialize(this.node);
          }

          this._nameToState[state.name] = state;
          return state;
        };

        _proto.doPlayOrCrossFade = function doPlayOrCrossFade(state, duration) {
          this._crossFade.play();

          this._crossFade.crossFade(state, duration);
        };

        _proto._removeStateOfAutomaticClip = function _removeStateOfAutomaticClip(clip) {
          for (var name in this._nameToState) {
            var state = this._nameToState[name];

            if (equalClips(clip, state.clip)) {
              state.stop();
              delete this._nameToState[name];
            }
          }
        };

        _proto._syncAllowLastFrameEvent = function _syncAllowLastFrameEvent() {
          if (this.hasEventListener(EventType$1.LASTFRAME)) {
            for (var stateName in this._nameToState) {
              this._nameToState[stateName].allowLastFrameEvent(true);
            }
          }
        };

        _proto._syncDisallowLastFrameEvent = function _syncDisallowLastFrameEvent() {
          if (!this.hasEventListener(EventType$1.LASTFRAME)) {
            for (var stateName in this._nameToState) {
              this._nameToState[stateName].allowLastFrameEvent(false);
            }
          }
        };

        _createClass(Animation, [{
          key: "clips",
          get: function get() {
            return this._clips;
          },
          set: function set(value) {
            var _this2 = this;

            if (this._crossFade) {
              this._crossFade.clear();
            }

            for (var _iterator = _createForOfIteratorHelperLoose(this._clips), _step; !(_step = _iterator()).done;) {
              var clip = _step.value;

              if (clip) {
                this._removeStateOfAutomaticClip(clip);
              }
            }

            for (var _iterator2 = _createForOfIteratorHelperLoose(value), _step2; !(_step2 = _iterator2()).done;) {
              var _clip = _step2.value;

              if (_clip) {
                this.createState(_clip);
              }
            }

            var newDefaultClip = value.find(function (clip) {
              return equalClips(clip, _this2._defaultClip);
            });

            if (newDefaultClip) {
              this._defaultClip = newDefaultClip;
            } else {
              this._defaultClip = null;
            }

            this._clips = value;
          }
        }, {
          key: "defaultClip",
          get: function get() {
            return this._defaultClip;
          },
          set: function set(value) {
            this._defaultClip = value;

            if (!value) {
              return;
            }

            var isBoundedDefaultClip = this._clips.findIndex(function (clip) {
              return equalClips(clip, value);
            }) >= 0;

            if (!isBoundedDefaultClip) {
              this._clips.push(value);

              this.createState(value);
            }
          }
        }]);

        return Animation;
      }(Eventify(Component)), _class3$8.EventType = EventType$1, _temp$H), (_applyDecoratedDescriptor(_class2$F.prototype, "clips", [_dec5$m, _dec6$j], Object.getOwnPropertyDescriptor(_class2$F.prototype, "clips"), _class2$F.prototype), _applyDecoratedDescriptor(_class2$F.prototype, "defaultClip", [_dec7$i, _dec8$g], Object.getOwnPropertyDescriptor(_class2$F.prototype, "defaultClip"), _class2$F.prototype), _descriptor$C = _applyDecoratedDescriptor(_class2$F.prototype, "playOnLoad", [serializable, _dec9$c], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor2$v = _applyDecoratedDescriptor(_class2$F.prototype, "_clips", [_dec10$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3$n = _applyDecoratedDescriptor(_class2$F.prototype, "_defaultClip", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$F)) || _class$N) || _class$N) || _class$N) || _class$N) || _class$N));

      function equalClips(clip1, clip2) {
        if (clip1 === clip2) {
          return true;
        }

        return !!clip1 && !!clip2 && clip1._uuid === clip2._uuid && clip1._uuid;
      }

      legacyCC.Animation = Animation;
      legacyCC.AnimationComponent = Animation;
      js.setClassAlias(Animation, 'cc.AnimationComponent');

      legacyCC.easing = easing;

      legacyCC.log = log;
      legacyCC.warn = warn;
      legacyCC.error = error;
      legacyCC.assert = assert;
      legacyCC._throw = _throw;
      legacyCC.logID = logID;
      legacyCC.warnID = warnID;
      legacyCC.errorID = errorID;
      legacyCC.assertID = assertID;
      legacyCC.debug = debug$1;
      legacyCC.path = {
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,

        get sep() {
          return getSeperator();
        }

      };

      var NodePool$1 = exports('NodePool', function () {
        function NodePool(poolHandlerComp) {
          this.poolHandlerComp = void 0;
          this._pool = void 0;
          this.poolHandlerComp = poolHandlerComp;
          this._pool = [];
        }

        var _proto = NodePool.prototype;

        _proto.size = function size() {
          return this._pool.length;
        };

        _proto.clear = function clear() {
          var count = this._pool.length;

          for (var i = 0; i < count; ++i) {
            this._pool[i].destroy();
          }

          this._pool.length = 0;
        };

        _proto.put = function put(obj) {
          if (obj && this._pool.indexOf(obj) === -1) {
            obj.removeFromParent();
            var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

            if (handler && handler.unuse) {
              handler.unuse();
            }

            this._pool.push(obj);
          }
        };

        _proto.get = function get() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var last = this._pool.length - 1;

          if (last < 0) {
            return null;
          } else {
            var obj = this._pool[last];
            this._pool.length = last;
            var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

            if (handler && handler.reuse) {
              handler.reuse(arguments);
            }

            return obj;
          }
        };

        return NodePool;
      }());
      legacyCC.NodePool = NodePool$1;

      var _globalThis$jsb, _globalJsb$copyTextTo;
      var globalJsb = (_globalThis$jsb = globalThis.jsb) !== null && _globalThis$jsb !== void 0 ? _globalThis$jsb : {};

      var _native = exports('native', {
        DownloaderHints: globalJsb.DownloaderHints,
        Downloader: globalJsb.Downloader,
        zipUtils: globalJsb.zipUtils,
        fileUtils: globalJsb.fileUtils,
        DebugRenderer: globalJsb.DebugRenderer,
        copyTextToClipboard: (_globalJsb$copyTextTo = globalJsb.copyTextToClipboard) === null || _globalJsb$copyTextTo === void 0 ? void 0 : _globalJsb$copyTextTo.bind(globalJsb),
        garbageCollect: globalJsb.garbageCollect,
        reflection: globalJsb.reflection,
        bridge: globalJsb.bridge,
        jsbBridgeWrapper: globalJsb.jsbBridgeWrapper,
        AssetsManager: globalJsb.AssetsManager,
        EventAssetsManager: globalJsb.EventAssetsManager,
        Manifest: globalJsb.Manifest,
        saveImageData: globalJsb.saveImageData
      });

      legacyCC.renderer = renderer;

      var WebGLDescriptorSet = function (_DescriptorSet) {
        _inheritsLoose(WebGLDescriptorSet, _DescriptorSet);

        function WebGLDescriptorSet() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _DescriptorSet.call.apply(_DescriptorSet, [this].concat(args)) || this;
          _this._gpuDescriptorSet = null;
          return _this;
        }

        var _proto = WebGLDescriptorSet.prototype;

        _proto.initialize = function initialize(info) {
          this._layout = info.layout;
          var _gpuDescriptorSetLayo = info.layout.gpuDescriptorSetLayout,
              bindings = _gpuDescriptorSetLayo.bindings,
              descriptorIndices = _gpuDescriptorSetLayo.descriptorIndices,
              descriptorCount = _gpuDescriptorSetLayo.descriptorCount;
          this._buffers = Array(descriptorCount).fill(null);
          this._textures = Array(descriptorCount).fill(null);
          this._samplers = Array(descriptorCount).fill(null);
          var gpuDescriptors = [];
          this._gpuDescriptorSet = {
            gpuDescriptors: gpuDescriptors,
            descriptorIndices: descriptorIndices
          };

          for (var i = 0; i < bindings.length; ++i) {
            var binding = bindings[i];

            for (var j = 0; j < binding.count; j++) {
              gpuDescriptors.push({
                type: binding.descriptorType,
                gpuBuffer: null,
                gpuTexture: null,
                gpuSampler: null
              });
            }
          }
        };

        _proto.destroy = function destroy() {
          this._layout = null;
          this._gpuDescriptorSet = null;
        };

        _proto.update = function update() {
          if (this._isDirty && this._gpuDescriptorSet) {
            var descriptors = this._gpuDescriptorSet.gpuDescriptors;

            for (var i = 0; i < descriptors.length; ++i) {
              if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                var buffer = this._buffers[i];

                if (buffer) {
                  descriptors[i].gpuBuffer = buffer.gpuBuffer || buffer.gpuBufferView;
                }
              } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                if (this._textures[i]) {
                  descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                }

                if (this._samplers[i]) {
                  descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                }
              }
            }

            this._isDirty = false;
          }
        };

        _createClass(WebGLDescriptorSet, [{
          key: "gpuDescriptorSet",
          get: function get() {
            return this._gpuDescriptorSet;
          }
        }]);

        return WebGLDescriptorSet;
      }(DescriptorSet);

      var WebGLEXT;

      (function (WebGLEXT) {
        WebGLEXT[WebGLEXT["RGBA16F_EXT"] = 34842] = "RGBA16F_EXT";
        WebGLEXT[WebGLEXT["RGB16F_EXT"] = 34843] = "RGB16F_EXT";
        WebGLEXT[WebGLEXT["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
        WebGLEXT[WebGLEXT["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
        WebGLEXT[WebGLEXT["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
        WebGLEXT[WebGLEXT["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
        WebGLEXT[WebGLEXT["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
        WebGLEXT[WebGLEXT["SRGB_EXT"] = 35904] = "SRGB_EXT";
        WebGLEXT[WebGLEXT["SRGB_ALPHA_EXT"] = 35906] = "SRGB_ALPHA_EXT";
        WebGLEXT[WebGLEXT["SRGB8_ALPHA8_EXT"] = 35907] = "SRGB8_ALPHA8_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
        WebGLEXT[WebGLEXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
      })(WebGLEXT || (WebGLEXT = {}));

      var WebGLDeviceManager = function () {
        function WebGLDeviceManager() {}

        WebGLDeviceManager.setInstance = function setInstance(instance) {
          WebGLDeviceManager._instance = instance;
        };

        _createClass(WebGLDeviceManager, null, [{
          key: "instance",
          get: function get() {
            return WebGLDeviceManager._instance;
          }
        }]);

        return WebGLDeviceManager;
      }();
      WebGLDeviceManager._instance = null;

      function GFXFormatToWebGLType(format, gl) {
        switch (format) {
          case Format.R8:
            return gl.UNSIGNED_BYTE;

          case Format.R8SN:
            return gl.BYTE;

          case Format.R8UI:
            return gl.UNSIGNED_BYTE;

          case Format.R8I:
            return gl.BYTE;

          case Format.R16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case Format.R16UI:
            return gl.UNSIGNED_SHORT;

          case Format.R16I:
            return gl.SHORT;

          case Format.R32F:
            return gl.FLOAT;

          case Format.R32UI:
            return gl.UNSIGNED_INT;

          case Format.R32I:
            return gl.INT;

          case Format.RG8:
            return gl.UNSIGNED_BYTE;

          case Format.RG8SN:
            return gl.BYTE;

          case Format.RG8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RG8I:
            return gl.BYTE;

          case Format.RG16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case Format.RG16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RG16I:
            return gl.SHORT;

          case Format.RG32F:
            return gl.FLOAT;

          case Format.RG32UI:
            return gl.UNSIGNED_INT;

          case Format.RG32I:
            return gl.INT;

          case Format.RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.SRGB8:
            return gl.UNSIGNED_BYTE;

          case Format.RGB8SN:
            return gl.BYTE;

          case Format.RGB8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RGB8I:
            return gl.BYTE;

          case Format.RGB16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case Format.RGB16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RGB16I:
            return gl.SHORT;

          case Format.RGB32F:
            return gl.FLOAT;

          case Format.RGB32UI:
            return gl.UNSIGNED_INT;

          case Format.RGB32I:
            return gl.INT;

          case Format.BGRA8:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8:
            return gl.UNSIGNED_BYTE;

          case Format.SRGB8_A8:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8SN:
            return gl.BYTE;

          case Format.RGBA8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8I:
            return gl.BYTE;

          case Format.RGBA16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case Format.RGBA16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RGBA16I:
            return gl.SHORT;

          case Format.RGBA32F:
            return gl.FLOAT;

          case Format.RGBA32UI:
            return gl.UNSIGNED_INT;

          case Format.RGBA32I:
            return gl.INT;

          case Format.R5G6B5:
            return gl.UNSIGNED_SHORT_5_6_5;

          case Format.R11G11B10F:
            return gl.FLOAT;

          case Format.RGB5A1:
            return gl.UNSIGNED_SHORT_5_5_5_1;

          case Format.RGBA4:
            return gl.UNSIGNED_SHORT_4_4_4_4;

          case Format.RGB10A2:
            return gl.UNSIGNED_BYTE;

          case Format.RGB10A2UI:
            return gl.UNSIGNED_INT;

          case Format.RGB9E5:
            return gl.UNSIGNED_BYTE;

          case Format.DEPTH:
            return gl.UNSIGNED_INT;

          case Format.DEPTH_STENCIL:
            return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

          case Format.BC1:
            return gl.UNSIGNED_BYTE;

          case Format.BC1_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC2:
            return gl.UNSIGNED_BYTE;

          case Format.BC2_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC3:
            return gl.UNSIGNED_BYTE;

          case Format.BC3_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC4:
            return gl.UNSIGNED_BYTE;

          case Format.BC4_SNORM:
            return gl.BYTE;

          case Format.BC5:
            return gl.UNSIGNED_BYTE;

          case Format.BC5_SNORM:
            return gl.BYTE;

          case Format.BC6H_SF16:
            return gl.FLOAT;

          case Format.BC6H_UF16:
            return gl.FLOAT;

          case Format.BC7:
            return gl.UNSIGNED_BYTE;

          case Format.BC7_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.ETC_RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_SRGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_RGB8_A1:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_SRGB8_A1:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_R11:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_R11SN:
            return gl.BYTE;

          case Format.EAC_RG11:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_RG11SN:
            return gl.BYTE;

          case Format.PVRTC_RGB2:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGBA2:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGB4:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGBA4:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC2_2BPP:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC2_4BPP:
            return gl.UNSIGNED_BYTE;

          case Format.ASTC_RGBA_4X4:
          case Format.ASTC_RGBA_5X4:
          case Format.ASTC_RGBA_5X5:
          case Format.ASTC_RGBA_6X5:
          case Format.ASTC_RGBA_6X6:
          case Format.ASTC_RGBA_8X5:
          case Format.ASTC_RGBA_8X6:
          case Format.ASTC_RGBA_8X8:
          case Format.ASTC_RGBA_10X5:
          case Format.ASTC_RGBA_10X6:
          case Format.ASTC_RGBA_10X8:
          case Format.ASTC_RGBA_10X10:
          case Format.ASTC_RGBA_12X10:
          case Format.ASTC_RGBA_12X12:
          case Format.ASTC_SRGBA_4X4:
          case Format.ASTC_SRGBA_5X4:
          case Format.ASTC_SRGBA_5X5:
          case Format.ASTC_SRGBA_6X5:
          case Format.ASTC_SRGBA_6X6:
          case Format.ASTC_SRGBA_8X5:
          case Format.ASTC_SRGBA_8X6:
          case Format.ASTC_SRGBA_8X8:
          case Format.ASTC_SRGBA_10X5:
          case Format.ASTC_SRGBA_10X6:
          case Format.ASTC_SRGBA_10X8:
          case Format.ASTC_SRGBA_10X10:
          case Format.ASTC_SRGBA_12X10:
          case Format.ASTC_SRGBA_12X12:
            return gl.UNSIGNED_BYTE;

          default:
            {
              return gl.UNSIGNED_BYTE;
            }
        }
      }
      function GFXFormatToWebGLInternalFormat(format, gl) {
        switch (format) {
          case Format.R5G6B5:
            return gl.RGB565;

          case Format.RGB5A1:
            return gl.RGB5_A1;

          case Format.RGBA4:
            return gl.RGBA4;

          case Format.RGBA16F:
            return WebGLEXT.RGBA16F_EXT;

          case Format.RGBA32F:
            return WebGLEXT.RGBA32F_EXT;

          case Format.SRGB8_A8:
            return WebGLEXT.SRGB8_ALPHA8_EXT;

          case Format.DEPTH:
            return gl.DEPTH_COMPONENT16;

          case Format.DEPTH_STENCIL:
            return gl.DEPTH_STENCIL;

          default:
            {
              console.error('Unsupported Format, convert to WebGL internal format failed.');
              return gl.RGBA;
            }
        }
      }
      function GFXFormatToWebGLFormat(format, gl) {
        switch (format) {
          case Format.A8:
            return gl.ALPHA;

          case Format.L8:
            return gl.LUMINANCE;

          case Format.LA8:
            return gl.LUMINANCE_ALPHA;

          case Format.RGB8:
            return gl.RGB;

          case Format.RGB16F:
            return gl.RGB;

          case Format.RGB32F:
            return gl.RGB;

          case Format.BGRA8:
            return gl.RGBA;

          case Format.RGBA8:
            return gl.RGBA;

          case Format.SRGB8_A8:
            return gl.RGBA;

          case Format.RGBA16F:
            return gl.RGBA;

          case Format.RGBA32F:
            return gl.RGBA;

          case Format.R5G6B5:
            return gl.RGB;

          case Format.RGB5A1:
            return gl.RGBA;

          case Format.RGBA4:
            return gl.RGBA;

          case Format.DEPTH:
            return gl.DEPTH_COMPONENT;

          case Format.DEPTH_STENCIL:
            return gl.DEPTH_STENCIL;

          case Format.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case Format.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case Format.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case Format.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case Format.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case Format.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case Format.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case Format.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case Format.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

          case Format.ETC2_RGB8:
            return WebGLEXT.COMPRESSED_RGB8_ETC2;

          case Format.ETC2_SRGB8:
            return WebGLEXT.COMPRESSED_SRGB8_ETC2;

          case Format.ETC2_RGB8_A1:
            return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case Format.ETC2_SRGB8_A1:
            return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case Format.ETC2_RGBA8:
            return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

          case Format.ETC2_SRGB8_A8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

          case Format.EAC_R11:
            return WebGLEXT.COMPRESSED_R11_EAC;

          case Format.EAC_R11SN:
            return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

          case Format.EAC_RG11:
            return WebGLEXT.COMPRESSED_RG11_EAC;

          case Format.EAC_RG11SN:
            return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

          case Format.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case Format.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case Format.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case Format.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          case Format.ASTC_RGBA_4X4:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

          case Format.ASTC_RGBA_5X4:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

          case Format.ASTC_RGBA_5X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

          case Format.ASTC_RGBA_6X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

          case Format.ASTC_RGBA_6X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

          case Format.ASTC_RGBA_8X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

          case Format.ASTC_RGBA_8X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

          case Format.ASTC_RGBA_8X8:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

          case Format.ASTC_RGBA_10X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

          case Format.ASTC_RGBA_10X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

          case Format.ASTC_RGBA_10X8:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

          case Format.ASTC_RGBA_10X10:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

          case Format.ASTC_RGBA_12X10:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

          case Format.ASTC_RGBA_12X12:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

          case Format.ASTC_SRGBA_4X4:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

          case Format.ASTC_SRGBA_5X4:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

          case Format.ASTC_SRGBA_5X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

          case Format.ASTC_SRGBA_6X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

          case Format.ASTC_SRGBA_6X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

          case Format.ASTC_SRGBA_8X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

          case Format.ASTC_SRGBA_8X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

          case Format.ASTC_SRGBA_8X8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

          case Format.ASTC_SRGBA_10X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

          case Format.ASTC_SRGBA_10X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

          case Format.ASTC_SRGBA_10X8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

          case Format.ASTC_SRGBA_10X10:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

          case Format.ASTC_SRGBA_12X10:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

          case Format.ASTC_SRGBA_12X12:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

          default:
            {
              console.error('Unsupported Format, convert to WebGL format failed.');
              return gl.RGBA;
            }
        }
      }

      function GFXTypeToWebGLType(type, gl) {
        switch (type) {
          case Type$1.BOOL:
            return gl.BOOL;

          case Type$1.BOOL2:
            return gl.BOOL_VEC2;

          case Type$1.BOOL3:
            return gl.BOOL_VEC3;

          case Type$1.BOOL4:
            return gl.BOOL_VEC4;

          case Type$1.INT:
            return gl.INT;

          case Type$1.INT2:
            return gl.INT_VEC2;

          case Type$1.INT3:
            return gl.INT_VEC3;

          case Type$1.INT4:
            return gl.INT_VEC4;

          case Type$1.UINT:
            return gl.UNSIGNED_INT;

          case Type$1.FLOAT:
            return gl.FLOAT;

          case Type$1.FLOAT2:
            return gl.FLOAT_VEC2;

          case Type$1.FLOAT3:
            return gl.FLOAT_VEC3;

          case Type$1.FLOAT4:
            return gl.FLOAT_VEC4;

          case Type$1.MAT2:
            return gl.FLOAT_MAT2;

          case Type$1.MAT3:
            return gl.FLOAT_MAT3;

          case Type$1.MAT4:
            return gl.FLOAT_MAT4;

          case Type$1.SAMPLER2D:
            return gl.SAMPLER_2D;

          case Type$1.SAMPLER_CUBE:
            return gl.SAMPLER_CUBE;

          default:
            {
              console.error('Unsupported GLType, convert to GL type failed.');
              return Type$1.UNKNOWN;
            }
        }
      }

      function GFXTypeToTypedArrayCtor(type) {
        switch (type) {
          case Type$1.BOOL:
          case Type$1.BOOL2:
          case Type$1.BOOL3:
          case Type$1.BOOL4:
          case Type$1.INT:
          case Type$1.INT2:
          case Type$1.INT3:
          case Type$1.INT4:
          case Type$1.UINT:
            return Int32Array;

          case Type$1.FLOAT:
          case Type$1.FLOAT2:
          case Type$1.FLOAT3:
          case Type$1.FLOAT4:
          case Type$1.MAT2:
          case Type$1.MAT3:
          case Type$1.MAT4:
            return Float32Array;

          default:
            {
              console.error('Unsupported GLType, convert to TypedArrayConstructor failed.');
              return Float32Array;
            }
        }
      }

      function WebGLTypeToGFXType(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return Type$1.BOOL;

          case gl.BOOL_VEC2:
            return Type$1.BOOL2;

          case gl.BOOL_VEC3:
            return Type$1.BOOL3;

          case gl.BOOL_VEC4:
            return Type$1.BOOL4;

          case gl.INT:
            return Type$1.INT;

          case gl.INT_VEC2:
            return Type$1.INT2;

          case gl.INT_VEC3:
            return Type$1.INT3;

          case gl.INT_VEC4:
            return Type$1.INT4;

          case gl.UNSIGNED_INT:
            return Type$1.UINT;

          case gl.FLOAT:
            return Type$1.FLOAT;

          case gl.FLOAT_VEC2:
            return Type$1.FLOAT2;

          case gl.FLOAT_VEC3:
            return Type$1.FLOAT3;

          case gl.FLOAT_VEC4:
            return Type$1.FLOAT4;

          case gl.FLOAT_MAT2:
            return Type$1.MAT2;

          case gl.FLOAT_MAT3:
            return Type$1.MAT3;

          case gl.FLOAT_MAT4:
            return Type$1.MAT4;

          case gl.SAMPLER_2D:
            return Type$1.SAMPLER2D;

          case gl.SAMPLER_CUBE:
            return Type$1.SAMPLER_CUBE;

          default:
            {
              console.error('Unsupported GLType, convert to Type failed.');
              return Type$1.UNKNOWN;
            }
        }
      }

      function WebGLGetTypeSize(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return 4;

          case gl.BOOL_VEC2:
            return 8;

          case gl.BOOL_VEC3:
            return 12;

          case gl.BOOL_VEC4:
            return 16;

          case gl.INT:
            return 4;

          case gl.INT_VEC2:
            return 8;

          case gl.INT_VEC3:
            return 12;

          case gl.INT_VEC4:
            return 16;

          case gl.UNSIGNED_INT:
            return 4;

          case gl.FLOAT:
            return 4;

          case gl.FLOAT_VEC2:
            return 8;

          case gl.FLOAT_VEC3:
            return 12;

          case gl.FLOAT_VEC4:
            return 16;

          case gl.FLOAT_MAT2:
            return 16;

          case gl.FLOAT_MAT3:
            return 36;

          case gl.FLOAT_MAT4:
            return 64;

          case gl.SAMPLER_2D:
            return 4;

          case gl.SAMPLER_CUBE:
            return 4;

          default:
            {
              console.error('Unsupported GLType, get type failed.');
              return 0;
            }
        }
      }

      function WebGLGetComponentCount(glType, gl) {
        switch (glType) {
          case gl.FLOAT_MAT2:
            return 2;

          case gl.FLOAT_MAT3:
            return 3;

          case gl.FLOAT_MAT4:
            return 4;

          default:
            {
              return 1;
            }
        }
      }

      var WebGLCmpFuncs = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
      var WebGLStencilOps = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
      var WebGLBlendOps = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
      var WebGLBlendFactors = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
      var WebGLCmd;

      (function (WebGLCmd) {
        WebGLCmd[WebGLCmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
        WebGLCmd[WebGLCmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
        WebGLCmd[WebGLCmd["BIND_STATES"] = 2] = "BIND_STATES";
        WebGLCmd[WebGLCmd["DRAW"] = 3] = "DRAW";
        WebGLCmd[WebGLCmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
        WebGLCmd[WebGLCmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
        WebGLCmd[WebGLCmd["COUNT"] = 6] = "COUNT";
      })(WebGLCmd || (WebGLCmd = {}));

      var WebGLCmdObject = function WebGLCmdObject(type) {
        this.cmdType = void 0;
        this.refCount = 0;
        this.cmdType = type;
      };
      var WebGLCmdBeginRenderPass = function (_WebGLCmdObject) {
        _inheritsLoose(WebGLCmdBeginRenderPass, _WebGLCmdObject);

        function WebGLCmdBeginRenderPass() {
          var _this;

          _this = _WebGLCmdObject.call(this, WebGLCmd.BEGIN_RENDER_PASS) || this;
          _this.gpuRenderPass = null;
          _this.gpuFramebuffer = null;
          _this.renderArea = new Rect$1();
          _this.clearFlag = ClearFlagBit.NONE;
          _this.clearColors = [];
          _this.clearDepth = 1.0;
          _this.clearStencil = 0;
          return _this;
        }

        var _proto = WebGLCmdBeginRenderPass.prototype;

        _proto.clear = function clear() {
          this.gpuFramebuffer = null;
          this.clearColors.length = 0;
        };

        return WebGLCmdBeginRenderPass;
      }(WebGLCmdObject);
      var WebGLCmdBindStates = function (_WebGLCmdObject2) {
        _inheritsLoose(WebGLCmdBindStates, _WebGLCmdObject2);

        function WebGLCmdBindStates() {
          var _this2;

          _this2 = _WebGLCmdObject2.call(this, WebGLCmd.BIND_STATES) || this;
          _this2.gpuPipelineState = null;
          _this2.gpuInputAssembler = null;
          _this2.gpuDescriptorSets = [];
          _this2.dynamicOffsets = [];
          _this2.dynamicStates = new DynamicStates();
          return _this2;
        }

        var _proto2 = WebGLCmdBindStates.prototype;

        _proto2.clear = function clear() {
          this.gpuPipelineState = null;
          this.gpuDescriptorSets.length = 0;
          this.gpuInputAssembler = null;
          this.dynamicOffsets.length = 0;
        };

        return WebGLCmdBindStates;
      }(WebGLCmdObject);
      var WebGLCmdDraw = function (_WebGLCmdObject3) {
        _inheritsLoose(WebGLCmdDraw, _WebGLCmdObject3);

        function WebGLCmdDraw() {
          var _this3;

          _this3 = _WebGLCmdObject3.call(this, WebGLCmd.DRAW) || this;
          _this3.drawInfo = new DrawInfo();
          return _this3;
        }

        var _proto3 = WebGLCmdDraw.prototype;

        _proto3.clear = function clear() {};

        return WebGLCmdDraw;
      }(WebGLCmdObject);
      var WebGLCmdUpdateBuffer = function (_WebGLCmdObject4) {
        _inheritsLoose(WebGLCmdUpdateBuffer, _WebGLCmdObject4);

        function WebGLCmdUpdateBuffer() {
          var _this4;

          _this4 = _WebGLCmdObject4.call(this, WebGLCmd.UPDATE_BUFFER) || this;
          _this4.gpuBuffer = null;
          _this4.buffer = null;
          _this4.offset = 0;
          _this4.size = 0;
          return _this4;
        }

        var _proto4 = WebGLCmdUpdateBuffer.prototype;

        _proto4.clear = function clear() {
          this.gpuBuffer = null;
          this.buffer = null;
        };

        return WebGLCmdUpdateBuffer;
      }(WebGLCmdObject);
      var WebGLCmdCopyBufferToTexture = function (_WebGLCmdObject5) {
        _inheritsLoose(WebGLCmdCopyBufferToTexture, _WebGLCmdObject5);

        function WebGLCmdCopyBufferToTexture() {
          var _this5;

          _this5 = _WebGLCmdObject5.call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE) || this;
          _this5.gpuTexture = null;
          _this5.buffers = [];
          _this5.regions = [];
          return _this5;
        }

        var _proto5 = WebGLCmdCopyBufferToTexture.prototype;

        _proto5.clear = function clear() {
          this.gpuTexture = null;
          this.buffers.length = 0;
          this.regions.length = 0;
        };

        return WebGLCmdCopyBufferToTexture;
      }(WebGLCmdObject);
      var WebGLCmdPackage = function () {
        function WebGLCmdPackage() {
          this.cmds = new CachedArray(1);
          this.beginRenderPassCmds = new CachedArray(1);
          this.bindStatesCmds = new CachedArray(1);
          this.drawCmds = new CachedArray(1);
          this.updateBufferCmds = new CachedArray(1);
          this.copyBufferToTextureCmds = new CachedArray(1);
        }

        var _proto6 = WebGLCmdPackage.prototype;

        _proto6.clearCmds = function clearCmds(allocator) {
          if (this.beginRenderPassCmds.length) {
            allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
            this.beginRenderPassCmds.clear();
          }

          if (this.bindStatesCmds.length) {
            allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
            this.bindStatesCmds.clear();
          }

          if (this.drawCmds.length) {
            allocator.drawCmdPool.freeCmds(this.drawCmds);
            this.drawCmds.clear();
          }

          if (this.updateBufferCmds.length) {
            allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
            this.updateBufferCmds.clear();
          }

          if (this.copyBufferToTextureCmds.length) {
            allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
            this.copyBufferToTextureCmds.clear();
          }

          this.cmds.clear();
        };

        return WebGLCmdPackage;
      }();
      function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;
        var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          gpuBuffer.glTarget = gl.ARRAY_BUFFER;
          var glBuffer = gl.createBuffer();

          if (glBuffer) {
            gpuBuffer.glBuffer = glBuffer;

            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  cache.glVAO = null;
                }
              }

              gfxStateCache.gpuInputAssembler = null;

              if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
              }

              gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;

          var _glBuffer = gl.createBuffer();

          if (_glBuffer) {
            gpuBuffer.glBuffer = _glBuffer;

            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  cache.glVAO = null;
                }
              }

              gfxStateCache.gpuInputAssembler = null;

              if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
              }

              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          gpuBuffer.glTarget = gl.NONE;

          if (gpuBuffer.buffer) {
            gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          console.error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;

        if (gpuBuffer.glBuffer) {
          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  device.stateCache.glVAO = null;
                }
              }

              gfxStateCache.gpuInputAssembler = null;
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
              break;

            case gl.ELEMENT_ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  device.stateCache.glVAO = null;
                }
              }

              gfxStateCache.gpuInputAssembler = null;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
              break;
          }

          gl.deleteBuffer(gpuBuffer.glBuffer);
          gpuBuffer.glBuffer = null;
        }
      }
      function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;
        var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
              cache.glVAO = null;
            }
          }

          gfxStateCache.gpuInputAssembler = null;

          if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
          }

          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }

          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          device.stateCache.glArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
              cache.glVAO = null;
            }
          }

          gfxStateCache.gpuInputAssembler = null;

          if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
          }

          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }

          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          device.stateCache.glElementArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          if (gpuBuffer.buffer) {
            gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          console.error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
        if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          if (ArrayBuffer.isView(buffer)) {
            gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT);
          } else {
            gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.indirects.clearDraws();
          var drawInfos = buffer.drawInfos;

          for (var i = 0; i < drawInfos.length; ++i) {
            gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
          }
        } else {
          var buff = buffer;
          var gl = device.gl;
          var cache = device.stateCache;

          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache.gpuInputAssembler = null;

                if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                  device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                }

                break;
              }

            case gl.ELEMENT_ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache.gpuInputAssembler = null;

                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                  device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                }

                break;
              }

            default:
              {
                console.error('Unsupported BufferType, update buffer failed.');
                return;
              }
          }

          if (size === buff.byteLength) {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
          } else {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
          }
        }
      }
      function WebGLCmdFuncCreateTexture(device, gpuTexture) {
        var gl = device.gl;
        gpuTexture.glFormat = gpuTexture.glInternalFmt = GFXFormatToWebGLFormat(gpuTexture.format, gl);
        gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
        var w = gpuTexture.width;
        var h = gpuTexture.height;

        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              if (gpuTexture.isSwapchainTexture) break;
              var maxSize = Math.max(w, h);

              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }

              if (!device.textureExclusive[gpuTexture.format] && !device.extensions.WEBGL_depth_texture && FormatInfos[gpuTexture.format].hasDepth) {
                gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl);
                gpuTexture.glRenderbuffer = gl.createRenderbuffer();

                if (gpuTexture.size > 0) {
                  if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                    gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                    device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                  }

                  gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                }
              } else {
                gpuTexture.glTexture = gl.createTexture();

                if (gpuTexture.size > 0) {
                  var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                  if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                    gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                    glTexUnit.glTexture = gpuTexture.glTexture;
                  }

                  if (FormatInfos[gpuTexture.format].isCompressed) {
                    for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                      var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                      var view = new Uint8Array(imgSize);
                      gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  } else {
                    for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                      gl.texImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }

                  if (gpuTexture.isPowerOf2) {
                    gpuTexture.glWrapS = gl.REPEAT;
                    gpuTexture.glWrapT = gl.REPEAT;
                  } else {
                    gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                    gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                  }

                  gpuTexture.glMinFilter = gl.LINEAR;
                  gpuTexture.glMagFilter = gl.LINEAR;
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                }
              }

              break;
            }

          case TextureType.CUBE:
            {
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

              var _maxSize = Math.max(w, h);

              if (_maxSize > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, _maxSize, device.capabilities.maxTextureSize);
              }

              gpuTexture.glTexture = gl.createTexture();

              if (gpuTexture.size > 0) {
                var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                  _glTexUnit.glTexture = gpuTexture.glTexture;
                }

                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (var f = 0; f < 6; ++f) {
                    w = gpuTexture.width;
                    h = gpuTexture.height;

                    for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                      var _imgSize = FormatSize(gpuTexture.format, w, h, 1);

                      var _view = new Uint8Array(_imgSize);

                      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternalFmt, w, h, 0, _view);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }
                } else {
                  for (var _f = 0; _f < 6; ++_f) {
                    w = gpuTexture.width;
                    h = gpuTexture.height;

                    for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }
                }

                if (gpuTexture.isPowerOf2) {
                  gpuTexture.glWrapS = gl.REPEAT;
                  gpuTexture.glWrapT = gl.REPEAT;
                } else {
                  gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                  gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                }

                gpuTexture.glMinFilter = gl.LINEAR;
                gpuTexture.glMagFilter = gl.LINEAR;
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
              }

              break;
            }

          default:
            {
              console.error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
        var gl = device.gl;

        if (gpuTexture.glTexture) {
          var glTexUnits = device.stateCache.glTexUnits;
          var texUnit = device.stateCache.texUnit;
          gl.deleteTexture(gpuTexture.glTexture);

          for (var i = 0; i < glTexUnits.length; i++) {
            if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
              gl.activeTexture(gl.TEXTURE0 + i);
              texUnit = i;
              gl.bindTexture(gpuTexture.glTarget, null);
              glTexUnits[i].glTexture = null;
            }
          }

          device.stateCache.texUnit = texUnit;
          gpuTexture.glTexture = null;
        }

        if (gpuTexture.glRenderbuffer) {
          var glRenderbuffer = device.stateCache.glRenderbuffer;
          gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);

          if (glRenderbuffer === gpuTexture.glRenderbuffer) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            glRenderbuffer = null;
          }

          gpuTexture.glRenderbuffer = null;
        }
      }
      function WebGLCmdFuncResizeTexture(device, gpuTexture) {
        if (!gpuTexture.size) return;
        var gl = device.gl;
        var w = gpuTexture.width;
        var h = gpuTexture.height;

        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              var maxSize = Math.max(w, h);

              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }

              if (gpuTexture.glRenderbuffer) {
                if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                  device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                }

                gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
              } else if (gpuTexture.glTexture) {
                var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }

                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                    var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                    var view = new Uint8Array(imgSize);
                    gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                    gl.texImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              }

              break;
            }

          case TextureType.CUBE:
            {
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

              var _maxSize2 = Math.max(w, h);

              if (_maxSize2 > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, _maxSize2, device.capabilities.maxTextureSize);
              }

              var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                _glTexUnit2.glTexture = gpuTexture.glTexture;
              }

              if (FormatInfos[gpuTexture.format].isCompressed) {
                for (var f = 0; f < 6; ++f) {
                  w = gpuTexture.width;
                  h = gpuTexture.height;

                  for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) {
                    var _imgSize2 = FormatSize(gpuTexture.format, w, h, 1);

                    var _view2 = new Uint8Array(_imgSize2);

                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternalFmt, w, h, 0, _view2);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              } else {
                for (var _f2 = 0; _f2 < 6; ++_f2) {
                  w = gpuTexture.width;
                  h = gpuTexture.height;

                  for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, _i6, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
        for (var i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
          var tex = gpuFramebuffer.gpuColorTextures[i];

          if (tex.isSwapchainTexture) {
            gpuFramebuffer.isOffscreen = false;
            return;
          }
        }

        var gl = device.gl;
        var attachments = [];
        var glFramebuffer = gl.createFramebuffer();

        if (glFramebuffer) {
          gpuFramebuffer.glFramebuffer = glFramebuffer;

          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
          }

          for (var _i7 = 0; _i7 < gpuFramebuffer.gpuColorTextures.length; ++_i7) {
            var gpuTexture = gpuFramebuffer.gpuColorTextures[_i7];

            if (gpuTexture) {
              if (gpuTexture.glTexture) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i7, gpuTexture.glTarget, gpuTexture.glTexture, 0);
              } else {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i7, gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
              }

              attachments.push(gl.COLOR_ATTACHMENT0 + _i7);
              gpuFramebuffer.width = Math.min(gpuFramebuffer.width, gpuTexture.width);
              gpuFramebuffer.height = Math.min(gpuFramebuffer.height, gpuTexture.height);
            }
          }

          var dst = gpuFramebuffer.gpuDepthStencilTexture;

          if (dst) {
            var glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

            if (dst.glTexture) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, 0);
            } else {
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
            }

            gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width);
            gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height);
          }

          if (device.extensions.WEBGL_draw_buffers) {
            device.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
          }

          var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

          if (status !== gl.FRAMEBUFFER_COMPLETE) {
            switch (status) {
              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                  break;
                }

              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                  break;
                }

              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                  break;
                }

              case gl.FRAMEBUFFER_UNSUPPORTED:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                  break;
                }
            }
          }

          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
          }
        }
      }
      function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
        if (gpuFramebuffer.glFramebuffer) {
          device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);

          if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
            device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
            device.stateCache.glFramebuffer = null;
          }

          gpuFramebuffer.glFramebuffer = null;
        }
      }
      function WebGLCmdFuncCreateShader(device, gpuShader) {
        var gl = device.gl;

        var _loop = function _loop(k) {
          var gpuStage = gpuShader.gpuStages[k];
          var glShaderType = 0;
          var shaderTypeStr = '';
          var lineNumber = 1;

          switch (gpuStage.type) {
            case ShaderStageFlagBit.VERTEX:
              {
                shaderTypeStr = 'VertexShader';
                glShaderType = gl.VERTEX_SHADER;
                break;
              }

            case ShaderStageFlagBit.FRAGMENT:
              {
                shaderTypeStr = 'FragmentShader';
                glShaderType = gl.FRAGMENT_SHADER;
                break;
              }

            default:
              {
                console.error('Unsupported ShaderType.');
                return {
                  v: void 0
                };
              }
          }

          var glShader = gl.createShader(glShaderType);

          if (glShader) {
            gpuStage.glShader = glShader;
            gl.shaderSource(gpuStage.glShader, gpuStage.source);
            gl.compileShader(gpuStage.glShader);

            if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
              console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed.");
              console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, function () {
                return "\n" + lineNumber++ + " ";
              }));
              console.error(gl.getShaderInfoLog(gpuStage.glShader));

              for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                var stage = gpuShader.gpuStages[k];

                if (stage.glShader) {
                  gl.deleteShader(stage.glShader);
                  stage.glShader = null;
                }
              }

              return {
                v: void 0
              };
            }
          }
        };

        for (var k = 0; k < gpuShader.gpuStages.length; k++) {
          var _ret = _loop(k);

          if (typeof _ret === "object") return _ret.v;
        }

        var glProgram = gl.createProgram();

        if (!glProgram) {
          return;
        }

        gpuShader.glProgram = glProgram;

        for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
          var gpuStage = gpuShader.gpuStages[_k];
          gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
        }

        gl.linkProgram(gpuShader.glProgram);

        if (device.extensions.destroyShadersImmediately) {
          for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
            var _gpuStage = gpuShader.gpuStages[_k2];

            if (_gpuStage.glShader) {
              gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
              gl.deleteShader(_gpuStage.glShader);
              _gpuStage.glShader = null;
            }
          }
        }

        if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
          debug("Shader '" + gpuShader.name + "' compilation succeeded.");
        } else {
          console.error("Failed to link shader '" + gpuShader.name + "'.");
          console.error(gl.getProgramInfoLog(gpuShader.glProgram));
          return;
        }

        var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
        gpuShader.glInputs = new Array(activeAttribCount);

        for (var i = 0; i < activeAttribCount; ++i) {
          var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

          if (attribInfo) {
            var varName = void 0;
            var nameOffset = attribInfo.name.indexOf('[');

            if (nameOffset !== -1) {
              varName = attribInfo.name.substr(0, nameOffset);
            } else {
              varName = attribInfo.name;
            }

            var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
            var type = WebGLTypeToGFXType(attribInfo.type, gl);
            var stride = WebGLGetTypeSize(attribInfo.type, gl);
            gpuShader.glInputs[i] = {
              binding: glLoc,
              name: varName,
              type: type,
              stride: stride,
              count: attribInfo.size,
              size: stride * attribInfo.size,
              glType: attribInfo.type,
              glLoc: glLoc
            };
          }
        }

        if (gpuShader.blocks.length > 0) {
          gpuShader.glBlocks = new Array(gpuShader.blocks.length);

          for (var _i8 = 0; _i8 < gpuShader.blocks.length; ++_i8) {
            var block = gpuShader.blocks[_i8];
            var glBlock = {
              set: block.set,
              binding: block.binding,
              name: block.name,
              size: 0,
              glUniforms: new Array(block.members.length),
              glActiveUniforms: []
            };
            gpuShader.glBlocks[_i8] = glBlock;

            for (var u = 0; u < block.members.length; ++u) {
              var uniform = block.members[u];
              var glType = GFXTypeToWebGLType(uniform.type, gl);

              var _stride = WebGLGetTypeSize(glType, gl);

              var size = _stride * uniform.count;
              glBlock.glUniforms[u] = {
                binding: -1,
                name: uniform.name,
                type: uniform.type,
                stride: _stride,
                count: uniform.count,
                size: size,
                offset: 0,
                glType: glType,
                glLoc: null,
                array: null
              };
            }
          }
        }

        for (var _i9 = 0; _i9 < gpuShader.subpassInputs.length; ++_i9) {
          var subpassInput = gpuShader.subpassInputs[_i9];
          gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type$1.SAMPLER2D, subpassInput.count));
        }

        if (gpuShader.samplerTextures.length > 0) {
          gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);

          for (var _i10 = 0; _i10 < gpuShader.samplerTextures.length; ++_i10) {
            var sampler = gpuShader.samplerTextures[_i10];
            gpuShader.glSamplerTextures[_i10] = {
              set: sampler.set,
              binding: sampler.binding,
              name: sampler.name,
              type: sampler.type,
              count: sampler.count,
              units: [],
              glUnits: null,
              glType: GFXTypeToWebGLType(sampler.type, gl),
              glLoc: null
            };
          }
        }

        var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS);

        for (var _i11 = 0; _i11 < activeUniformCount; ++_i11) {
          var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i11);

          if (uniformInfo) {
            var isSampler = uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE;

            if (!isSampler) {
              var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);

              if (device.extensions.isLocationActive(_glLoc)) {
                var _varName = void 0;

                var _nameOffset = uniformInfo.name.indexOf('[');

                if (_nameOffset !== -1) {
                  _varName = uniformInfo.name.substr(0, _nameOffset);
                } else {
                  _varName = uniformInfo.name;
                }

                for (var j = 0; j < gpuShader.glBlocks.length; j++) {
                  var _glBlock = gpuShader.glBlocks[j];

                  for (var _k3 = 0; _k3 < _glBlock.glUniforms.length; _k3++) {
                    var glUniform = _glBlock.glUniforms[_k3];

                    if (glUniform.name === _varName) {
                      glUniform.glLoc = _glLoc;
                      glUniform.count = uniformInfo.size;
                      glUniform.size = glUniform.stride * glUniform.count;
                      glUniform.array = new (GFXTypeToTypedArrayCtor(glUniform.type))(glUniform.size / 4);

                      _glBlock.glActiveUniforms.push(glUniform);

                      break;
                    }
                  }
                }
              }
            }
          }
        }

        for (var _j = 0; _j < gpuShader.glBlocks.length; _j++) {
          var _glBlock2 = gpuShader.glBlocks[_j];

          for (var _k4 = 0; _k4 < _glBlock2.glUniforms.length; _k4++) {
            var _glUniform = _glBlock2.glUniforms[_k4];
            _glUniform.offset = _glBlock2.size / 4;
            _glBlock2.size += _glUniform.size;
          }
        }

        var glActiveSamplers = [];
        var glActiveSamplerLocations = [];
        var bindingMappings = device.bindingMappings;
        var texUnitCacheMap = device.stateCache.texUnitCacheMap;
        var flexibleSetBaseOffset = 0;

        for (var _i12 = 0; _i12 < gpuShader.blocks.length; ++_i12) {
          if (gpuShader.blocks[_i12].set === bindingMappings.flexibleSet) {
            flexibleSetBaseOffset++;
          }
        }

        var arrayOffset = 0;

        for (var _i13 = 0; _i13 < gpuShader.samplerTextures.length; ++_i13) {
          var _sampler = gpuShader.samplerTextures[_i13];

          var _glLoc2 = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);

          if (device.extensions.isLocationActive(_glLoc2)) {
            glActiveSamplers.push(gpuShader.glSamplerTextures[_i13]);
            glActiveSamplerLocations.push(_glLoc2);
          }

          if (texUnitCacheMap[_sampler.name] === undefined) {
            var binding = _sampler.binding + bindingMappings.samplerTextureOffsets[_sampler.set] + arrayOffset;

            if (_sampler.set === bindingMappings.flexibleSet) {
              binding -= flexibleSetBaseOffset;
            }

            texUnitCacheMap[_sampler.name] = binding % device.capabilities.maxTextureUnits;
            arrayOffset += _sampler.count - 1;
          }
        }

        if (glActiveSamplers.length) {
          var usedTexUnits = [];

          for (var _i14 = 0; _i14 < glActiveSamplers.length; ++_i14) {
            var glSampler = glActiveSamplers[_i14];
            var cachedUnit = texUnitCacheMap[glSampler.name];

            if (cachedUnit !== undefined) {
              glSampler.glLoc = glActiveSamplerLocations[_i14];

              for (var t = 0; t < glSampler.count; ++t) {
                while (usedTexUnits[cachedUnit]) {
                  cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                }

                glSampler.units.push(cachedUnit);
                usedTexUnits[cachedUnit] = true;
              }
            }
          }

          var unitIdx = 0;

          for (var _i15 = 0; _i15 < glActiveSamplers.length; ++_i15) {
            var _glSampler = glActiveSamplers[_i15];

            if (!device.extensions.isLocationActive(_glSampler.glLoc)) {
              _glSampler.glLoc = glActiveSamplerLocations[_i15];

              for (var _t = 0; _t < _glSampler.count; ++_t) {
                while (usedTexUnits[unitIdx]) {
                  unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                }

                if (texUnitCacheMap[_glSampler.name] === undefined) {
                  texUnitCacheMap[_glSampler.name] = unitIdx;
                }

                _glSampler.units.push(unitIdx);

                usedTexUnits[unitIdx] = true;
              }
            }
          }

          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(gpuShader.glProgram);
          }

          for (var _i16 = 0; _i16 < glActiveSamplers.length; _i16++) {
            var _glSampler2 = glActiveSamplers[_i16];
            _glSampler2.glUnits = new Int32Array(_glSampler2.units);
            gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
          }

          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(device.stateCache.glProgram);
          }
        }

        for (var _i17 = 0; _i17 < gpuShader.glBlocks.length;) {
          if (gpuShader.glBlocks[_i17].glActiveUniforms.length) {
            _i17++;
          } else {
            gpuShader.glBlocks[_i17] = gpuShader.glBlocks[gpuShader.glBlocks.length - 1];
            gpuShader.glBlocks.length--;
          }
        }

        gpuShader.glSamplerTextures = glActiveSamplers;
      }
      function WebGLCmdFuncDestroyShader(device, gpuShader) {
        if (gpuShader.glProgram) {
          var gl = device.gl;

          if (!device.extensions.destroyShadersImmediately) {
            for (var k = 0; k < gpuShader.gpuStages.length; k++) {
              var gpuStage = gpuShader.gpuStages[k];

              if (gpuStage.glShader) {
                gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                gl.deleteShader(gpuStage.glShader);
                gpuStage.glShader = null;
              }
            }
          }

          gl.deleteProgram(gpuShader.glProgram);

          if (device.stateCache.glProgram === gpuShader.glProgram) {
            device.gl.useProgram(null);
            device.stateCache.glProgram = null;
          }

          gpuShader.glProgram = null;
        }
      }
      function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
        var gl = device.gl;
        gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
        var offsets = [0, 0, 0, 0, 0, 0, 0, 0];

        for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
          var attrib = gpuInputAssembler.attributes[i];
          var stream = attrib.stream !== undefined ? attrib.stream : 0;
          var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
          var glType = GFXFormatToWebGLType(attrib.format, gl);
          var size = FormatInfos[attrib.format].size;
          gpuInputAssembler.glAttribs[i] = {
            name: attrib.name,
            glBuffer: gpuBuffer.glBuffer,
            glType: glType,
            size: size,
            count: FormatInfos[attrib.format].count,
            stride: gpuBuffer.stride,
            componentCount: WebGLGetComponentCount(glType, gl),
            isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
            isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
            offset: offsets[stream]
          };
          offsets[stream] += size;
        }
      }
      function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
        var it = gpuInputAssembler.glVAOs.values();
        var res = it.next();
        var OES_vertex_array_object = device.extensions.OES_vertex_array_object;
        var glVAO = device.stateCache.glVAO;

        while (!res.done) {
          OES_vertex_array_object.deleteVertexArrayOES(res.value);

          if (glVAO === res.value) {
            OES_vertex_array_object.bindVertexArrayOES(null);
            glVAO = null;
          }

          res = it.next();
        }

        device.stateCache.glVAO = glVAO;
        gpuInputAssembler.glVAOs.clear();
      }
      var gfxStateCache = {
        gpuPipelineState: null,
        gpuInputAssembler: null,
        glPrimitive: 0
      };
      var realRenderArea = new Rect$1();
      function WebGLCmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
        var gl = device.gl;
        var cache = device.stateCache;
        var clears = 0;

        if (gpuFramebuffer) {
          realRenderArea.x = renderArea.x << gpuFramebuffer.lodLevel;
          realRenderArea.y = renderArea.y << gpuFramebuffer.lodLevel;
          realRenderArea.width = renderArea.width << gpuFramebuffer.lodLevel;
          realRenderArea.height = renderArea.height << gpuFramebuffer.lodLevel;
        }

        if (gpuFramebuffer && gpuRenderPass) {
          if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
            cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
          }

          if (cache.viewport.left !== realRenderArea.x || cache.viewport.top !== realRenderArea.y || cache.viewport.width !== realRenderArea.width || cache.viewport.height !== realRenderArea.height) {
            gl.viewport(realRenderArea.x, realRenderArea.y, realRenderArea.width, realRenderArea.height);
            cache.viewport.left = realRenderArea.x;
            cache.viewport.top = realRenderArea.y;
            cache.viewport.width = realRenderArea.width;
            cache.viewport.height = realRenderArea.height;
          }

          if (cache.scissorRect.x !== realRenderArea.x || cache.scissorRect.y !== realRenderArea.y || cache.scissorRect.width !== realRenderArea.width || cache.scissorRect.height !== realRenderArea.height) {
            gl.scissor(realRenderArea.x, realRenderArea.y, realRenderArea.width, realRenderArea.height);
            cache.scissorRect.x = realRenderArea.x;
            cache.scissorRect.y = realRenderArea.y;
            cache.scissorRect.width = realRenderArea.width;
            cache.scissorRect.height = realRenderArea.height;
          }

          var clearCount = clearColors.length;

          if (!device.extensions.WEBGL_draw_buffers) {
            clearCount = 1;
          }

          for (var j = 0; j < clearCount; ++j) {
            var colorAttachment = gpuRenderPass.colorAttachments[j];

            if (colorAttachment.format !== Format.UNKNOWN) {
              switch (colorAttachment.loadOp) {
                case LoadOp.LOAD:
                  break;

                case LoadOp.CLEAR:
                  {
                    if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                      gl.colorMask(true, true, true, true);
                    }

                    var clearColor = clearColors[0];
                    gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                    clears |= gl.COLOR_BUFFER_BIT;
                    break;
                  }

                case LoadOp.DISCARD:
                  {
                    break;
                  }
              }
            }
          }

          if (gpuRenderPass.depthStencilAttachment) {
            if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
              switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                case LoadOp.LOAD:
                  break;

                case LoadOp.CLEAR:
                  {
                    if (!cache.dss.depthWrite) {
                      gl.depthMask(true);
                    }

                    gl.clearDepth(clearDepth);
                    clears |= gl.DEPTH_BUFFER_BIT;
                    break;
                  }

                case LoadOp.DISCARD:
                  {
                    break;
                  }
              }

              if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                  case LoadOp.LOAD:
                    break;

                  case LoadOp.CLEAR:
                    {
                      if (!cache.dss.stencilWriteMaskFront) {
                        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                      }

                      if (!cache.dss.stencilWriteMaskBack) {
                        gl.stencilMaskSeparate(gl.BACK, 0xffff);
                      }

                      gl.clearStencil(clearStencil);
                      clears |= gl.STENCIL_BUFFER_BIT;
                      break;
                    }

                  case LoadOp.DISCARD:
                    {
                      break;
                    }
                }
              }
            }
          }

          if (clears) {
            gl.clear(clears);
          }

          if (clears & gl.COLOR_BUFFER_BIT) {
            var colorMask = cache.bs.targets[0].blendColorMask;

            if (colorMask !== ColorMask.ALL) {
              var r = (colorMask & ColorMask.R) !== ColorMask.NONE;
              var g = (colorMask & ColorMask.G) !== ColorMask.NONE;
              var b = (colorMask & ColorMask.B) !== ColorMask.NONE;
              var a = (colorMask & ColorMask.A) !== ColorMask.NONE;
              gl.colorMask(r, g, b, a);
            }
          }

          if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
            gl.depthMask(false);
          }

          if (clears & gl.STENCIL_BUFFER_BIT) {
            if (!cache.dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, 0);
            }

            if (!cache.dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, 0);
            }
          }
        }
      }
      function WebGLCmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
        var gl = device.gl;
        var cache = device.stateCache;
        var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
        var isShaderChanged = false;
        var glWrapS;
        var glWrapT;
        var glMinFilter;

        if (gpuPipelineState && gfxStateCache.gpuPipelineState !== gpuPipelineState) {
          gfxStateCache.gpuPipelineState = gpuPipelineState;
          gfxStateCache.glPrimitive = gpuPipelineState.glPrimitive;

          if (gpuPipelineState.gpuShader) {
            var glProgram = gpuPipelineState.gpuShader.glProgram;

            if (cache.glProgram !== glProgram) {
              gl.useProgram(glProgram);
              cache.glProgram = glProgram;
              isShaderChanged = true;
            }
          }

          var rs = gpuPipelineState.rs;

          if (rs) {
            if (cache.rs.cullMode !== rs.cullMode) {
              switch (rs.cullMode) {
                case CullMode.NONE:
                  {
                    gl.disable(gl.CULL_FACE);
                    break;
                  }

                case CullMode.FRONT:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.FRONT);
                    break;
                  }

                case CullMode.BACK:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                    break;
                  }
              }

              cache.rs.cullMode = rs.cullMode;
            }

            var isFrontFaceCCW = rs.isFrontFaceCCW;

            if (cache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
              gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
              cache.rs.isFrontFaceCCW = isFrontFaceCCW;
            }

            if (cache.rs.depthBias !== rs.depthBias || cache.rs.depthBiasSlop !== rs.depthBiasSlop) {
              gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
              cache.rs.depthBias = rs.depthBias;
              cache.rs.depthBiasSlop = rs.depthBiasSlop;
            }

            if (cache.rs.lineWidth !== rs.lineWidth) {
              gl.lineWidth(rs.lineWidth);
              cache.rs.lineWidth = rs.lineWidth;
            }
          }

          var dss = gpuPipelineState.dss;

          if (dss) {
            if (cache.dss.depthTest !== dss.depthTest) {
              if (dss.depthTest) {
                gl.enable(gl.DEPTH_TEST);
              } else {
                gl.disable(gl.DEPTH_TEST);
              }

              cache.dss.depthTest = dss.depthTest;
            }

            if (cache.dss.depthWrite !== dss.depthWrite) {
              gl.depthMask(dss.depthWrite);
              cache.dss.depthWrite = dss.depthWrite;
            }

            if (cache.dss.depthFunc !== dss.depthFunc) {
              gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]);
              cache.dss.depthFunc = dss.depthFunc;
            }

            if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
              if (dss.stencilTestFront || dss.stencilTestBack) {
                gl.enable(gl.STENCIL_TEST);
              } else {
                gl.disable(gl.STENCIL_TEST);
              }

              cache.dss.stencilTestFront = dss.stencilTestFront;
              cache.dss.stencilTestBack = dss.stencilTestBack;
            }

            if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
              gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
              cache.dss.stencilFuncFront = dss.stencilFuncFront;
              cache.dss.stencilRefFront = dss.stencilRefFront;
              cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
            }

            if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
              gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]);
              cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
              cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
              cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
            }

            if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
              cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
            }

            if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
              gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
              cache.dss.stencilFuncBack = dss.stencilFuncBack;
              cache.dss.stencilRefBack = dss.stencilRefBack;
              cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
            }

            if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
              gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]);
              cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
              cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
              cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
            }

            if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
              cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
            }
          }

          var bs = gpuPipelineState.bs;

          if (bs) {
            if (cache.bs.isA2C !== bs.isA2C) {
              if (bs.isA2C) {
                gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              } else {
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              }

              cache.bs.isA2C = bs.isA2C;
            }

            if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
              gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
              cache.bs.blendColor.x = bs.blendColor.x;
              cache.bs.blendColor.y = bs.blendColor.y;
              cache.bs.blendColor.z = bs.blendColor.z;
              cache.bs.blendColor.w = bs.blendColor.w;
            }

            var target0 = bs.targets[0];
            var target0Cache = cache.bs.targets[0];

            if (target0Cache.blend !== target0.blend) {
              if (target0.blend) {
                gl.enable(gl.BLEND);
              } else {
                gl.disable(gl.BLEND);
              }

              target0Cache.blend = target0.blend;
            }

            if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
              gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]);
              target0Cache.blendEq = target0.blendEq;
              target0Cache.blendAlphaEq = target0.blendAlphaEq;
            }

            if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
              gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]);
              target0Cache.blendSrc = target0.blendSrc;
              target0Cache.blendDst = target0.blendDst;
              target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
              target0Cache.blendDstAlpha = target0.blendDstAlpha;
            }

            if (target0Cache.blendColorMask !== target0.blendColorMask) {
              gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
              target0Cache.blendColorMask = target0.blendColorMask;
            }
          }
        }

        if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
          var blockLen = gpuShader.glBlocks.length;
          var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;

          for (var j = 0; j < blockLen; j++) {
            var glBlock = gpuShader.glBlocks[j];
            var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
            var descriptorIdx = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
            var gpuDescriptor = descriptorIdx >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIdx];
            var vf32 = null;
            var offset = 0;

            if (gpuDescriptor && gpuDescriptor.gpuBuffer) {
              var gpuBuffer = gpuDescriptor.gpuBuffer;
              var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
              var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];

              if (dynamicOffsetIndex >= 0) {
                offset = dynamicOffsets[dynamicOffsetIndex];
              }

              if ('vf32' in gpuBuffer) {
                vf32 = gpuBuffer.vf32;
              } else {
                offset += gpuBuffer.offset;
                vf32 = gpuBuffer.gpuBuffer.vf32;
              }

              offset >>= 2;
            }

            if (!vf32) {
              error("Buffer binding '" + glBlock.name + "' at set " + glBlock.set + " binding " + glBlock.binding + " is not bounded");
              continue;
            }

            var uniformLen = glBlock.glActiveUniforms.length;

            for (var l = 0; l < uniformLen; l++) {
              var glUniform = glBlock.glActiveUniforms[l];

              switch (glUniform.glType) {
                case gl.BOOL:
                case gl.INT:
                  {
                    for (var u = 0; u < glUniform.array.length; ++u) {
                      var idx = glUniform.offset + offset + u;

                      if (vf32[idx] !== glUniform.array[u]) {
                        for (var n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }

                        gl.uniform1iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.BOOL_VEC2:
                case gl.INT_VEC2:
                  {
                    for (var _u = 0; _u < glUniform.array.length; ++_u) {
                      var _idx = glUniform.offset + offset + _u;

                      if (vf32[_idx] !== glUniform.array[_u]) {
                        for (var _n = _u, _m = _idx; _n < glUniform.array.length; ++_n, ++_m) {
                          glUniform.array[_n] = vf32[_m];
                        }

                        gl.uniform2iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.BOOL_VEC3:
                case gl.INT_VEC3:
                  {
                    for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                      var _idx2 = glUniform.offset + offset + _u2;

                      if (vf32[_idx2] !== glUniform.array[_u2]) {
                        for (var _n2 = _u2, _m2 = _idx2; _n2 < glUniform.array.length; ++_n2, ++_m2) {
                          glUniform.array[_n2] = vf32[_m2];
                        }

                        gl.uniform3iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.BOOL_VEC4:
                case gl.INT_VEC4:
                  {
                    for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                      var _idx3 = glUniform.offset + offset + _u3;

                      if (vf32[_idx3] !== glUniform.array[_u3]) {
                        for (var _n3 = _u3, _m3 = _idx3; _n3 < glUniform.array.length; ++_n3, ++_m3) {
                          glUniform.array[_n3] = vf32[_m3];
                        }

                        gl.uniform4iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT:
                  {
                    for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                      var _idx4 = glUniform.offset + offset + _u4;

                      if (vf32[_idx4] !== glUniform.array[_u4]) {
                        for (var _n4 = _u4, _m4 = _idx4; _n4 < glUniform.array.length; ++_n4, ++_m4) {
                          glUniform.array[_n4] = vf32[_m4];
                        }

                        gl.uniform1fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_VEC2:
                  {
                    for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                      var _idx5 = glUniform.offset + offset + _u5;

                      if (vf32[_idx5] !== glUniform.array[_u5]) {
                        for (var _n5 = _u5, _m5 = _idx5; _n5 < glUniform.array.length; ++_n5, ++_m5) {
                          glUniform.array[_n5] = vf32[_m5];
                        }

                        gl.uniform2fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_VEC3:
                  {
                    for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                      var _idx6 = glUniform.offset + offset + _u6;

                      if (vf32[_idx6] !== glUniform.array[_u6]) {
                        for (var _n6 = _u6, _m6 = _idx6; _n6 < glUniform.array.length; ++_n6, ++_m6) {
                          glUniform.array[_n6] = vf32[_m6];
                        }

                        gl.uniform3fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_VEC4:
                  {
                    for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                      var _idx7 = glUniform.offset + offset + _u7;

                      if (vf32[_idx7] !== glUniform.array[_u7]) {
                        for (var _n7 = _u7, _m7 = _idx7; _n7 < glUniform.array.length; ++_n7, ++_m7) {
                          glUniform.array[_n7] = vf32[_m7];
                        }

                        gl.uniform4fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_MAT2:
                  {
                    for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                      var _idx8 = glUniform.offset + offset + _u8;

                      if (vf32[_idx8] !== glUniform.array[_u8]) {
                        for (var _n8 = _u8, _m8 = _idx8; _n8 < glUniform.array.length; ++_n8, ++_m8) {
                          glUniform.array[_n8] = vf32[_m8];
                        }

                        gl.uniformMatrix2fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_MAT3:
                  {
                    for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                      var _idx9 = glUniform.offset + offset + _u9;

                      if (vf32[_idx9] !== glUniform.array[_u9]) {
                        for (var _n9 = _u9, _m9 = _idx9; _n9 < glUniform.array.length; ++_n9, ++_m9) {
                          glUniform.array[_n9] = vf32[_m9];
                        }

                        gl.uniformMatrix3fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_MAT4:
                  {
                    for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                      var _idx10 = glUniform.offset + offset + _u10;

                      if (vf32[_idx10] !== glUniform.array[_u10]) {
                        for (var _n10 = _u10, _m10 = _idx10; _n10 < glUniform.array.length; ++_n10, ++_m10) {
                          glUniform.array[_n10] = vf32[_m10];
                        }

                        gl.uniformMatrix4fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }
              }
            }

            continue;
          }

          var samplerLen = gpuShader.glSamplerTextures.length;

          for (var i = 0; i < samplerLen; i++) {
            var glSampler = gpuShader.glSamplerTextures[i];
            var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
            var descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];

            var _gpuDescriptor = descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[descriptorIndex];

            var texUnitLen = glSampler.units.length;

            for (var _l = 0; _l < texUnitLen; _l++) {
              var texUnit = glSampler.units[_l];

              if (!_gpuDescriptor || !_gpuDescriptor.gpuSampler) {
                error("Sampler binding '" + glSampler.name + "' at set " + glSampler.set + " binding " + glSampler.binding + " index " + _l + " is not bounded");
                continue;
              }

              if (_gpuDescriptor.gpuTexture && _gpuDescriptor.gpuTexture.size > 0) {
                var _gpuDescriptor2 = _gpuDescriptor,
                    gpuTexture = _gpuDescriptor2.gpuTexture;
                var glTexUnit = cache.glTexUnits[texUnit];

                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  if (gpuTexture.glTexture) {
                    gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                  } else {
                    gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                  }

                  glTexUnit.glTexture = gpuTexture.glTexture;
                }

                var _gpuDescriptor3 = _gpuDescriptor,
                    gpuSampler = _gpuDescriptor3.gpuSampler;

                if (gpuTexture.isPowerOf2) {
                  glWrapS = gpuSampler.glWrapS;
                  glWrapT = gpuSampler.glWrapT;
                } else {
                  glWrapS = gl.CLAMP_TO_EDGE;
                  glWrapT = gl.CLAMP_TO_EDGE;
                }

                if (gpuTexture.isPowerOf2) {
                  if (gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR)) {
                    glMinFilter = gl.LINEAR;
                  } else {
                    glMinFilter = gpuSampler.glMinFilter;
                  }
                } else if (gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) {
                  glMinFilter = gl.LINEAR;
                } else {
                  glMinFilter = gl.NEAREST;
                }

                if (gpuTexture.glWrapS !== glWrapS) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS);
                  gpuTexture.glWrapS = glWrapS;
                }

                if (gpuTexture.glWrapT !== glWrapT) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT);
                  gpuTexture.glWrapT = glWrapT;
                }

                if (gpuTexture.glMinFilter !== glMinFilter) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter);
                  gpuTexture.glMinFilter = glMinFilter;
                }

                if (gpuTexture.glMagFilter !== gpuSampler.glMagFilter) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter);
                  gpuTexture.glMagFilter = gpuSampler.glMagFilter;
                }
              }

              _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
            }
          }
        }

        if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache.gpuInputAssembler !== gpuInputAssembler)) {
          gfxStateCache.gpuInputAssembler = gpuInputAssembler;
          var ia = device.extensions.ANGLE_instanced_arrays;

          if (device.extensions.useVAO) {
            var vao = device.extensions.OES_vertex_array_object;
            var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

            if (!glVAO) {
              glVAO = vao.createVertexArrayOES();
              gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
              vao.bindVertexArrayOES(glVAO);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
              var glAttrib;
              var inputLen = gpuShader.glInputs.length;

              for (var _j2 = 0; _j2 < inputLen; _j2++) {
                var glInput = gpuShader.glInputs[_j2];
                glAttrib = null;
                var attribLen = gpuInputAssembler.glAttribs.length;

                for (var k = 0; k < attribLen; k++) {
                  var attrib = gpuInputAssembler.glAttribs[k];

                  if (attrib.name === glInput.name) {
                    glAttrib = attrib;
                    break;
                  }
                }

                if (glAttrib) {
                  if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                    cache.glArrayBuffer = glAttrib.glBuffer;
                  }

                  for (var c = 0; c < glAttrib.componentCount; ++c) {
                    var glLoc = glInput.glLoc + c;
                    var attribOffset = glAttrib.offset + glAttrib.size * c;
                    gl.enableVertexAttribArray(glLoc);
                    cache.glCurrentAttribLocs[glLoc] = true;
                    gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);

                    if (ia) {
                      ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                    }
                  }
                }
              }

              var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

              if (_gpuBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer);
              }

              vao.bindVertexArrayOES(null);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
            }

            if (cache.glVAO !== glVAO) {
              vao.bindVertexArrayOES(glVAO);
              cache.glVAO = glVAO;
            }
          } else {
            for (var a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
              cache.glCurrentAttribLocs[a] = false;
            }

            var _inputLen = gpuShader.glInputs.length;

            for (var _j3 = 0; _j3 < _inputLen; _j3++) {
              var _glInput = gpuShader.glInputs[_j3];
              var _glAttrib = null;
              var _attribLen = gpuInputAssembler.glAttribs.length;

              for (var _k5 = 0; _k5 < _attribLen; _k5++) {
                var _attrib = gpuInputAssembler.glAttribs[_k5];

                if (_attrib.name === _glInput.name) {
                  _glAttrib = _attrib;
                  break;
                }
              }

              if (_glAttrib) {
                if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer);
                  cache.glArrayBuffer = _glAttrib.glBuffer;
                }

                for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                  var _glLoc3 = _glInput.glLoc + _c;

                  var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;

                  if (!cache.glEnabledAttribLocs[_glLoc3] && _glLoc3 >= 0) {
                    gl.enableVertexAttribArray(_glLoc3);
                    cache.glEnabledAttribLocs[_glLoc3] = true;
                  }

                  cache.glCurrentAttribLocs[_glLoc3] = true;
                  gl.vertexAttribPointer(_glLoc3, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);

                  if (ia) {
                    ia.vertexAttribDivisorANGLE(_glLoc3, _glAttrib.isInstanced ? 1 : 0);
                  }
                }
              }
            }

            var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;

            if (_gpuBuffer2) {
              if (cache.glElementArrayBuffer !== _gpuBuffer2.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer2.glBuffer);
                cache.glElementArrayBuffer = _gpuBuffer2.glBuffer;
              }
            }

            for (var _a = 0; _a < device.capabilities.maxVertexAttributes; ++_a) {
              if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                gl.disableVertexAttribArray(_a);
                cache.glEnabledAttribLocs[_a] = false;
              }
            }
          }
        }

        if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
          var dsLen = gpuPipelineState.dynamicStates.length;

          for (var _j4 = 0; _j4 < dsLen; _j4++) {
            var dynamicState = gpuPipelineState.dynamicStates[_j4];

            switch (dynamicState) {
              case DynamicStateFlagBit.LINE_WIDTH:
                {
                  if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                    gl.lineWidth(dynamicStates.lineWidth);
                    cache.rs.lineWidth = dynamicStates.lineWidth;
                  }

                  break;
                }

              case DynamicStateFlagBit.DEPTH_BIAS:
                {
                  if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                    gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                    cache.rs.depthBias = dynamicStates.depthBiasConstant;
                    cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                  }

                  break;
                }

              case DynamicStateFlagBit.BLEND_CONSTANTS:
                {
                  var blendConstant = dynamicStates.blendConstant;

                  if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                    gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                    cache.bs.blendColor.copy(blendConstant);
                  }

                  break;
                }

              case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                {
                  var front = dynamicStates.stencilStatesFront;
                  var back = dynamicStates.stencilStatesBack;

                  if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                    gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                    cache.dss.stencilWriteMaskFront = front.writeMask;
                  }

                  if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                    gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                    cache.dss.stencilWriteMaskBack = back.writeMask;
                  }

                  break;
                }

              case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                {
                  var _front = dynamicStates.stencilStatesFront;
                  var _back = dynamicStates.stencilStatesBack;

                  if (cache.dss.stencilRefFront !== _front.reference || cache.dss.stencilReadMaskFront !== _front.compareMask) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], _front.reference, _front.compareMask);
                    cache.dss.stencilRefFront = _front.reference;
                    cache.dss.stencilReadMaskFront = _front.compareMask;
                  }

                  if (cache.dss.stencilRefBack !== _back.reference || cache.dss.stencilReadMaskBack !== _back.compareMask) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], _back.reference, _back.compareMask);
                    cache.dss.stencilRefBack = _back.reference;
                    cache.dss.stencilReadMaskBack = _back.compareMask;
                  }

                  break;
                }
            }
          }
        }
      }
      function WebGLCmdFuncDraw(device, drawInfo) {
        var gl = device.gl;
        var _device$extensions = device.extensions,
            ia = _device$extensions.ANGLE_instanced_arrays,
            md = _device$extensions.WEBGL_multi_draw;
        var gpuInputAssembler = gfxStateCache.gpuInputAssembler,
            glPrimitive = gfxStateCache.glPrimitive;

        if (gpuInputAssembler) {
          var indexBuffer = gpuInputAssembler.gpuIndexBuffer;

          if (gpuInputAssembler.gpuIndirectBuffer) {
            var indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;

            if (indirects.drawByIndex) {
              for (var j = 0; j < indirects.drawCount; j++) {
                indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
              }

              if (md) {
                if (indirects.instancedDraw) {
                  md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                } else {
                  md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                }
              } else {
                for (var _j5 = 0; _j5 < indirects.drawCount; _j5++) {
                  if (indirects.instances[_j5] && ia) {
                    ia.drawElementsInstancedANGLE(glPrimitive, indirects.counts[_j5], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j5], indirects.instances[_j5]);
                  } else {
                    gl.drawElements(glPrimitive, indirects.counts[_j5], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j5]);
                  }
                }
              }
            } else if (md) {
              if (indirects.instancedDraw) {
                md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
              } else {
                md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
              }
            } else {
              for (var _j6 = 0; _j6 < indirects.drawCount; _j6++) {
                if (indirects.instances[_j6] && ia) {
                  ia.drawArraysInstancedANGLE(glPrimitive, indirects.offsets[_j6], indirects.counts[_j6], indirects.instances[_j6]);
                } else {
                  gl.drawArrays(glPrimitive, indirects.offsets[_j6], indirects.counts[_j6]);
                }
              }
            }
          } else if (drawInfo.instanceCount && ia) {
            if (indexBuffer) {
              if (drawInfo.indexCount > 0) {
                var offset = drawInfo.firstIndex * indexBuffer.stride;
                ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
              }
            } else if (drawInfo.vertexCount > 0) {
              ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
            }
          } else if (indexBuffer) {
            if (drawInfo.indexCount > 0) {
              var _offset = drawInfo.firstIndex * indexBuffer.stride;

              gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
            }
          } else if (drawInfo.vertexCount > 0) {
            gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
          }
        }
      }
      var cmdIds = new Array(WebGLCmd.COUNT);
      function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
        cmdIds.fill(0);

        for (var i = 0; i < cmdPackage.cmds.length; ++i) {
          var cmd = cmdPackage.cmds.array[i];
          var cmdId = cmdIds[cmd]++;

          switch (cmd) {
            case WebGLCmd.BEGIN_RENDER_PASS:
              {
                var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                WebGLCmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                break;
              }

            case WebGLCmd.BIND_STATES:
              {
                var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                WebGLCmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                break;
              }

            case WebGLCmd.DRAW:
              {
                var cmd3 = cmdPackage.drawCmds.array[cmdId];
                WebGLCmdFuncDraw(device, cmd3.drawInfo);
                break;
              }

            case WebGLCmd.UPDATE_BUFFER:
              {
                var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                break;
              }

            case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
              {
                var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                WebGLCmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                break;
              }
          }
        }
      }
      function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
        var gl = device.gl;
        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }

        var n = 0;
        var f = 0;

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var i = 0; i < regions.length; i++) {
                var region = regions[i];
                gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
              }

              break;
            }

          case gl.TEXTURE_CUBE_MAP:
            {
              for (var _i18 = 0; _i18 < regions.length; _i18++) {
                var _region = regions[_i18];
                var fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;

                for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                  gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region.texSubres.mipLevel, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }

        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      var stagingBuffer = new Uint8Array(1);

      function pixelBufferPick(buffer, format, offset, stride, extent) {
        var blockHeight = formatAlignment(format).height;
        var bufferSize = FormatSize(format, extent.width, extent.height, extent.depth);
        var rowStride = FormatSize(format, stride.width, 1, 1);
        var sliceStride = FormatSize(format, stride.width, stride.height, 1);
        var chunkSize = FormatSize(format, extent.width, 1, 1);
        var ArrayBufferCtor = getTypedArrayConstructor(FormatInfos[format]);

        if (stagingBuffer.byteLength < bufferSize) {
          stagingBuffer = new Uint8Array(bufferSize);
        }

        var destOffset = 0;
        var bufferOffset = offset;

        for (var i = 0; i < extent.depth; i++) {
          bufferOffset = offset + sliceStride * i;

          for (var j = 0; j < extent.height; j += blockHeight) {
            stagingBuffer.subarray(destOffset, destOffset + chunkSize).set(new Uint8Array(buffer.buffer, buffer.byteOffset + bufferOffset, chunkSize));
            destOffset += chunkSize;
            bufferOffset += rowStride;
          }
        }

        return new ArrayBufferCtor(stagingBuffer.buffer);
      }

      function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
        var gl = device.gl;
        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }

        var n = 0;
        var f = 0;
        var fmtInfo = FormatInfos[gpuTexture.format];
        var ArrayBufferCtor = getTypedArrayConstructor(fmtInfo);
        var isCompressed = fmtInfo.isCompressed;
        var blockSize = formatAlignment(gpuTexture.format);
        var extent = new Extent();
        var offset = new Offset();
        var stride = new Extent();

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var i = 0; i < regions.length; i++) {
                var region = regions[i];
                var mipLevel = region.texSubres.mipLevel;
                offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                var destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                var destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                var pixels = void 0;
                var buffer = buffers[n++];

                if (stride.width === extent.width && stride.height === extent.height) {
                  pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset);
                } else {
                  pixels = pixelBufferPick(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                }

                if (!isCompressed) {
                  gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                  gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                } else {
                  gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                }
              }

              break;
            }

          case gl.TEXTURE_CUBE_MAP:
            {
              for (var _i19 = 0; _i19 < regions.length; _i19++) {
                var _region2 = regions[_i19];
                var _mipLevel = _region2.texSubres.mipLevel;
                offset.x = _region2.texOffset.x === 0 ? 0 : alignTo(_region2.texOffset.x, blockSize.width);
                offset.y = _region2.texOffset.y === 0 ? 0 : alignTo(_region2.texOffset.y, blockSize.height);
                extent.width = _region2.texExtent.width < blockSize.width ? _region2.texExtent.width : alignTo(_region2.texExtent.width, blockSize.width);
                extent.height = _region2.texExtent.height < blockSize.height ? _region2.texExtent.width : alignTo(_region2.texExtent.height, blockSize.height);
                stride.width = _region2.buffStride > 0 ? _region2.buffStride : extent.width;
                stride.height = _region2.buffTexHeight > 0 ? _region2.buffTexHeight : extent.height;

                var _destWidth = _region2.texExtent.width + offset.x === gpuTexture.width >> _mipLevel ? _region2.texExtent.width : extent.width;

                var _destHeight = _region2.texExtent.height + offset.y === gpuTexture.height >> _mipLevel ? _region2.texExtent.height : extent.height;

                var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;

                for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                  var _pixels = void 0;

                  var _buffer = buffers[n++];

                  if (stride.width === extent.width && stride.height === extent.height) {
                    _pixels = new ArrayBufferCtor(_buffer.buffer, _buffer.byteOffset + _region2.buffOffset);
                  } else {
                    _pixels = pixelBufferPick(_buffer, gpuTexture.format, _region2.buffOffset, stride, extent);
                  }

                  if (!isCompressed) {
                    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel, offset.x, offset.y, _destWidth, _destHeight, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                  } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel, offset.x, offset.y, _destWidth, _destHeight, gpuTexture.glFormat, _pixels);
                  } else {
                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel, gpuTexture.glInternalFmt, _destWidth, _destHeight, 0, _pixels);
                  }
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }

        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      function WebGLCmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
        var gl = device.gl;
        var cache = device.stateCache;
        var framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        var x = 0;
        var y = 0;
        var w = 1;
        var h = 1;

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var k = 0; k < regions.length; k++) {
                var region = regions[k];
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                x = region.texOffset.x;
                y = region.texOffset.y;
                w = region.texExtent.width;
                h = region.texExtent.height;
                gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy texture to buffers failed.');
            }
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        cache.glFramebuffer = null;
        gl.deleteFramebuffer(framebuffer);
      }

      var WebGLIndirectDrawInfos = function () {
        function WebGLIndirectDrawInfos() {
          this.counts = void 0;
          this.offsets = void 0;
          this.instances = void 0;
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
          this.byteOffsets = void 0;
          this._capacity = 4;
          this.counts = new Int32Array(this._capacity);
          this.offsets = new Int32Array(this._capacity);
          this.instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
        }

        var _proto = WebGLIndirectDrawInfos.prototype;

        _proto.clearDraws = function clearDraws() {
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
        };

        _proto.setDrawInfo = function setDrawInfo(idx, info) {
          this._ensureCapacity(idx);

          this.drawByIndex = info.indexCount > 0;
          this.instancedDraw = !!info.instanceCount;
          this.drawCount = Math.max(idx + 1, this.drawCount);

          if (this.drawByIndex) {
            this.counts[idx] = info.indexCount;
            this.offsets[idx] = info.firstIndex;
          } else {
            this.counts[idx] = info.vertexCount;
            this.offsets[idx] = info.firstVertex;
          }

          this.instances[idx] = Math.max(1, info.instanceCount);
        };

        _proto._ensureCapacity = function _ensureCapacity(target) {
          if (this._capacity > target) return;
          this._capacity = nextPow2$1(target);
          var counts = new Int32Array(this._capacity);
          var offsets = new Int32Array(this._capacity);
          var instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
          counts.set(this.counts);
          offsets.set(this.offsets);
          instances.set(this.instances);
          this.counts = counts;
          this.offsets = offsets;
          this.instances = instances;
        };

        return WebGLIndirectDrawInfos;
      }();

      var WebGLBuffer = function (_Buffer) {
        _inheritsLoose(WebGLBuffer, _Buffer);

        function WebGLBuffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Buffer.call.apply(_Buffer, [this].concat(args)) || this;
          _this._gpuBuffer = null;
          _this._gpuBufferView = null;
          _this._uniformBuffer = null;
          return _this;
        }

        var _proto = WebGLBuffer.prototype;

        _proto.initialize = function initialize(info) {
          if ('buffer' in info) {
            this._isBufferView = true;
            var buffer = info.buffer;
            this._usage = buffer.usage;
            this._memUsage = buffer.memUsage;
            this._size = this._stride = info.range;
            this._count = 1;
            this._flags = buffer.flags;
            this._gpuBufferView = {
              gpuBuffer: buffer.gpuBuffer,
              offset: info.offset,
              range: info.range
            };
          } else {
            this._usage = info.usage;
            this._memUsage = info.memUsage;
            this._size = info.size;
            this._stride = Math.max(info.stride || this._size, 1);
            this._count = this._size / this._stride;
            this._flags = info.flags;

            if (this._usage & BufferUsageBit.UNIFORM && this._size > 0) {
              this._uniformBuffer = new Uint8Array(this._size);
            }

            this._gpuBuffer = {
              usage: this._usage,
              memUsage: this._memUsage,
              size: this._size,
              stride: this._stride,
              buffer: null,
              vf32: null,
              indirects: new WebGLIndirectDrawInfos(),
              glTarget: 0,
              glBuffer: null
            };

            if (this._usage & BufferUsageBit.UNIFORM) {
              this._gpuBuffer.buffer = this._uniformBuffer;
            }

            WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
            WebGLDeviceManager.instance.memoryStatus.bufferSize += this._size;
          }
        };

        _proto.destroy = function destroy() {
          if (this._gpuBuffer) {
            WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
            WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._size;
            this._gpuBuffer = null;
          }

          if (this._gpuBufferView) {
            this._gpuBufferView = null;
          }
        };

        _proto.resize = function resize(size) {
          if (this._isBufferView) {
            console.warn('cannot resize buffer views!');
            return;
          }

          var oldSize = this._size;

          if (oldSize === size) {
            return;
          }

          this._size = size;
          this._count = this._size / this._stride;

          if (this._uniformBuffer) {
            this._uniformBuffer = new Uint8Array(size);
          }

          if (this._gpuBuffer) {
            if (this._uniformBuffer) {
              this._gpuBuffer.buffer = this._uniformBuffer;
            }

            this._gpuBuffer.size = size;

            if (size > 0) {
              WebGLCmdFuncResizeBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
              WebGLDeviceManager.instance.memoryStatus.bufferSize -= oldSize;
              WebGLDeviceManager.instance.memoryStatus.bufferSize += size;
            }
          }
        };

        _proto.update = function update(buffer, size) {
          if (this._isBufferView) {
            console.warn('cannot update through buffer views!');
            return;
          }

          var buffSize;

          if (size !== undefined) {
            buffSize = size;
          } else if (this._usage & BufferUsageBit.INDIRECT) {
            buffSize = 0;
          } else {
            buffSize = buffer.byteLength;
          }

          WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
        };

        _createClass(WebGLBuffer, [{
          key: "gpuBuffer",
          get: function get() {
            return this._gpuBuffer;
          }
        }, {
          key: "gpuBufferView",
          get: function get() {
            return this._gpuBufferView;
          }
        }]);

        return WebGLBuffer;
      }(Buffer);

      var WebGLCommandPool = function () {
        function WebGLCommandPool(Clazz, count) {
          this._frees = void 0;
          this._freeIdx = 0;
          this._freeCmds = void 0;
          this._frees = new Array(count);
          this._freeCmds = new CachedArray(count);

          for (var i = 0; i < count; ++i) {
            this._frees[i] = new Clazz();
          }

          this._freeIdx = count - 1;
        }

        var _proto = WebGLCommandPool.prototype;

        _proto.alloc = function alloc(Clazz) {
          if (this._freeIdx < 0) {
            var size = this._frees.length * 2;
            var temp = this._frees;
            this._frees = new Array(size);
            var increase = size - temp.length;

            for (var i = 0; i < increase; ++i) {
              this._frees[i] = new Clazz();
            }

            for (var _i = increase, j = 0; _i < size; ++_i, ++j) {
              this._frees[_i] = temp[j];
            }

            this._freeIdx += increase;
          }

          var cmd = this._frees[this._freeIdx];
          this._frees[this._freeIdx--] = null;
          ++cmd.refCount;
          return cmd;
        };

        _proto.free = function free(cmd) {
          if (--cmd.refCount === 0) {
            this._freeCmds.push(cmd);
          }
        };

        _proto.freeCmds = function freeCmds(cmds) {
          for (var i = 0; i < cmds.length; ++i) {
            if (--cmds.array[i].refCount === 0) {
              this._freeCmds.push(cmds.array[i]);
            }
          }
        };

        _proto.release = function release() {
          for (var i = 0; i < this._freeCmds.length; ++i) {
            var cmd = this._freeCmds.array[i];
            cmd.clear();
            this._frees[++this._freeIdx] = cmd;
          }

          this._freeCmds.clear();
        };

        return WebGLCommandPool;
      }();
      var WebGLCommandAllocator = function () {
        function WebGLCommandAllocator() {
          this.beginRenderPassCmdPool = void 0;
          this.bindStatesCmdPool = void 0;
          this.drawCmdPool = void 0;
          this.updateBufferCmdPool = void 0;
          this.copyBufferToTextureCmdPool = void 0;
          this.beginRenderPassCmdPool = new WebGLCommandPool(WebGLCmdBeginRenderPass, 1);
          this.bindStatesCmdPool = new WebGLCommandPool(WebGLCmdBindStates, 1);
          this.drawCmdPool = new WebGLCommandPool(WebGLCmdDraw, 1);
          this.updateBufferCmdPool = new WebGLCommandPool(WebGLCmdUpdateBuffer, 1);
          this.copyBufferToTextureCmdPool = new WebGLCommandPool(WebGLCmdCopyBufferToTexture, 1);
        }

        var _proto2 = WebGLCommandAllocator.prototype;

        _proto2.clearCmds = function clearCmds(cmdPackage) {
          if (cmdPackage.beginRenderPassCmds.length) {
            this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
            cmdPackage.beginRenderPassCmds.clear();
          }

          if (cmdPackage.bindStatesCmds.length) {
            this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
            cmdPackage.bindStatesCmds.clear();
          }

          if (cmdPackage.drawCmds.length) {
            this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
            cmdPackage.drawCmds.clear();
          }

          if (cmdPackage.updateBufferCmds.length) {
            this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
            cmdPackage.updateBufferCmds.clear();
          }

          if (cmdPackage.copyBufferToTextureCmds.length) {
            this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
            cmdPackage.copyBufferToTextureCmds.clear();
          }

          cmdPackage.cmds.clear();
        };

        _proto2.releaseCmds = function releaseCmds() {
          this.beginRenderPassCmdPool.release();
          this.bindStatesCmdPool.release();
          this.drawCmdPool.release();
          this.updateBufferCmdPool.release();
          this.copyBufferToTextureCmdPool.release();
        };

        return WebGLCommandAllocator;
      }();

      var WebGLCommandBuffer = function (_CommandBuffer) {
        _inheritsLoose(WebGLCommandBuffer, _CommandBuffer);

        function WebGLCommandBuffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _CommandBuffer.call.apply(_CommandBuffer, [this].concat(args)) || this;
          _this.cmdPackage = new WebGLCmdPackage();
          _this._cmdAllocator = new WebGLCommandAllocator();
          _this._isInRenderPass = false;
          _this._curGPUPipelineState = null;
          _this._curGPUInputAssembler = null;
          _this._curGPUDescriptorSets = [];
          _this._curDynamicOffsets = Array(8).fill(0);
          _this._curDynamicStates = new DynamicStates();
          _this._isStateInvalied = false;
          return _this;
        }

        var _proto = WebGLCommandBuffer.prototype;

        _proto.initialize = function initialize(info) {
          this._type = info.type;
          this._queue = info.queue;
          var setCount = WebGLDeviceManager.instance.bindingMappings.blockOffsets.length;

          for (var i = 0; i < setCount; i++) {
            this._curGPUDescriptorSets.push(null);
          }
        };

        _proto.destroy = function destroy() {
          this._cmdAllocator.clearCmds(this.cmdPackage);
        };

        _proto.begin = function begin(renderPass, subpass, frameBuffer) {

          this._cmdAllocator.clearCmds(this.cmdPackage);

          this._curGPUPipelineState = null;
          this._curGPUInputAssembler = null;
          this._curGPUDescriptorSets.length = 0;
          this._numDrawCalls = 0;
          this._numInstances = 0;
          this._numTris = 0;
        };

        _proto.end = function end() {
          if (this._isStateInvalied) {
            this.bindStates();
          }

          this._isInRenderPass = false;
        };

        _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          var cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);

          cmd.gpuRenderPass = renderPass.gpuRenderPass;
          cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
          cmd.renderArea.copy(renderArea);
          cmd.clearColors.length = clearColors.length;

          for (var i = 0; i < clearColors.length; ++i) {
            cmd.clearColors[i] = clearColors[i];
          }

          cmd.clearDepth = clearDepth;
          cmd.clearStencil = clearStencil;
          this.cmdPackage.beginRenderPassCmds.push(cmd);
          this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS);
          this._isInRenderPass = true;
        };

        _proto.endRenderPass = function endRenderPass() {
          this._isInRenderPass = false;
        };

        _proto.bindPipelineState = function bindPipelineState(pipelineState) {
          var gpuPipelineState = pipelineState.gpuPipelineState;

          if (gpuPipelineState !== this._curGPUPipelineState) {
            this._curGPUPipelineState = gpuPipelineState;
            this._isStateInvalied = true;
          }
        };

        _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
          var gpuDescriptorSet = descriptorSet.gpuDescriptorSet;

          if (gpuDescriptorSet !== this._curGPUDescriptorSets[set]) {
            this._curGPUDescriptorSets[set] = gpuDescriptorSet;
            this._isStateInvalied = true;
          }

          if (dynamicOffsets) {
            var _this$_curGPUPipeline;

            var gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;

            if (gpuPipelineLayout) {
              var offsets = this._curDynamicOffsets;
              var idx = gpuPipelineLayout.dynamicOffsetOffsets[set];

              for (var i = 0; i < dynamicOffsets.length; i++) {
                offsets[idx + i] = dynamicOffsets[i];
              }

              this._isStateInvalied = true;
            }
          }
        };

        _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
          var gpuInputAssembler = inputAssembler.gpuInputAssembler;
          this._curGPUInputAssembler = gpuInputAssembler;
          this._isStateInvalied = true;
        };

        _proto.setViewport = function setViewport(viewport) {
          var cache = this._curDynamicStates.viewport;

          if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
            cache.left = viewport.left;
            cache.top = viewport.top;
            cache.width = viewport.width;
            cache.height = viewport.height;
            cache.minDepth = viewport.minDepth;
            cache.maxDepth = viewport.maxDepth;
            this._isStateInvalied = true;
          }
        };

        _proto.setScissor = function setScissor(scissor) {
          var cache = this._curDynamicStates.scissor;

          if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
            cache.x = scissor.x;
            cache.y = scissor.y;
            cache.width = scissor.width;
            cache.height = scissor.height;
            this._isStateInvalied = true;
          }
        };

        _proto.setLineWidth = function setLineWidth(lineWidth) {
          if (this._curDynamicStates.lineWidth !== lineWidth) {
            this._curDynamicStates.lineWidth = lineWidth;
            this._isStateInvalied = true;
          }
        };

        _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
          var cache = this._curDynamicStates;

          if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
            cache.depthBiasConstant = depthBiasConstantFactor;
            cache.depthBiasClamp = depthBiasClamp;
            cache.depthBiasSlope = depthBiasSlopeFactor;
            this._isStateInvalied = true;
          }
        };

        _proto.setBlendConstants = function setBlendConstants(blendConstants) {
          var cache = this._curDynamicStates.blendConstant;

          if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
            cache.copy(blendConstants);
            this._isStateInvalied = true;
          }
        };

        _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
          var cache = this._curDynamicStates;

          if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
            cache.depthMinBounds = minDepthBounds;
            cache.depthMaxBounds = maxDepthBounds;
            this._isStateInvalied = true;
          }
        };

        _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
          var front = this._curDynamicStates.stencilStatesFront;
          var back = this._curDynamicStates.stencilStatesBack;

          if (face & StencilFace.FRONT) {
            if (front.writeMask !== writeMask) {
              front.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }

          if (face & StencilFace.BACK) {
            if (back.writeMask !== writeMask) {
              back.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }
        };

        _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
          var front = this._curDynamicStates.stencilStatesFront;
          var back = this._curDynamicStates.stencilStatesBack;

          if (face & StencilFace.FRONT) {
            if (front.compareMask !== compareMask || front.reference !== reference) {
              front.reference = reference;
              front.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }

          if (face & StencilFace.BACK) {
            if (back.compareMask !== compareMask || back.reference !== reference) {
              back.reference = reference;
              back.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }
        };

        _proto.draw = function draw(infoOrAssembler) {
          if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            if (this._isStateInvalied) {
              this.bindStates();
            }

            var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;

            var cmd = this._cmdAllocator.drawCmdPool.alloc(WebGLCmdDraw);

            cmd.drawInfo.copy(info);
            this.cmdPackage.drawCmds.push(cmd);
            this.cmdPackage.cmds.push(WebGLCmd.DRAW);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            var indexCount = info.indexCount || info.vertexCount;

            if (this._curGPUPipelineState) {
              var glPrimitive = this._curGPUPipelineState.glPrimitive;

              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }

                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        };

        _proto.updateBuffer = function updateBuffer(buffer, data, size) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            var gpuBuffer = buffer.gpuBuffer;

            if (gpuBuffer) {
              var cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);

              var buffSize = 0;
              var buff = null;

              if (buffer.usage & BufferUsageBit.INDIRECT) {
                buff = data;
              } else {
                if (size !== undefined) {
                  buffSize = size;
                } else {
                  buffSize = data.byteLength;
                }

                buff = data;
              }

              cmd.gpuBuffer = gpuBuffer;
              cmd.buffer = buff;
              cmd.offset = 0;
              cmd.size = buffSize;
              this.cmdPackage.updateBufferCmds.push(cmd);
              this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            var gpuTexture = texture.gpuTexture;

            if (gpuTexture) {
              var cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);

              if (cmd) {
                cmd.gpuTexture = gpuTexture;
                cmd.regions = regions;
                cmd.buffers = buffers;
                this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE);
              }
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        };

        _proto.execute = function execute(cmdBuffs, count) {
          for (var i = 0; i < count; ++i) {
            var webGLCmdBuff = cmdBuffs[i];

            for (var c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
              var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.beginRenderPassCmds.push(cmd);
            }

            for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
              var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
              ++_cmd.refCount;
              this.cmdPackage.bindStatesCmds.push(_cmd);
            }

            for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
              var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
              ++_cmd2.refCount;
              this.cmdPackage.drawCmds.push(_cmd2);
            }

            for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
              var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
              ++_cmd3.refCount;
              this.cmdPackage.updateBufferCmds.push(_cmd3);
            }

            for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
              var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
              ++_cmd4.refCount;
              this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
            }

            this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds.array);
            this._numDrawCalls += webGLCmdBuff._numDrawCalls;
            this._numInstances += webGLCmdBuff._numInstances;
            this._numTris += webGLCmdBuff._numTris;
          }
        };

        _proto.pipelineBarrier = function pipelineBarrier(GeneralBarrier, bufferBarriers, buffers, textureBarriers, textures) {};

        _proto.bindStates = function bindStates() {
          var bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);

          if (bindStatesCmd) {
            bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
            Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
            Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
            bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
            bindStatesCmd.dynamicStates.copy(this._curDynamicStates);
            this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
            this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES);
            this._isStateInvalied = false;
          }
        };

        return WebGLCommandBuffer;
      }(CommandBuffer);

      var WebGLFramebuffer = function (_Framebuffer) {
        _inheritsLoose(WebGLFramebuffer, _Framebuffer);

        function WebGLFramebuffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Framebuffer.call.apply(_Framebuffer, [this].concat(args)) || this;
          _this._gpuFramebuffer = null;
          return _this;
        }

        var _proto = WebGLFramebuffer.prototype;

        _proto.initialize = function initialize(info) {
          this._renderPass = info.renderPass;
          this._colorTextures = info.colorTextures || [];
          this._depthStencilTexture = info.depthStencilTexture || null;
          var lodLevel = 0;
          var gpuColorTextures = [];

          for (var i = 0; i < info.colorTextures.length; ++i) {
            var colorTexture = info.colorTextures[i];

            if (colorTexture) {
              gpuColorTextures.push(colorTexture.gpuTexture);
              lodLevel = colorTexture.lodLevel;
            }
          }

          var gpuDepthStencilTexture = null;

          if (info.depthStencilTexture) {
            gpuDepthStencilTexture = info.depthStencilTexture.gpuTexture;
            lodLevel = info.depthStencilTexture.lodLevel;
          }

          var width = Number.MAX_SAFE_INTEGER;
          var height = Number.MAX_SAFE_INTEGER;
          this._gpuFramebuffer = {
            gpuRenderPass: info.renderPass.gpuRenderPass,
            gpuColorTextures: gpuColorTextures,
            gpuDepthStencilTexture: gpuDepthStencilTexture,
            glFramebuffer: null,
            isOffscreen: true,

            get width() {
              return this.isOffscreen ? width : this.gpuColorTextures[0].width;
            },

            set width(val) {
              width = val;
            },

            get height() {
              return this.isOffscreen ? height : this.gpuColorTextures[0].height;
            },

            set height(val) {
              height = val;
            },

            lodLevel: lodLevel
          };
          WebGLCmdFuncCreateFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
        };

        _proto.destroy = function destroy() {
          if (this._gpuFramebuffer) {
            WebGLCmdFuncDestroyFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
            this._gpuFramebuffer = null;
          }
        };

        _createClass(WebGLFramebuffer, [{
          key: "gpuFramebuffer",
          get: function get() {
            return this._gpuFramebuffer;
          }
        }]);

        return WebGLFramebuffer;
      }(Framebuffer);

      var WebGLInputAssembler = function (_InputAssembler) {
        _inheritsLoose(WebGLInputAssembler, _InputAssembler);

        function WebGLInputAssembler() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _InputAssembler.call.apply(_InputAssembler, [this].concat(args)) || this;
          _this._gpuInputAssembler = null;
          return _this;
        }

        var _proto = WebGLInputAssembler.prototype;

        _proto.initialize = function initialize(info) {
          if (info.vertexBuffers.length === 0) {
            console.error('InputAssemblerInfo.vertexBuffers is null.');
            return;
          }

          this._attributes = info.attributes;
          this._attributesHash = this.computeAttributesHash();
          this._vertexBuffers = info.vertexBuffers;

          if (info.indexBuffer) {
            this._indexBuffer = info.indexBuffer;
            this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
            this._drawInfo.firstIndex = 0;
          } else {
            var vertBuff = this._vertexBuffers[0];
            this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
            this._drawInfo.firstVertex = 0;
            this._drawInfo.vertexOffset = 0;
          }

          this._drawInfo.instanceCount = 0;
          this._drawInfo.firstInstance = 0;
          this._indirectBuffer = info.indirectBuffer || null;
          var gpuVertexBuffers = new Array(info.vertexBuffers.length);

          for (var i = 0; i < info.vertexBuffers.length; ++i) {
            var vb = info.vertexBuffers[i];

            if (vb.gpuBuffer) {
              gpuVertexBuffers[i] = vb.gpuBuffer;
            }
          }

          var gpuIndexBuffer = null;
          var glIndexType = 0;

          if (info.indexBuffer) {
            gpuIndexBuffer = info.indexBuffer.gpuBuffer;

            if (gpuIndexBuffer) {
              switch (gpuIndexBuffer.stride) {
                case 1:
                  glIndexType = 0x1401;
                  break;

                case 2:
                  glIndexType = 0x1403;
                  break;

                case 4:
                  glIndexType = 0x1405;
                  break;

                default:
                  {
                    console.error('Error index buffer stride.');
                  }
              }
            }
          }

          var gpuIndirectBuffer = null;

          if (info.indirectBuffer) {
            gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
          }

          this._gpuInputAssembler = {
            attributes: info.attributes,
            gpuVertexBuffers: gpuVertexBuffers,
            gpuIndexBuffer: gpuIndexBuffer,
            gpuIndirectBuffer: gpuIndirectBuffer,
            glAttribs: [],
            glIndexType: glIndexType,
            glVAOs: new Map()
          };
          WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
        };

        _proto.destroy = function destroy() {
          var device = WebGLDeviceManager.instance;

          if (this._gpuInputAssembler && device.extensions.useVAO) {
            WebGLCmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
          }

          this._gpuInputAssembler = null;
        };

        _createClass(WebGLInputAssembler, [{
          key: "gpuInputAssembler",
          get: function get() {
            return this._gpuInputAssembler;
          }
        }]);

        return WebGLInputAssembler;
      }(InputAssembler);

      var WebGLDescriptorSetLayout = function (_DescriptorSetLayout) {
        _inheritsLoose(WebGLDescriptorSetLayout, _DescriptorSetLayout);

        function WebGLDescriptorSetLayout() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _DescriptorSetLayout.call.apply(_DescriptorSetLayout, [this].concat(args)) || this;
          _this._gpuDescriptorSetLayout = null;
          return _this;
        }

        var _proto = WebGLDescriptorSetLayout.prototype;

        _proto.initialize = function initialize(info) {
          Array.prototype.push.apply(this._bindings, info.bindings);
          var descriptorCount = 0;
          var maxBinding = -1;
          var flattenedIndices = [];

          for (var i = 0; i < this._bindings.length; i++) {
            var binding = this._bindings[i];
            flattenedIndices.push(descriptorCount);
            descriptorCount += binding.count;
            if (binding.binding > maxBinding) maxBinding = binding.binding;
          }

          this._bindingIndices = Array(maxBinding + 1).fill(-1);
          var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

          for (var _i = 0; _i < this._bindings.length; _i++) {
            var _binding = this._bindings[_i];
            this._bindingIndices[_binding.binding] = _i;
            descriptorIndices[_binding.binding] = flattenedIndices[_i];
          }

          var dynamicBindings = [];

          for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
            var _binding2 = this._bindings[_i2];

            if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
              for (var j = 0; j < _binding2.count; j++) {
                dynamicBindings.push(_binding2.binding);
              }
            }
          }

          this._gpuDescriptorSetLayout = {
            bindings: this._bindings,
            dynamicBindings: dynamicBindings,
            descriptorIndices: descriptorIndices,
            descriptorCount: descriptorCount
          };
        };

        _proto.destroy = function destroy() {
          this._bindings.length = 0;
        };

        _createClass(WebGLDescriptorSetLayout, [{
          key: "gpuDescriptorSetLayout",
          get: function get() {
            return this._gpuDescriptorSetLayout;
          }
        }]);

        return WebGLDescriptorSetLayout;
      }(DescriptorSetLayout);

      var WebGLPipelineLayout = function (_PipelineLayout) {
        _inheritsLoose(WebGLPipelineLayout, _PipelineLayout);

        function WebGLPipelineLayout() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineLayout.call.apply(_PipelineLayout, [this].concat(args)) || this;
          _this._gpuPipelineLayout = null;
          return _this;
        }

        var _proto = WebGLPipelineLayout.prototype;

        _proto.initialize = function initialize(info) {
          Array.prototype.push.apply(this._setLayouts, info.setLayouts);
          var dynamicOffsetIndices = [];
          var gpuSetLayouts = [];
          var dynamicOffsetCount = 0;
          var dynamicOffsetOffsets = [];

          for (var i = 0; i < this._setLayouts.length; i++) {
            var setLayout = this._setLayouts[i];
            var dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
            var indices = Array(setLayout.bindingIndices.length).fill(-1);

            for (var j = 0; j < dynamicBindings.length; j++) {
              var binding = dynamicBindings[j];
              if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
            }

            gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
            dynamicOffsetIndices.push(indices);
            dynamicOffsetOffsets.push(dynamicOffsetCount);
            dynamicOffsetCount += dynamicBindings.length;
          }

          this._gpuPipelineLayout = {
            gpuSetLayouts: gpuSetLayouts,
            dynamicOffsetIndices: dynamicOffsetIndices,
            dynamicOffsetCount: dynamicOffsetCount,
            dynamicOffsetOffsets: dynamicOffsetOffsets
          };
        };

        _proto.destroy = function destroy() {
          this._setLayouts.length = 0;
        };

        _createClass(WebGLPipelineLayout, [{
          key: "gpuPipelineLayout",
          get: function get() {
            return this._gpuPipelineLayout;
          }
        }]);

        return WebGLPipelineLayout;
      }(PipelineLayout);

      var WebGLPrimitives = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
      var WebGLPipelineState = function (_PipelineState) {
        _inheritsLoose(WebGLPipelineState, _PipelineState);

        function WebGLPipelineState() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineState.call.apply(_PipelineState, [this].concat(args)) || this;
          _this._gpuPipelineState = null;
          return _this;
        }

        var _proto = WebGLPipelineState.prototype;

        _proto.initialize = function initialize(info) {
          this._primitive = info.primitive;
          this._shader = info.shader;
          this._pipelineLayout = info.pipelineLayout;
          var bs = this._bs;

          if (info.blendState) {
            var bsInfo = info.blendState;
            var targets = bsInfo.targets;

            if (targets) {
              targets.forEach(function (t, i) {
                bs.setTarget(i, t);
              });
            }

            if (bsInfo.isA2C !== undefined) {
              bs.isA2C = bsInfo.isA2C;
            }

            if (bsInfo.isIndepend !== undefined) {
              bs.isIndepend = bsInfo.isIndepend;
            }

            if (bsInfo.blendColor !== undefined) {
              bs.blendColor = bsInfo.blendColor;
            }
          }

          Object.assign(this._rs, info.rasterizerState);
          Object.assign(this._dss, info.depthStencilState);
          this._is = info.inputState;
          this._renderPass = info.renderPass;
          this._dynamicStates = info.dynamicStates;
          var dynamicStates = [];

          for (var i = 0; i < 31; i++) {
            if (this._dynamicStates & 1 << i) {
              dynamicStates.push(1 << i);
            }
          }

          this._gpuPipelineState = {
            glPrimitive: WebGLPrimitives[info.primitive],
            gpuShader: info.shader.gpuShader,
            gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
            rs: info.rasterizerState,
            dss: info.depthStencilState,
            bs: info.blendState,
            gpuRenderPass: info.renderPass.gpuRenderPass,
            dynamicStates: dynamicStates
          };
        };

        _proto.destroy = function destroy() {
          this._gpuPipelineState = null;
        };

        _createClass(WebGLPipelineState, [{
          key: "gpuPipelineState",
          get: function get() {
            return this._gpuPipelineState;
          }
        }]);

        return WebGLPipelineState;
      }(PipelineState);

      var WebGLPrimaryCommandBuffer = function (_WebGLCommandBuffer) {
        _inheritsLoose(WebGLPrimaryCommandBuffer, _WebGLCommandBuffer);

        function WebGLPrimaryCommandBuffer() {
          return _WebGLCommandBuffer.apply(this, arguments) || this;
        }

        var _proto = WebGLPrimaryCommandBuffer.prototype;

        _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          WebGLCmdFuncBeginRenderPass(WebGLDeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
          this._isInRenderPass = true;
        };

        _proto.draw = function draw(infoOrAssembler) {
          if (this._isInRenderPass) {
            if (this._isStateInvalied) {
              this.bindStates();
            }

            var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
            WebGLCmdFuncDraw(WebGLDeviceManager.instance, info);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            var indexCount = info.indexCount || info.vertexCount;

            if (this._curGPUPipelineState) {
              var glPrimitive = this._curGPUPipelineState.glPrimitive;

              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }

                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        };

        _proto.setViewport = function setViewport(viewport) {
          var _WebGLDeviceManager$i = WebGLDeviceManager.instance,
              cache = _WebGLDeviceManager$i.stateCache,
              gl = _WebGLDeviceManager$i.gl;

          if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
            gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
            cache.viewport.left = viewport.left;
            cache.viewport.top = viewport.top;
            cache.viewport.width = viewport.width;
            cache.viewport.height = viewport.height;
          }
        };

        _proto.setScissor = function setScissor(scissor) {
          var _WebGLDeviceManager$i2 = WebGLDeviceManager.instance,
              cache = _WebGLDeviceManager$i2.stateCache,
              gl = _WebGLDeviceManager$i2.gl;

          if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
            gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
            cache.scissorRect.x = scissor.x;
            cache.scissorRect.y = scissor.y;
            cache.scissorRect.width = scissor.width;
            cache.scissorRect.height = scissor.height;
          }
        };

        _proto.updateBuffer = function updateBuffer(buffer, data, size) {
          if (!this._isInRenderPass) {
            var gpuBuffer = buffer.gpuBuffer;

            if (gpuBuffer) {
              var buffSize;

              if (size !== undefined) {
                buffSize = size;
              } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                buffSize = 0;
              } else {
                buffSize = data.byteLength;
              }

              WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, gpuBuffer, data, 0, buffSize);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          if (!this._isInRenderPass) {
            var gpuTexture = texture.gpuTexture;

            if (gpuTexture) {
              WebGLCmdFuncCopyBuffersToTexture(WebGLDeviceManager.instance, buffers, gpuTexture, regions);
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        };

        _proto.execute = function execute(cmdBuffs, count) {
          for (var i = 0; i < count; ++i) {
            var webGLCmdBuff = cmdBuffs[i];
            WebGLCmdFuncExecuteCmds(WebGLDeviceManager.instance, webGLCmdBuff.cmdPackage);
            this._numDrawCalls += webGLCmdBuff._numDrawCalls;
            this._numInstances += webGLCmdBuff._numInstances;
            this._numTris += webGLCmdBuff._numTris;
          }
        };

        _proto.bindStates = function bindStates() {
          WebGLCmdFuncBindStates(WebGLDeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
          this._isStateInvalied = false;
        };

        return WebGLPrimaryCommandBuffer;
      }(WebGLCommandBuffer);

      var WebGLQueue = function (_Queue) {
        _inheritsLoose(WebGLQueue, _Queue);

        function WebGLQueue() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Queue.call.apply(_Queue, [this].concat(args)) || this;
          _this.numDrawCalls = 0;
          _this.numInstances = 0;
          _this.numTris = 0;
          return _this;
        }

        var _proto = WebGLQueue.prototype;

        _proto.initialize = function initialize(info) {
          this._type = info.type;
        };

        _proto.destroy = function destroy() {};

        _proto.submit = function submit(cmdBuffs) {
          var len = cmdBuffs.length;

          for (var i = 0; i < len; i++) {
            var cmdBuff = cmdBuffs[i];
            this.numDrawCalls += cmdBuff.numDrawCalls;
            this.numInstances += cmdBuff.numInstances;
            this.numTris += cmdBuff.numTris;
          }
        };

        _proto.clear = function clear() {
          this.numDrawCalls = 0;
          this.numInstances = 0;
          this.numTris = 0;
        };

        return WebGLQueue;
      }(Queue);

      var WebGLRenderPass = function (_RenderPass) {
        _inheritsLoose(WebGLRenderPass, _RenderPass);

        function WebGLRenderPass() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
          _this._gpuRenderPass = null;
          return _this;
        }

        var _proto = WebGLRenderPass.prototype;

        _proto.initialize = function initialize(info) {
          this._colorInfos = info.colorAttachments;
          this._depthStencilInfo = info.depthStencilAttachment;
          this._subpasses = info.subpasses;
          this._gpuRenderPass = {
            colorAttachments: this._colorInfos,
            depthStencilAttachment: this._depthStencilInfo
          };
          this._hash = this.computeHash();
        };

        _proto.destroy = function destroy() {
          this._gpuRenderPass = null;
        };

        _createClass(WebGLRenderPass, [{
          key: "gpuRenderPass",
          get: function get() {
            return this._gpuRenderPass;
          }
        }]);

        return WebGLRenderPass;
      }(RenderPass);

      var WebGLWraps = [0x2901, 0x8370, 0x812F, 0x812F];
      var WebGLSampler = function (_Sampler) {
        _inheritsLoose(WebGLSampler, _Sampler);

        function WebGLSampler(info, hash) {
          var _this;

          _this = _Sampler.call(this, info, hash) || this;
          _this._gpuSampler = null;
          var glMinFilter = 0;
          var glMagFilter = 0;
          var minFilter = _this._info.minFilter;
          var magFilter = _this._info.magFilter;
          var mipFilter = _this._info.mipFilter;

          if (minFilter === Filter.LINEAR || minFilter === Filter.ANISOTROPIC) {
            if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
              glMinFilter = 0x2703;
            } else if (mipFilter === Filter.POINT) {
              glMinFilter = 0x2701;
            } else {
              glMinFilter = 0x2601;
            }
          } else if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
            glMinFilter = 0x2702;
          } else if (mipFilter === Filter.POINT) {
            glMinFilter = 0x2700;
          } else {
            glMinFilter = 0x2600;
          }

          if (magFilter === Filter.LINEAR || magFilter === Filter.ANISOTROPIC) {
            glMagFilter = 0x2601;
          } else {
            glMagFilter = 0x2600;
          }

          var glWrapS = WebGLWraps[_this._info.addressU];
          var glWrapT = WebGLWraps[_this._info.addressV];
          var glWrapR = WebGLWraps[_this._info.addressW];
          _this._gpuSampler = {
            glMinFilter: glMinFilter,
            glMagFilter: glMagFilter,
            glWrapS: glWrapS,
            glWrapT: glWrapT,
            glWrapR: glWrapR
          };
          return _this;
        }

        _createClass(WebGLSampler, [{
          key: "gpuSampler",
          get: function get() {
            return this._gpuSampler;
          }
        }]);

        return WebGLSampler;
      }(Sampler);

      var WebGLShader = function (_Shader) {
        _inheritsLoose(WebGLShader, _Shader);

        function WebGLShader() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Shader.call.apply(_Shader, [this].concat(args)) || this;
          _this._gpuShader = null;
          return _this;
        }

        var _proto = WebGLShader.prototype;

        _proto.initialize = function initialize(info) {
          this._name = info.name;
          this._stages = info.stages;
          this._attributes = info.attributes;
          this._blocks = info.blocks;
          this._samplers = info.samplers;
          this._gpuShader = {
            name: info.name,
            blocks: info.blocks.slice(),
            samplerTextures: info.samplerTextures.slice(),
            subpassInputs: info.subpassInputs.slice(),
            gpuStages: new Array(info.stages.length),
            glProgram: null,
            glInputs: [],
            glUniforms: [],
            glBlocks: [],
            glSamplerTextures: []
          };

          for (var i = 0; i < info.stages.length; ++i) {
            var stage = info.stages[i];
            this._gpuShader.gpuStages[i] = {
              type: stage.stage,
              source: stage.source,
              glShader: null
            };
          }
        };

        _proto.destroy = function destroy() {
          if (this._gpuShader) {
            WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
            this._gpuShader = null;
          }
        };

        _createClass(WebGLShader, [{
          key: "gpuShader",
          get: function get() {
            if (this._gpuShader.glProgram === null) {
              WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
            }

            return this._gpuShader;
          }
        }]);

        return WebGLShader;
      }(Shader);

      var WebGLStateCache = function () {
        function WebGLStateCache() {
          this.glArrayBuffer = null;
          this.glElementArrayBuffer = null;
          this.glVAO = null;
          this.texUnit = 0;
          this.glTexUnits = [];
          this.glRenderbuffer = null;
          this.glFramebuffer = null;
          this.viewport = new Viewport();
          this.scissorRect = new Rect$1(0, 0, 0, 0);
          this.rs = new RasterizerState();
          this.dss = new DepthStencilState();
          this.bs = new BlendState();
          this.glProgram = null;
          this.glEnabledAttribLocs = [];
          this.glCurrentAttribLocs = [];
          this.texUnitCacheMap = {};
        }

        var _proto = WebGLStateCache.prototype;

        _proto.initialize = function initialize(texUnit, vertexAttributes) {
          for (var i = 0; i < texUnit; ++i) {
            this.glTexUnits.push({
              glTexture: null
            });
          }

          this.glEnabledAttribLocs.length = vertexAttributes;
          this.glEnabledAttribLocs.fill(false);
          this.glCurrentAttribLocs.length = vertexAttributes;
          this.glCurrentAttribLocs.fill(false);
        };

        return WebGLStateCache;
      }();

      var WebGLTexture = function (_Texture) {
        _inheritsLoose(WebGLTexture, _Texture);

        function WebGLTexture() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Texture.call.apply(_Texture, [this].concat(args)) || this;
          _this._gpuTexture = null;
          _this._lodLevel = 0;
          return _this;
        }

        var _proto = WebGLTexture.prototype;

        _proto.initialize = function initialize(info, isSwapchainTexture) {
          var texInfo = info;
          var viewInfo = info;

          if ('texture' in info) {
            texInfo = viewInfo.texture.info;
            this._isTextureView = true;
          }

          this._info.copy(texInfo);

          this._isPowerOf2 = IsPowerOf2(this._info.width) && IsPowerOf2(this._info.height);
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

          if (!this._isTextureView) {
            this._gpuTexture = {
              type: texInfo.type,
              format: texInfo.format,
              usage: texInfo.usage,
              width: texInfo.width,
              height: texInfo.height,
              depth: texInfo.depth,
              size: this._size,
              arrayLayer: texInfo.layerCount,
              mipLevel: texInfo.levelCount,
              samples: texInfo.samples,
              flags: texInfo.flags,
              isPowerOf2: this._isPowerOf2,
              glTarget: 0,
              glInternalFmt: 0,
              glFormat: 0,
              glType: 0,
              glUsage: 0,
              glTexture: null,
              glRenderbuffer: null,
              glWrapS: 0,
              glWrapT: 0,
              glMinFilter: 0,
              glMagFilter: 0,
              isSwapchainTexture: isSwapchainTexture || false
            };
            WebGLCmdFuncCreateTexture(WebGLDeviceManager.instance, this._gpuTexture);
            WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
            this._viewInfo.texture = this;
            this._viewInfo.type = info.type;
            this._viewInfo.format = info.format;
            this._viewInfo.baseLevel = 0;
            this._viewInfo.levelCount = info.levelCount;
            this._viewInfo.baseLayer = 0;
            this._viewInfo.layerCount = info.layerCount;
          } else {
            this._viewInfo.copy(viewInfo);

            this._lodLevel = viewInfo.baseLevel;
            this._gpuTexture = viewInfo.texture._gpuTexture;
          }
        };

        _proto.destroy = function destroy() {
          if (!this._isTextureView && this._gpuTexture) {
            WebGLCmdFuncDestroyTexture(WebGLDeviceManager.instance, this._gpuTexture);
            WebGLDeviceManager.instance.memoryStatus.textureSize -= this._size;
            this._gpuTexture = null;
          }
        };

        _proto.resize = function resize(width, height) {
          if (this._info.width === width && this._info.height === height) {
            return;
          }

          if (this._info.levelCount === WebGLTexture.getLevelCount(this._info.width, this._info.height)) {
            this._info.levelCount = WebGLTexture.getLevelCount(width, height);
          } else if (this._info.levelCount > 1) {
            this._info.levelCount = Math.min(this._info.levelCount, WebGLTexture.getLevelCount(width, height));
          }

          var oldSize = this._size;
          this._info.width = width;
          this._info.height = height;
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

          if (!this._isTextureView && this._gpuTexture) {
            this._gpuTexture.width = width;
            this._gpuTexture.height = height;
            this._gpuTexture.size = this._size;
            WebGLCmdFuncResizeTexture(WebGLDeviceManager.instance, this._gpuTexture);
            WebGLDeviceManager.instance.memoryStatus.textureSize -= oldSize;
            WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
          }
        };

        _proto.initAsSwapchainTexture = function initAsSwapchainTexture(info) {
          var texInfo = new TextureInfo();
          texInfo.format = info.format;
          texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
          texInfo.width = info.width;
          texInfo.height = info.height;
          this.initialize(texInfo, true);
        };

        _createClass(WebGLTexture, [{
          key: "gpuTexture",
          get: function get() {
            return this._gpuTexture;
          }
        }, {
          key: "lodLevel",
          get: function get() {
            return this._lodLevel;
          }
        }]);

        return WebGLTexture;
      }(Texture);

      var eventWebGLContextLost = 'webglcontextlost';

      function initStates(gl) {
        gl.activeTexture(gl.TEXTURE0);
        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.enable(gl.SCISSOR_TEST);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.frontFace(gl.CCW);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(0.0, 0.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.depthRange(0.0, 1.0);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.BACK, 0xffff);
        gl.disable(gl.STENCIL_TEST);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        gl.disable(gl.BLEND);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.colorMask(true, true, true, true);
        gl.blendColor(0.0, 0.0, 0.0, 0.0);
      }

      function getExtension(gl, ext) {
        var prefixes = ['', 'WEBKIT_', 'MOZ_'];

        for (var i = 0; i < prefixes.length; ++i) {
          var _ext = gl.getExtension(prefixes[i] + ext);

          if (_ext) {
            return _ext;
          }
        }

        return null;
      }

      function getExtensions(gl) {
        var res = {
          EXT_texture_filter_anisotropic: getExtension(gl, 'EXT_texture_filter_anisotropic'),
          EXT_blend_minmax: getExtension(gl, 'EXT_blend_minmax'),
          EXT_frag_depth: getExtension(gl, 'EXT_frag_depth'),
          EXT_shader_texture_lod: getExtension(gl, 'EXT_shader_texture_lod'),
          EXT_sRGB: getExtension(gl, 'EXT_sRGB'),
          OES_vertex_array_object: getExtension(gl, 'OES_vertex_array_object'),
          EXT_color_buffer_half_float: getExtension(gl, 'EXT_color_buffer_half_float'),
          WEBGL_color_buffer_float: getExtension(gl, 'WEBGL_color_buffer_float'),
          WEBGL_compressed_texture_etc1: getExtension(gl, 'WEBGL_compressed_texture_etc1'),
          WEBGL_compressed_texture_etc: getExtension(gl, 'WEBGL_compressed_texture_etc'),
          WEBGL_compressed_texture_pvrtc: getExtension(gl, 'WEBGL_compressed_texture_pvrtc'),
          WEBGL_compressed_texture_s3tc: getExtension(gl, 'WEBGL_compressed_texture_s3tc'),
          WEBGL_compressed_texture_s3tc_srgb: getExtension(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
          WEBGL_debug_shaders: getExtension(gl, 'WEBGL_debug_shaders'),
          WEBGL_draw_buffers: getExtension(gl, 'WEBGL_draw_buffers'),
          WEBGL_lose_context: getExtension(gl, 'WEBGL_lose_context'),
          WEBGL_depth_texture: getExtension(gl, 'WEBGL_depth_texture'),
          OES_texture_half_float: getExtension(gl, 'OES_texture_half_float'),
          OES_texture_half_float_linear: getExtension(gl, 'OES_texture_half_float_linear'),
          OES_texture_float: getExtension(gl, 'OES_texture_float'),
          OES_texture_float_linear: getExtension(gl, 'OES_texture_float_linear'),
          OES_standard_derivatives: getExtension(gl, 'OES_standard_derivatives'),
          OES_element_index_uint: getExtension(gl, 'OES_element_index_uint'),
          ANGLE_instanced_arrays: getExtension(gl, 'ANGLE_instanced_arrays'),
          WEBGL_debug_renderer_info: getExtension(gl, 'WEBGL_debug_renderer_info'),
          WEBGL_multi_draw: null,
          WEBGL_compressed_texture_astc: null,
          destroyShadersImmediately: true,
          noCompressedTexSubImage2D: false,
          isLocationActive: function isLocationActive(glLoc) {
            return !!glLoc;
          },
          useVAO: false
        };
        {
          if (systemInfo.os !== OS.IOS || systemInfo.osMainVersion !== 14 || !systemInfo.isBrowser) {
            res.WEBGL_compressed_texture_astc = getExtension(gl, 'WEBGL_compressed_texture_astc');
          }

          if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
            res.WEBGL_multi_draw = getExtension(gl, 'WEBGL_multi_draw');
          }

          if (systemInfo.browserType === BrowserType.UC) {
            res.ANGLE_instanced_arrays = null;
          }

          if (systemInfo.os === OS.IOS && systemInfo.osMainVersion <= 10 || WECHAT ) {
            res.destroyShadersImmediately = false;
          }
        }

        if (res.OES_vertex_array_object) {
          res.useVAO = true;
        }

        return res;
      }
      function getContext(canvas) {
        var context = null;

        try {
          var webGLCtxAttribs = {
            alpha: macro.ENABLE_TRANSPARENT_CANVAS,
            antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
            depth: true,
            stencil: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'default',
            failIfMajorPerformanceCaveat: false
          };
          context = canvas.getContext('webgl', webGLCtxAttribs);
        } catch (err) {
          return null;
        }

        return context;
      }
      var WebGLSwapchain = function (_Swapchain) {
        _inheritsLoose(WebGLSwapchain, _Swapchain);

        function WebGLSwapchain() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Swapchain.call.apply(_Swapchain, [this].concat(args)) || this;
          _this.stateCache = new WebGLStateCache();
          _this.cmdAllocator = new WebGLCommandAllocator();
          _this.nullTex2D = null;
          _this.nullTexCube = null;
          _this._canvas = null;
          _this._webGLContextLostHandler = null;
          _this._extensions = null;
          return _this;
        }

        var _proto = WebGLSwapchain.prototype;

        _proto.initialize = function initialize(info) {
          this._canvas = info.windowHandle;
          this._webGLContextLostHandler = this._onWebGLContextLost.bind(this);

          this._canvas.addEventListener(eventWebGLContextLost, this._onWebGLContextLost);

          var gl = WebGLDeviceManager.instance.gl;
          this.stateCache.initialize(WebGLDeviceManager.instance.capabilities.maxTextureUnits, WebGLDeviceManager.instance.capabilities.maxVertexAttributes);
          this._extensions = getExtensions(gl);
          initStates(gl);
          var colorFmt = Format.RGBA8;
          var depthStencilFmt = Format.DEPTH_STENCIL;
          var depthBits = gl.getParameter(gl.DEPTH_BITS);
          var stencilBits = gl.getParameter(gl.STENCIL_BITS);

          if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
          this._colorTexture = new WebGLTexture();

          this._colorTexture.initAsSwapchainTexture({
            swapchain: this,
            format: colorFmt,
            width: info.width,
            height: info.height
          });

          this._depthStencilTexture = new WebGLTexture();

          this._depthStencilTexture.initAsSwapchainTexture({
            swapchain: this,
            format: depthStencilFmt,
            width: info.width,
            height: info.height
          });

          this.nullTex2D = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP));
          this.nullTexCube = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP, 6));
          var nullTexRegion = new BufferTextureCopy();
          nullTexRegion.texExtent.width = 2;
          nullTexRegion.texExtent.height = 2;
          var nullTexBuff = new Uint8Array(this.nullTex2D.size);
          nullTexBuff.fill(0);
          WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
          nullTexRegion.texSubres.layerCount = 6;
          WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
        };

        _proto.destroy = function destroy() {
          if (this._canvas && this._webGLContextLostHandler) {
            this._canvas.removeEventListener(eventWebGLContextLost, this._webGLContextLostHandler);

            this._webGLContextLostHandler = null;
          }

          if (this.nullTex2D) {
            this.nullTex2D.destroy();
            this.nullTex2D = null;
          }

          if (this.nullTexCube) {
            this.nullTexCube.destroy();
            this.nullTexCube = null;
          }

          this._extensions = null;
          this._canvas = null;
        };

        _proto.resize = function resize(width, height, surfaceTransform) {
          if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
            debug("Resizing swapchain: " + width + "x" + height);
            this._canvas.width = width;
            this._canvas.height = height;

            this._colorTexture.resize(width, height);

            this._depthStencilTexture.resize(width, height);
          }
        };

        _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
          warnID(11000);
          warn(event);
        };

        _createClass(WebGLSwapchain, [{
          key: "extensions",
          get: function get() {
            return this._extensions;
          }
        }]);

        return WebGLSwapchain;
      }(Swapchain);

      var WebGLDevice = exports('WebGLDevice', function (_Device) {
        _inheritsLoose(WebGLDevice, _Device);

        function WebGLDevice() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Device.call.apply(_Device, [this].concat(args)) || this;
          _this._swapchain = null;
          _this._context = null;
          _this._bindingMappings = null;
          _this._textureExclusive = new Array(Format.COUNT);
          return _this;
        }

        var _proto = WebGLDevice.prototype;

        _proto.initialize = function initialize(info) {
          WebGLDeviceManager.setInstance(this);
          this._gfxAPI = API.WEBGL;
          var mapping = this._bindingMappingInfo = info.bindingMappingInfo;
          var blockOffsets = [];
          var samplerTextureOffsets = [];
          var firstSet = mapping.setIndices[0];
          blockOffsets[firstSet] = 0;
          samplerTextureOffsets[firstSet] = 0;

          for (var i = 1; i < mapping.setIndices.length; ++i) {
            var curSet = mapping.setIndices[i];
            var prevSet = mapping.setIndices[i - 1];
            blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
            samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
          }

          for (var _i = 0; _i < mapping.setIndices.length; ++_i) {
            var _curSet = mapping.setIndices[_i];
            samplerTextureOffsets[_curSet] -= mapping.maxBlockCounts[_curSet];
          }

          this._bindingMappings = {
            blockOffsets: blockOffsets,
            samplerTextureOffsets: samplerTextureOffsets,
            flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
          };
          var gl = this._context = getContext(Device.canvas);

          if (!gl) {
            console.error('This device does not support WebGL.');
            return false;
          }

          this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
          this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
          this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
          this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
          this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
          this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
          this._caps.maxUniformBufferBindings = 16;
          var extensions = gl.getSupportedExtensions();
          var extStr = '';

          if (extensions) {
            for (var _iterator = _createForOfIteratorHelperLoose(extensions), _step; !(_step = _iterator()).done;) {
              var ext = _step.value;
              extStr += ext + " ";
            }
          }

          var exts = getExtensions(gl);

          if (exts.WEBGL_debug_renderer_info) {
            this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
            this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
          } else {
            this._renderer = gl.getParameter(gl.RENDERER);
            this._vendor = gl.getParameter(gl.VENDOR);
          }

          var version = gl.getParameter(gl.VERSION);

          this._features.fill(false);

          this.initFormatFeatures(exts);

          if (exts.EXT_blend_minmax) {
            this._features[Feature.BLEND_MINMAX] = true;
          }

          if (exts.OES_element_index_uint) {
            this._features[Feature.ELEMENT_INDEX_UINT] = true;
          }

          if (exts.ANGLE_instanced_arrays) {
            this._features[Feature.INSTANCED_ARRAYS] = true;
          }

          if (exts.WEBGL_draw_buffers) {
            this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
          }

          var compressedFormat = '';

          if (this.getFormatFeatures(Format.ETC_RGB8)) {
            compressedFormat += 'etc1 ';
          }

          if (this.getFormatFeatures(Format.ETC2_RGB8)) {
            compressedFormat += 'etc2 ';
          }

          if (this.getFormatFeatures(Format.BC1)) {
            compressedFormat += 'dxt ';
          }

          if (this.getFormatFeatures(Format.PVRTC_RGB2)) {
            compressedFormat += 'pvrtc ';
          }

          if (this.getFormatFeatures(Format.ASTC_RGBA_4X4)) {
            compressedFormat += 'astc ';
          }

          debug('WebGL device initialized.');
          debug("RENDERER: " + this._renderer);
          debug("VENDOR: " + this._vendor);
          debug("VERSION: " + version);
          debug("COMPRESSED_FORMAT: " + compressedFormat);
          debug("EXTENSIONS: " + extStr);
          return true;
        };

        _proto.destroy = function destroy() {
          if (this._queue) {
            this._queue.destroy();

            this._queue = null;
          }

          if (this._cmdBuff) {
            this._cmdBuff.destroy();

            this._cmdBuff = null;
          }

          this._swapchain = null;
        };

        _proto.flushCommands = function flushCommands(cmdBuffs) {};

        _proto.acquire = function acquire(swapchains) {};

        _proto.present = function present() {
          var queue = this._queue;
          this._numDrawCalls = queue.numDrawCalls;
          this._numInstances = queue.numInstances;
          this._numTris = queue.numTris;
          queue.clear();
        };

        _proto.initFormatFeatures = function initFormatFeatures(exts) {
          this._formatFeatures.fill(FormatFeatureBit.NONE);

          this._textureExclusive.fill(true);

          var tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          this._formatFeatures[Format.RGB8] = tempFeature;
          this._formatFeatures[Format.R5G6B5] = tempFeature;
          this._textureExclusive[Format.R5G6B5] = false;
          this._formatFeatures[Format.RGBA8] = tempFeature;
          this._formatFeatures[Format.RGBA4] = tempFeature;
          this._textureExclusive[Format.RGBA4] = false;
          this._formatFeatures[Format.RGB5A1] = tempFeature;
          this._textureExclusive[Format.RGB5A1] = false;
          this._formatFeatures[Format.DEPTH] = FormatFeatureBit.RENDER_TARGET;
          this._textureExclusive[Format.DEPTH] = false;
          this._formatFeatures[Format.DEPTH_STENCIL] = FormatFeatureBit.RENDER_TARGET;
          this._textureExclusive[Format.DEPTH_STENCIL] = false;
          this._formatFeatures[Format.R8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;

          if (exts.EXT_sRGB) {
            this._formatFeatures[Format.SRGB8] = tempFeature;
            this._formatFeatures[Format.SRGB8_A8] = tempFeature;
            this._textureExclusive[Format.SRGB8_A8] = false;
          }

          if (exts.WEBGL_depth_texture) {
            this._formatFeatures[Format.DEPTH] |= tempFeature;
            this._formatFeatures[Format.DEPTH_STENCIL] |= tempFeature;
          }

          if (exts.WEBGL_color_buffer_float) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET;
            this._textureExclusive[Format.RGB32F] = false;
            this._textureExclusive[Format.RGBA32F] = false;
          }

          if (exts.EXT_color_buffer_half_float) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.RENDER_TARGET;
            this._textureExclusive[Format.RGB16F] = false;
            this._textureExclusive[Format.RGBA16F] = false;
          }

          if (exts.OES_texture_float) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
          }

          if (exts.OES_texture_half_float) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
          }

          if (exts.OES_texture_float_linear) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.LINEAR_FILTER;
          }

          if (exts.OES_texture_half_float_linear) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.LINEAR_FILTER;
          }

          var compressedFeature = FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;

          if (exts.WEBGL_compressed_texture_etc1) {
            this._formatFeatures[Format.ETC_RGB8] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_etc) {
            this._formatFeatures[Format.ETC2_RGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGBA8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGB8_A1] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A1] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_s3tc) {
            this._formatFeatures[Format.BC1] = compressedFeature;
            this._formatFeatures[Format.BC1_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC2] = compressedFeature;
            this._formatFeatures[Format.BC2_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC3] = compressedFeature;
            this._formatFeatures[Format.BC3_SRGB] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_pvrtc) {
            this._formatFeatures[Format.PVRTC_RGB2] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA2] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGB4] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA4] |= compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_astc) {
            this._formatFeatures[Format.ASTC_RGBA_4X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X12] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_4X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X12] |= compressedFeature;
          }
        };

        _proto.createCommandBuffer = function createCommandBuffer(info) {
          var Ctor = info.type === CommandBufferType.PRIMARY ? WebGLPrimaryCommandBuffer : WebGLCommandBuffer;
          var cmdBuff = new Ctor();
          cmdBuff.initialize(info);
          return cmdBuff;
        };

        _proto.createSwapchain = function createSwapchain(info) {
          var swapchain = new WebGLSwapchain();
          this._swapchain = swapchain;
          swapchain.initialize(info);
          return swapchain;
        };

        _proto.createBuffer = function createBuffer(info) {
          var buffer = new WebGLBuffer();
          buffer.initialize(info);
          return buffer;
        };

        _proto.createTexture = function createTexture(info) {
          var texture = new WebGLTexture();
          texture.initialize(info);
          return texture;
        };

        _proto.createDescriptorSet = function createDescriptorSet(info) {
          var descriptorSet = new WebGLDescriptorSet();
          descriptorSet.initialize(info);
          return descriptorSet;
        };

        _proto.createShader = function createShader(info) {
          var shader = new WebGLShader();
          shader.initialize(info);
          return shader;
        };

        _proto.createInputAssembler = function createInputAssembler(info) {
          var inputAssembler = new WebGLInputAssembler();
          inputAssembler.initialize(info);
          return inputAssembler;
        };

        _proto.createRenderPass = function createRenderPass(info) {
          var renderPass = new WebGLRenderPass();
          renderPass.initialize(info);
          return renderPass;
        };

        _proto.createFramebuffer = function createFramebuffer(info) {
          var framebuffer = new WebGLFramebuffer();
          framebuffer.initialize(info);
          return framebuffer;
        };

        _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
          var descriptorSetLayout = new WebGLDescriptorSetLayout();
          descriptorSetLayout.initialize(info);
          return descriptorSetLayout;
        };

        _proto.createPipelineLayout = function createPipelineLayout(info) {
          var pipelineLayout = new WebGLPipelineLayout();
          pipelineLayout.initialize(info);
          return pipelineLayout;
        };

        _proto.createPipelineState = function createPipelineState(info) {
          var pipelineState = new WebGLPipelineState();
          pipelineState.initialize(info);
          return pipelineState;
        };

        _proto.createQueue = function createQueue(info) {
          var queue = new WebGLQueue();
          queue.initialize(info);
          return queue;
        };

        _proto.getSampler = function getSampler(info) {
          var hash = Sampler.computeHash(info);

          if (!this._samplers.has(hash)) {
            this._samplers.set(hash, new WebGLSampler(info, hash));
          }

          return this._samplers.get(hash);
        };

        _proto.getSwapchains = function getSwapchains() {
          return [this._swapchain];
        };

        _proto.getGeneralBarrier = function getGeneralBarrier(info) {
          var hash = GeneralBarrier.computeHash(info);

          if (!this._generalBarrierss.has(hash)) {
            this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
          }

          return this._generalBarrierss.get(hash);
        };

        _proto.getTextureBarrier = function getTextureBarrier(info) {
          var hash = TextureBarrier.computeHash(info);

          if (!this._textureBarriers.has(hash)) {
            this._textureBarriers.set(hash, new TextureBarrier(info, hash));
          }

          return this._textureBarriers.get(hash);
        };

        _proto.getBufferBarrier = function getBufferBarrier(info) {
          var hash = BufferBarrier.computeHash(info);

          if (!this._bufferBarriers.has(hash)) {
            this._bufferBarriers.set(hash, new BufferBarrier(info, hash));
          }

          return this._bufferBarriers.get(hash);
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
        };

        _proto.copyTextureToBuffers = function copyTextureToBuffers(texture, buffers, regions) {
          WebGLCmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
        };

        _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
          WebGLCmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
        };

        _createClass(WebGLDevice, [{
          key: "gl",
          get: function get() {
            return this._context;
          }
        }, {
          key: "extensions",
          get: function get() {
            return this._swapchain.extensions;
          }
        }, {
          key: "stateCache",
          get: function get() {
            return this._swapchain.stateCache;
          }
        }, {
          key: "nullTex2D",
          get: function get() {
            return this._swapchain.nullTex2D;
          }
        }, {
          key: "nullTexCube",
          get: function get() {
            return this._swapchain.nullTexCube;
          }
        }, {
          key: "textureExclusive",
          get: function get() {
            return this._textureExclusive;
          }
        }, {
          key: "bindingMappings",
          get: function get() {
            return this._bindingMappings;
          }
        }]);

        return WebGLDevice;
      }(Device));

      legacyCC.WebGLDevice = WebGLDevice;

      var WebGL2DescriptorSet = function (_DescriptorSet) {
        _inheritsLoose(WebGL2DescriptorSet, _DescriptorSet);

        function WebGL2DescriptorSet() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _DescriptorSet.call.apply(_DescriptorSet, [this].concat(args)) || this;
          _this._gpuDescriptorSet = null;
          return _this;
        }

        var _proto = WebGL2DescriptorSet.prototype;

        _proto.initialize = function initialize(info) {
          this._layout = info.layout;
          var _gpuDescriptorSetLayo = info.layout.gpuDescriptorSetLayout,
              bindings = _gpuDescriptorSetLayo.bindings,
              descriptorIndices = _gpuDescriptorSetLayo.descriptorIndices,
              descriptorCount = _gpuDescriptorSetLayo.descriptorCount;
          this._buffers = Array(descriptorCount).fill(null);
          this._textures = Array(descriptorCount).fill(null);
          this._samplers = Array(descriptorCount).fill(null);
          var gpuDescriptors = [];
          this._gpuDescriptorSet = {
            gpuDescriptors: gpuDescriptors,
            descriptorIndices: descriptorIndices
          };

          for (var i = 0; i < bindings.length; ++i) {
            var binding = bindings[i];

            for (var j = 0; j < binding.count; j++) {
              gpuDescriptors.push({
                type: binding.descriptorType,
                gpuBuffer: null,
                gpuTextureView: null,
                gpuSampler: null
              });
            }
          }
        };

        _proto.destroy = function destroy() {
          this._layout = null;
          this._gpuDescriptorSet = null;
        };

        _proto.update = function update() {
          if (this._isDirty && this._gpuDescriptorSet) {
            var descriptors = this._gpuDescriptorSet.gpuDescriptors;

            for (var i = 0; i < descriptors.length; ++i) {
              if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                if (this._buffers[i]) {
                  descriptors[i].gpuBuffer = this._buffers[i].gpuBuffer;
                }
              } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                if (this._textures[i]) {
                  descriptors[i].gpuTextureView = this._textures[i].gpuTextureView;
                }

                if (this._samplers[i]) {
                  descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                }
              }
            }

            this._isDirty = false;
          }
        };

        _createClass(WebGL2DescriptorSet, [{
          key: "gpuDescriptorSet",
          get: function get() {
            return this._gpuDescriptorSet;
          }
        }]);

        return WebGL2DescriptorSet;
      }(DescriptorSet);

      var WebGL2EXT;

      (function (WebGL2EXT) {
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
        WebGL2EXT[WebGL2EXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
        WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
      })(WebGL2EXT || (WebGL2EXT = {}));

      var WebGL2DeviceManager = function () {
        function WebGL2DeviceManager() {}

        WebGL2DeviceManager.setInstance = function setInstance(instance) {
          WebGL2DeviceManager._instance = instance;
        };

        _createClass(WebGL2DeviceManager, null, [{
          key: "instance",
          get: function get() {
            return WebGL2DeviceManager._instance;
          }
        }]);

        return WebGL2DeviceManager;
      }();
      WebGL2DeviceManager._instance = null;

      var WebGLWraps$1 = [0x2901, 0x8370, 0x812F, 0x812F];

      var _f32v4 = new Float32Array(4);

      function GFXFormatToWebGLType$1(format, gl) {
        switch (format) {
          case Format.R8:
            return gl.UNSIGNED_BYTE;

          case Format.R8SN:
            return gl.BYTE;

          case Format.R8UI:
            return gl.UNSIGNED_BYTE;

          case Format.R8I:
            return gl.BYTE;

          case Format.R16F:
            return gl.HALF_FLOAT;

          case Format.R16UI:
            return gl.UNSIGNED_SHORT;

          case Format.R16I:
            return gl.SHORT;

          case Format.R32F:
            return gl.FLOAT;

          case Format.R32UI:
            return gl.UNSIGNED_INT;

          case Format.R32I:
            return gl.INT;

          case Format.RG8:
            return gl.UNSIGNED_BYTE;

          case Format.RG8SN:
            return gl.BYTE;

          case Format.RG8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RG8I:
            return gl.BYTE;

          case Format.RG16F:
            return gl.HALF_FLOAT;

          case Format.RG16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RG16I:
            return gl.SHORT;

          case Format.RG32F:
            return gl.FLOAT;

          case Format.RG32UI:
            return gl.UNSIGNED_INT;

          case Format.RG32I:
            return gl.INT;

          case Format.RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.SRGB8:
            return gl.UNSIGNED_BYTE;

          case Format.RGB8SN:
            return gl.BYTE;

          case Format.RGB8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RGB8I:
            return gl.BYTE;

          case Format.RGB16F:
            return gl.HALF_FLOAT;

          case Format.RGB16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RGB16I:
            return gl.SHORT;

          case Format.RGB32F:
            return gl.FLOAT;

          case Format.RGB32UI:
            return gl.UNSIGNED_INT;

          case Format.RGB32I:
            return gl.INT;

          case Format.BGRA8:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8:
            return gl.UNSIGNED_BYTE;

          case Format.SRGB8_A8:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8SN:
            return gl.BYTE;

          case Format.RGBA8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8I:
            return gl.BYTE;

          case Format.RGBA16F:
            return gl.HALF_FLOAT;

          case Format.RGBA16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RGBA16I:
            return gl.SHORT;

          case Format.RGBA32F:
            return gl.FLOAT;

          case Format.RGBA32UI:
            return gl.UNSIGNED_INT;

          case Format.RGBA32I:
            return gl.INT;

          case Format.R5G6B5:
            return gl.UNSIGNED_SHORT_5_6_5;

          case Format.R11G11B10F:
            return gl.UNSIGNED_INT_10F_11F_11F_REV;

          case Format.RGB5A1:
            return gl.UNSIGNED_SHORT_5_5_5_1;

          case Format.RGBA4:
            return gl.UNSIGNED_SHORT_4_4_4_4;

          case Format.RGB10A2:
            return gl.UNSIGNED_INT_2_10_10_10_REV;

          case Format.RGB10A2UI:
            return gl.UNSIGNED_INT_2_10_10_10_REV;

          case Format.RGB9E5:
            return gl.FLOAT;

          case Format.DEPTH:
            return gl.FLOAT;

          case Format.DEPTH_STENCIL:
            return gl.UNSIGNED_INT_24_8;

          case Format.BC1:
            return gl.UNSIGNED_BYTE;

          case Format.BC1_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC2:
            return gl.UNSIGNED_BYTE;

          case Format.BC2_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC3:
            return gl.UNSIGNED_BYTE;

          case Format.BC3_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC4:
            return gl.UNSIGNED_BYTE;

          case Format.BC4_SNORM:
            return gl.BYTE;

          case Format.BC5:
            return gl.UNSIGNED_BYTE;

          case Format.BC5_SNORM:
            return gl.BYTE;

          case Format.BC6H_SF16:
            return gl.FLOAT;

          case Format.BC6H_UF16:
            return gl.FLOAT;

          case Format.BC7:
            return gl.UNSIGNED_BYTE;

          case Format.BC7_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.ETC_RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_SRGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_RGB8_A1:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_SRGB8_A1:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_R11:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_R11SN:
            return gl.BYTE;

          case Format.EAC_RG11:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_RG11SN:
            return gl.BYTE;

          case Format.PVRTC_RGB2:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGBA2:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGB4:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGBA4:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC2_2BPP:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC2_4BPP:
            return gl.UNSIGNED_BYTE;

          case Format.ASTC_RGBA_4X4:
          case Format.ASTC_RGBA_5X4:
          case Format.ASTC_RGBA_5X5:
          case Format.ASTC_RGBA_6X5:
          case Format.ASTC_RGBA_6X6:
          case Format.ASTC_RGBA_8X5:
          case Format.ASTC_RGBA_8X6:
          case Format.ASTC_RGBA_8X8:
          case Format.ASTC_RGBA_10X5:
          case Format.ASTC_RGBA_10X6:
          case Format.ASTC_RGBA_10X8:
          case Format.ASTC_RGBA_10X10:
          case Format.ASTC_RGBA_12X10:
          case Format.ASTC_RGBA_12X12:
          case Format.ASTC_SRGBA_4X4:
          case Format.ASTC_SRGBA_5X4:
          case Format.ASTC_SRGBA_5X5:
          case Format.ASTC_SRGBA_6X5:
          case Format.ASTC_SRGBA_6X6:
          case Format.ASTC_SRGBA_8X5:
          case Format.ASTC_SRGBA_8X6:
          case Format.ASTC_SRGBA_8X8:
          case Format.ASTC_SRGBA_10X5:
          case Format.ASTC_SRGBA_10X6:
          case Format.ASTC_SRGBA_10X8:
          case Format.ASTC_SRGBA_10X10:
          case Format.ASTC_SRGBA_12X10:
          case Format.ASTC_SRGBA_12X12:
            return gl.UNSIGNED_BYTE;

          default:
            {
              return gl.UNSIGNED_BYTE;
            }
        }
      }
      function GFXFormatToWebGLInternalFormat$1(format, gl) {
        switch (format) {
          case Format.A8:
            return gl.ALPHA;

          case Format.L8:
            return gl.LUMINANCE;

          case Format.LA8:
            return gl.LUMINANCE_ALPHA;

          case Format.R8:
            return gl.R8;

          case Format.R8SN:
            return gl.R8_SNORM;

          case Format.R8UI:
            return gl.R8UI;

          case Format.R8I:
            return gl.R8I;

          case Format.RG8:
            return gl.RG8;

          case Format.RG8SN:
            return gl.RG8_SNORM;

          case Format.RG8UI:
            return gl.RG8UI;

          case Format.RG8I:
            return gl.RG8I;

          case Format.RGB8:
            return gl.RGB8;

          case Format.RGB8SN:
            return gl.RGB8_SNORM;

          case Format.RGB8UI:
            return gl.RGB8UI;

          case Format.RGB8I:
            return gl.RGB8I;

          case Format.BGRA8:
            return gl.RGBA8;

          case Format.RGBA8:
            return gl.RGBA8;

          case Format.RGBA8SN:
            return gl.RGBA8_SNORM;

          case Format.RGBA8UI:
            return gl.RGBA8UI;

          case Format.RGBA8I:
            return gl.RGBA8I;

          case Format.R16I:
            return gl.R16I;

          case Format.R16UI:
            return gl.R16UI;

          case Format.R16F:
            return gl.R16F;

          case Format.RG16I:
            return gl.RG16I;

          case Format.RG16UI:
            return gl.RG16UI;

          case Format.RG16F:
            return gl.RG16F;

          case Format.RGB16I:
            return gl.RGB16I;

          case Format.RGB16UI:
            return gl.RGB16UI;

          case Format.RGB16F:
            return gl.RGB16F;

          case Format.RGBA16I:
            return gl.RGBA16I;

          case Format.RGBA16UI:
            return gl.RGBA16UI;

          case Format.RGBA16F:
            return gl.RGBA16F;

          case Format.R32I:
            return gl.R32I;

          case Format.R32UI:
            return gl.R32UI;

          case Format.R32F:
            return gl.R32F;

          case Format.RG32I:
            return gl.RG32I;

          case Format.RG32UI:
            return gl.RG32UI;

          case Format.RG32F:
            return gl.RG32F;

          case Format.RGB32I:
            return gl.RGB32I;

          case Format.RGB32UI:
            return gl.RGB32UI;

          case Format.RGB32F:
            return gl.RGB32F;

          case Format.RGBA32I:
            return gl.RGBA32I;

          case Format.RGBA32UI:
            return gl.RGBA32UI;

          case Format.RGBA32F:
            return gl.RGBA32F;

          case Format.R5G6B5:
            return gl.RGB565;

          case Format.RGB5A1:
            return gl.RGB5_A1;

          case Format.RGBA4:
            return gl.RGBA4;

          case Format.SRGB8:
            return gl.SRGB8;

          case Format.SRGB8_A8:
            return gl.SRGB8_ALPHA8;

          case Format.RGB10A2:
            return gl.RGB10_A2;

          case Format.RGB10A2UI:
            return gl.RGB10_A2UI;

          case Format.R11G11B10F:
            return gl.R11F_G11F_B10F;

          case Format.DEPTH:
            return gl.DEPTH_COMPONENT32F;

          case Format.DEPTH_STENCIL:
            return gl.DEPTH24_STENCIL8;

          case Format.BC1:
            return WebGL2EXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case Format.BC1_ALPHA:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case Format.BC1_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case Format.BC1_SRGB_ALPHA:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case Format.BC2:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case Format.BC2_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case Format.BC3:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case Format.BC3_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case Format.ETC_RGB8:
            return WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL;

          case Format.ETC2_RGB8:
            return WebGL2EXT.COMPRESSED_RGB8_ETC2;

          case Format.ETC2_SRGB8:
            return WebGL2EXT.COMPRESSED_SRGB8_ETC2;

          case Format.ETC2_RGB8_A1:
            return WebGL2EXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case Format.ETC2_SRGB8_A1:
            return WebGL2EXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case Format.ETC2_RGBA8:
            return WebGL2EXT.COMPRESSED_RGBA8_ETC2_EAC;

          case Format.ETC2_SRGB8_A8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

          case Format.EAC_R11:
            return WebGL2EXT.COMPRESSED_R11_EAC;

          case Format.EAC_R11SN:
            return WebGL2EXT.COMPRESSED_SIGNED_R11_EAC;

          case Format.EAC_RG11:
            return WebGL2EXT.COMPRESSED_RG11_EAC;

          case Format.EAC_RG11SN:
            return WebGL2EXT.COMPRESSED_SIGNED_RG11_EAC;

          case Format.PVRTC_RGB2:
            return WebGL2EXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case Format.PVRTC_RGBA2:
            return WebGL2EXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case Format.PVRTC_RGB4:
            return WebGL2EXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case Format.PVRTC_RGBA4:
            return WebGL2EXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          case Format.ASTC_RGBA_4X4:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

          case Format.ASTC_RGBA_5X4:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

          case Format.ASTC_RGBA_5X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

          case Format.ASTC_RGBA_6X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

          case Format.ASTC_RGBA_6X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

          case Format.ASTC_RGBA_8X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

          case Format.ASTC_RGBA_8X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

          case Format.ASTC_RGBA_8X8:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

          case Format.ASTC_RGBA_10X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

          case Format.ASTC_RGBA_10X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

          case Format.ASTC_RGBA_10X8:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

          case Format.ASTC_RGBA_10X10:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

          case Format.ASTC_RGBA_12X10:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

          case Format.ASTC_RGBA_12X12:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

          case Format.ASTC_SRGBA_4X4:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

          case Format.ASTC_SRGBA_5X4:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

          case Format.ASTC_SRGBA_5X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

          case Format.ASTC_SRGBA_6X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

          case Format.ASTC_SRGBA_6X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

          case Format.ASTC_SRGBA_8X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

          case Format.ASTC_SRGBA_8X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

          case Format.ASTC_SRGBA_8X8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

          case Format.ASTC_SRGBA_10X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

          case Format.ASTC_SRGBA_10X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

          case Format.ASTC_SRGBA_10X8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

          case Format.ASTC_SRGBA_10X10:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

          case Format.ASTC_SRGBA_12X10:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

          case Format.ASTC_SRGBA_12X12:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

          default:
            {
              console.error('Unsupported Format, convert to WebGL internal format failed.');
              return gl.RGBA;
            }
        }
      }
      function GFXFormatToWebGLFormat$1(format, gl) {
        switch (format) {
          case Format.A8:
            return gl.ALPHA;

          case Format.L8:
            return gl.LUMINANCE;

          case Format.LA8:
            return gl.LUMINANCE_ALPHA;

          case Format.R8:
          case Format.R8SN:
            return gl.RED;

          case Format.R8UI:
          case Format.R8I:
            return gl.RED;

          case Format.RG8:
          case Format.RG8SN:
          case Format.RG8UI:
          case Format.RG8I:
            return gl.RG;

          case Format.RGB8:
          case Format.RGB8SN:
          case Format.RGB8UI:
          case Format.RGB8I:
            return gl.RGB;

          case Format.BGRA8:
          case Format.RGBA8:
          case Format.RGBA8SN:
          case Format.RGBA8UI:
          case Format.RGBA8I:
            return gl.RGBA;

          case Format.R16UI:
          case Format.R16I:
          case Format.R16F:
            return gl.RED;

          case Format.RG16UI:
          case Format.RG16I:
          case Format.RG16F:
            return gl.RG;

          case Format.RGB16UI:
          case Format.RGB16I:
          case Format.RGB16F:
            return gl.RGB;

          case Format.RGBA16UI:
          case Format.RGBA16I:
          case Format.RGBA16F:
            return gl.RGBA;

          case Format.R32UI:
          case Format.R32I:
          case Format.R32F:
            return gl.RED;

          case Format.RG32UI:
          case Format.RG32I:
          case Format.RG32F:
            return gl.RG;

          case Format.RGB32UI:
          case Format.RGB32I:
          case Format.RGB32F:
            return gl.RGB;

          case Format.RGBA32UI:
          case Format.RGBA32I:
          case Format.RGBA32F:
            return gl.RGBA;

          case Format.RGB10A2:
            return gl.RGBA;

          case Format.R11G11B10F:
            return gl.RGB;

          case Format.R5G6B5:
            return gl.RGB;

          case Format.RGB5A1:
            return gl.RGBA;

          case Format.RGBA4:
            return gl.RGBA;

          case Format.SRGB8:
            return gl.RGB;

          case Format.SRGB8_A8:
            return gl.RGBA;

          case Format.DEPTH:
            return gl.DEPTH_COMPONENT;

          case Format.DEPTH_STENCIL:
            return gl.DEPTH_STENCIL;

          case Format.BC1:
            return WebGL2EXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case Format.BC1_ALPHA:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case Format.BC1_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case Format.BC1_SRGB_ALPHA:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case Format.BC2:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case Format.BC2_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case Format.BC3:
            return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case Format.BC3_SRGB:
            return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case Format.ETC_RGB8:
            return WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL;

          case Format.ETC2_RGB8:
            return WebGL2EXT.COMPRESSED_RGB8_ETC2;

          case Format.ETC2_SRGB8:
            return WebGL2EXT.COMPRESSED_SRGB8_ETC2;

          case Format.ETC2_RGB8_A1:
            return WebGL2EXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case Format.ETC2_SRGB8_A1:
            return WebGL2EXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case Format.ETC2_RGBA8:
            return WebGL2EXT.COMPRESSED_RGBA8_ETC2_EAC;

          case Format.ETC2_SRGB8_A8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

          case Format.EAC_R11:
            return WebGL2EXT.COMPRESSED_R11_EAC;

          case Format.EAC_R11SN:
            return WebGL2EXT.COMPRESSED_SIGNED_R11_EAC;

          case Format.EAC_RG11:
            return WebGL2EXT.COMPRESSED_RG11_EAC;

          case Format.EAC_RG11SN:
            return WebGL2EXT.COMPRESSED_SIGNED_RG11_EAC;

          case Format.PVRTC_RGB2:
            return WebGL2EXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case Format.PVRTC_RGBA2:
            return WebGL2EXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case Format.PVRTC_RGB4:
            return WebGL2EXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case Format.PVRTC_RGBA4:
            return WebGL2EXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          case Format.ASTC_RGBA_4X4:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

          case Format.ASTC_RGBA_5X4:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

          case Format.ASTC_RGBA_5X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

          case Format.ASTC_RGBA_6X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

          case Format.ASTC_RGBA_6X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

          case Format.ASTC_RGBA_8X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

          case Format.ASTC_RGBA_8X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

          case Format.ASTC_RGBA_8X8:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

          case Format.ASTC_RGBA_10X5:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

          case Format.ASTC_RGBA_10X6:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

          case Format.ASTC_RGBA_10X8:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

          case Format.ASTC_RGBA_10X10:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

          case Format.ASTC_RGBA_12X10:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

          case Format.ASTC_RGBA_12X12:
            return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

          case Format.ASTC_SRGBA_4X4:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

          case Format.ASTC_SRGBA_5X4:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

          case Format.ASTC_SRGBA_5X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

          case Format.ASTC_SRGBA_6X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

          case Format.ASTC_SRGBA_6X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

          case Format.ASTC_SRGBA_8X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

          case Format.ASTC_SRGBA_8X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

          case Format.ASTC_SRGBA_8X8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

          case Format.ASTC_SRGBA_10X5:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

          case Format.ASTC_SRGBA_10X6:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

          case Format.ASTC_SRGBA_10X8:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

          case Format.ASTC_SRGBA_10X10:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

          case Format.ASTC_SRGBA_12X10:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

          case Format.ASTC_SRGBA_12X12:
            return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

          default:
            {
              console.error('Unsupported Format, convert to WebGL format failed.');
              return gl.RGBA;
            }
        }
      }

      function GFXTypeToWebGLType$1(type, gl) {
        switch (type) {
          case Type$1.BOOL:
            return gl.BOOL;

          case Type$1.BOOL2:
            return gl.BOOL_VEC2;

          case Type$1.BOOL3:
            return gl.BOOL_VEC3;

          case Type$1.BOOL4:
            return gl.BOOL_VEC4;

          case Type$1.INT:
            return gl.INT;

          case Type$1.INT2:
            return gl.INT_VEC2;

          case Type$1.INT3:
            return gl.INT_VEC3;

          case Type$1.INT4:
            return gl.INT_VEC4;

          case Type$1.UINT:
            return gl.UNSIGNED_INT;

          case Type$1.FLOAT:
            return gl.FLOAT;

          case Type$1.FLOAT2:
            return gl.FLOAT_VEC2;

          case Type$1.FLOAT3:
            return gl.FLOAT_VEC3;

          case Type$1.FLOAT4:
            return gl.FLOAT_VEC4;

          case Type$1.MAT2:
            return gl.FLOAT_MAT2;

          case Type$1.MAT2X3:
            return gl.FLOAT_MAT2x3;

          case Type$1.MAT2X4:
            return gl.FLOAT_MAT2x4;

          case Type$1.MAT3X2:
            return gl.FLOAT_MAT3x2;

          case Type$1.MAT3:
            return gl.FLOAT_MAT3;

          case Type$1.MAT3X4:
            return gl.FLOAT_MAT3x4;

          case Type$1.MAT4X2:
            return gl.FLOAT_MAT4x2;

          case Type$1.MAT4X3:
            return gl.FLOAT_MAT4x3;

          case Type$1.MAT4:
            return gl.FLOAT_MAT4;

          case Type$1.SAMPLER2D:
            return gl.SAMPLER_2D;

          case Type$1.SAMPLER2D_ARRAY:
            return gl.SAMPLER_2D_ARRAY;

          case Type$1.SAMPLER3D:
            return gl.SAMPLER_3D;

          case Type$1.SAMPLER_CUBE:
            return gl.SAMPLER_CUBE;

          default:
            {
              console.error('Unsupported GLType, convert to GL type failed.');
              return Type$1.UNKNOWN;
            }
        }
      }

      function WebGLTypeToGFXType$1(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return Type$1.BOOL;

          case gl.BOOL_VEC2:
            return Type$1.BOOL2;

          case gl.BOOL_VEC3:
            return Type$1.BOOL3;

          case gl.BOOL_VEC4:
            return Type$1.BOOL4;

          case gl.INT:
            return Type$1.INT;

          case gl.INT_VEC2:
            return Type$1.INT2;

          case gl.INT_VEC3:
            return Type$1.INT3;

          case gl.INT_VEC4:
            return Type$1.INT4;

          case gl.UNSIGNED_INT:
            return Type$1.UINT;

          case gl.UNSIGNED_INT_VEC2:
            return Type$1.UINT2;

          case gl.UNSIGNED_INT_VEC3:
            return Type$1.UINT3;

          case gl.UNSIGNED_INT_VEC4:
            return Type$1.UINT4;

          case gl.FLOAT:
            return Type$1.FLOAT;

          case gl.FLOAT_VEC2:
            return Type$1.FLOAT2;

          case gl.FLOAT_VEC3:
            return Type$1.FLOAT3;

          case gl.FLOAT_VEC4:
            return Type$1.FLOAT4;

          case gl.FLOAT_MAT2:
            return Type$1.MAT2;

          case gl.FLOAT_MAT2x3:
            return Type$1.MAT2X3;

          case gl.FLOAT_MAT2x4:
            return Type$1.MAT2X4;

          case gl.FLOAT_MAT3x2:
            return Type$1.MAT3X2;

          case gl.FLOAT_MAT3:
            return Type$1.MAT3;

          case gl.FLOAT_MAT3x4:
            return Type$1.MAT3X4;

          case gl.FLOAT_MAT4x2:
            return Type$1.MAT4X2;

          case gl.FLOAT_MAT4x3:
            return Type$1.MAT4X3;

          case gl.FLOAT_MAT4:
            return Type$1.MAT4;

          case gl.SAMPLER_2D:
            return Type$1.SAMPLER2D;

          case gl.SAMPLER_2D_ARRAY:
            return Type$1.SAMPLER2D_ARRAY;

          case gl.SAMPLER_3D:
            return Type$1.SAMPLER3D;

          case gl.SAMPLER_CUBE:
            return Type$1.SAMPLER_CUBE;

          default:
            {
              console.error('Unsupported GLType, convert to Type failed.');
              return Type$1.UNKNOWN;
            }
        }
      }

      function WebGLGetTypeSize$1(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return 4;

          case gl.BOOL_VEC2:
            return 8;

          case gl.BOOL_VEC3:
            return 12;

          case gl.BOOL_VEC4:
            return 16;

          case gl.INT:
            return 4;

          case gl.INT_VEC2:
            return 8;

          case gl.INT_VEC3:
            return 12;

          case gl.INT_VEC4:
            return 16;

          case gl.UNSIGNED_INT:
            return 4;

          case gl.UNSIGNED_INT_VEC2:
            return 8;

          case gl.UNSIGNED_INT_VEC3:
            return 12;

          case gl.UNSIGNED_INT_VEC4:
            return 16;

          case gl.FLOAT:
            return 4;

          case gl.FLOAT_VEC2:
            return 8;

          case gl.FLOAT_VEC3:
            return 12;

          case gl.FLOAT_VEC4:
            return 16;

          case gl.FLOAT_MAT2:
            return 16;

          case gl.FLOAT_MAT2x3:
            return 24;

          case gl.FLOAT_MAT2x4:
            return 32;

          case gl.FLOAT_MAT3x2:
            return 24;

          case gl.FLOAT_MAT3:
            return 36;

          case gl.FLOAT_MAT3x4:
            return 48;

          case gl.FLOAT_MAT4x2:
            return 32;

          case gl.FLOAT_MAT4x3:
            return 48;

          case gl.FLOAT_MAT4:
            return 64;

          case gl.SAMPLER_2D:
            return 4;

          case gl.SAMPLER_2D_ARRAY:
            return 4;

          case gl.SAMPLER_2D_ARRAY_SHADOW:
            return 4;

          case gl.SAMPLER_3D:
            return 4;

          case gl.SAMPLER_CUBE:
            return 4;

          case gl.INT_SAMPLER_2D:
            return 4;

          case gl.INT_SAMPLER_2D_ARRAY:
            return 4;

          case gl.INT_SAMPLER_3D:
            return 4;

          case gl.INT_SAMPLER_CUBE:
            return 4;

          case gl.UNSIGNED_INT_SAMPLER_2D:
            return 4;

          case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
            return 4;

          case gl.UNSIGNED_INT_SAMPLER_3D:
            return 4;

          case gl.UNSIGNED_INT_SAMPLER_CUBE:
            return 4;

          default:
            {
              console.error('Unsupported GLType, get type failed.');
              return 0;
            }
        }
      }

      function WebGLGetComponentCount$1(glType, gl) {
        switch (glType) {
          case gl.FLOAT_MAT2:
            return 2;

          case gl.FLOAT_MAT2x3:
            return 2;

          case gl.FLOAT_MAT2x4:
            return 2;

          case gl.FLOAT_MAT3x2:
            return 3;

          case gl.FLOAT_MAT3:
            return 3;

          case gl.FLOAT_MAT3x4:
            return 3;

          case gl.FLOAT_MAT4x2:
            return 4;

          case gl.FLOAT_MAT4x3:
            return 4;

          case gl.FLOAT_MAT4:
            return 4;

          default:
            {
              return 1;
            }
        }
      }

      var WebGLCmpFuncs$1 = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
      var WebGLStencilOps$1 = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
      var WebGLBlendOps$1 = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
      var WebGLBlendFactors$1 = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
      var WebGL2Cmd;

      (function (WebGL2Cmd) {
        WebGL2Cmd[WebGL2Cmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
        WebGL2Cmd[WebGL2Cmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
        WebGL2Cmd[WebGL2Cmd["BIND_STATES"] = 2] = "BIND_STATES";
        WebGL2Cmd[WebGL2Cmd["DRAW"] = 3] = "DRAW";
        WebGL2Cmd[WebGL2Cmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
        WebGL2Cmd[WebGL2Cmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
        WebGL2Cmd[WebGL2Cmd["COUNT"] = 6] = "COUNT";
      })(WebGL2Cmd || (WebGL2Cmd = {}));

      var WebGL2CmdObject = function WebGL2CmdObject(type) {
        this.cmdType = void 0;
        this.refCount = 0;
        this.cmdType = type;
      };
      var WebGL2CmdBeginRenderPass = function (_WebGL2CmdObject) {
        _inheritsLoose(WebGL2CmdBeginRenderPass, _WebGL2CmdObject);

        function WebGL2CmdBeginRenderPass() {
          var _this;

          _this = _WebGL2CmdObject.call(this, WebGL2Cmd.BEGIN_RENDER_PASS) || this;
          _this.gpuRenderPass = null;
          _this.gpuFramebuffer = null;
          _this.renderArea = new Rect$1();
          _this.clearColors = [];
          _this.clearDepth = 1.0;
          _this.clearStencil = 0;
          return _this;
        }

        var _proto = WebGL2CmdBeginRenderPass.prototype;

        _proto.clear = function clear() {
          this.gpuFramebuffer = null;
          this.clearColors.length = 0;
        };

        return WebGL2CmdBeginRenderPass;
      }(WebGL2CmdObject);
      var WebGL2CmdBindStates = function (_WebGL2CmdObject2) {
        _inheritsLoose(WebGL2CmdBindStates, _WebGL2CmdObject2);

        function WebGL2CmdBindStates() {
          var _this2;

          _this2 = _WebGL2CmdObject2.call(this, WebGL2Cmd.BIND_STATES) || this;
          _this2.gpuPipelineState = null;
          _this2.gpuInputAssembler = null;
          _this2.gpuDescriptorSets = [];
          _this2.dynamicOffsets = [];
          _this2.dynamicStates = new DynamicStates();
          return _this2;
        }

        var _proto2 = WebGL2CmdBindStates.prototype;

        _proto2.clear = function clear() {
          this.gpuPipelineState = null;
          this.gpuInputAssembler = null;
          this.gpuDescriptorSets.length = 0;
          this.dynamicOffsets.length = 0;
        };

        return WebGL2CmdBindStates;
      }(WebGL2CmdObject);
      var WebGL2CmdDraw = function (_WebGL2CmdObject3) {
        _inheritsLoose(WebGL2CmdDraw, _WebGL2CmdObject3);

        function WebGL2CmdDraw() {
          var _this3;

          _this3 = _WebGL2CmdObject3.call(this, WebGL2Cmd.DRAW) || this;
          _this3.drawInfo = new DrawInfo();
          return _this3;
        }

        var _proto3 = WebGL2CmdDraw.prototype;

        _proto3.clear = function clear() {};

        return WebGL2CmdDraw;
      }(WebGL2CmdObject);
      var WebGL2CmdUpdateBuffer = function (_WebGL2CmdObject4) {
        _inheritsLoose(WebGL2CmdUpdateBuffer, _WebGL2CmdObject4);

        function WebGL2CmdUpdateBuffer() {
          var _this4;

          _this4 = _WebGL2CmdObject4.call(this, WebGL2Cmd.UPDATE_BUFFER) || this;
          _this4.gpuBuffer = null;
          _this4.buffer = null;
          _this4.offset = 0;
          _this4.size = 0;
          return _this4;
        }

        var _proto4 = WebGL2CmdUpdateBuffer.prototype;

        _proto4.clear = function clear() {
          this.gpuBuffer = null;
          this.buffer = null;
        };

        return WebGL2CmdUpdateBuffer;
      }(WebGL2CmdObject);
      var WebGL2CmdCopyBufferToTexture = function (_WebGL2CmdObject5) {
        _inheritsLoose(WebGL2CmdCopyBufferToTexture, _WebGL2CmdObject5);

        function WebGL2CmdCopyBufferToTexture() {
          var _this5;

          _this5 = _WebGL2CmdObject5.call(this, WebGL2Cmd.COPY_BUFFER_TO_TEXTURE) || this;
          _this5.gpuTexture = null;
          _this5.buffers = [];
          _this5.regions = [];
          return _this5;
        }

        var _proto5 = WebGL2CmdCopyBufferToTexture.prototype;

        _proto5.clear = function clear() {
          this.gpuTexture = null;
          this.buffers.length = 0;
          this.regions.length = 0;
        };

        return WebGL2CmdCopyBufferToTexture;
      }(WebGL2CmdObject);
      var WebGL2CmdPackage = function () {
        function WebGL2CmdPackage() {
          this.cmds = new CachedArray(1);
          this.beginRenderPassCmds = new CachedArray(1);
          this.bindStatesCmds = new CachedArray(1);
          this.drawCmds = new CachedArray(1);
          this.updateBufferCmds = new CachedArray(1);
          this.copyBufferToTextureCmds = new CachedArray(1);
        }

        var _proto6 = WebGL2CmdPackage.prototype;

        _proto6.clearCmds = function clearCmds(allocator) {
          if (this.beginRenderPassCmds.length) {
            allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
            this.beginRenderPassCmds.clear();
          }

          if (this.bindStatesCmds.length) {
            allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
            this.bindStatesCmds.clear();
          }

          if (this.drawCmds.length) {
            allocator.drawCmdPool.freeCmds(this.drawCmds);
            this.drawCmds.clear();
          }

          if (this.updateBufferCmds.length) {
            allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
            this.updateBufferCmds.clear();
          }

          if (this.copyBufferToTextureCmds.length) {
            allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
            this.copyBufferToTextureCmds.clear();
          }

          this.cmds.clear();
        };

        return WebGL2CmdPackage;
      }();
      function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;
        var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          gpuBuffer.glTarget = gl.ARRAY_BUFFER;
          var glBuffer = gl.createBuffer();

          if (glBuffer) {
            gpuBuffer.glBuffer = glBuffer;

            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  gl.bindVertexArray(null);
                  cache.glVAO = null;
                }
              }

              gfxStateCache$1.gpuInputAssembler = null;

              if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
              }

              gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;

          var _glBuffer = gl.createBuffer();

          if (_glBuffer) {
            gpuBuffer.glBuffer = _glBuffer;

            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  gl.bindVertexArray(null);
                  cache.glVAO = null;
                }
              }

              gfxStateCache$1.gpuInputAssembler = null;

              if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
              }

              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          gpuBuffer.glTarget = gl.UNIFORM_BUFFER;

          var _glBuffer2 = gl.createBuffer();

          if (_glBuffer2 && gpuBuffer.size > 0) {
            gpuBuffer.glBuffer = _glBuffer2;

            if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
              gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
              device.stateCache.glUniformBuffer = gpuBuffer.glBuffer;
            }

            gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);
            device.stateCache.glUniformBuffer = null;
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          console.error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;

        if (gpuBuffer.glBuffer) {
          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  gl.bindVertexArray(null);
                  device.stateCache.glVAO = null;
                }
              }

              gfxStateCache$1.gpuInputAssembler = null;
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
              break;

            case gl.ELEMENT_ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  gl.bindVertexArray(null);
                  device.stateCache.glVAO = null;
                }
              }

              gfxStateCache$1.gpuInputAssembler = null;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
              break;

            case gl.UNIFORM_BUFFER:
              gl.bindBuffer(gl.UNIFORM_BUFFER, null);
              device.stateCache.glUniformBuffer = null;
              break;
          }

          gl.deleteBuffer(gpuBuffer.glBuffer);
          gpuBuffer.glBuffer = null;
        }
      }
      function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;
        var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              gl.bindVertexArray(null);
              cache.glVAO = null;
            }
          }

          gfxStateCache$1.gpuInputAssembler = null;

          if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
          }

          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }

          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          cache.glArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              gl.bindVertexArray(null);
              cache.glVAO = null;
            }
          }

          gfxStateCache$1.gpuInputAssembler = null;

          if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
          }

          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }

          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          device.stateCache.glElementArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
          }

          gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
          gl.bindBuffer(gl.UNIFORM_BUFFER, null);
          device.stateCache.glUniformBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          console.error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
        if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.indirects.clearDraws();
          var drawInfos = buffer.drawInfos;

          for (var i = 0; i < drawInfos.length; ++i) {
            gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
          }
        } else {
          var buff = buffer;
          var gl = device.gl;
          var cache = device.stateCache;

          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache$1.gpuInputAssembler = null;

                if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                  cache.glArrayBuffer = gpuBuffer.glBuffer;
                }

                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }

                break;
              }

            case gl.ELEMENT_ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache$1.gpuInputAssembler = null;

                if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                  cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                }

                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }

                break;
              }

            case gl.UNIFORM_BUFFER:
              {
                if (cache.glUniformBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                  cache.glUniformBuffer = gpuBuffer.glBuffer;
                }

                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buff, 0, size / 4));
                }

                break;
              }

            default:
              {
                console.error('Unsupported BufferType, update buffer failed.');
              }
          }
        }
      }
      function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
        var gl = device.gl;
        gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl);
        gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl);
        gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl);
        var w = gpuTexture.width;
        var h = gpuTexture.height;

        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              if (gpuTexture.isSwapchainTexture) break;
              var maxSize = Math.max(w, h);

              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }

              if (gpuTexture.samples === SampleCount.ONE) {
                gpuTexture.glTexture = gl.createTexture();

                if (gpuTexture.size > 0) {
                  var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                  if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                    gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                    glTexUnit.glTexture = gpuTexture.glTexture;
                  }

                  if (FormatInfos[gpuTexture.format].isCompressed) {
                    for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                      var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                      var view = new Uint8Array(imgSize);
                      gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  } else {
                    gl.texStorage2D(gl.TEXTURE_2D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                  }
                }
              } else {
                gpuTexture.glRenderbuffer = gl.createRenderbuffer();

                if (gpuTexture.size > 0) {
                  if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                    gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                    device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                  }

                  gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                }
              }

              break;
            }

          case TextureType.CUBE:
            {
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

              var _maxSize = Math.max(w, h);

              if (_maxSize > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, _maxSize, device.capabilities.maxTextureSize);
              }

              gpuTexture.glTexture = gl.createTexture();

              if (gpuTexture.size > 0) {
                var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                  _glTexUnit.glTexture = gpuTexture.glTexture;
                }

                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                    var _imgSize = FormatSize(gpuTexture.format, w, h, 1);

                    var _view = new Uint8Array(_imgSize);

                    for (var f = 0; f < 6; ++f) {
                      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i, gpuTexture.glInternalFmt, w, h, 0, _view);
                    }

                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  gl.texStorage2D(gl.TEXTURE_CUBE_MAP, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
        var gl = device.gl;

        if (gpuTexture.glTexture) {
          var glTexUnits = device.stateCache.glTexUnits;
          var texUnit = device.stateCache.texUnit;
          gl.deleteTexture(gpuTexture.glTexture);

          for (var i = 0; i < glTexUnits.length; ++i) {
            if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
              gl.activeTexture(gl.TEXTURE0 + i);
              texUnit = i;
              gl.bindTexture(gpuTexture.glTarget, null);
              glTexUnits[i].glTexture = null;
            }
          }

          device.stateCache.texUnit = texUnit;
          gpuTexture.glTexture = null;
        }

        if (gpuTexture.glRenderbuffer) {
          var glRenderbuffer = device.stateCache.glRenderbuffer;
          gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);

          if (glRenderbuffer === gpuTexture.glRenderbuffer) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            glRenderbuffer = null;
          }

          gpuTexture.glRenderbuffer = null;
        }
      }
      function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
        if (!gpuTexture.size) return;
        var gl = device.gl;
        var w = gpuTexture.width;
        var h = gpuTexture.height;

        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              var maxSize = Math.max(w, h);

              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }

              if (gpuTexture.samples === SampleCount.ONE) {
                var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }

                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                    var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                    var view = new Uint8Array(imgSize);
                    gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                  WebGL2CmdFuncCreateTexture(device, gpuTexture);
                }
              } else if (gpuTexture.glRenderbuffer) {
                if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                  device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                }

                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
              }

              break;
            }

          case TextureType.CUBE:
            {
              gpuTexture.type = TextureType.CUBE;
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

              var _maxSize2 = Math.max(w, h);

              if (_maxSize2 > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, _maxSize2, device.capabilities.maxTextureSize);
              }

              var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                _glTexUnit2.glTexture = gpuTexture.glTexture;
              }

              if (FormatInfos[gpuTexture.format].isCompressed) {
                for (var f = 0; f < 6; ++f) {
                  w = gpuTexture.width;
                  h = gpuTexture.height;

                  for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                    var _imgSize2 = FormatSize(gpuTexture.format, w, h, 1);

                    var _view2 = new Uint8Array(_imgSize2);

                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternalFmt, w, h, 0, _view2);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              } else {
                WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                WebGL2CmdFuncCreateTexture(device, gpuTexture);
              }

              break;
            }

          default:
            {
              console.error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGL2CmdFuncPrepareSamplerInfo(device, gpuSampler) {
        var gl = device.gl;

        if (gpuSampler.minFilter === Filter.LINEAR || gpuSampler.minFilter === Filter.ANISOTROPIC) {
          if (gpuSampler.mipFilter === Filter.LINEAR || gpuSampler.mipFilter === Filter.ANISOTROPIC) {
            gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
          } else if (gpuSampler.mipFilter === Filter.POINT) {
            gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_NEAREST;
          } else {
            gpuSampler.glMinFilter = gl.LINEAR;
          }
        } else if (gpuSampler.mipFilter === Filter.LINEAR || gpuSampler.mipFilter === Filter.ANISOTROPIC) {
          gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else if (gpuSampler.mipFilter === Filter.POINT) {
          gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          gpuSampler.glMinFilter = gl.NEAREST;
        }

        if (gpuSampler.magFilter === Filter.LINEAR || gpuSampler.magFilter === Filter.ANISOTROPIC) {
          gpuSampler.glMagFilter = gl.LINEAR;
        } else {
          gpuSampler.glMagFilter = gl.NEAREST;
        }

        gpuSampler.glWrapS = WebGLWraps$1[gpuSampler.addressU];
        gpuSampler.glWrapT = WebGLWraps$1[gpuSampler.addressV];
        gpuSampler.glWrapR = WebGLWraps$1[gpuSampler.addressW];
      }
      function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
        var gl = device.gl;
        var it = gpuSampler.glSamplers.values();
        var res = it.next();

        while (!res.done) {
          gl.deleteSampler(res.value);
          var glSamplerUnits = device.stateCache.glSamplerUnits;

          for (var i = 0; i < glSamplerUnits.length; ++i) {
            if (glSamplerUnits[i] === res.value) {
              gl.bindSampler(i, null);
              glSamplerUnits[i] = null;
            }
          }
        }

        gpuSampler.glSamplers.clear();
      }
      function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
        for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
          var tex = gpuFramebuffer.gpuColorViews[i].gpuTexture;

          if (tex.isSwapchainTexture) {
            gpuFramebuffer.isOffscreen = false;
            return;
          }
        }

        var gl = device.gl;
        var attachments = [];
        var glFramebuffer = gl.createFramebuffer();

        if (glFramebuffer) {
          gpuFramebuffer.glFramebuffer = glFramebuffer;

          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
          }

          for (var _i3 = 0; _i3 < gpuFramebuffer.gpuColorViews.length; ++_i3) {
            var colorTextureView = gpuFramebuffer.gpuColorViews[_i3];
            var colorTexture = colorTextureView.gpuTexture;

            if (colorTexture) {
              if (colorTexture.glTexture) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i3, colorTexture.glTarget, colorTexture.glTexture, colorTextureView.baseLevel);
              } else {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i3, gl.RENDERBUFFER, colorTexture.glRenderbuffer);
              }

              attachments.push(gl.COLOR_ATTACHMENT0 + _i3);
              gpuFramebuffer.width = Math.min(gpuFramebuffer.width, colorTexture.width >> colorTextureView.baseLevel);
              gpuFramebuffer.height = Math.min(gpuFramebuffer.height, colorTexture.height >> colorTextureView.baseLevel);
            }
          }

          var dstView = gpuFramebuffer.gpuDepthStencilView;

          if (dstView) {
            var dst = dstView.gpuTexture;
            var glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

            if (dst.glTexture) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, gpuFramebuffer.gpuDepthStencilView.baseLevel);
            } else {
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
            }

            gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width >> dstView.baseLevel);
            gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height >> dstView.baseLevel);
          }

          gl.drawBuffers(attachments);
          var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

          if (status !== gl.FRAMEBUFFER_COMPLETE) {
            switch (status) {
              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                  break;
                }

              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                  break;
                }

              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                  break;
                }

              case gl.FRAMEBUFFER_UNSUPPORTED:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                  break;
                }
            }
          }

          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
          }
        }
      }
      function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
        if (gpuFramebuffer.glFramebuffer) {
          device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);

          if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
            device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
            device.stateCache.glFramebuffer = null;
          }

          gpuFramebuffer.glFramebuffer = null;
        }
      }
      function WebGL2CmdFuncCreateShader(device, gpuShader) {
        var gl = device.gl;

        var _loop = function _loop(k) {
          var gpuStage = gpuShader.gpuStages[k];
          var glShaderType = 0;
          var shaderTypeStr = '';
          var lineNumber = 1;

          switch (gpuStage.type) {
            case ShaderStageFlagBit.VERTEX:
              {
                shaderTypeStr = 'VertexShader';
                glShaderType = gl.VERTEX_SHADER;
                break;
              }

            case ShaderStageFlagBit.FRAGMENT:
              {
                shaderTypeStr = 'FragmentShader';
                glShaderType = gl.FRAGMENT_SHADER;
                break;
              }

            default:
              {
                console.error('Unsupported ShaderType.');
                return {
                  v: void 0
                };
              }
          }

          var glShader = gl.createShader(glShaderType);

          if (glShader) {
            gpuStage.glShader = glShader;
            gl.shaderSource(gpuStage.glShader, "#version 300 es\n" + gpuStage.source);
            gl.compileShader(gpuStage.glShader);

            if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
              console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed.");
              console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, function () {
                return "\n" + lineNumber++ + " ";
              }));
              console.error(gl.getShaderInfoLog(gpuStage.glShader));

              for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                var stage = gpuShader.gpuStages[k];

                if (stage.glShader) {
                  gl.deleteShader(stage.glShader);
                  stage.glShader = null;
                }
              }

              return {
                v: void 0
              };
            }
          }
        };

        for (var k = 0; k < gpuShader.gpuStages.length; k++) {
          var _ret = _loop(k);

          if (typeof _ret === "object") return _ret.v;
        }

        var glProgram = gl.createProgram();

        if (!glProgram) {
          return;
        }

        gpuShader.glProgram = glProgram;

        for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
          var gpuStage = gpuShader.gpuStages[_k];
          gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
        }

        gl.linkProgram(gpuShader.glProgram);

        for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
          var _gpuStage = gpuShader.gpuStages[_k2];

          if (_gpuStage.glShader) {
            gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
            gl.deleteShader(_gpuStage.glShader);
            _gpuStage.glShader = null;
          }
        }

        if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
          debug("Shader '" + gpuShader.name + "' compilation succeeded.");
        } else {
          console.error("Failed to link shader '" + gpuShader.name + "'.");
          console.error(gl.getProgramInfoLog(gpuShader.glProgram));
          return;
        }

        var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
        gpuShader.glInputs = new Array(activeAttribCount);

        for (var i = 0; i < activeAttribCount; ++i) {
          var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

          if (attribInfo) {
            var varName = void 0;
            var nameOffset = attribInfo.name.indexOf('[');

            if (nameOffset !== -1) {
              varName = attribInfo.name.substr(0, nameOffset);
            } else {
              varName = attribInfo.name;
            }

            var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
            var type = WebGLTypeToGFXType$1(attribInfo.type, gl);
            var stride = WebGLGetTypeSize$1(attribInfo.type, gl);
            gpuShader.glInputs[i] = {
              name: varName,
              type: type,
              stride: stride,
              count: attribInfo.size,
              size: stride * attribInfo.size,
              glType: attribInfo.type,
              glLoc: glLoc
            };
          }
        }

        var activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORM_BLOCKS);
        var blockName;
        var blockIdx;
        var blockSize;
        var block;

        if (activeBlockCount) {
          gpuShader.glBlocks = new Array(activeBlockCount);

          for (var b = 0; b < activeBlockCount; ++b) {
            blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b);

            var _nameOffset = blockName.indexOf('[');

            if (_nameOffset !== -1) {
              blockName = blockName.substr(0, _nameOffset);
            }

            block = null;

            for (var _k3 = 0; _k3 < gpuShader.blocks.length; _k3++) {
              if (gpuShader.blocks[_k3].name === blockName) {
                block = gpuShader.blocks[_k3];
                break;
              }
            }

            if (!block) {
              error("Block '" + blockName + "' does not bound");
            } else {
              blockIdx = b;
              blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_DATA_SIZE);
              var glBinding = block.binding + (device.bindingMappings.blockOffsets[block.set] || 0);
              gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, glBinding);
              gpuShader.glBlocks[b] = {
                set: block.set,
                binding: block.binding,
                idx: blockIdx,
                name: blockName,
                size: blockSize,
                glBinding: glBinding
              };
            }
          }
        }

        for (var _i4 = 0; _i4 < gpuShader.subpassInputs.length; ++_i4) {
          var subpassInput = gpuShader.subpassInputs[_i4];
          gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type$1.SAMPLER2D, subpassInput.count));
        }

        if (gpuShader.samplerTextures.length > 0) {
          gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);

          for (var _i5 = 0; _i5 < gpuShader.samplerTextures.length; ++_i5) {
            var sampler = gpuShader.samplerTextures[_i5];
            gpuShader.glSamplerTextures[_i5] = {
              set: sampler.set,
              binding: sampler.binding,
              name: sampler.name,
              type: sampler.type,
              count: sampler.count,
              units: [],
              glUnits: null,
              glType: GFXTypeToWebGLType$1(sampler.type, gl),
              glLoc: null
            };
          }
        }

        var glActiveSamplers = [];
        var glActiveSamplerLocations = [];
        var texUnitCacheMap = device.stateCache.texUnitCacheMap;
        var flexibleSetBaseOffset = 0;

        for (var _i6 = 0; _i6 < gpuShader.blocks.length; ++_i6) {
          if (gpuShader.blocks[_i6].set === device.bindingMappings.flexibleSet) {
            flexibleSetBaseOffset++;
          }
        }

        var arrayOffset = 0;

        for (var _i7 = 0; _i7 < gpuShader.samplerTextures.length; ++_i7) {
          var _sampler = gpuShader.samplerTextures[_i7];

          var _glLoc = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);

          if (_glLoc && _glLoc.id !== -1) {
            glActiveSamplers.push(gpuShader.glSamplerTextures[_i7]);
            glActiveSamplerLocations.push(_glLoc);
          }

          if (texUnitCacheMap[_sampler.name] === undefined) {
            var binding = _sampler.binding + device.bindingMappings.samplerTextureOffsets[_sampler.set] + arrayOffset;

            if (_sampler.set === device.bindingMappings.flexibleSet) {
              binding -= flexibleSetBaseOffset;
            }

            texUnitCacheMap[_sampler.name] = binding % device.capabilities.maxTextureUnits;
            arrayOffset += _sampler.count - 1;
          }
        }

        if (glActiveSamplers.length) {
          var usedTexUnits = [];

          for (var _i8 = 0; _i8 < glActiveSamplers.length; ++_i8) {
            var glSampler = glActiveSamplers[_i8];
            var cachedUnit = texUnitCacheMap[glSampler.name];

            if (cachedUnit !== undefined) {
              glSampler.glLoc = glActiveSamplerLocations[_i8];

              for (var t = 0; t < glSampler.count; ++t) {
                while (usedTexUnits[cachedUnit]) {
                  cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                }

                glSampler.units.push(cachedUnit);
                usedTexUnits[cachedUnit] = true;
              }
            }
          }

          var unitIdx = 0;

          for (var _i9 = 0; _i9 < glActiveSamplers.length; ++_i9) {
            var _glSampler = glActiveSamplers[_i9];

            if (!_glSampler.glLoc) {
              _glSampler.glLoc = glActiveSamplerLocations[_i9];

              while (usedTexUnits[unitIdx]) {
                unitIdx++;
              }

              for (var _t = 0; _t < _glSampler.count; ++_t) {
                while (usedTexUnits[unitIdx]) {
                  unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                }

                if (texUnitCacheMap[_glSampler.name] === undefined) {
                  texUnitCacheMap[_glSampler.name] = unitIdx;
                }

                _glSampler.units.push(unitIdx);

                usedTexUnits[unitIdx] = true;
              }
            }
          }

          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(gpuShader.glProgram);
          }

          for (var _k4 = 0; _k4 < glActiveSamplers.length; _k4++) {
            var _glSampler2 = glActiveSamplers[_k4];
            _glSampler2.glUnits = new Int32Array(_glSampler2.units);
            gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
          }

          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(device.stateCache.glProgram);
          }
        }

        gpuShader.glSamplerTextures = glActiveSamplers;
      }
      function WebGL2CmdFuncDestroyShader(device, gpuShader) {
        if (gpuShader.glProgram) {
          device.gl.deleteProgram(gpuShader.glProgram);

          if (device.stateCache.glProgram === gpuShader.glProgram) {
            device.gl.useProgram(null);
            device.stateCache.glProgram = null;
          }

          gpuShader.glProgram = null;
        }
      }
      function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
        var gl = device.gl;
        gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
        var offsets = [0, 0, 0, 0, 0, 0, 0, 0];

        for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
          var attrib = gpuInputAssembler.attributes[i];
          var stream = attrib.stream !== undefined ? attrib.stream : 0;
          var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
          var glType = GFXFormatToWebGLType$1(attrib.format, gl);
          var size = FormatInfos[attrib.format].size;
          gpuInputAssembler.glAttribs[i] = {
            name: attrib.name,
            glBuffer: gpuBuffer.glBuffer,
            glType: glType,
            size: size,
            count: FormatInfos[attrib.format].count,
            stride: gpuBuffer.stride,
            componentCount: WebGLGetComponentCount$1(glType, gl),
            isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
            isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
            offset: offsets[stream]
          };
          offsets[stream] += size;
        }
      }
      function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
        var it = gpuInputAssembler.glVAOs.values();
        var res = it.next();
        var gl = device.gl;
        var glVAO = device.stateCache.glVAO;

        while (!res.done) {
          gl.deleteVertexArray(res.value);

          if (glVAO === res.value) {
            gl.bindVertexArray(null);
            glVAO = null;
          }

          res = it.next();
        }

        device.stateCache.glVAO = glVAO;
        gpuInputAssembler.glVAOs.clear();
      }
      var gfxStateCache$1 = {
        gpuPipelineState: null,
        gpuInputAssembler: null,
        glPrimitive: 0,
        invalidateAttachments: []
      };
      function WebGL2CmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
        var gl = device.gl;
        var cache = device.stateCache;
        var clears = 0;

        if (gpuFramebuffer && gpuRenderPass) {
          if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
            cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
          }

          if (cache.viewport.left !== renderArea.x || cache.viewport.top !== renderArea.y || cache.viewport.width !== renderArea.width || cache.viewport.height !== renderArea.height) {
            gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
            cache.viewport.left = renderArea.x;
            cache.viewport.top = renderArea.y;
            cache.viewport.width = renderArea.width;
            cache.viewport.height = renderArea.height;
          }

          if (cache.scissorRect.x !== renderArea.x || cache.scissorRect.y !== renderArea.y || cache.scissorRect.width !== renderArea.width || cache.scissorRect.height !== renderArea.height) {
            gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
            cache.scissorRect.x = renderArea.x;
            cache.scissorRect.y = renderArea.y;
            cache.scissorRect.width = renderArea.width;
            cache.scissorRect.height = renderArea.height;
          }

          gfxStateCache$1.invalidateAttachments.length = 0;

          for (var j = 0; j < clearColors.length; ++j) {
            var colorAttachment = gpuRenderPass.colorAttachments[j];

            if (colorAttachment.format !== Format.UNKNOWN) {
              switch (colorAttachment.loadOp) {
                case LoadOp.LOAD:
                  break;

                case LoadOp.CLEAR:
                  {
                    if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                      gl.colorMask(true, true, true, true);
                    }

                    if (!gpuFramebuffer.isOffscreen) {
                      var clearColor = clearColors[0];
                      gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                      clears |= gl.COLOR_BUFFER_BIT;
                    } else {
                      _f32v4[0] = clearColors[j].x;
                      _f32v4[1] = clearColors[j].y;
                      _f32v4[2] = clearColors[j].z;
                      _f32v4[3] = clearColors[j].w;
                      gl.clearBufferfv(gl.COLOR, j, _f32v4);
                    }

                    break;
                  }

                case LoadOp.DISCARD:
                  {
                    gfxStateCache$1.invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + j);
                    break;
                  }
              }
            }
          }

          if (gpuRenderPass.depthStencilAttachment) {
            if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
              switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                case LoadOp.LOAD:
                  break;

                case LoadOp.CLEAR:
                  {
                    if (!cache.dss.depthWrite) {
                      gl.depthMask(true);
                    }

                    gl.clearDepth(clearDepth);
                    clears |= gl.DEPTH_BUFFER_BIT;
                    break;
                  }

                case LoadOp.DISCARD:
                  {
                    gfxStateCache$1.invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
                    break;
                  }
              }

              if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                  case LoadOp.LOAD:
                    break;

                  case LoadOp.CLEAR:
                    {
                      if (!cache.dss.stencilWriteMaskFront) {
                        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                      }

                      if (!cache.dss.stencilWriteMaskBack) {
                        gl.stencilMaskSeparate(gl.BACK, 0xffff);
                      }

                      gl.clearStencil(clearStencil);
                      clears |= gl.STENCIL_BUFFER_BIT;
                      break;
                    }

                  case LoadOp.DISCARD:
                    {
                      gfxStateCache$1.invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
                      break;
                    }
                }
              }
            }
          }

          if (gpuFramebuffer.glFramebuffer && gfxStateCache$1.invalidateAttachments.length) {
            gl.invalidateFramebuffer(gl.FRAMEBUFFER, gfxStateCache$1.invalidateAttachments);
          }

          if (clears) {
            gl.clear(clears);
          }

          if (clears & gl.COLOR_BUFFER_BIT) {
            var colorMask = cache.bs.targets[0].blendColorMask;

            if (colorMask !== ColorMask.ALL) {
              var r = (colorMask & ColorMask.R) !== ColorMask.NONE;
              var g = (colorMask & ColorMask.G) !== ColorMask.NONE;
              var b = (colorMask & ColorMask.B) !== ColorMask.NONE;
              var a = (colorMask & ColorMask.A) !== ColorMask.NONE;
              gl.colorMask(r, g, b, a);
            }
          }

          if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
            gl.depthMask(false);
          }

          if (clears & gl.STENCIL_BUFFER_BIT) {
            if (!cache.dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, 0);
            }

            if (!cache.dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, 0);
            }
          }
        }
      }
      function WebGL2CmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
        var gl = device.gl;
        var cache = device.stateCache;
        var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
        var isShaderChanged = false;

        if (gpuPipelineState && gfxStateCache$1.gpuPipelineState !== gpuPipelineState) {
          gfxStateCache$1.gpuPipelineState = gpuPipelineState;
          gfxStateCache$1.glPrimitive = gpuPipelineState.glPrimitive;

          if (gpuShader) {
            var glProgram = gpuShader.glProgram;

            if (cache.glProgram !== glProgram) {
              gl.useProgram(glProgram);
              cache.glProgram = glProgram;
              isShaderChanged = true;
            }
          }

          var rs = gpuPipelineState.rs;

          if (rs) {
            if (cache.rs.cullMode !== rs.cullMode) {
              switch (rs.cullMode) {
                case CullMode.NONE:
                  {
                    gl.disable(gl.CULL_FACE);
                    break;
                  }

                case CullMode.FRONT:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.FRONT);
                    break;
                  }

                case CullMode.BACK:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                    break;
                  }
              }

              device.stateCache.rs.cullMode = rs.cullMode;
            }

            var isFrontFaceCCW = rs.isFrontFaceCCW;

            if (device.stateCache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
              gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
              device.stateCache.rs.isFrontFaceCCW = isFrontFaceCCW;
            }

            if (device.stateCache.rs.depthBias !== rs.depthBias || device.stateCache.rs.depthBiasSlop !== rs.depthBiasSlop) {
              gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
              device.stateCache.rs.depthBias = rs.depthBias;
              device.stateCache.rs.depthBiasSlop = rs.depthBiasSlop;
            }

            if (device.stateCache.rs.lineWidth !== rs.lineWidth) {
              gl.lineWidth(rs.lineWidth);
              device.stateCache.rs.lineWidth = rs.lineWidth;
            }
          }

          var dss = gpuPipelineState.dss;

          if (dss) {
            if (cache.dss.depthTest !== dss.depthTest) {
              if (dss.depthTest) {
                gl.enable(gl.DEPTH_TEST);
              } else {
                gl.disable(gl.DEPTH_TEST);
              }

              cache.dss.depthTest = dss.depthTest;
            }

            if (cache.dss.depthWrite !== dss.depthWrite) {
              gl.depthMask(dss.depthWrite);
              cache.dss.depthWrite = dss.depthWrite;
            }

            if (cache.dss.depthFunc !== dss.depthFunc) {
              gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]);
              cache.dss.depthFunc = dss.depthFunc;
            }

            if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
              if (dss.stencilTestFront || dss.stencilTestBack) {
                gl.enable(gl.STENCIL_TEST);
              } else {
                gl.disable(gl.STENCIL_TEST);
              }

              cache.dss.stencilTestFront = dss.stencilTestFront;
              cache.dss.stencilTestBack = dss.stencilTestBack;
            }

            if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
              gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
              cache.dss.stencilFuncFront = dss.stencilFuncFront;
              cache.dss.stencilRefFront = dss.stencilRefFront;
              cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
            }

            if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
              gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]);
              cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
              cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
              cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
            }

            if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
              cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
            }

            if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
              gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
              cache.dss.stencilFuncBack = dss.stencilFuncBack;
              cache.dss.stencilRefBack = dss.stencilRefBack;
              cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
            }

            if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
              gl.stencilOpSeparate(gl.BACK, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]);
              cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
              cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
              cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
            }

            if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
              cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
            }
          }

          var bs = gpuPipelineState.bs;

          if (bs) {
            if (cache.bs.isA2C !== bs.isA2C) {
              if (bs.isA2C) {
                gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              } else {
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              }

              cache.bs.isA2C = bs.isA2C;
            }

            if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
              gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
              cache.bs.blendColor.x = bs.blendColor.x;
              cache.bs.blendColor.y = bs.blendColor.y;
              cache.bs.blendColor.z = bs.blendColor.z;
              cache.bs.blendColor.w = bs.blendColor.w;
            }

            var target0 = bs.targets[0];
            var target0Cache = cache.bs.targets[0];

            if (target0Cache.blend !== target0.blend) {
              if (target0.blend) {
                gl.enable(gl.BLEND);
              } else {
                gl.disable(gl.BLEND);
              }

              target0Cache.blend = target0.blend;
            }

            if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
              gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]);
              target0Cache.blendEq = target0.blendEq;
              target0Cache.blendAlphaEq = target0.blendAlphaEq;
            }

            if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
              gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]);
              target0Cache.blendSrc = target0.blendSrc;
              target0Cache.blendDst = target0.blendDst;
              target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
              target0Cache.blendDstAlpha = target0.blendDstAlpha;
            }

            if (target0Cache.blendColorMask !== target0.blendColorMask) {
              gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
              target0Cache.blendColorMask = target0.blendColorMask;
            }
          }
        }

        if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
          var blockLen = gpuShader.glBlocks.length;
          var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;

          for (var j = 0; j < blockLen; j++) {
            var glBlock = gpuShader.glBlocks[j];
            var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
            var descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
            var gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];

            if (!gpuDescriptor || !gpuDescriptor.gpuBuffer) {
              error("Buffer binding '" + glBlock.name + "' at set " + glBlock.set + " binding " + glBlock.binding + " is not bounded");
              continue;
            }

            var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
            var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];
            var offset = gpuDescriptor.gpuBuffer.glOffset;

            if (dynamicOffsetIndex >= 0) {
              offset += dynamicOffsets[dynamicOffsetIndex];
            }

            if (cache.glBindUBOs[glBlock.glBinding] !== gpuDescriptor.gpuBuffer.glBuffer || cache.glBindUBOOffsets[glBlock.glBinding] !== offset) {
              if (offset) {
                gl.bindBufferRange(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer, offset, gpuDescriptor.gpuBuffer.size);
              } else {
                gl.bindBufferBase(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer);
              }

              cache.glUniformBuffer = cache.glBindUBOs[glBlock.glBinding] = gpuDescriptor.gpuBuffer.glBuffer;
              cache.glBindUBOOffsets[glBlock.glBinding] = offset;
            }
          }

          var samplerLen = gpuShader.glSamplerTextures.length;

          for (var i = 0; i < samplerLen; i++) {
            var glSampler = gpuShader.glSamplerTextures[i];
            var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];

            var _descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];

            var _gpuDescriptor = _descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[_descriptorIndex];

            for (var l = 0; l < glSampler.units.length; l++) {
              var texUnit = glSampler.units[l];
              var glTexUnit = cache.glTexUnits[texUnit];

              if (!_gpuDescriptor || !_gpuDescriptor.gpuTextureView || !_gpuDescriptor.gpuTextureView.gpuTexture || !_gpuDescriptor.gpuSampler) {
                error("Sampler binding '" + glSampler.name + "' at set " + glSampler.set + " binding " + glSampler.binding + " index " + l + " is not bounded");
                continue;
              }

              var gpuTextureView = _gpuDescriptor.gpuTextureView;
              var gpuTexture = gpuTextureView.gpuTexture;
              var minLod = gpuTextureView.baseLevel;
              var maxLod = minLod + gpuTextureView.levelCount;

              if (gpuTexture.size > 0) {
                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  if (gpuTexture.glTexture) {
                    gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                  } else {
                    gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                  }

                  glTexUnit.glTexture = gpuTexture.glTexture;
                }

                var _gpuDescriptor2 = _gpuDescriptor,
                    gpuSampler = _gpuDescriptor2.gpuSampler;

                var _glSampler3 = gpuSampler.getGLSampler(device, minLod, maxLod);

                if (cache.glSamplerUnits[texUnit] !== _glSampler3) {
                  gl.bindSampler(texUnit, _glSampler3);
                  cache.glSamplerUnits[texUnit] = _glSampler3;
                }
              }

              _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++_descriptorIndex];
            }
          }
        }

        if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache$1.gpuInputAssembler !== gpuInputAssembler)) {
          gfxStateCache$1.gpuInputAssembler = gpuInputAssembler;

          if (device.extensions.useVAO) {
            var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

            if (!glVAO) {
              glVAO = gl.createVertexArray();
              gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
              gl.bindVertexArray(glVAO);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
              var glAttrib;

              for (var _j = 0; _j < gpuShader.glInputs.length; _j++) {
                var glInput = gpuShader.glInputs[_j];
                glAttrib = null;

                for (var k = 0; k < gpuInputAssembler.glAttribs.length; k++) {
                  var attrib = gpuInputAssembler.glAttribs[k];

                  if (attrib.name === glInput.name) {
                    glAttrib = attrib;
                    break;
                  }
                }

                if (glAttrib) {
                  if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                    cache.glArrayBuffer = glAttrib.glBuffer;
                  }

                  for (var c = 0; c < glAttrib.componentCount; ++c) {
                    var glLoc = glInput.glLoc + c;
                    var attribOffset = glAttrib.offset + glAttrib.size * c;
                    gl.enableVertexAttribArray(glLoc);
                    cache.glCurrentAttribLocs[glLoc] = true;
                    gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                    gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                  }
                }
              }

              var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

              if (gpuBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
              }

              gl.bindVertexArray(null);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
            }

            if (cache.glVAO !== glVAO) {
              gl.bindVertexArray(glVAO);
              cache.glVAO = glVAO;
            }
          } else {
            for (var a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
              cache.glCurrentAttribLocs[a] = false;
            }

            for (var _j2 = 0; _j2 < gpuShader.glInputs.length; _j2++) {
              var _glInput = gpuShader.glInputs[_j2];
              var _glAttrib = null;

              for (var _k5 = 0; _k5 < gpuInputAssembler.glAttribs.length; _k5++) {
                var _attrib = gpuInputAssembler.glAttribs[_k5];

                if (_attrib.name === _glInput.name) {
                  _glAttrib = _attrib;
                  break;
                }
              }

              if (_glAttrib) {
                if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer);
                  cache.glArrayBuffer = _glAttrib.glBuffer;
                }

                for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                  var _glLoc2 = _glInput.glLoc + _c;

                  var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;

                  if (!cache.glEnabledAttribLocs[_glLoc2] && _glLoc2 >= 0) {
                    gl.enableVertexAttribArray(_glLoc2);
                    cache.glEnabledAttribLocs[_glLoc2] = true;
                  }

                  cache.glCurrentAttribLocs[_glLoc2] = true;
                  gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                  gl.vertexAttribDivisor(_glLoc2, _glAttrib.isInstanced ? 1 : 0);
                }
              }
            }

            var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

            if (_gpuBuffer) {
              if (cache.glElementArrayBuffer !== _gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer);
                cache.glElementArrayBuffer = _gpuBuffer.glBuffer;
              }
            }

            for (var _a = 0; _a < device.capabilities.maxVertexAttributes; ++_a) {
              if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                gl.disableVertexAttribArray(_a);
                cache.glEnabledAttribLocs[_a] = false;
              }
            }
          }
        }

        if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
          var dsLen = gpuPipelineState.dynamicStates.length;

          for (var _k6 = 0; _k6 < dsLen; _k6++) {
            var dynamicState = gpuPipelineState.dynamicStates[_k6];

            switch (dynamicState) {
              case DynamicStateFlagBit.LINE_WIDTH:
                {
                  if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                    gl.lineWidth(dynamicStates.lineWidth);
                    cache.rs.lineWidth = dynamicStates.lineWidth;
                  }

                  break;
                }

              case DynamicStateFlagBit.DEPTH_BIAS:
                {
                  if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                    gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                    cache.rs.depthBias = dynamicStates.depthBiasConstant;
                    cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                  }

                  break;
                }

              case DynamicStateFlagBit.BLEND_CONSTANTS:
                {
                  var blendConstant = dynamicStates.blendConstant;

                  if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                    gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                    cache.bs.blendColor.copy(blendConstant);
                  }

                  break;
                }

              case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                {
                  var front = dynamicStates.stencilStatesFront;
                  var back = dynamicStates.stencilStatesBack;

                  if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                    gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                    cache.dss.stencilWriteMaskFront = front.writeMask;
                  }

                  if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                    gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                    cache.dss.stencilWriteMaskBack = back.writeMask;
                  }

                  break;
                }

              case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                {
                  var _front = dynamicStates.stencilStatesFront;
                  var _back = dynamicStates.stencilStatesBack;

                  if (cache.dss.stencilRefFront !== _front.reference || cache.dss.stencilReadMaskFront !== _front.compareMask) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[cache.dss.stencilFuncFront], _front.reference, _front.compareMask);
                    cache.dss.stencilRefFront = _front.reference;
                    cache.dss.stencilReadMaskFront = _front.compareMask;
                  }

                  if (cache.dss.stencilRefBack !== _back.reference || cache.dss.stencilReadMaskBack !== _back.compareMask) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[cache.dss.stencilFuncBack], _back.reference, _back.compareMask);
                    cache.dss.stencilRefBack = _back.reference;
                    cache.dss.stencilReadMaskBack = _back.compareMask;
                  }

                  break;
                }
            }
          }
        }
      }
      function WebGL2CmdFuncDraw(device, drawInfo) {
        var gl = device.gl;
        var gpuInputAssembler = gfxStateCache$1.gpuInputAssembler,
            glPrimitive = gfxStateCache$1.glPrimitive;
        var md = device.extensions.WEBGL_multi_draw;

        if (gpuInputAssembler) {
          var indexBuffer = gpuInputAssembler.gpuIndexBuffer;

          if (gpuInputAssembler.gpuIndirectBuffer) {
            var indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;

            if (indirects.drawByIndex) {
              for (var j = 0; j < indirects.drawCount; j++) {
                indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
              }

              if (md) {
                if (indirects.instancedDraw) {
                  md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                } else {
                  md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                }
              } else {
                for (var _j3 = 0; _j3 < indirects.drawCount; _j3++) {
                  if (indirects.instances[_j3]) {
                    gl.drawElementsInstanced(glPrimitive, indirects.counts[_j3], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j3], indirects.instances[_j3]);
                  } else {
                    gl.drawElements(glPrimitive, indirects.counts[_j3], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j3]);
                  }
                }
              }
            } else if (md) {
              if (indirects.instancedDraw) {
                md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
              } else {
                md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
              }
            } else {
              for (var _j4 = 0; _j4 < indirects.drawCount; _j4++) {
                if (indirects.instances[_j4]) {
                  gl.drawArraysInstanced(glPrimitive, indirects.offsets[_j4], indirects.counts[_j4], indirects.instances[_j4]);
                } else {
                  gl.drawArrays(glPrimitive, indirects.offsets[_j4], indirects.counts[_j4]);
                }
              }
            }
          } else if (drawInfo.instanceCount) {
            if (indexBuffer) {
              if (drawInfo.indexCount > 0) {
                var offset = drawInfo.firstIndex * indexBuffer.stride;
                gl.drawElementsInstanced(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
              }
            } else if (drawInfo.vertexCount > 0) {
              gl.drawArraysInstanced(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
            }
          } else if (indexBuffer) {
            if (drawInfo.indexCount > 0) {
              var _offset = drawInfo.firstIndex * indexBuffer.stride;

              gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
            }
          } else if (drawInfo.vertexCount > 0) {
            gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
          }
        }
      }
      var cmdIds$1 = new Array(WebGL2Cmd.COUNT);
      function WebGL2CmdFuncExecuteCmds(device, cmdPackage) {
        cmdIds$1.fill(0);

        for (var i = 0; i < cmdPackage.cmds.length; ++i) {
          var cmd = cmdPackage.cmds.array[i];
          var cmdId = cmdIds$1[cmd]++;

          switch (cmd) {
            case WebGL2Cmd.BEGIN_RENDER_PASS:
              {
                var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                WebGL2CmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                break;
              }

            case WebGL2Cmd.BIND_STATES:
              {
                var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                WebGL2CmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                break;
              }

            case WebGL2Cmd.DRAW:
              {
                var cmd3 = cmdPackage.drawCmds.array[cmdId];
                WebGL2CmdFuncDraw(device, cmd3.drawInfo);
                break;
              }

            case WebGL2Cmd.UPDATE_BUFFER:
              {
                var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                WebGL2CmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                break;
              }

            case WebGL2Cmd.COPY_BUFFER_TO_TEXTURE:
              {
                var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                WebGL2CmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                break;
              }
          }
        }
      }
      function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
        var gl = device.gl;
        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }

        var n = 0;
        var f = 0;

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var k = 0; k < regions.length; k++) {
                var region = regions[k];
                gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
              }

              break;
            }

          case gl.TEXTURE_CUBE_MAP:
            {
              for (var _k7 = 0; _k7 < regions.length; _k7++) {
                var _region = regions[_k7];
                var fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;

                for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                  gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region.texSubres.mipLevel, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }

        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      var stagingBuffer$1 = new Uint8Array(1);

      function pixelBufferPick$1(buffer, format, offset, stride, extent) {
        var blockHeight = formatAlignment(format).height;
        var bufferSize = FormatSize(format, extent.width, extent.height, extent.depth);
        var rowStrideSize = FormatSize(format, stride.width, 1, 1);
        var sliceStrideSize = FormatSize(format, stride.width, stride.height, 1);
        var destRowSize = FormatSize(format, extent.width, 1, 1);
        var ArrayBufferCtor = getTypedArrayConstructor(FormatInfos[format]);

        if (stagingBuffer$1.byteLength < bufferSize) {
          stagingBuffer$1 = new Uint8Array(bufferSize);
        }

        var destOffset = 0;
        var bufferOffset = offset;

        for (var i = 0; i < extent.depth; i++) {
          bufferOffset = offset + sliceStrideSize * i;

          for (var j = 0; j < extent.height; j += blockHeight) {
            stagingBuffer$1.subarray(destOffset, destOffset + destRowSize).set(new Uint8Array(buffer.buffer, buffer.byteOffset + bufferOffset, destRowSize));
            destOffset += destRowSize;
            bufferOffset += rowStrideSize;
          }
        }

        return new ArrayBufferCtor(stagingBuffer$1.buffer);
      }

      function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
        var gl = device.gl;
        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }

        var n = 0;
        var f = 0;
        var fmtInfo = FormatInfos[gpuTexture.format];
        var ArrayBufferCtor = getTypedArrayConstructor(fmtInfo);
        var isCompressed = fmtInfo.isCompressed;
        var blockSize = formatAlignment(gpuTexture.format);
        var extent = new Extent();
        var offset = new Offset();
        var stride = new Extent();

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var k = 0; k < regions.length; k++) {
                var region = regions[k];
                var mipLevel = region.texSubres.mipLevel;
                offset.x = region.texOffset.x === 0 ? 0 : alignTo(region.texOffset.x, blockSize.width);
                offset.y = region.texOffset.y === 0 ? 0 : alignTo(region.texOffset.y, blockSize.height);
                extent.width = region.texExtent.width < blockSize.width ? region.texExtent.width : alignTo(region.texExtent.width, blockSize.width);
                extent.height = region.texExtent.height < blockSize.height ? region.texExtent.width : alignTo(region.texExtent.height, blockSize.height);
                stride.width = region.buffStride > 0 ? region.buffStride : extent.width;
                stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                var destWidth = region.texExtent.width + offset.x === gpuTexture.width >> mipLevel ? region.texExtent.width : extent.width;
                var destHeight = region.texExtent.height + offset.y === gpuTexture.height >> mipLevel ? region.texExtent.height : extent.height;
                var pixels = void 0;
                var buffer = buffers[n++];

                if (stride.width === extent.width && stride.height === extent.height) {
                  pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset);
                } else {
                  pixels = pixelBufferPick$1(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                }

                if (!isCompressed) {
                  gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                  gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                } else {
                  gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                }
              }

              break;
            }

          case gl.TEXTURE_2D_ARRAY:
            {
              for (var _k8 = 0; _k8 < regions.length; _k8++) {
                var _region2 = regions[_k8];
                var _mipLevel = _region2.texSubres.mipLevel;
                offset.x = _region2.texOffset.x === 0 ? 0 : alignTo(_region2.texOffset.x, blockSize.width);
                offset.y = _region2.texOffset.y === 0 ? 0 : alignTo(_region2.texOffset.y, blockSize.height);
                extent.width = _region2.texExtent.width < blockSize.width ? _region2.texExtent.width : alignTo(_region2.texExtent.width, blockSize.width);
                extent.height = _region2.texExtent.height < blockSize.height ? _region2.texExtent.width : alignTo(_region2.texExtent.height, blockSize.height);
                extent.depth = 1;
                stride.width = _region2.buffStride > 0 ? _region2.buffStride : extent.width;
                stride.height = _region2.buffTexHeight > 0 ? _region2.buffTexHeight : extent.height;

                var _destWidth = _region2.texExtent.width + offset.x === gpuTexture.width >> _mipLevel ? _region2.texExtent.width : extent.width;

                var _destHeight = _region2.texExtent.height + offset.y === gpuTexture.height >> _mipLevel ? _region2.texExtent.height : extent.height;

                var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;

                for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                  offset.z = f;

                  var _pixels = void 0;

                  var _buffer = buffers[n++];

                  if (stride.width === extent.width && stride.height === extent.height) {
                    _pixels = new ArrayBufferCtor(_buffer.buffer, _buffer.byteOffset + _region2.buffOffset);
                  } else {
                    _pixels = pixelBufferPick$1(_buffer, gpuTexture.format, _region2.buffOffset, stride, extent);
                  }

                  if (!isCompressed) {
                    gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, offset.x, offset.y, offset.z, _destWidth, _destHeight, extent.depth, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                  } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                    gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, offset.x, offset.y, offset.z, _destWidth, _destHeight, extent.depth, gpuTexture.glFormat, _pixels);
                  } else {
                    gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, gpuTexture.glInternalFmt, _destWidth, _destHeight, extent.depth, 0, _pixels);
                  }
                }
              }

              break;
            }

          case gl.TEXTURE_3D:
            {
              for (var _k9 = 0; _k9 < regions.length; _k9++) {
                var _region3 = regions[_k9];
                var _mipLevel2 = _region3.texSubres.mipLevel;
                offset.x = _region3.texOffset.x === 0 ? 0 : alignTo(_region3.texOffset.x, blockSize.width);
                offset.y = _region3.texOffset.y === 0 ? 0 : alignTo(_region3.texOffset.y, blockSize.height);
                offset.z = _region3.texOffset.z;
                extent.width = _region3.texExtent.width < blockSize.width ? _region3.texExtent.width : alignTo(_region3.texExtent.width, blockSize.width);
                extent.height = _region3.texExtent.height < blockSize.height ? _region3.texExtent.width : alignTo(_region3.texExtent.height, blockSize.height);
                extent.depth = _region3.texExtent.depth;
                stride.width = _region3.buffStride > 0 ? _region3.buffStride : extent.width;
                stride.height = _region3.buffTexHeight > 0 ? _region3.buffTexHeight : extent.height;

                var _destWidth2 = _region3.texExtent.width + offset.x === gpuTexture.width >> _mipLevel2 ? _region3.texExtent.width : extent.width;

                var _destHeight2 = _region3.texExtent.height + offset.y === gpuTexture.height >> _mipLevel2 ? _region3.texExtent.height : extent.height;

                var _pixels2 = void 0;

                var _buffer2 = buffers[n++];

                if (stride.width === extent.width && stride.height === extent.height) {
                  _pixels2 = new ArrayBufferCtor(_buffer2.buffer, _buffer2.byteOffset + _region3.buffOffset);
                } else {
                  _pixels2 = pixelBufferPick$1(_buffer2, gpuTexture.format, _region3.buffOffset, stride, extent);
                }

                if (!isCompressed) {
                  gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, offset.x, offset.y, offset.z, _destWidth2, _destHeight2, extent.depth, gpuTexture.glFormat, gpuTexture.glType, _pixels2);
                } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                  gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, offset.x, offset.y, offset.z, _destWidth2, _destHeight2, extent.depth, gpuTexture.glFormat, _pixels2);
                } else {
                  gl.compressedTexImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, gpuTexture.glInternalFmt, _destWidth2, _destHeight2, extent.depth, 0, _pixels2);
                }
              }

              break;
            }

          case gl.TEXTURE_CUBE_MAP:
            {
              for (var _k10 = 0; _k10 < regions.length; _k10++) {
                var _region4 = regions[_k10];
                var _mipLevel3 = _region4.texSubres.mipLevel;
                offset.x = _region4.texOffset.x === 0 ? 0 : alignTo(_region4.texOffset.x, blockSize.width);
                offset.y = _region4.texOffset.y === 0 ? 0 : alignTo(_region4.texOffset.y, blockSize.height);
                extent.width = _region4.texExtent.width < blockSize.width ? _region4.texExtent.width : alignTo(_region4.texExtent.width, blockSize.width);
                extent.height = _region4.texExtent.height < blockSize.height ? _region4.texExtent.width : alignTo(_region4.texExtent.height, blockSize.height);
                stride.width = _region4.buffStride > 0 ? _region4.buffStride : extent.width;
                stride.height = _region4.buffTexHeight > 0 ? _region4.buffTexHeight : extent.height;

                var _destWidth3 = _region4.texExtent.width + offset.x === gpuTexture.width >> _mipLevel3 ? _region4.texExtent.width : extent.width;

                var _destHeight3 = _region4.texExtent.height + offset.y === gpuTexture.height >> _mipLevel3 ? _region4.texExtent.height : extent.height;

                var _fcount = _region4.texSubres.baseArrayLayer + _region4.texSubres.layerCount;

                for (f = _region4.texSubres.baseArrayLayer; f < _fcount; ++f) {
                  var _pixels3 = void 0;

                  var _buffer3 = buffers[n++];

                  if (stride.width === extent.width && stride.height === extent.height) {
                    _pixels3 = new ArrayBufferCtor(_buffer3.buffer, _buffer3.byteOffset + _region4.buffOffset);
                  } else {
                    _pixels3 = pixelBufferPick$1(_buffer3, gpuTexture.format, _region4.buffOffset, stride, extent);
                  }

                  if (!isCompressed) {
                    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel3, offset.x, offset.y, _destWidth3, _destHeight3, gpuTexture.glFormat, gpuTexture.glType, _pixels3);
                  } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel3, offset.x, offset.y, _destWidth3, _destHeight3, gpuTexture.glFormat, _pixels3);
                  } else {
                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _mipLevel3, gpuTexture.glInternalFmt, _destWidth3, _destHeight3, 0, _pixels3);
                  }
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }

        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      function WebGL2CmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
        var gl = device.gl;
        var cache = device.stateCache;
        var framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        var x = 0;
        var y = 0;
        var w = 1;
        var h = 1;

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var k = 0; k < regions.length; k++) {
                var region = regions[k];
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                x = region.texOffset.x;
                y = region.texOffset.y;
                w = region.texExtent.width;
                h = region.texExtent.height;
                gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy texture to buffers failed.');
            }
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        cache.glFramebuffer = null;
        gl.deleteFramebuffer(framebuffer);
      }

      var WebGL2IndirectDrawInfos = function () {
        function WebGL2IndirectDrawInfos() {
          this.counts = void 0;
          this.offsets = void 0;
          this.instances = void 0;
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
          this.byteOffsets = void 0;
          this._capacity = 4;
          this.counts = new Int32Array(this._capacity);
          this.offsets = new Int32Array(this._capacity);
          this.instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
        }

        var _proto = WebGL2IndirectDrawInfos.prototype;

        _proto.clearDraws = function clearDraws() {
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
        };

        _proto.setDrawInfo = function setDrawInfo(idx, info) {
          this._ensureCapacity(idx);

          this.drawByIndex = info.indexCount > 0;
          this.instancedDraw = !!info.instanceCount;
          this.drawCount = Math.max(idx + 1, this.drawCount);

          if (this.drawByIndex) {
            this.counts[idx] = info.indexCount;
            this.offsets[idx] = info.firstIndex;
          } else {
            this.counts[idx] = info.vertexCount;
            this.offsets[idx] = info.firstVertex;
          }

          this.instances[idx] = Math.max(1, info.instanceCount);
        };

        _proto._ensureCapacity = function _ensureCapacity(target) {
          if (this._capacity > target) return;
          this._capacity = nextPow2$1(target);
          var counts = new Int32Array(this._capacity);
          var offsets = new Int32Array(this._capacity);
          var instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
          counts.set(this.counts);
          offsets.set(this.offsets);
          instances.set(this.instances);
          this.counts = counts;
          this.offsets = offsets;
          this.instances = instances;
        };

        return WebGL2IndirectDrawInfos;
      }();

      var WebGL2Buffer = function (_Buffer) {
        _inheritsLoose(WebGL2Buffer, _Buffer);

        function WebGL2Buffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Buffer.call.apply(_Buffer, [this].concat(args)) || this;
          _this._gpuBuffer = null;
          return _this;
        }

        var _proto = WebGL2Buffer.prototype;

        _proto.initialize = function initialize(info) {
          if ('buffer' in info) {
            this._isBufferView = true;
            var buffer = info.buffer;
            this._usage = buffer.usage;
            this._memUsage = buffer.memUsage;
            this._size = this._stride = info.range;
            this._count = 1;
            this._flags = buffer.flags;
            this._gpuBuffer = {
              usage: this._usage,
              memUsage: this._memUsage,
              size: this._size,
              stride: this._stride,
              buffer: null,
              indirects: buffer.gpuBuffer.indirects,
              glTarget: buffer.gpuBuffer.glTarget,
              glBuffer: buffer.gpuBuffer.glBuffer,
              glOffset: info.offset
            };
          } else {
            this._usage = info.usage;
            this._memUsage = info.memUsage;
            this._size = info.size;
            this._stride = Math.max(info.stride || this._size, 1);
            this._count = this._size / this._stride;
            this._flags = info.flags;
            this._gpuBuffer = {
              usage: this._usage,
              memUsage: this._memUsage,
              size: this._size,
              stride: this._stride,
              buffer: null,
              indirects: new WebGL2IndirectDrawInfos(),
              glTarget: 0,
              glBuffer: null,
              glOffset: 0
            };
            WebGL2CmdFuncCreateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
            WebGL2DeviceManager.instance.memoryStatus.bufferSize += this._size;
          }
        };

        _proto.destroy = function destroy() {
          if (this._gpuBuffer) {
            if (!this._isBufferView) {
              WebGL2CmdFuncDestroyBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
              WebGL2DeviceManager.instance.memoryStatus.bufferSize -= this._size;
            }

            this._gpuBuffer = null;
          }
        };

        _proto.resize = function resize(size) {
          if (this._isBufferView) {
            console.warn('cannot resize buffer views!');
            return;
          }

          var oldSize = this._size;

          if (oldSize === size) {
            return;
          }

          this._size = size;
          this._count = this._size / this._stride;

          if (this._gpuBuffer) {
            this._gpuBuffer.size = size;

            if (size > 0) {
              WebGL2CmdFuncResizeBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
              WebGL2DeviceManager.instance.memoryStatus.bufferSize -= oldSize;
              WebGL2DeviceManager.instance.memoryStatus.bufferSize += size;
            }
          }
        };

        _proto.update = function update(buffer, size) {
          if (this._isBufferView) {
            console.warn('cannot update through buffer views!');
            return;
          }

          var buffSize;

          if (size !== undefined) {
            buffSize = size;
          } else if (this._usage & BufferUsageBit.INDIRECT) {
            buffSize = 0;
          } else {
            buffSize = buffer.byteLength;
          }

          WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
        };

        _createClass(WebGL2Buffer, [{
          key: "gpuBuffer",
          get: function get() {
            return this._gpuBuffer;
          }
        }]);

        return WebGL2Buffer;
      }(Buffer);

      var WebGL2CommandPool = function () {
        function WebGL2CommandPool(Clazz, count) {
          this._frees = void 0;
          this._freeIdx = 0;
          this._freeCmds = void 0;
          this._frees = new Array(count);
          this._freeCmds = new CachedArray(count);

          for (var i = 0; i < count; ++i) {
            this._frees[i] = new Clazz();
          }

          this._freeIdx = count - 1;
        }

        var _proto = WebGL2CommandPool.prototype;

        _proto.alloc = function alloc(Clazz) {
          if (this._freeIdx < 0) {
            var size = this._frees.length * 2;
            var temp = this._frees;
            this._frees = new Array(size);
            var increase = size - temp.length;

            for (var i = 0; i < increase; ++i) {
              this._frees[i] = new Clazz();
            }

            for (var _i = increase, j = 0; _i < size; ++_i, ++j) {
              this._frees[_i] = temp[j];
            }

            this._freeIdx += increase;
          }

          var cmd = this._frees[this._freeIdx];
          this._frees[this._freeIdx--] = null;
          ++cmd.refCount;
          return cmd;
        };

        _proto.free = function free(cmd) {
          if (--cmd.refCount === 0) {
            this._freeCmds.push(cmd);
          }
        };

        _proto.freeCmds = function freeCmds(cmds) {
          for (var i = 0; i < cmds.length; ++i) {
            if (--cmds.array[i].refCount === 0) {
              this._freeCmds.push(cmds.array[i]);
            }
          }
        };

        _proto.release = function release() {
          for (var i = 0; i < this._freeCmds.length; ++i) {
            var cmd = this._freeCmds.array[i];
            cmd.clear();
            this._frees[++this._freeIdx] = cmd;
          }

          this._freeCmds.clear();
        };

        return WebGL2CommandPool;
      }();
      var WebGL2CommandAllocator = function () {
        function WebGL2CommandAllocator() {
          this.beginRenderPassCmdPool = void 0;
          this.bindStatesCmdPool = void 0;
          this.drawCmdPool = void 0;
          this.updateBufferCmdPool = void 0;
          this.copyBufferToTextureCmdPool = void 0;
          this.beginRenderPassCmdPool = new WebGL2CommandPool(WebGL2CmdBeginRenderPass, 1);
          this.bindStatesCmdPool = new WebGL2CommandPool(WebGL2CmdBindStates, 1);
          this.drawCmdPool = new WebGL2CommandPool(WebGL2CmdDraw, 1);
          this.updateBufferCmdPool = new WebGL2CommandPool(WebGL2CmdUpdateBuffer, 1);
          this.copyBufferToTextureCmdPool = new WebGL2CommandPool(WebGL2CmdCopyBufferToTexture, 1);
        }

        var _proto2 = WebGL2CommandAllocator.prototype;

        _proto2.clearCmds = function clearCmds(cmdPackage) {
          if (cmdPackage.beginRenderPassCmds.length) {
            this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
            cmdPackage.beginRenderPassCmds.clear();
          }

          if (cmdPackage.bindStatesCmds.length) {
            this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
            cmdPackage.bindStatesCmds.clear();
          }

          if (cmdPackage.drawCmds.length) {
            this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
            cmdPackage.drawCmds.clear();
          }

          if (cmdPackage.updateBufferCmds.length) {
            this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
            cmdPackage.updateBufferCmds.clear();
          }

          if (cmdPackage.copyBufferToTextureCmds.length) {
            this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
            cmdPackage.copyBufferToTextureCmds.clear();
          }

          cmdPackage.cmds.clear();
        };

        _proto2.releaseCmds = function releaseCmds() {
          this.beginRenderPassCmdPool.release();
          this.bindStatesCmdPool.release();
          this.drawCmdPool.release();
          this.updateBufferCmdPool.release();
          this.copyBufferToTextureCmdPool.release();
        };

        return WebGL2CommandAllocator;
      }();

      var WebGL2CommandBuffer = function (_CommandBuffer) {
        _inheritsLoose(WebGL2CommandBuffer, _CommandBuffer);

        function WebGL2CommandBuffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _CommandBuffer.call.apply(_CommandBuffer, [this].concat(args)) || this;
          _this.cmdPackage = new WebGL2CmdPackage();
          _this._cmdAllocator = new WebGL2CommandAllocator();
          _this._isInRenderPass = false;
          _this._curGPUPipelineState = null;
          _this._curGPUDescriptorSets = [];
          _this._curGPUInputAssembler = null;
          _this._curDynamicOffsets = Array(8).fill(0);
          _this._curDynamicStates = new DynamicStates();
          _this._isStateInvalied = false;
          return _this;
        }

        var _proto = WebGL2CommandBuffer.prototype;

        _proto.initialize = function initialize(info) {
          this._type = info.type;
          this._queue = info.queue;
          var setCount = WebGL2DeviceManager.instance.bindingMappings.blockOffsets.length;

          for (var i = 0; i < setCount; i++) {
            this._curGPUDescriptorSets.push(null);
          }
        };

        _proto.destroy = function destroy() {
          this._cmdAllocator.clearCmds(this.cmdPackage);
        };

        _proto.begin = function begin(renderPass, subpass, frameBuffer) {

          this._cmdAllocator.clearCmds(this.cmdPackage);

          this._curGPUPipelineState = null;
          this._curGPUInputAssembler = null;
          this._curGPUDescriptorSets.length = 0;
          this._numDrawCalls = 0;
          this._numInstances = 0;
          this._numTris = 0;
        };

        _proto.end = function end() {
          if (this._isStateInvalied) {
            this.bindStates();
          }

          this._isInRenderPass = false;
        };

        _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          var cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGL2CmdBeginRenderPass);

          cmd.gpuRenderPass = renderPass.gpuRenderPass;
          cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
          cmd.renderArea.copy(renderArea);

          for (var i = 0; i < clearColors.length; ++i) {
            cmd.clearColors[i] = clearColors[i];
          }

          cmd.clearDepth = clearDepth;
          cmd.clearStencil = clearStencil;
          this.cmdPackage.beginRenderPassCmds.push(cmd);
          this.cmdPackage.cmds.push(WebGL2Cmd.BEGIN_RENDER_PASS);
          this._isInRenderPass = true;
        };

        _proto.endRenderPass = function endRenderPass() {
          this._isInRenderPass = false;
        };

        _proto.bindPipelineState = function bindPipelineState(pipelineState) {
          var gpuPipelineState = pipelineState.gpuPipelineState;

          if (gpuPipelineState !== this._curGPUPipelineState) {
            this._curGPUPipelineState = gpuPipelineState;
            this._isStateInvalied = true;
          }
        };

        _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
          var gpuDescriptorSets = descriptorSet.gpuDescriptorSet;

          if (gpuDescriptorSets !== this._curGPUDescriptorSets[set]) {
            this._curGPUDescriptorSets[set] = gpuDescriptorSets;
            this._isStateInvalied = true;
          }

          if (dynamicOffsets) {
            var _this$_curGPUPipeline;

            var gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;

            if (gpuPipelineLayout) {
              var offsets = this._curDynamicOffsets;
              var idx = gpuPipelineLayout.dynamicOffsetOffsets[set];

              for (var i = 0; i < dynamicOffsets.length; i++) {
                offsets[idx + i] = dynamicOffsets[i];
              }

              this._isStateInvalied = true;
            }
          }
        };

        _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
          var gpuInputAssembler = inputAssembler.gpuInputAssembler;
          this._curGPUInputAssembler = gpuInputAssembler;
          this._isStateInvalied = true;
        };

        _proto.setViewport = function setViewport(viewport) {
          var cache = this._curDynamicStates.viewport;

          if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
            cache.left = viewport.left;
            cache.top = viewport.top;
            cache.width = viewport.width;
            cache.height = viewport.height;
            cache.minDepth = viewport.minDepth;
            cache.maxDepth = viewport.maxDepth;
            this._isStateInvalied = true;
          }
        };

        _proto.setScissor = function setScissor(scissor) {
          var cache = this._curDynamicStates.scissor;

          if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
            cache.x = scissor.x;
            cache.y = scissor.y;
            cache.width = scissor.width;
            cache.height = scissor.height;
            this._isStateInvalied = true;
          }
        };

        _proto.setLineWidth = function setLineWidth(lineWidth) {
          if (this._curDynamicStates.lineWidth !== lineWidth) {
            this._curDynamicStates.lineWidth = lineWidth;
            this._isStateInvalied = true;
          }
        };

        _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
          var cache = this._curDynamicStates;

          if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
            cache.depthBiasConstant = depthBiasConstantFactor;
            cache.depthBiasClamp = depthBiasClamp;
            cache.depthBiasSlope = depthBiasSlopeFactor;
            this._isStateInvalied = true;
          }
        };

        _proto.setBlendConstants = function setBlendConstants(blendConstants) {
          var cache = this._curDynamicStates.blendConstant;

          if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
            cache.copy(blendConstants);
            this._isStateInvalied = true;
          }
        };

        _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
          var cache = this._curDynamicStates;

          if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
            cache.depthMinBounds = minDepthBounds;
            cache.depthMaxBounds = maxDepthBounds;
            this._isStateInvalied = true;
          }
        };

        _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
          var front = this._curDynamicStates.stencilStatesFront;
          var back = this._curDynamicStates.stencilStatesBack;

          if (face & StencilFace.FRONT) {
            if (front.writeMask !== writeMask) {
              front.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }

          if (face & StencilFace.BACK) {
            if (back.writeMask !== writeMask) {
              back.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }
        };

        _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
          var front = this._curDynamicStates.stencilStatesFront;
          var back = this._curDynamicStates.stencilStatesBack;

          if (face & StencilFace.FRONT) {
            if (front.compareMask !== compareMask || front.reference !== reference) {
              front.reference = reference;
              front.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }

          if (face & StencilFace.BACK) {
            if (back.compareMask !== compareMask || back.reference !== reference) {
              back.reference = reference;
              back.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }
        };

        _proto.draw = function draw(infoOrAssembler) {
          if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            if (this._isStateInvalied) {
              this.bindStates();
            }

            var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;

            var cmd = this._cmdAllocator.drawCmdPool.alloc(WebGL2CmdDraw);

            cmd.drawInfo.copy(info);
            this.cmdPackage.drawCmds.push(cmd);
            this.cmdPackage.cmds.push(WebGL2Cmd.DRAW);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            var indexCount = info.indexCount || info.vertexCount;

            if (this._curGPUPipelineState) {
              var glPrimitive = this._curGPUPipelineState.glPrimitive;

              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }

                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        };

        _proto.updateBuffer = function updateBuffer(buffer, data, size) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            var gpuBuffer = buffer.gpuBuffer;

            if (gpuBuffer) {
              var cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGL2CmdUpdateBuffer);

              var buffSize = 0;
              var buff = null;

              if (buffer.usage & BufferUsageBit.INDIRECT) {
                buff = data;
              } else {
                if (size !== undefined) {
                  buffSize = size;
                } else {
                  buffSize = data.byteLength;
                }

                buff = data;
              }

              cmd.gpuBuffer = gpuBuffer;
              cmd.buffer = buff;
              cmd.offset = 0;
              cmd.size = buffSize;
              this.cmdPackage.updateBufferCmds.push(cmd);
              this.cmdPackage.cmds.push(WebGL2Cmd.UPDATE_BUFFER);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            var gpuTexture = texture.gpuTexture;

            if (gpuTexture) {
              var cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGL2CmdCopyBufferToTexture);

              cmd.gpuTexture = gpuTexture;
              cmd.regions = regions;
              cmd.buffers = buffers;
              this.cmdPackage.copyBufferToTextureCmds.push(cmd);
              this.cmdPackage.cmds.push(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        };

        _proto.execute = function execute(cmdBuffs, count) {
          for (var i = 0; i < count; ++i) {
            var webGL2CmdBuff = cmdBuffs[i];

            for (var c = 0; c < webGL2CmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
              var cmd = webGL2CmdBuff.cmdPackage.beginRenderPassCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.beginRenderPassCmds.push(cmd);
            }

            for (var _c = 0; _c < webGL2CmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
              var _cmd = webGL2CmdBuff.cmdPackage.bindStatesCmds.array[_c];
              ++_cmd.refCount;
              this.cmdPackage.bindStatesCmds.push(_cmd);
            }

            for (var _c2 = 0; _c2 < webGL2CmdBuff.cmdPackage.drawCmds.length; ++_c2) {
              var _cmd2 = webGL2CmdBuff.cmdPackage.drawCmds.array[_c2];
              ++_cmd2.refCount;
              this.cmdPackage.drawCmds.push(_cmd2);
            }

            for (var _c3 = 0; _c3 < webGL2CmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
              var _cmd3 = webGL2CmdBuff.cmdPackage.updateBufferCmds.array[_c3];
              ++_cmd3.refCount;
              this.cmdPackage.updateBufferCmds.push(_cmd3);
            }

            for (var _c4 = 0; _c4 < webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
              var _cmd4 = webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
              ++_cmd4.refCount;
              this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
            }

            this.cmdPackage.cmds.concat(webGL2CmdBuff.cmdPackage.cmds.array);
            this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
            this._numInstances += webGL2CmdBuff._numInstances;
            this._numTris += webGL2CmdBuff._numTris;
          }
        };

        _proto.pipelineBarrier = function pipelineBarrier(GeneralBarrier, bufferBarriers, buffers, textureBarriers, textures) {};

        _proto.bindStates = function bindStates() {
          var bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGL2CmdBindStates);

          bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
          Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
          Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
          bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
          bindStatesCmd.dynamicStates = this._curDynamicStates;
          this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
          this.cmdPackage.cmds.push(WebGL2Cmd.BIND_STATES);
          this._isStateInvalied = false;
        };

        return WebGL2CommandBuffer;
      }(CommandBuffer);

      var WebGL2Framebuffer = function (_Framebuffer) {
        _inheritsLoose(WebGL2Framebuffer, _Framebuffer);

        function WebGL2Framebuffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Framebuffer.call.apply(_Framebuffer, [this].concat(args)) || this;
          _this._gpuFramebuffer = null;
          return _this;
        }

        var _proto = WebGL2Framebuffer.prototype;

        _proto.initialize = function initialize(info) {
          this._renderPass = info.renderPass;
          this._colorTextures = info.colorTextures || [];
          this._depthStencilTexture = info.depthStencilTexture || null;
          var gpuColorViews = [];

          for (var i = 0; i < info.colorTextures.length; i++) {
            var colorTexture = info.colorTextures[i];

            if (colorTexture) {
              gpuColorViews.push(colorTexture.gpuTextureView);
            }
          }

          var gpuDepthStencilView = null;

          if (info.depthStencilTexture) {
            gpuDepthStencilView = info.depthStencilTexture.gpuTextureView;
          }

          var width = Number.MAX_SAFE_INTEGER;
          this._gpuFramebuffer = {
            gpuRenderPass: info.renderPass.gpuRenderPass,
            gpuColorViews: gpuColorViews,
            gpuDepthStencilView: gpuDepthStencilView,
            glFramebuffer: null,
            isOffscreen: true,

            get width() {
              if (this.isOffscreen) {
                return width;
              } else if (this.gpuColorViews.length > 0) {
                return this.gpuColorViews[0].gpuTexture.width;
              } else {
                return this.gpuDepthStencilView.gpuTexture.width;
              }
            },

            set width(val) {
              width = val;
            },

            get height() {
              if (this.isOffscreen) {
                return width;
              } else if (this.gpuColorViews.length > 0) {
                return this.gpuColorViews[0].gpuTexture.height;
              } else {
                return this.gpuDepthStencilView.gpuTexture.height;
              }
            },

            set height(val) {
            }

          };
          WebGL2CmdFuncCreateFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
        };

        _proto.destroy = function destroy() {
          if (this._gpuFramebuffer) {
            WebGL2CmdFuncDestroyFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
            this._gpuFramebuffer = null;
          }
        };

        _createClass(WebGL2Framebuffer, [{
          key: "gpuFramebuffer",
          get: function get() {
            return this._gpuFramebuffer;
          }
        }]);

        return WebGL2Framebuffer;
      }(Framebuffer);

      var WebGL2InputAssembler = function (_InputAssembler) {
        _inheritsLoose(WebGL2InputAssembler, _InputAssembler);

        function WebGL2InputAssembler() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _InputAssembler.call.apply(_InputAssembler, [this].concat(args)) || this;
          _this._gpuInputAssembler = null;
          return _this;
        }

        var _proto = WebGL2InputAssembler.prototype;

        _proto.initialize = function initialize(info) {
          if (info.vertexBuffers.length === 0) {
            console.error('InputAssemblerInfo.vertexBuffers is null.');
            return;
          }

          this._attributes = info.attributes;
          this._attributesHash = this.computeAttributesHash();
          this._vertexBuffers = info.vertexBuffers;

          if (info.indexBuffer) {
            this._indexBuffer = info.indexBuffer;
            this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
            this._drawInfo.firstIndex = 0;
          } else {
            var vertBuff = this._vertexBuffers[0];
            this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
            this._drawInfo.firstVertex = 0;
            this._drawInfo.vertexOffset = 0;
          }

          this._drawInfo.instanceCount = 0;
          this._drawInfo.firstInstance = 0;
          this._indirectBuffer = info.indirectBuffer || null;
          var gpuVertexBuffers = new Array(info.vertexBuffers.length);

          for (var i = 0; i < info.vertexBuffers.length; ++i) {
            var vb = info.vertexBuffers[i];

            if (vb.gpuBuffer) {
              gpuVertexBuffers[i] = vb.gpuBuffer;
            }
          }

          var gpuIndexBuffer = null;
          var glIndexType = 0;

          if (info.indexBuffer) {
            gpuIndexBuffer = info.indexBuffer.gpuBuffer;

            if (gpuIndexBuffer) {
              switch (gpuIndexBuffer.stride) {
                case 1:
                  glIndexType = 0x1401;
                  break;

                case 2:
                  glIndexType = 0x1403;
                  break;

                case 4:
                  glIndexType = 0x1405;
                  break;

                default:
                  {
                    console.error('Illegal index buffer stride.');
                  }
              }
            }
          }

          var gpuIndirectBuffer = null;

          if (info.indirectBuffer) {
            gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
          }

          this._gpuInputAssembler = {
            attributes: info.attributes,
            gpuVertexBuffers: gpuVertexBuffers,
            gpuIndexBuffer: gpuIndexBuffer,
            gpuIndirectBuffer: gpuIndirectBuffer,
            glAttribs: [],
            glIndexType: glIndexType,
            glVAOs: new Map()
          };
          WebGL2CmdFuncCreateInputAssember(WebGL2DeviceManager.instance, this._gpuInputAssembler);
        };

        _proto.destroy = function destroy() {
          var device = WebGL2DeviceManager.instance;

          if (this._gpuInputAssembler && device.extensions.useVAO) {
            WebGL2CmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
          }

          this._gpuInputAssembler = null;
        };

        _createClass(WebGL2InputAssembler, [{
          key: "gpuInputAssembler",
          get: function get() {
            return this._gpuInputAssembler;
          }
        }]);

        return WebGL2InputAssembler;
      }(InputAssembler);

      var WebGL2DescriptorSetLayout = function (_DescriptorSetLayout) {
        _inheritsLoose(WebGL2DescriptorSetLayout, _DescriptorSetLayout);

        function WebGL2DescriptorSetLayout() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _DescriptorSetLayout.call.apply(_DescriptorSetLayout, [this].concat(args)) || this;
          _this._gpuDescriptorSetLayout = null;
          return _this;
        }

        var _proto = WebGL2DescriptorSetLayout.prototype;

        _proto.initialize = function initialize(info) {
          Array.prototype.push.apply(this._bindings, info.bindings);
          var descriptorCount = 0;
          var maxBinding = -1;
          var flattenedIndices = [];

          for (var i = 0; i < this._bindings.length; i++) {
            var binding = this._bindings[i];
            flattenedIndices.push(descriptorCount);
            descriptorCount += binding.count;
            if (binding.binding > maxBinding) maxBinding = binding.binding;
          }

          this._bindingIndices = Array(maxBinding + 1).fill(-1);
          var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

          for (var _i = 0; _i < this._bindings.length; _i++) {
            var _binding = this._bindings[_i];
            this._bindingIndices[_binding.binding] = _i;
            descriptorIndices[_binding.binding] = flattenedIndices[_i];
          }

          var dynamicBindings = [];

          for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
            var _binding2 = this._bindings[_i2];

            if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
              for (var j = 0; j < _binding2.count; j++) {
                dynamicBindings.push(_binding2.binding);
              }
            }
          }

          this._gpuDescriptorSetLayout = {
            bindings: this._bindings,
            dynamicBindings: dynamicBindings,
            descriptorIndices: descriptorIndices,
            descriptorCount: descriptorCount
          };
        };

        _proto.destroy = function destroy() {
          this._bindings.length = 0;
        };

        _createClass(WebGL2DescriptorSetLayout, [{
          key: "gpuDescriptorSetLayout",
          get: function get() {
            return this._gpuDescriptorSetLayout;
          }
        }]);

        return WebGL2DescriptorSetLayout;
      }(DescriptorSetLayout);

      var WebGL2PipelineLayout = function (_PipelineLayout) {
        _inheritsLoose(WebGL2PipelineLayout, _PipelineLayout);

        function WebGL2PipelineLayout() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineLayout.call.apply(_PipelineLayout, [this].concat(args)) || this;
          _this._gpuPipelineLayout = null;
          return _this;
        }

        var _proto = WebGL2PipelineLayout.prototype;

        _proto.initialize = function initialize(info) {
          Array.prototype.push.apply(this._setLayouts, info.setLayouts);
          var dynamicOffsetIndices = [];
          var gpuSetLayouts = [];
          var dynamicOffsetCount = 0;
          var dynamicOffsetOffsets = [];

          for (var i = 0; i < this._setLayouts.length; i++) {
            var setLayout = this._setLayouts[i];
            var dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
            var indices = Array(setLayout.bindingIndices.length).fill(-1);

            for (var j = 0; j < dynamicBindings.length; j++) {
              var binding = dynamicBindings[j];
              if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
            }

            gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
            dynamicOffsetIndices.push(indices);
            dynamicOffsetOffsets.push(dynamicOffsetCount);
            dynamicOffsetCount += dynamicBindings.length;
          }

          this._gpuPipelineLayout = {
            gpuSetLayouts: gpuSetLayouts,
            dynamicOffsetIndices: dynamicOffsetIndices,
            dynamicOffsetCount: dynamicOffsetCount,
            dynamicOffsetOffsets: dynamicOffsetOffsets
          };
        };

        _proto.destroy = function destroy() {
          this._setLayouts.length = 0;
        };

        _createClass(WebGL2PipelineLayout, [{
          key: "gpuPipelineLayout",
          get: function get() {
            return this._gpuPipelineLayout;
          }
        }]);

        return WebGL2PipelineLayout;
      }(PipelineLayout);

      var WebGLPrimitives$1 = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
      var WebGL2PipelineState = function (_PipelineState) {
        _inheritsLoose(WebGL2PipelineState, _PipelineState);

        function WebGL2PipelineState() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineState.call.apply(_PipelineState, [this].concat(args)) || this;
          _this._gpuPipelineState = null;
          return _this;
        }

        var _proto = WebGL2PipelineState.prototype;

        _proto.initialize = function initialize(info) {
          this._primitive = info.primitive;
          this._shader = info.shader;
          this._pipelineLayout = info.pipelineLayout;
          var bs = this._bs;

          if (info.blendState) {
            var bsInfo = info.blendState;
            var targets = bsInfo.targets;

            if (targets) {
              targets.forEach(function (t, i) {
                bs.setTarget(i, t);
              });
            }

            if (bsInfo.isA2C !== undefined) {
              bs.isA2C = bsInfo.isA2C;
            }

            if (bsInfo.isIndepend !== undefined) {
              bs.isIndepend = bsInfo.isIndepend;
            }

            if (bsInfo.blendColor !== undefined) {
              bs.blendColor = bsInfo.blendColor;
            }
          }

          Object.assign(this._rs, info.rasterizerState);
          Object.assign(this._dss, info.depthStencilState);
          this._is = info.inputState;
          this._renderPass = info.renderPass;
          this._dynamicStates = info.dynamicStates;
          var dynamicStates = [];

          for (var i = 0; i < 31; i++) {
            if (this._dynamicStates & 1 << i) {
              dynamicStates.push(1 << i);
            }
          }

          this._gpuPipelineState = {
            glPrimitive: WebGLPrimitives$1[info.primitive],
            gpuShader: info.shader.gpuShader,
            gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
            rs: info.rasterizerState,
            dss: info.depthStencilState,
            bs: info.blendState,
            gpuRenderPass: info.renderPass.gpuRenderPass,
            dynamicStates: dynamicStates
          };
        };

        _proto.destroy = function destroy() {
          this._gpuPipelineState = null;
        };

        _createClass(WebGL2PipelineState, [{
          key: "gpuPipelineState",
          get: function get() {
            return this._gpuPipelineState;
          }
        }]);

        return WebGL2PipelineState;
      }(PipelineState);

      var WebGL2PrimaryCommandBuffer = function (_WebGL2CommandBuffer) {
        _inheritsLoose(WebGL2PrimaryCommandBuffer, _WebGL2CommandBuffer);

        function WebGL2PrimaryCommandBuffer() {
          return _WebGL2CommandBuffer.apply(this, arguments) || this;
        }

        var _proto = WebGL2PrimaryCommandBuffer.prototype;

        _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          WebGL2CmdFuncBeginRenderPass(WebGL2DeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
          this._isInRenderPass = true;
        };

        _proto.draw = function draw(infoOrAssembler) {
          if (this._isInRenderPass) {
            if (this._isStateInvalied) {
              this.bindStates();
            }

            var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
            WebGL2CmdFuncDraw(WebGL2DeviceManager.instance, info);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            var indexCount = info.indexCount || info.vertexCount;

            if (this._curGPUPipelineState) {
              var glPrimitive = this._curGPUPipelineState.glPrimitive;

              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }

                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        };

        _proto.setViewport = function setViewport(viewport) {
          var _WebGL2DeviceManager$ = WebGL2DeviceManager.instance,
              cache = _WebGL2DeviceManager$.stateCache,
              gl = _WebGL2DeviceManager$.gl;

          if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
            gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
            cache.viewport.left = viewport.left;
            cache.viewport.top = viewport.top;
            cache.viewport.width = viewport.width;
            cache.viewport.height = viewport.height;
          }
        };

        _proto.setScissor = function setScissor(scissor) {
          var _WebGL2DeviceManager$2 = WebGL2DeviceManager.instance,
              cache = _WebGL2DeviceManager$2.stateCache,
              gl = _WebGL2DeviceManager$2.gl;

          if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
            gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
            cache.scissorRect.x = scissor.x;
            cache.scissorRect.y = scissor.y;
            cache.scissorRect.width = scissor.width;
            cache.scissorRect.height = scissor.height;
          }
        };

        _proto.updateBuffer = function updateBuffer(buffer, data, size) {
          if (!this._isInRenderPass) {
            var gpuBuffer = buffer.gpuBuffer;

            if (gpuBuffer) {
              var buffSize;

              if (size !== undefined) {
                buffSize = size;
              } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                buffSize = 0;
              } else {
                buffSize = data.byteLength;
              }

              WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, gpuBuffer, data, 0, buffSize);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          if (!this._isInRenderPass) {
            var gpuTexture = texture.gpuTexture;

            if (gpuTexture) {
              WebGL2CmdFuncCopyBuffersToTexture(WebGL2DeviceManager.instance, buffers, gpuTexture, regions);
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        };

        _proto.execute = function execute(cmdBuffs, count) {
          for (var i = 0; i < count; ++i) {
            var webGL2CmdBuff = cmdBuffs[i];
            WebGL2CmdFuncExecuteCmds(WebGL2DeviceManager.instance, webGL2CmdBuff.cmdPackage);
            this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
            this._numInstances += webGL2CmdBuff._numInstances;
            this._numTris += webGL2CmdBuff._numTris;
          }
        };

        _proto.bindStates = function bindStates() {
          WebGL2CmdFuncBindStates(WebGL2DeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
          this._isStateInvalied = false;
        };

        return WebGL2PrimaryCommandBuffer;
      }(WebGL2CommandBuffer);

      var WebGL2Queue = function (_Queue) {
        _inheritsLoose(WebGL2Queue, _Queue);

        function WebGL2Queue() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Queue.call.apply(_Queue, [this].concat(args)) || this;
          _this.numDrawCalls = 0;
          _this.numInstances = 0;
          _this.numTris = 0;
          return _this;
        }

        var _proto = WebGL2Queue.prototype;

        _proto.initialize = function initialize(info) {
          this._type = info.type;
        };

        _proto.destroy = function destroy() {};

        _proto.submit = function submit(cmdBuffs) {
          for (var i = 0; i < cmdBuffs.length; i++) {
            var cmdBuff = cmdBuffs[i];
            this.numDrawCalls += cmdBuff.numDrawCalls;
            this.numInstances += cmdBuff.numInstances;
            this.numTris += cmdBuff.numTris;
          }
        };

        _proto.clear = function clear() {
          this.numDrawCalls = 0;
          this.numInstances = 0;
          this.numTris = 0;
        };

        return WebGL2Queue;
      }(Queue);

      var WebGL2RenderPass = function (_RenderPass) {
        _inheritsLoose(WebGL2RenderPass, _RenderPass);

        function WebGL2RenderPass() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
          _this._gpuRenderPass = null;
          return _this;
        }

        var _proto = WebGL2RenderPass.prototype;

        _proto.initialize = function initialize(info) {
          this._colorInfos = info.colorAttachments;
          this._depthStencilInfo = info.depthStencilAttachment;
          this._subpasses = info.subpasses;
          this._gpuRenderPass = {
            colorAttachments: this._colorInfos,
            depthStencilAttachment: this._depthStencilInfo
          };
          this._hash = this.computeHash();
        };

        _proto.destroy = function destroy() {
          this._gpuRenderPass = null;
        };

        _createClass(WebGL2RenderPass, [{
          key: "gpuRenderPass",
          get: function get() {
            return this._gpuRenderPass;
          }
        }]);

        return WebGL2RenderPass;
      }(RenderPass);

      var WebGL2Sampler = function (_Sampler) {
        _inheritsLoose(WebGL2Sampler, _Sampler);

        function WebGL2Sampler(info, hash) {
          var _this;

          _this = _Sampler.call(this, info, hash) || this;
          _this._gpuSampler = null;
          _this._gpuSampler = {
            glSamplers: new Map(),
            minFilter: _this._info.minFilter,
            magFilter: _this._info.magFilter,
            mipFilter: _this._info.mipFilter,
            addressU: _this._info.addressU,
            addressV: _this._info.addressV,
            addressW: _this._info.addressW,
            glMinFilter: 0,
            glMagFilter: 0,
            glWrapS: 0,
            glWrapT: 0,
            glWrapR: 0,
            getGLSampler: function getGLSampler(device, minLod, maxLod) {
              var gl = device.gl;
              var samplerHash = minLod << 16 | maxLod;

              if (!this.glSamplers.has(samplerHash)) {
                var glSampler = gl.createSampler();

                if (glSampler) {
                  this.glSamplers.set(samplerHash, glSampler);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, this.glWrapS);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, this.glWrapT);
                  gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, this.glWrapR);
                  gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, minLod);
                  gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, maxLod);
                }
              }

              var sampler = this.glSamplers.get(samplerHash);
              return sampler;
            }
          };
          WebGL2CmdFuncPrepareSamplerInfo(WebGL2DeviceManager.instance, _this._gpuSampler);
          return _this;
        }

        var _proto = WebGL2Sampler.prototype;

        _proto.destroy = function destroy() {
          if (this._gpuSampler) {
            WebGL2CmdFuncDestroySampler(WebGL2DeviceManager.instance, this._gpuSampler);
            this._gpuSampler = null;
          }
        };

        _createClass(WebGL2Sampler, [{
          key: "gpuSampler",
          get: function get() {
            return this._gpuSampler;
          }
        }]);

        return WebGL2Sampler;
      }(Sampler);

      var WebGL2Shader = function (_Shader) {
        _inheritsLoose(WebGL2Shader, _Shader);

        function WebGL2Shader() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Shader.call.apply(_Shader, [this].concat(args)) || this;
          _this._gpuShader = null;
          return _this;
        }

        var _proto = WebGL2Shader.prototype;

        _proto.initialize = function initialize(info) {
          this._name = info.name;
          this._stages = info.stages;
          this._attributes = info.attributes;
          this._blocks = info.blocks;
          this._samplers = info.samplers;
          this._gpuShader = {
            name: info.name,
            blocks: info.blocks.slice(),
            samplerTextures: info.samplerTextures.slice(),
            subpassInputs: info.subpassInputs.slice(),
            gpuStages: new Array(info.stages.length),
            glProgram: null,
            glInputs: [],
            glUniforms: [],
            glBlocks: [],
            glSamplerTextures: []
          };

          for (var i = 0; i < info.stages.length; ++i) {
            var stage = info.stages[i];
            this._gpuShader.gpuStages[i] = {
              type: stage.stage,
              source: stage.source,
              glShader: null
            };
          }
        };

        _proto.destroy = function destroy() {
          if (this._gpuShader) {
            WebGL2CmdFuncDestroyShader(WebGL2DeviceManager.instance, this._gpuShader);
            this._gpuShader = null;
          }
        };

        _createClass(WebGL2Shader, [{
          key: "gpuShader",
          get: function get() {
            if (this._gpuShader.glProgram === null) {
              WebGL2CmdFuncCreateShader(WebGL2DeviceManager.instance, this._gpuShader);
            }

            return this._gpuShader;
          }
        }]);

        return WebGL2Shader;
      }(Shader);

      var WebGL2StateCache = function () {
        function WebGL2StateCache() {
          this.glArrayBuffer = null;
          this.glElementArrayBuffer = null;
          this.glUniformBuffer = null;
          this.glBindUBOs = [];
          this.glBindUBOOffsets = [];
          this.glVAO = null;
          this.texUnit = 0;
          this.glTexUnits = [];
          this.glSamplerUnits = [];
          this.glRenderbuffer = null;
          this.glFramebuffer = null;
          this.glReadFramebuffer = null;
          this.viewport = new Viewport();
          this.scissorRect = new Rect$1(0, 0, 0, 0);
          this.rs = new RasterizerState();
          this.dss = new DepthStencilState();
          this.bs = new BlendState();
          this.glProgram = null;
          this.glEnabledAttribLocs = [];
          this.glCurrentAttribLocs = [];
          this.texUnitCacheMap = {};
        }

        var _proto = WebGL2StateCache.prototype;

        _proto.initialize = function initialize(texUnit, bufferBindings, vertexAttributes) {
          for (var i = 0; i < texUnit; ++i) {
            this.glTexUnits.push({
              glTexture: null
            });
          }

          this.glSamplerUnits.length = texUnit;
          this.glSamplerUnits.fill(null);
          this.glBindUBOs.length = bufferBindings;
          this.glBindUBOs.fill(null);
          this.glBindUBOOffsets.length = bufferBindings;
          this.glBindUBOOffsets.fill(0);
          this.glEnabledAttribLocs.length = vertexAttributes;
          this.glEnabledAttribLocs.fill(false);
          this.glCurrentAttribLocs.length = vertexAttributes;
          this.glCurrentAttribLocs.fill(false);
        };

        return WebGL2StateCache;
      }();

      var WebGL2Texture = function (_Texture) {
        _inheritsLoose(WebGL2Texture, _Texture);

        function WebGL2Texture() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Texture.call.apply(_Texture, [this].concat(args)) || this;
          _this._gpuTexture = null;
          _this._gpuTextureView = null;
          return _this;
        }

        var _proto = WebGL2Texture.prototype;

        _proto.initialize = function initialize(info, isSwapchainTexture) {
          var texInfo = info;
          var viewInfo = info;

          if ('texture' in info) {
            texInfo = viewInfo.texture.info;
            this._isTextureView = true;
          }

          this._info.copy(texInfo);

          this._isPowerOf2 = IsPowerOf2(this._info.width) && IsPowerOf2(this._info.height);
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

          if (!this._isTextureView) {
            this._gpuTexture = {
              type: texInfo.type,
              format: texInfo.format,
              usage: texInfo.usage,
              width: texInfo.width,
              height: texInfo.height,
              depth: texInfo.depth,
              size: this._size,
              arrayLayer: texInfo.layerCount,
              mipLevel: texInfo.levelCount,
              samples: texInfo.samples,
              flags: texInfo.flags,
              isPowerOf2: this._isPowerOf2,
              glTarget: 0,
              glInternalFmt: 0,
              glFormat: 0,
              glType: 0,
              glUsage: 0,
              glTexture: null,
              glRenderbuffer: null,
              glWrapS: 0,
              glWrapT: 0,
              glMinFilter: 0,
              glMagFilter: 0,
              isSwapchainTexture: isSwapchainTexture || false
            };
            WebGL2CmdFuncCreateTexture(WebGL2DeviceManager.instance, this._gpuTexture);
            WebGL2DeviceManager.instance.memoryStatus.textureSize += this._size;
            this._viewInfo.texture = this;
            this._viewInfo.type = info.type;
            this._viewInfo.format = info.format;
            this._viewInfo.baseLevel = 0;
            this._viewInfo.levelCount = info.levelCount;
            this._viewInfo.baseLayer = 0;
            this._viewInfo.layerCount = info.layerCount;
            this._gpuTextureView = {
              gpuTexture: this._gpuTexture,
              type: this._viewInfo.type,
              format: this._viewInfo.format,
              baseLevel: this._viewInfo.baseLevel,
              levelCount: this._viewInfo.levelCount
            };
          } else {
            var _this$_gpuTexture;

            this._viewInfo.copy(viewInfo);

            this._gpuTexture = viewInfo.texture._gpuTexture;

            if (((_this$_gpuTexture = this._gpuTexture) === null || _this$_gpuTexture === void 0 ? void 0 : _this$_gpuTexture.format) !== texInfo.format) {
              console.log('GPU memory alias is not supported');
              return;
            }

            this._gpuTextureView = {
              gpuTexture: this._gpuTexture,
              type: viewInfo.type,
              format: viewInfo.format,
              baseLevel: viewInfo.baseLevel,
              levelCount: viewInfo.levelCount
            };
          }
        };

        _proto.destroy = function destroy() {
          if (!this._isTextureView && this._gpuTexture) {
            WebGL2CmdFuncDestroyTexture(WebGL2DeviceManager.instance, this._gpuTexture);
            WebGL2DeviceManager.instance.memoryStatus.textureSize -= this._size;
            this._gpuTexture = null;
          }
        };

        _proto.resize = function resize(width, height) {
          if (this._info.width === width && this._info.height === height) {
            return;
          }

          if (this._info.levelCount === WebGL2Texture.getLevelCount(this._info.width, this._info.height)) {
            this._info.levelCount = WebGL2Texture.getLevelCount(width, height);
          } else if (this._info.levelCount > 1) {
            this._info.levelCount = Math.min(this._info.levelCount, WebGL2Texture.getLevelCount(width, height));
          }

          var oldSize = this._size;
          this._info.width = width;
          this._info.height = height;
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

          if (!this._isTextureView && this._gpuTexture) {
            this._gpuTexture.width = width;
            this._gpuTexture.height = height;
            this._gpuTexture.size = this._size;
            WebGL2CmdFuncResizeTexture(WebGL2DeviceManager.instance, this._gpuTexture);
            WebGL2DeviceManager.instance.memoryStatus.textureSize -= oldSize;
            WebGL2DeviceManager.instance.memoryStatus.textureSize += this._size;
          }
        };

        _proto.initAsSwapchainTexture = function initAsSwapchainTexture(info) {
          var texInfo = new TextureInfo();
          texInfo.format = info.format;
          texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
          texInfo.width = info.width;
          texInfo.height = info.height;
          this.initialize(texInfo, true);
        };

        _createClass(WebGL2Texture, [{
          key: "gpuTexture",
          get: function get() {
            return this._gpuTexture;
          }
        }, {
          key: "gpuTextureView",
          get: function get() {
            return this._gpuTextureView;
          }
        }]);

        return WebGL2Texture;
      }(Texture);

      var eventWebGLContextLost$1 = 'webglcontextlost';

      function initStates$1(gl) {
        gl.activeTexture(gl.TEXTURE0);
        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.enable(gl.SCISSOR_TEST);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.frontFace(gl.CCW);
        gl.polygonOffset(0.0, 0.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.BACK, 0xffff);
        gl.disable(gl.STENCIL_TEST);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        gl.disable(gl.BLEND);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.colorMask(true, true, true, true);
        gl.blendColor(0.0, 0.0, 0.0, 0.0);
      }

      function getExtension$1(gl, ext) {
        var prefixes = ['', 'WEBKIT_', 'MOZ_'];

        for (var i = 0; i < prefixes.length; ++i) {
          var _ext = gl.getExtension(prefixes[i] + ext);

          if (_ext) {
            return _ext;
          }
        }

        return null;
      }

      function getExtensions$1(gl) {
        var res = {
          EXT_texture_filter_anisotropic: getExtension$1(gl, 'EXT_texture_filter_anisotropic'),
          EXT_color_buffer_half_float: getExtension$1(gl, 'EXT_color_buffer_half_float'),
          EXT_color_buffer_float: getExtension$1(gl, 'EXT_color_buffer_float'),
          WEBGL_compressed_texture_etc1: getExtension$1(gl, 'WEBGL_compressed_texture_etc1'),
          WEBGL_compressed_texture_etc: getExtension$1(gl, 'WEBGL_compressed_texture_etc'),
          WEBGL_compressed_texture_pvrtc: getExtension$1(gl, 'WEBGL_compressed_texture_pvrtc'),
          WEBGL_compressed_texture_astc: getExtension$1(gl, 'WEBGL_compressed_texture_astc'),
          WEBGL_compressed_texture_s3tc: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc'),
          WEBGL_compressed_texture_s3tc_srgb: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
          WEBGL_debug_shaders: getExtension$1(gl, 'WEBGL_debug_shaders'),
          WEBGL_lose_context: getExtension$1(gl, 'WEBGL_lose_context'),
          WEBGL_debug_renderer_info: getExtension$1(gl, 'WEBGL_debug_renderer_info'),
          OES_texture_half_float_linear: getExtension$1(gl, 'OES_texture_half_float_linear'),
          OES_texture_float_linear: getExtension$1(gl, 'OES_texture_float_linear'),
          WEBGL_multi_draw: null,
          useVAO: true
        };
        {
          if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
            res.WEBGL_multi_draw = getExtension$1(gl, 'WEBGL_multi_draw');
          }
        }
        return res;
      }
      function getContext$1(canvas) {
        var context = null;

        try {
          var webGLCtxAttribs = {
            alpha: macro.ENABLE_TRANSPARENT_CANVAS,
            antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
            depth: true,
            stencil: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'default',
            failIfMajorPerformanceCaveat: false
          };
          context = canvas.getContext('webgl2', webGLCtxAttribs);
        } catch (err) {
          return null;
        }

        return context;
      }
      var WebGL2Swapchain = function (_Swapchain) {
        _inheritsLoose(WebGL2Swapchain, _Swapchain);

        function WebGL2Swapchain() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Swapchain.call.apply(_Swapchain, [this].concat(args)) || this;
          _this.stateCache = new WebGL2StateCache();
          _this.nullTex2D = null;
          _this.nullTexCube = null;
          _this._canvas = null;
          _this._webGL2ContextLostHandler = null;
          _this._extensions = null;
          return _this;
        }

        var _proto = WebGL2Swapchain.prototype;

        _proto.initialize = function initialize(info) {
          this._canvas = info.windowHandle;
          this._webGL2ContextLostHandler = this._onWebGLContextLost.bind(this);

          this._canvas.addEventListener(eventWebGLContextLost$1, this._onWebGLContextLost);

          var gl = WebGL2DeviceManager.instance.gl;
          this.stateCache.initialize(WebGL2DeviceManager.instance.capabilities.maxTextureUnits, WebGL2DeviceManager.instance.capabilities.maxUniformBufferBindings, WebGL2DeviceManager.instance.capabilities.maxVertexAttributes);
          this._extensions = getExtensions$1(gl);
          initStates$1(gl);
          var colorFmt = Format.RGBA8;
          var depthStencilFmt = Format.DEPTH_STENCIL;
          var depthBits = gl.getParameter(gl.DEPTH_BITS);
          var stencilBits = gl.getParameter(gl.STENCIL_BITS);
          if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
          this._colorTexture = new WebGL2Texture();

          this._colorTexture.initAsSwapchainTexture({
            swapchain: this,
            format: colorFmt,
            width: info.width,
            height: info.height
          });

          this._depthStencilTexture = new WebGL2Texture();

          this._depthStencilTexture.initAsSwapchainTexture({
            swapchain: this,
            format: depthStencilFmt,
            width: info.width,
            height: info.height
          });

          this.nullTex2D = WebGL2DeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE));
          this.nullTexCube = WebGL2DeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE, 6));
          var nullTexRegion = new BufferTextureCopy();
          nullTexRegion.texExtent.width = 2;
          nullTexRegion.texExtent.height = 2;
          var nullTexBuff = new Uint8Array(this.nullTex2D.size);
          nullTexBuff.fill(0);
          WebGL2DeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
          nullTexRegion.texSubres.layerCount = 6;
          WebGL2DeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
        };

        _proto.destroy = function destroy() {
          if (this._canvas && this._webGL2ContextLostHandler) {
            this._canvas.removeEventListener(eventWebGLContextLost$1, this._webGL2ContextLostHandler);

            this._webGL2ContextLostHandler = null;
          }

          if (this.nullTex2D) {
            this.nullTex2D.destroy();
            this.nullTex2D = null;
          }

          if (this.nullTexCube) {
            this.nullTexCube.destroy();
            this.nullTexCube = null;
          }

          this._extensions = null;
          this._canvas = null;
        };

        _proto.resize = function resize(width, height, surfaceTransform) {
          if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
            debug("Resizing swapchain: " + width + "x" + height);
            this._canvas.width = width;
            this._canvas.height = height;

            this._colorTexture.resize(width, height);

            this._depthStencilTexture.resize(width, height);
          }
        };

        _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
          warnID(11000);
          warn(event);
        };

        _createClass(WebGL2Swapchain, [{
          key: "extensions",
          get: function get() {
            return this._extensions;
          }
        }]);

        return WebGL2Swapchain;
      }(Swapchain);

      var WebGL2Device = exports('WebGL2Device', function (_Device) {
        _inheritsLoose(WebGL2Device, _Device);

        function WebGL2Device() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Device.call.apply(_Device, [this].concat(args)) || this;
          _this._swapchain = null;
          _this._context = null;
          _this._bindingMappings = null;
          _this._textureExclusive = new Array(Format.COUNT);
          return _this;
        }

        var _proto = WebGL2Device.prototype;

        _proto.initialize = function initialize(info) {
          WebGL2DeviceManager.setInstance(this);
          this._gfxAPI = API.WEBGL2;
          var mapping = this._bindingMappingInfo = info.bindingMappingInfo;
          var blockOffsets = [];
          var samplerTextureOffsets = [];
          var firstSet = mapping.setIndices[0];
          blockOffsets[firstSet] = 0;
          samplerTextureOffsets[firstSet] = 0;

          for (var i = 1; i < mapping.setIndices.length; ++i) {
            var curSet = mapping.setIndices[i];
            var prevSet = mapping.setIndices[i - 1];
            blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
            samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
          }

          for (var _i = 0; _i < mapping.setIndices.length; ++_i) {
            var _curSet = mapping.setIndices[_i];
            samplerTextureOffsets[_curSet] -= mapping.maxBlockCounts[_curSet];
          }

          this._bindingMappings = {
            blockOffsets: blockOffsets,
            samplerTextureOffsets: samplerTextureOffsets,
            flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
          };
          var gl = this._context = getContext$1(Device.canvas);

          if (!gl) {
            console.error('This device does not support WebGL.');
            return false;
          }

          this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
          this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
          this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
          this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
          this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
          this._caps.maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
          this._caps.maxUniformBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE);
          this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
          this._caps.uboOffsetAlignment = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
          var extensions = gl.getSupportedExtensions();
          var extStr = '';

          if (extensions) {
            for (var _iterator = _createForOfIteratorHelperLoose(extensions), _step; !(_step = _iterator()).done;) {
              var ext = _step.value;
              extStr += ext + " ";
            }
          }

          var exts = getExtensions$1(gl);

          if (exts.WEBGL_debug_renderer_info) {
            this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
            this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
          } else {
            this._renderer = gl.getParameter(gl.RENDERER);
            this._vendor = gl.getParameter(gl.VENDOR);
          }

          var version = gl.getParameter(gl.VERSION);

          this._features.fill(false);

          this.initFormatFeatures(exts);
          this._features[Feature.ELEMENT_INDEX_UINT] = true;
          this._features[Feature.INSTANCED_ARRAYS] = true;
          this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
          this._features[Feature.BLEND_MINMAX] = true;
          var compressedFormat = '';

          if (this.getFormatFeatures(Format.ETC_RGB8)) {
            compressedFormat += 'etc1 ';
          }

          if (this.getFormatFeatures(Format.ETC2_RGB8)) {
            compressedFormat += 'etc2 ';
          }

          if (this.getFormatFeatures(Format.BC1)) {
            compressedFormat += 'dxt ';
          }

          if (this.getFormatFeatures(Format.PVRTC_RGB2)) {
            compressedFormat += 'pvrtc ';
          }

          if (this.getFormatFeatures(Format.ASTC_RGBA_4X4)) {
            compressedFormat += 'astc ';
          }

          debug('WebGL2 device initialized.');
          debug("RENDERER: " + this._renderer);
          debug("VENDOR: " + this._vendor);
          debug("VERSION: " + version);
          debug("COMPRESSED_FORMAT: " + compressedFormat);
          debug("EXTENSIONS: " + extStr);
          return true;
        };

        _proto.destroy = function destroy() {
          if (this._queue) {
            this._queue.destroy();

            this._queue = null;
          }

          if (this._cmdBuff) {
            this._cmdBuff.destroy();

            this._cmdBuff = null;
          }

          var it = this._samplers.values();

          var res = it.next();

          while (!res.done) {
            res.value.destroy();
            res = it.next();
          }

          this._swapchain = null;
        };

        _proto.flushCommands = function flushCommands(cmdBuffs) {};

        _proto.acquire = function acquire(swapchains) {};

        _proto.present = function present() {
          var queue = this._queue;
          this._numDrawCalls = queue.numDrawCalls;
          this._numInstances = queue.numInstances;
          this._numTris = queue.numTris;
          queue.clear();
        };

        _proto.initFormatFeatures = function initFormatFeatures(exts) {
          this._formatFeatures.fill(FormatFeatureBit.NONE);

          this._textureExclusive.fill(true);

          var tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.LINEAR_FILTER | FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8] = tempFeature;
          this._formatFeatures[Format.RG8] = tempFeature;
          this._formatFeatures[Format.RGB8] = tempFeature;
          this._formatFeatures[Format.RGBA8] = tempFeature;
          tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          this._formatFeatures[Format.R8SN] = tempFeature;
          this._formatFeatures[Format.RG8SN] = tempFeature;
          this._formatFeatures[Format.RGB8SN] = tempFeature;
          this._formatFeatures[Format.RGBA8SN] = tempFeature;
          this._formatFeatures[Format.R5G6B5] = tempFeature;
          this._formatFeatures[Format.RGBA4] = tempFeature;
          this._formatFeatures[Format.RGB5A1] = tempFeature;
          this._formatFeatures[Format.RGB10A2] = tempFeature;
          this._formatFeatures[Format.SRGB8] = tempFeature;
          this._formatFeatures[Format.SRGB8_A8] = tempFeature;
          this._formatFeatures[Format.R11G11B10F] = tempFeature;
          this._formatFeatures[Format.RGB9E5] = tempFeature;
          this._formatFeatures[Format.DEPTH] = tempFeature;
          this._formatFeatures[Format.DEPTH_STENCIL] = tempFeature;
          this._formatFeatures[Format.RGB10A2UI] = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R16F] = tempFeature;
          this._formatFeatures[Format.RG16F] = tempFeature;
          this._formatFeatures[Format.RGB16F] = tempFeature;
          this._formatFeatures[Format.RGBA16F] = tempFeature;
          tempFeature = FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R32F] = tempFeature;
          this._formatFeatures[Format.RG32F] = tempFeature;
          this._formatFeatures[Format.RGB32F] = tempFeature;
          this._formatFeatures[Format.RGBA32F] = tempFeature;
          this._formatFeatures[Format.RGB10A2UI] = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.STORAGE_TEXTURE | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER | FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8I] = tempFeature;
          this._formatFeatures[Format.R8UI] = tempFeature;
          this._formatFeatures[Format.R16I] = tempFeature;
          this._formatFeatures[Format.R16UI] = tempFeature;
          this._formatFeatures[Format.R32I] = tempFeature;
          this._formatFeatures[Format.R32UI] = tempFeature;
          this._formatFeatures[Format.RG8I] = tempFeature;
          this._formatFeatures[Format.RG8UI] = tempFeature;
          this._formatFeatures[Format.RG16I] = tempFeature;
          this._formatFeatures[Format.RG16UI] = tempFeature;
          this._formatFeatures[Format.RG32I] = tempFeature;
          this._formatFeatures[Format.RG32UI] = tempFeature;
          this._formatFeatures[Format.RGB8I] = tempFeature;
          this._formatFeatures[Format.RGB8UI] = tempFeature;
          this._formatFeatures[Format.RGB16I] = tempFeature;
          this._formatFeatures[Format.RGB16UI] = tempFeature;
          this._formatFeatures[Format.RGB32I] = tempFeature;
          this._formatFeatures[Format.RGB32UI] = tempFeature;
          this._formatFeatures[Format.RGBA8I] = tempFeature;
          this._formatFeatures[Format.RGBA8UI] = tempFeature;
          this._formatFeatures[Format.RGBA16I] = tempFeature;
          this._formatFeatures[Format.RGBA16UI] = tempFeature;
          this._formatFeatures[Format.RGBA32I] = tempFeature;
          this._formatFeatures[Format.RGBA32UI] = tempFeature;
          this._textureExclusive[Format.R8] = false;
          this._textureExclusive[Format.RG8] = false;
          this._textureExclusive[Format.RGB8] = false;
          this._textureExclusive[Format.R5G6B5] = false;
          this._textureExclusive[Format.RGBA4] = false;
          this._textureExclusive[Format.RGB5A1] = false;
          this._textureExclusive[Format.RGBA8] = false;
          this._textureExclusive[Format.RGB10A2] = false;
          this._textureExclusive[Format.RGB10A2UI] = false;
          this._textureExclusive[Format.SRGB8_A8] = false;
          this._textureExclusive[Format.R8I] = false;
          this._textureExclusive[Format.R8UI] = false;
          this._textureExclusive[Format.R16I] = false;
          this._textureExclusive[Format.R16UI] = false;
          this._textureExclusive[Format.R32I] = false;
          this._textureExclusive[Format.R32UI] = false;
          this._textureExclusive[Format.RG8I] = false;
          this._textureExclusive[Format.RG8UI] = false;
          this._textureExclusive[Format.RG16I] = false;
          this._textureExclusive[Format.RG16UI] = false;
          this._textureExclusive[Format.RG32I] = false;
          this._textureExclusive[Format.RG32UI] = false;
          this._textureExclusive[Format.RGBA8I] = false;
          this._textureExclusive[Format.RGBA8UI] = false;
          this._textureExclusive[Format.RGBA16I] = false;
          this._textureExclusive[Format.RGBA16UI] = false;
          this._textureExclusive[Format.RGBA32I] = false;
          this._textureExclusive[Format.RGBA32UI] = false;
          this._textureExclusive[Format.DEPTH] = false;
          this._textureExclusive[Format.DEPTH_STENCIL] = false;

          if (exts.EXT_color_buffer_float) {
            this._formatFeatures[Format.R32F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RG32F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET;
            this._textureExclusive[Format.R32F] = false;
            this._textureExclusive[Format.RG32F] = false;
            this._textureExclusive[Format.RGBA32F] = false;
          }

          if (exts.EXT_color_buffer_half_float) {
            this._textureExclusive[Format.R16F] = false;
            this._textureExclusive[Format.RG16F] = false;
            this._textureExclusive[Format.RGBA16F] = false;
          }

          if (exts.OES_texture_float_linear) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.R32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RG32F] |= FormatFeatureBit.LINEAR_FILTER;
          }

          if (exts.OES_texture_half_float_linear) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.R16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RG16F] |= FormatFeatureBit.LINEAR_FILTER;
          }

          var compressedFeature = FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;

          if (exts.WEBGL_compressed_texture_etc1) {
            this._formatFeatures[Format.ETC_RGB8] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_etc) {
            this._formatFeatures[Format.ETC2_RGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGBA8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGB8_A1] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A1] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_s3tc) {
            this._formatFeatures[Format.BC1] = compressedFeature;
            this._formatFeatures[Format.BC1_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC2] = compressedFeature;
            this._formatFeatures[Format.BC2_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC3] = compressedFeature;
            this._formatFeatures[Format.BC3_SRGB] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_pvrtc) {
            this._formatFeatures[Format.PVRTC_RGB2] = compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA2] = compressedFeature;
            this._formatFeatures[Format.PVRTC_RGB4] = compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA4] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_astc) {
            this._formatFeatures[Format.ASTC_RGBA_4X4] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X4] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X8] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X8] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X10] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X10] = compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X12] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_4X4] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X4] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X8] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X5] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X6] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X8] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X10] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X10] = compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X12] = compressedFeature;
          }
        };

        _proto.createCommandBuffer = function createCommandBuffer(info) {
          var Ctor = info.type === CommandBufferType.PRIMARY ? WebGL2PrimaryCommandBuffer : WebGL2CommandBuffer;
          var cmdBuff = new Ctor();
          cmdBuff.initialize(info);
          return cmdBuff;
        };

        _proto.createSwapchain = function createSwapchain(info) {
          var swapchain = new WebGL2Swapchain();
          this._swapchain = swapchain;
          swapchain.initialize(info);
          return swapchain;
        };

        _proto.createBuffer = function createBuffer(info) {
          var buffer = new WebGL2Buffer();
          buffer.initialize(info);
          return buffer;
        };

        _proto.createTexture = function createTexture(info) {
          var texture = new WebGL2Texture();
          texture.initialize(info);
          return texture;
        };

        _proto.createDescriptorSet = function createDescriptorSet(info) {
          var descriptorSet = new WebGL2DescriptorSet();
          descriptorSet.initialize(info);
          return descriptorSet;
        };

        _proto.createShader = function createShader(info) {
          var shader = new WebGL2Shader();
          shader.initialize(info);
          return shader;
        };

        _proto.createInputAssembler = function createInputAssembler(info) {
          var inputAssembler = new WebGL2InputAssembler();
          inputAssembler.initialize(info);
          return inputAssembler;
        };

        _proto.createRenderPass = function createRenderPass(info) {
          var renderPass = new WebGL2RenderPass();
          renderPass.initialize(info);
          return renderPass;
        };

        _proto.createFramebuffer = function createFramebuffer(info) {
          var framebuffer = new WebGL2Framebuffer();
          framebuffer.initialize(info);
          return framebuffer;
        };

        _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
          var descriptorSetLayout = new WebGL2DescriptorSetLayout();
          descriptorSetLayout.initialize(info);
          return descriptorSetLayout;
        };

        _proto.createPipelineLayout = function createPipelineLayout(info) {
          var pipelineLayout = new WebGL2PipelineLayout();
          pipelineLayout.initialize(info);
          return pipelineLayout;
        };

        _proto.createPipelineState = function createPipelineState(info) {
          var pipelineState = new WebGL2PipelineState();
          pipelineState.initialize(info);
          return pipelineState;
        };

        _proto.createQueue = function createQueue(info) {
          var queue = new WebGL2Queue();
          queue.initialize(info);
          return queue;
        };

        _proto.getSampler = function getSampler(info) {
          var hash = Sampler.computeHash(info);

          if (!this._samplers.has(hash)) {
            this._samplers.set(hash, new WebGL2Sampler(info, hash));
          }

          return this._samplers.get(hash);
        };

        _proto.getSwapchains = function getSwapchains() {
          return [this._swapchain];
        };

        _proto.getGeneralBarrier = function getGeneralBarrier(info) {
          var hash = GeneralBarrier.computeHash(info);

          if (!this._generalBarrierss.has(hash)) {
            this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
          }

          return this._generalBarrierss.get(hash);
        };

        _proto.getTextureBarrier = function getTextureBarrier(info) {
          var hash = TextureBarrier.computeHash(info);

          if (!this._textureBarriers.has(hash)) {
            this._textureBarriers.set(hash, new TextureBarrier(info, hash));
          }

          return this._textureBarriers.get(hash);
        };

        _proto.getBufferBarrier = function getBufferBarrier(info) {
          var hash = BufferBarrier.computeHash(info);

          if (!this._bufferBarriers.has(hash)) {
            this._bufferBarriers.set(hash, new BufferBarrier(info, hash));
          }

          return this._bufferBarriers.get(hash);
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
        };

        _proto.copyTextureToBuffers = function copyTextureToBuffers(texture, buffers, regions) {
          WebGL2CmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
        };

        _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
          WebGL2CmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
        };

        _createClass(WebGL2Device, [{
          key: "gl",
          get: function get() {
            return this._context;
          }
        }, {
          key: "extensions",
          get: function get() {
            return this._swapchain.extensions;
          }
        }, {
          key: "stateCache",
          get: function get() {
            return this._swapchain.stateCache;
          }
        }, {
          key: "nullTex2D",
          get: function get() {
            return this._swapchain.nullTex2D;
          }
        }, {
          key: "nullTexCube",
          get: function get() {
            return this._swapchain.nullTexCube;
          }
        }, {
          key: "textureExclusive",
          get: function get() {
            return this._textureExclusive;
          }
        }, {
          key: "bindingMappings",
          get: function get() {
            return this._bindingMappings;
          }
        }]);

        return WebGL2Device;
      }(Device));

      legacyCC.WebGL2Device = WebGL2Device;

      var _dec$N, _dec2$w, _dec3$s, _dec4$p, _dec5$n, _dec6$k, _dec7$j, _dec8$h, _dec9$d, _class$O, _class2$G, _descriptor$D, _descriptor2$w, _descriptor3$o, _descriptor4$j, _temp$I;
      var Billboard = function (v) { return exports({ Billboard: v, BillboardComponent: v }), v; }((_dec$N = ccclass('cc.Billboard'), _dec2$w = help(), _dec3$s = menu(), _dec4$p = type(Texture2D), _dec5$n = type(Texture2D), _dec6$k = tooltip(), _dec7$j = tooltip(), _dec8$h = tooltip(), _dec9$d = tooltip(), _dec$N(_class$O = _dec2$w(_class$O = _dec3$s(_class$O = executeInEditMode(_class$O = (_class2$G = (_temp$I = function (_Component) {
        _inheritsLoose(Billboard, _Component);

        function Billboard() {
          var _this;

          _this = _Component.call(this) || this;

          _initializerDefineProperty(_this, "_texture", _descriptor$D, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_height", _descriptor2$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_width", _descriptor3$o, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_rotation", _descriptor4$j, _assertThisInitialized(_this));

          _this._model = null;
          _this._mesh = null;
          _this._material = null;
          _this._uniform = new Vec4(1, 1, 0, 0);
          return _this;
        }

        var _proto = Billboard.prototype;

        _proto.onLoad = function onLoad() {
          this.createModel();
        };

        _proto.onEnable = function onEnable() {
          this.attachToScene();
          this._model.enabled = true;
          this.width = this._width;
          this.height = this._height;
          this.rotation = this.rotation;
          this.texture = this.texture;
        };

        _proto.onDisable = function onDisable() {
          this.detachFromScene();
        };

        _proto.attachToScene = function attachToScene() {
          if (this._model && this.node && this.node.scene) {
            if (this._model.scene) {
              this.detachFromScene();
            }

            this._getRenderScene().addModel(this._model);
          }
        };

        _proto.detachFromScene = function detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        };

        _proto.createModel = function createModel() {
          this._mesh = _createMesh({
            primitiveMode: PrimitiveMode.TRIANGLE_LIST,
            positions: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            uvs: [0, 0, 1, 0, 0, 1, 1, 1],
            colors: [Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a],
            attributes: [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8UI, true)],
            indices: [0, 1, 2, 1, 2, 3]
          }, undefined, {
            calculateBounds: false
          });
          var model = this._model = legacyCC.director.root.createModel(Model, this.node);
          model.node = model.transform = this.node;

          if (this._material == null) {
            this._material = new Material();

            this._material.copy(builtinResMgr.get('default-billboard-material'));
          }

          model.initSubModel(0, this._mesh.renderingSubMeshes[0], this._material);
        };

        _createClass(Billboard, [{
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(val) {
            this._texture = val;

            if (this._material) {
              this._material.setProperty('mainTexture', val);
            }
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          },
          set: function set(val) {
            this._height = val;

            if (this._material) {
              this._uniform.y = val;

              this._material.setProperty('cc_size_rotation', this._uniform);
            }
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          },
          set: function set(val) {
            this._width = val;

            if (this._material) {
              this._uniform.x = val;

              this._material.setProperty('cc_size_rotation', this._uniform);
            }
          }
        }, {
          key: "rotation",
          get: function get() {
            return Math.round(toDegree(this._rotation) * 100) / 100;
          },
          set: function set(val) {
            this._rotation = toRadian(val);

            if (this._material) {
              this._uniform.z = this._rotation;

              this._material.setProperty('cc_size_rotation', this._uniform);
            }
          }
        }]);

        return Billboard;
      }(Component), _temp$I), (_descriptor$D = _applyDecoratedDescriptor(_class2$G.prototype, "_texture", [_dec4$p], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$G.prototype, "texture", [_dec5$n, _dec6$k], Object.getOwnPropertyDescriptor(_class2$G.prototype, "texture"), _class2$G.prototype), _descriptor2$w = _applyDecoratedDescriptor(_class2$G.prototype, "_height", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$G.prototype, "height", [_dec7$j], Object.getOwnPropertyDescriptor(_class2$G.prototype, "height"), _class2$G.prototype), _descriptor3$o = _applyDecoratedDescriptor(_class2$G.prototype, "_width", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$G.prototype, "width", [_dec8$h], Object.getOwnPropertyDescriptor(_class2$G.prototype, "width"), _class2$G.prototype), _descriptor4$j = _applyDecoratedDescriptor(_class2$G.prototype, "_rotation", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$G.prototype, "rotation", [_dec9$d], Object.getOwnPropertyDescriptor(_class2$G.prototype, "rotation"), _class2$G.prototype)), _class2$G)) || _class$O) || _class$O) || _class$O) || _class$O));

      var _vertex_attrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGBA32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];

      var _temp_v1 = new Vec3();

      var _temp_v2 = new Vec3();

      var LineModel = function (_scene$Model) {
        _inheritsLoose(LineModel, _scene$Model);

        function LineModel() {
          var _this;

          _this = _scene$Model.call(this) || this;
          _this._capacity = void 0;
          _this._vertSize = 0;
          _this._vBuffer = null;
          _this._vertAttrsFloatCount = 0;
          _this._vdataF32 = null;
          _this._vdataUint32 = null;
          _this._iaInfo = void 0;
          _this._iaInfoBuffer = void 0;
          _this._subMeshData = null;
          _this._vertCount = 0;
          _this._indexCount = 0;
          _this._material = null;

          _this.type = ModelType.LINE;
          _this._capacity = 100;
          _this._iaInfo = new IndirectBuffer([new DrawInfo()]);
          _this._iaInfoBuffer = _this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
          return _this;
        }

        var _proto = LineModel.prototype;

        _proto.setCapacity = function setCapacity(capacity) {
          this._capacity = capacity;
          this.createBuffer();
        };

        _proto.createBuffer = function createBuffer() {
          this._vertSize = 0;

          for (var _iterator = _createForOfIteratorHelperLoose(_vertex_attrs), _step; !(_step = _iterator()).done;) {
            var a = _step.value;
            a.offset = this._vertSize;
            this._vertSize += FormatInfos[a.format].size;
          }

          this._vertAttrsFloatCount = this._vertSize / 4;
          this._vBuffer = this.createSubMeshData();
          this._vdataF32 = new Float32Array(this._vBuffer);
          this._vdataUint32 = new Uint32Array(this._vBuffer);
        };

        _proto.updateMaterial = function updateMaterial(mat) {
          this._material = mat;

          _scene$Model.prototype.setSubModelMaterial.call(this, 0, mat);
        };

        _proto.createSubMeshData = function createSubMeshData() {
          if (this._subMeshData) {
            this.destroySubMeshData();
          }

          this._vertCount = 2;
          this._indexCount = 6;

          var vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._vertSize * this._capacity * this._vertCount, this._vertSize));

          var vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
          vertexBuffer.update(vBuffer);
          var indices = new Uint16Array((this._capacity - 1) * this._indexCount);
          var dst = 0;

          for (var i = 0; i < this._capacity - 1; ++i) {
            var baseIdx = 2 * i;
            indices[dst++] = baseIdx;
            indices[dst++] = baseIdx + 1;
            indices[dst++] = baseIdx + 2;
            indices[dst++] = baseIdx + 3;
            indices[dst++] = baseIdx + 2;
            indices[dst++] = baseIdx + 1;
          }

          var indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

          indexBuffer.update(indices);
          this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount;
          this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount;

          this._iaInfoBuffer.update(this._iaInfo);

          this._subMeshData = new RenderingSubMesh([vertexBuffer], _vertex_attrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
          this.initSubModel(0, this._subMeshData, this._material);
          return vBuffer;
        };

        _proto.addLineVertexData = function addLineVertexData(positions, width, color) {
          if (positions.length > 1) {
            var offset = 0;
            Vec3.subtract(_temp_v1, positions[1], positions[0]);
            this._vdataF32[offset++] = positions[0].x;
            this._vdataF32[offset++] = positions[0].y;
            this._vdataF32[offset++] = positions[0].z;
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = width.evaluate(0, 1);
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = _temp_v1.x;
            this._vdataF32[offset++] = _temp_v1.y;
            this._vdataF32[offset++] = _temp_v1.z;
            this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
            this._vdataF32[offset++] = positions[0].x;
            this._vdataF32[offset++] = positions[0].y;
            this._vdataF32[offset++] = positions[0].z;
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = width.evaluate(0, 1);
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = _temp_v1.x;
            this._vdataF32[offset++] = _temp_v1.y;
            this._vdataF32[offset++] = _temp_v1.z;
            this._vdataUint32[offset++] = color.evaluate(0, 1)._val;

            for (var i = 1; i < positions.length - 1; i++) {
              Vec3.subtract(_temp_v1, positions[i - 1], positions[i]);
              Vec3.subtract(_temp_v2, positions[i + 1], positions[i]);
              Vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
              var seg = i / positions.length;
              this._vdataF32[offset++] = positions[i].x;
              this._vdataF32[offset++] = positions[i].y;
              this._vdataF32[offset++] = positions[i].z;
              this._vdataF32[offset++] = 0;
              this._vdataF32[offset++] = width.evaluate(seg, 1);
              this._vdataF32[offset++] = seg;
              this._vdataF32[offset++] = 0;
              this._vdataF32[offset++] = _temp_v2.x;
              this._vdataF32[offset++] = _temp_v2.y;
              this._vdataF32[offset++] = _temp_v2.z;
              this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
              this._vdataF32[offset++] = positions[i].x;
              this._vdataF32[offset++] = positions[i].y;
              this._vdataF32[offset++] = positions[i].z;
              this._vdataF32[offset++] = 1;
              this._vdataF32[offset++] = width.evaluate(seg, 1);
              this._vdataF32[offset++] = seg;
              this._vdataF32[offset++] = 1;
              this._vdataF32[offset++] = _temp_v2.x;
              this._vdataF32[offset++] = _temp_v2.y;
              this._vdataF32[offset++] = _temp_v2.z;
              this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
            }

            Vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]);
            this._vdataF32[offset++] = positions[positions.length - 1].x;
            this._vdataF32[offset++] = positions[positions.length - 1].y;
            this._vdataF32[offset++] = positions[positions.length - 1].z;
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = width.evaluate(1, 1);
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = _temp_v1.x;
            this._vdataF32[offset++] = _temp_v1.y;
            this._vdataF32[offset++] = _temp_v1.z;
            this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
            this._vdataF32[offset++] = positions[positions.length - 1].x;
            this._vdataF32[offset++] = positions[positions.length - 1].y;
            this._vdataF32[offset++] = positions[positions.length - 1].z;
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = width.evaluate(1, 1);
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = _temp_v1.x;
            this._vdataF32[offset++] = _temp_v1.y;
            this._vdataF32[offset++] = _temp_v1.z;
            this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
          }

          this.updateIA(Math.max(0, positions.length - 1));
        };

        _proto.updateIA = function updateIA(count) {
          var ia = this._subModels[0].inputAssembler;
          ia.vertexBuffers[0].update(this._vdataF32);
          this._iaInfo.drawInfos[0].firstIndex = 0;
          this._iaInfo.drawInfos[0].indexCount = this._indexCount * count;

          this._iaInfoBuffer.update(this._iaInfo);
        };

        _proto.destroySubMeshData = function destroySubMeshData() {
          if (this._subMeshData) {
            this._subMeshData.destroy();

            this._subMeshData = null;
          }
        };

        return LineModel;
      }(Model);

      var _dec$O, _class$P, _class2$H, _temp$J;
      var setClassAttr = CCClass.Attr.setClassAttr;
      var SerializableTable = [['mode', 'constant', 'multiplier'], ['mode', 'spline', 'multiplier'], ['mode', 'splineMin', 'splineMax', 'multiplier'], ['mode', 'constantMin', 'constantMax', 'multiplier']];
      var Mode = Enum({
        Constant: 0,
        Curve: 1,
        TwoCurves: 2,
        TwoConstants: 3
      });
      var CurveRange = exports('CurveRange', (_dec$O = ccclass('cc.CurveRange'), _dec$O(_class$P = (_temp$J = _class2$H = function () {
        function CurveRange() {
          this.mode = Mode.Constant;
          this.spline = constructLegacyCurveAndConvert();
          this.splineMin = constructLegacyCurveAndConvert();
          this.splineMax = constructLegacyCurveAndConvert();
          this.constant = 0;
          this.constantMin = 0;
          this.constantMax = 0;
          this.multiplier = 1;
        }

        var _proto = CurveRange.prototype;

        _proto.evaluate = function evaluate(time, rndRatio) {
          switch (this.mode) {
            default:
            case Mode.Constant:
              return this.constant;

            case Mode.Curve:
              return this.spline.evaluate(time) * this.multiplier;

            case Mode.TwoCurves:
              return lerp(this.splineMin.evaluate(time), this.splineMax.evaluate(time), rndRatio) * this.multiplier;

            case Mode.TwoConstants:
              return lerp(this.constantMin, this.constantMax, rndRatio);
          }
        };

        _proto.getMax = function getMax() {
          switch (this.mode) {
            default:
            case Mode.Constant:
              return this.constant;

            case Mode.Curve:
              return this.multiplier;

            case Mode.TwoConstants:
              return this.constantMax;

            case Mode.TwoCurves:
              return this.multiplier;
          }
        };

        _proto._onBeforeSerialize = function _onBeforeSerialize(props) {
          return SerializableTable[this.mode];
        };

        _createClass(CurveRange, [{
          key: "curve",
          get: function get() {
            var _this$_curve;

            return (_this$_curve = this._curve) !== null && _this$_curve !== void 0 ? _this$_curve : this._curve = new AnimationCurve(this.spline);
          },
          set: function set(value) {
            this._curve = value;
            this.spline = value._internalCurve;
          }
        }, {
          key: "curveMin",
          get: function get() {
            var _this$_curveMin;

            return (_this$_curveMin = this._curveMin) !== null && _this$_curveMin !== void 0 ? _this$_curveMin : this._curveMin = new AnimationCurve(this.splineMin);
          },
          set: function set(value) {
            this._curveMin = value;
            this.splineMin = value._internalCurve;
          }
        }, {
          key: "curveMax",
          get: function get() {
            var _this$_curveMax;

            return (_this$_curveMax = this._curveMax) !== null && _this$_curveMax !== void 0 ? _this$_curveMax : this._curveMax = new AnimationCurve(this.splineMax);
          },
          set: function set(value) {
            this._curveMax = value;
            this.splineMax = value._internalCurve;
          }
        }]);

        return CurveRange;
      }(), _class2$H.Mode = Mode, _temp$J)) || _class$P));
      CCClass.fastDefine('cc.CurveRange', CurveRange, {
        multiplier: 1,
        constantMax: 0,
        constantMin: 0,
        constant: 0,
        mode: Mode.Constant,
        splineMax: Object.freeze(constructLegacyCurveAndConvert()),
        splineMin: Object.freeze(constructLegacyCurveAndConvert()),
        spline: Object.freeze(constructLegacyCurveAndConvert())
      });
      setClassAttr(CurveRange, 'multiplier', 'visible', true);
      setClassAttr(CurveRange, 'constantMax', 'visible', true);
      setClassAttr(CurveRange, 'constantMin', 'visible', true);
      setClassAttr(CurveRange, 'constant', 'visible', true);
      setClassAttr(CurveRange, 'mode', 'type', 'Enum');
      setClassAttr(CurveRange, 'mode', 'enumList', Enum.getList(Mode));
      setClassAttr(CurveRange, 'mode', 'visible', true);
      setClassAttr(CurveRange, 'splineMax', 'type', 'Object');
      setClassAttr(CurveRange, 'splineMax', 'ctor', RealCurve);
      setClassAttr(CurveRange, 'splineMax', 'visible', true);
      setClassAttr(CurveRange, 'splineMin', 'type', 'Object');
      setClassAttr(CurveRange, 'splineMin', 'ctor', RealCurve);
      setClassAttr(CurveRange, 'splineMin', 'visible', true);
      setClassAttr(CurveRange, 'spline', 'type', 'Object');
      setClassAttr(CurveRange, 'spline', 'ctor', RealCurve);
      setClassAttr(CurveRange, 'spline', 'visible', true);

      function evaluateCurve(cr, time, index) {
        switch (cr.mode) {
          case Mode.Constant:
            return cr.constant;

          case Mode.Curve:
            return cr.spline.evaluate(time) * cr.multiplier;

          case Mode.TwoCurves:
            return index === 0 ? cr.splineMin.evaluate(time) * cr.multiplier : cr.splineMax.evaluate(time) * cr.multiplier;

          case Mode.TwoConstants:
            return index === 0 ? cr.constantMin : cr.constantMax;

          default:
            return 0;
        }
      }

      function evaluateHeight(cr) {
        switch (cr.mode) {
          case Mode.TwoConstants:
            return 2;

          case Mode.TwoCurves:
            return 2;

          default:
            return 1;
        }
      }

      function packTexture(data, width, height) {
        var image = new ImageAsset({
          width: width,
          height: height,
          _data: data,
          _compressed: false,
          format: PixelFormat.RGBA32F
        });
        var texture = new Texture2D();
        texture.setFilters(Filter$1.NEAREST, Filter$1.NEAREST);
        texture.setMipFilter(Filter$1.NONE);
        texture.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
        texture.image = image;
        return texture;
      }

      function updateTexture(tex, data, width, height) {
        if (tex === null || width !== tex.width || height !== tex.height) {
          if (tex) {
            tex.destroy();
          }

          tex = packTexture(data, width, height);
        } else {
          tex.uploadData(data);
        }

        return tex;
      }

      function packCurveRangeZ(tex, data, samples, cr, discrete) {
        var height = evaluateHeight(cr);
        var len = samples * height * 4;

        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }

        var interval = 1.0 / (samples - 1);
        var offset = 0;

        for (var h = 0; h < height; h++) {

          for (var j = 0; j < samples; j++) {
            var value = evaluateCurve(cr, interval * j, h);

            data[offset + 2] = value;
            offset += 4;
          }
        }

        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }
      function packCurveRangeN(tex, data, samples, cr, discrete) {
        var height = evaluateHeight(cr);
        var len = samples * height * 4;

        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }

        var interval = 1.0 / (samples - 1);
        var sum = 0;
        var average = 0;
        var offset = 0;

        for (var h = 0; h < height; h++) {
          sum = 0;

          for (var j = 0; j < samples; j++) {
            var value = evaluateCurve(cr, interval * j, h);

            if (discrete) {
              average = value;
            } else {
              sum += value;
              average = sum / (j + 1);
            }

            data[offset] = average;
            data[offset + 1] = average;
            data[offset + 2] = average;
            offset += 4;
          }
        }

        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }
      function packCurveRangeXY(tex, data, samples, x, y, discrete) {
        var height = Math.max(evaluateHeight(x), evaluateHeight(y));
        var len = samples * height * 4;

        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }

        var curves = [x, y];
        var interval = 1.0 / (samples - 1);

        for (var h = 0; h < height; h++) {
          for (var i = 0; i < 2; i++) {
            var cr = curves[i];
            var sum = 0;
            var average = 0;

            for (var j = 0; j < samples; j++) {
              var value = evaluateCurve(cr, interval * j, h);

              if (discrete) {
                average = value;
              } else {
                sum += value;
                average = sum / (j + 1);
              }

              data[(h * samples + j) * 4 + i] = average;
            }
          }
        }

        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }
      function packCurveRangeXYZ(tex, data, samples, x, y, z, discrete) {
        var height = Math.max(evaluateHeight(x), evaluateHeight(y), evaluateHeight(z));
        var len = samples * height * 4;

        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }

        var curves = [x, y, z];
        var interval = 1.0 / (samples - 1);

        for (var h = 0; h < height; h++) {
          for (var i = 0; i < 3; i++) {
            var cr = curves[i];
            var sum = 0;
            var average = 0;

            for (var j = 0; j < samples; j++) {
              var value = evaluateCurve(cr, interval * j, h);

              if (discrete) {
                average = value;
              } else {
                sum += value;
                average = sum / (j + 1);
              }

              data[(h * samples + j) * 4 + i] = average;
            }
          }
        }

        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }
      function packCurveRangeXYZW(tex, data, samples, x, y, z, w, discrete) {
        var height = Math.max(evaluateHeight(x), evaluateHeight(y), evaluateHeight(z), evaluateHeight(w));
        var len = samples * height * 4;

        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }

        var curves = [x, y, z, w];
        var interval = 1.0 / (samples - 1);

        for (var h = 0; h < height; h++) {
          for (var i = 0; i < 4; i++) {
            var cr = curves[i];
            var sum = 0;
            var average = 0;

            for (var j = 0; j < samples; j++) {
              var value = evaluateCurve(cr, interval * j, h);

              if (discrete) {
                average = value;
              } else {
                sum += value;
                average = sum / (j + 1);
              }

              data[(h * samples + j) * 4 + i] = average;
            }
          }
        }

        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }

      var Mode$1 = Enum({
        Blend: 0,
        Fixed: 1
      });
      var ColorKey = exports('ColorKey', function ColorKey() {
        this.color = Color.WHITE.clone();
        this.time = 0;
      });
      CCClass.fastDefine('cc.ColorKey', ColorKey, {
        color: Color.WHITE.clone(),
        time: 0
      });
      CCClass.Attr.setClassAttr(ColorKey, 'color', 'visible', true);
      CCClass.Attr.setClassAttr(ColorKey, 'time', 'visible', true);
      var AlphaKey = exports('AlphaKey', function AlphaKey() {
        this.alpha = 1;
        this.time = 0;
      });
      CCClass.fastDefine('cc.AlphaKey', AlphaKey, {
        alpha: 1,
        time: 0
      });
      CCClass.Attr.setClassAttr(AlphaKey, 'alpha', 'visible', true);
      CCClass.Attr.setClassAttr(AlphaKey, 'time', 'visible', true);

      var Gradient = exports('Gradient', function () {
        function Gradient() {
          this.colorKeys = new Array();
          this.alphaKeys = new Array();
          this.mode = Mode$1.Blend;
          this._color = void 0;
          this._color = Color.WHITE.clone();
        }

        var _proto = Gradient.prototype;

        _proto.setKeys = function setKeys(colorKeys, alphaKeys) {
          this.colorKeys = colorKeys;
          this.alphaKeys = alphaKeys;
        };

        _proto.sortKeys = function sortKeys() {
          if (this.colorKeys.length > 1) {
            this.colorKeys.sort(function (a, b) {
              return a.time - b.time;
            });
          }

          if (this.alphaKeys.length > 1) {
            this.alphaKeys.sort(function (a, b) {
              return a.time - b.time;
            });
          }
        };

        _proto.evaluate = function evaluate(time) {
          this.getRGB(time);

          this._color._set_a_unsafe(this.getAlpha(time));

          return this._color;
        };

        _proto.randomColor = function randomColor() {
          var c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)];
          var a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];

          this._color.set(c.color);

          this._color._set_a_unsafe(a.alpha);

          return this._color;
        };

        _proto.getRGB = function getRGB(time) {
          if (this.colorKeys.length > 1) {
            time = repeat$1(time, 1);

            for (var i = 1; i < this.colorKeys.length; ++i) {
              var preTime = this.colorKeys[i - 1].time;
              var curTime = this.colorKeys[i].time;

              if (time >= preTime && time < curTime) {
                if (this.mode === Mode$1.Fixed) {
                  return this.colorKeys[i].color;
                }

                var factor = (time - preTime) / (curTime - preTime);
                Color.lerp(this._color, this.colorKeys[i - 1].color, this.colorKeys[i].color, factor);
                return this._color;
              }
            }

            var lastIndex = this.colorKeys.length - 1;

            if (time < this.colorKeys[0].time) {
              Color.lerp(this._color, Color.BLACK, this.colorKeys[0].color, time / this.colorKeys[0].time);
            } else if (time > this.colorKeys[lastIndex].time) {
              Color.lerp(this._color, this.colorKeys[lastIndex].color, Color.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time));
            }

            return this._color;
          } else if (this.colorKeys.length === 1) {
            this._color.set(this.colorKeys[0].color);

            return this._color;
          } else {
            this._color.set(Color.WHITE);

            return this._color;
          }
        };

        _proto.getAlpha = function getAlpha(time) {
          var basicAlpha = 0;

          if (this.alphaKeys.length > 1) {
            time = repeat$1(time, 1);

            for (var i = 1; i < this.alphaKeys.length; ++i) {
              var preTime = this.alphaKeys[i - 1].time;
              var curTime = this.alphaKeys[i].time;

              if (time >= preTime && time < curTime) {
                if (this.mode === Mode$1.Fixed) {
                  return this.alphaKeys[i].alpha;
                }

                var factor = (time - preTime) / (curTime - preTime);
                return lerp(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
              }
            }

            var lastIndex = this.alphaKeys.length - 1;

            if (time < this.alphaKeys[0].time) {
              return lerp(basicAlpha, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time);
            } else if (time > this.alphaKeys[lastIndex].time) {
              return lerp(this.alphaKeys[lastIndex].alpha, basicAlpha, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time));
            }

            return 255;
          } else if (this.alphaKeys.length === 1) {
            return this.alphaKeys[0].alpha;
          } else {
            return 255;
          }
        };

        return Gradient;
      }());

      Gradient.Mode = Mode$1;
      CCClass.fastDefine('cc.Gradient', Gradient, {
        colorKeys: [],
        alphaKeys: [],
        mode: Mode$1.Blend
      });
      CCClass.Attr.setClassAttr(Gradient, 'colorKeys', 'visible', true);
      CCClass.Attr.setClassAttr(Gradient, 'alphaKeys', 'visible', true);
      CCClass.Attr.setClassAttr(Gradient, 'mode', 'visible', true);

      var _dec$P, _dec2$x, _dec3$t, _dec4$q, _dec5$o, _dec6$l, _class$Q, _class2$I, _descriptor$E, _descriptor2$x, _descriptor3$p, _descriptor4$k, _descriptor5$g, _descriptor6$e, _descriptor7$a, _class3$9, _temp$K;
      var SerializableTable$1 = EDITOR ;
      var Mode$2 = Enum({
        Color: 0,
        Gradient: 1,
        TwoColors: 2,
        TwoGradients: 3,
        RandomColor: 4
      });
      var GradientRange = exports('GradientRange', (_dec$P = ccclass('cc.GradientRange'), _dec2$x = type(Mode$2), _dec3$t = type(Gradient), _dec4$q = type(Gradient), _dec5$o = type(Gradient), _dec6$l = type(Mode$2), _dec$P(_class$Q = (_class2$I = (_temp$K = _class3$9 = function () {
        function GradientRange() {
          _initializerDefineProperty(this, "color", _descriptor$E, this);

          _initializerDefineProperty(this, "colorMin", _descriptor2$x, this);

          _initializerDefineProperty(this, "colorMax", _descriptor3$p, this);

          _initializerDefineProperty(this, "gradient", _descriptor4$k, this);

          _initializerDefineProperty(this, "gradientMin", _descriptor5$g, this);

          _initializerDefineProperty(this, "gradientMax", _descriptor6$e, this);

          _initializerDefineProperty(this, "_mode", _descriptor7$a, this);

          this._color = Color.WHITE.clone();
        }

        var _proto = GradientRange.prototype;

        _proto.evaluate = function evaluate(time, rndRatio) {
          switch (this._mode) {
            case Mode$2.Color:
              return this.color;

            case Mode$2.TwoColors:
              Color.lerp(this._color, this.colorMin, this.colorMax, rndRatio);
              return this._color;

            case Mode$2.RandomColor:
              return this.gradient.randomColor();

            case Mode$2.Gradient:
              return this.gradient.evaluate(time);

            case Mode$2.TwoGradients:
              Color.lerp(this._color, this.gradientMin.evaluate(time), this.gradientMax.evaluate(time), rndRatio);
              return this._color;

            default:
              return this.color;
          }
        };

        _proto._onBeforeSerialize = function _onBeforeSerialize(props) {
          return SerializableTable$1[this._mode];
        };

        _createClass(GradientRange, [{
          key: "mode",
          get: function get() {
            return this._mode;
          },
          set: function set(m) {

            this._mode = m;
          }
        }]);

        return GradientRange;
      }(), _class3$9.Mode = Mode$2, _temp$K), (_applyDecoratedDescriptor(_class2$I.prototype, "mode", [_dec2$x], Object.getOwnPropertyDescriptor(_class2$I.prototype, "mode"), _class2$I.prototype), _descriptor$E = _applyDecoratedDescriptor(_class2$I.prototype, "color", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor2$x = _applyDecoratedDescriptor(_class2$I.prototype, "colorMin", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor3$p = _applyDecoratedDescriptor(_class2$I.prototype, "colorMax", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor4$k = _applyDecoratedDescriptor(_class2$I.prototype, "gradient", [_dec3$t], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Gradient();
        }
      }), _descriptor5$g = _applyDecoratedDescriptor(_class2$I.prototype, "gradientMin", [_dec4$q], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Gradient();
        }
      }), _descriptor6$e = _applyDecoratedDescriptor(_class2$I.prototype, "gradientMax", [_dec5$o], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Gradient();
        }
      }), _descriptor7$a = _applyDecoratedDescriptor(_class2$I.prototype, "_mode", [_dec6$l], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Mode$2.Color;
        }
      })), _class2$I)) || _class$Q));

      function evaluateGradient(gr, time, index) {
        switch (gr.mode) {
          case Mode$2.Color:
            return gr.color;

          case Mode$2.TwoColors:
            return index === 0 ? gr.colorMin : gr.colorMax;

          case Mode$2.RandomColor:
            return gr.gradient.randomColor();

          case Mode$2.Gradient:
            return gr.gradient.evaluate(time);

          case Mode$2.TwoGradients:
            return index === 0 ? gr.gradientMin.evaluate(time) : gr.gradientMax.evaluate(time);

          default:
            return gr.color;
        }
      }

      function evaluateHeight$1(gr) {
        switch (gr.mode) {
          case Mode$2.TwoColors:
            return 2;

          case Mode$2.TwoGradients:
            return 2;

          default:
            return 1;
        }
      }

      function packGradientRange(tex, data, samples, gr) {
        var height = evaluateHeight$1(gr);
        var len = samples * height * 4;

        if (data === null || data.length !== len) {
          data = new Uint8Array(samples * height * 4);
        }

        var interval = 1.0 / samples;
        var offset = 0;

        for (var h = 0; h < height; h++) {
          for (var j = 0; j < samples; j++) {
            var color = evaluateGradient(gr, interval * j, h);
            data[offset] = color.r;
            data[offset + 1] = color.g;
            data[offset + 2] = color.b;
            data[offset + 3] = color.a;
            offset += 4;
          }
        }

        if (tex === null || samples !== tex.width || height !== tex.height) {
          if (tex) {
            tex.destroy();
          }

          tex = new Texture2D();
          tex.create(samples, height, PixelFormat.RGBA8888);
          tex.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);
          tex.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
        }

        tex.uploadData(data);
        return {
          texture: tex,
          texdata: data
        };
      }

      var _dec$Q, _dec2$y, _dec3$u, _dec4$r, _dec5$p, _dec6$m, _dec7$k, _dec8$i, _dec9$e, _dec10$c, _dec11$a, _dec12$9, _dec13$9, _dec14$7, _dec15$7, _dec16$7, _dec17$6, _dec18$6, _dec19$6, _dec20$6, _dec21$6, _dec22$5, _dec23$4, _dec24$4, _dec25$4, _dec26$4, _dec27$4, _dec28$3, _dec29$3, _dec30$3, _dec31$3, _class$R, _class2$J, _descriptor$F, _descriptor2$y, _descriptor3$q, _descriptor4$l, _descriptor5$h, _descriptor6$f, _descriptor7$b, _descriptor8$a, _temp$L;
      var _matInsInfo = {
        parent: null,
        owner: null,
        subModelIdx: 0
      };
      var CC_USE_WORLD_SPACE = 'CC_USE_WORLD_SPACE';
      var define = {
        CC_USE_WORLD_SPACE: false
      };
      var Line = function (v) { return exports({ Line: v, LineComponent: v }), v; }((_dec$Q = ccclass('cc.Line'), _dec2$y = help(), _dec3$u = menu(), _dec4$r = type(Texture2D), _dec5$p = type(Texture2D), _dec6$m = displayOrder(), _dec7$k = tooltip(), _dec8$i = type(Material), _dec9$e = displayOrder(), _dec10$c = tooltip(), _dec11$a = displayOrder(), _dec12$9 = tooltip(), _dec13$9 = type([Vec3]), _dec14$7 = type([Vec3]), _dec15$7 = displayOrder(), _dec16$7 = tooltip(), _dec17$6 = type(CurveRange), _dec18$6 = type(CurveRange), _dec19$6 = range(), _dec20$6 = displayOrder(), _dec21$6 = tooltip(), _dec22$5 = type(Vec2), _dec23$4 = displayOrder(), _dec24$4 = tooltip(), _dec25$4 = type(Vec2), _dec26$4 = displayOrder(), _dec27$4 = tooltip(), _dec28$3 = type(GradientRange), _dec29$3 = type(GradientRange), _dec30$3 = displayOrder(), _dec31$3 = tooltip(), _dec$Q(_class$R = _dec2$y(_class$R = _dec3$u(_class$R = executeInEditMode(_class$R = (_class2$J = (_temp$L = function (_Component) {
        _inheritsLoose(Line, _Component);

        function Line() {
          var _this;

          _this = _Component.call(this) || this;

          _initializerDefineProperty(_this, "_texture", _descriptor$F, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_material", _descriptor2$y, _assertThisInitialized(_this));

          _this._materialInstance = null;

          _initializerDefineProperty(_this, "_worldSpace", _descriptor3$q, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_positions", _descriptor4$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_width", _descriptor5$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_tile", _descriptor6$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_offset", _descriptor7$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_color", _descriptor8$a, _assertThisInitialized(_this));

          _this._model = null;
          _this._tile_offset = new Vec4();
          return _this;
        }

        var _proto = Line.prototype;

        _proto.onLoad = function onLoad() {
          var model = this._model = legacyCC.director.root.createModel(LineModel);
          model.node = model.transform = this.node;

          if (this._material === null) {
            this._material = new Material();

            this._material.copy(builtinResMgr.get('default-trail-material'));
          }

          if (this._material) {
            define[CC_USE_WORLD_SPACE] = this.worldSpace;
            _matInsInfo.parent = this._material;
            _matInsInfo.subModelIdx = 0;
            this._materialInstance = new MaterialInstance(_matInsInfo);
            _matInsInfo.parent = null;
            _matInsInfo.subModelIdx = 0;

            this._materialInstance.recompileShaders(define);
          }

          model.updateMaterial(this._materialInstance);
          model.setCapacity(100);
        };

        _proto.onEnable = function onEnable() {
          if (!this._model) {
            return;
          }

          this._attachToScene();

          this.texture = this._texture;
          this.tile = this._tile;
          this.offset = this._offset;

          this._model.addLineVertexData(this._positions, this._width, this._color);
        };

        _proto.onDisable = function onDisable() {
          if (this._model) {
            this._detachFromScene();
          }
        };

        _proto._attachToScene = function _attachToScene() {
          if (this._model && this.node && this.node.scene) {
            if (this._model.scene) {
              this._detachFromScene();
            }

            this._getRenderScene().addModel(this._model);
          }
        };

        _proto._detachFromScene = function _detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        };

        _createClass(Line, [{
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(val) {
            this._texture = val;

            if (this._materialInstance) {
              this._materialInstance.setProperty('mainTexture', val);
            }
          }
        }, {
          key: "material",
          get: function get() {
            return this._material;
          },
          set: function set(val) {
            this._material = val;
          }
        }, {
          key: "worldSpace",
          get: function get() {
            return this._worldSpace;
          },
          set: function set(val) {
            this._worldSpace = val;

            if (this._materialInstance) {
              define[CC_USE_WORLD_SPACE] = this.worldSpace;

              this._materialInstance.recompileShaders(define);

              if (this._model) {
                this._model.setSubModelMaterial(0, this._materialInstance);
              }
            }
          }
        }, {
          key: "positions",
          get: function get() {
            return this._positions;
          },
          set: function set(val) {
            this._positions = val;

            if (this._model) {
              this._model.addLineVertexData(this._positions, this._width, this._color);
            }
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          },
          set: function set(val) {
            this._width = val;

            if (this._model) {
              this._model.addLineVertexData(this._positions, this._width, this._color);
            }
          }
        }, {
          key: "tile",
          get: function get() {
            return this._tile;
          },
          set: function set(val) {
            this._tile.set(val);

            if (this._materialInstance) {
              this._tile_offset.x = this._tile.x;
              this._tile_offset.y = this._tile.y;

              this._materialInstance.setProperty('mainTiling_Offset', this._tile_offset);
            }
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(val) {
            this._offset.set(val);

            if (this._materialInstance) {
              this._tile_offset.z = this._offset.x;
              this._tile_offset.w = this._offset.y;

              this._materialInstance.setProperty('mainTiling_Offset', this._tile_offset);
            }
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(val) {
            this._color = val;

            if (this._model) {
              this._model.addLineVertexData(this._positions, this._width, this._color);
            }
          }
        }]);

        return Line;
      }(Component), _temp$L), (_descriptor$F = _applyDecoratedDescriptor(_class2$J.prototype, "_texture", [_dec4$r], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "texture", [_dec5$p, _dec6$m, _dec7$k], Object.getOwnPropertyDescriptor(_class2$J.prototype, "texture"), _class2$J.prototype), _descriptor2$y = _applyDecoratedDescriptor(_class2$J.prototype, "_material", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "material", [_dec8$i, _dec9$e, _dec10$c], Object.getOwnPropertyDescriptor(_class2$J.prototype, "material"), _class2$J.prototype), _descriptor3$q = _applyDecoratedDescriptor(_class2$J.prototype, "_worldSpace", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "worldSpace", [_dec11$a, _dec12$9], Object.getOwnPropertyDescriptor(_class2$J.prototype, "worldSpace"), _class2$J.prototype), _descriptor4$l = _applyDecoratedDescriptor(_class2$J.prototype, "_positions", [_dec13$9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "positions", [_dec14$7, _dec15$7, _dec16$7], Object.getOwnPropertyDescriptor(_class2$J.prototype, "positions"), _class2$J.prototype), _descriptor5$h = _applyDecoratedDescriptor(_class2$J.prototype, "_width", [_dec17$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "width", [_dec18$6, _dec19$6, _dec20$6, _dec21$6], Object.getOwnPropertyDescriptor(_class2$J.prototype, "width"), _class2$J.prototype), _descriptor6$f = _applyDecoratedDescriptor(_class2$J.prototype, "_tile", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(1, 1);
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "tile", [_dec22$5, _dec23$4, _dec24$4], Object.getOwnPropertyDescriptor(_class2$J.prototype, "tile"), _class2$J.prototype), _descriptor7$b = _applyDecoratedDescriptor(_class2$J.prototype, "_offset", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(0, 0);
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "offset", [_dec25$4, _dec26$4, _dec27$4], Object.getOwnPropertyDescriptor(_class2$J.prototype, "offset"), _class2$J.prototype), _descriptor8$a = _applyDecoratedDescriptor(_class2$J.prototype, "_color", [_dec28$3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new GradientRange();
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "color", [_dec29$3, _dec30$3, _dec31$3], Object.getOwnPropertyDescriptor(_class2$J.prototype, "color"), _class2$J.prototype)), _class2$J)) || _class$R) || _class$R) || _class$R) || _class$R));

      var Particle = function () {
        function Particle(particleSystem) {
          this.particleSystem = void 0;
          this.position = void 0;
          this.velocity = void 0;
          this.animatedVelocity = void 0;
          this.ultimateVelocity = void 0;
          this.angularVelocity = void 0;
          this.axisOfRotation = void 0;
          this.rotation = void 0;
          this.startEuler = void 0;
          this.startRotation = void 0;
          this.startRotated = void 0;
          this.deltaQuat = void 0;
          this.deltaMat = void 0;
          this.localMat = void 0;
          this.startSize = void 0;
          this.size = void 0;
          this.startColor = void 0;
          this.color = void 0;
          this.randomSeed = void 0;
          this.remainingLifetime = void 0;
          this.loopCount = void 0;
          this.lastLoop = void 0;
          this.trailDelay = void 0;
          this.startLifetime = void 0;
          this.emitAccumulator0 = void 0;
          this.emitAccumulator1 = void 0;
          this.frameIndex = void 0;
          this.startRow = void 0;
          this.particleSystem = particleSystem;
          this.position = new Vec3(0, 0, 0);
          this.velocity = new Vec3(0, 0, 0);
          this.animatedVelocity = new Vec3(0, 0, 0);
          this.ultimateVelocity = new Vec3(0, 0, 0);
          this.angularVelocity = new Vec3(0, 0, 0);
          this.axisOfRotation = new Vec3(0, 0, 0);
          this.rotation = new Vec3(0, 0, 0);
          this.startEuler = new Vec3(0, 0, 0);
          this.startRotation = new Quat();
          this.startRotated = false;
          this.deltaQuat = new Quat();
          this.deltaMat = new Mat4();
          this.localMat = new Mat4();
          this.startSize = new Vec3(0, 0, 0);
          this.size = new Vec3(0, 0, 0);
          this.startColor = Color.WHITE.clone();
          this.color = Color.WHITE.clone();
          this.randomSeed = 0;
          this.remainingLifetime = 0.0;
          this.loopCount = 0;
          this.lastLoop = 0;
          this.trailDelay = 0;
          this.startLifetime = 0.0;
          this.emitAccumulator0 = 0.0;
          this.emitAccumulator1 = 0.0;
          this.frameIndex = 0.0;
          this.startRow = 0;
        }

        var _proto = Particle.prototype;

        _proto.reset = function reset() {
          this.rotation.set(0, 0, 0);
          this.startEuler.set(0, 0, 0);
          this.startRotation.set(0, 0, 0, 1);
          this.startRotated = false;
          this.deltaQuat.set(0, 0, 0, 1);
          this.deltaMat.identity();
          this.localMat.identity();
        };

        return Particle;
      }();
      Particle.INDENTIFY_NEG_QUAT = 10;
      Particle.R2D = 180.0 / Math.PI;
      var PARTICLE_MODULE_NAME = {
        COLOR: 'colorModule',
        FORCE: 'forceModule',
        LIMIT: 'limitModule',
        ROTATION: 'rotationModule',
        SIZE: 'sizeModule',
        VELOCITY: 'velocityModule',
        TEXTURE: 'textureModule',
        NOISE: 'noiseModule'
      };
      var PARTICLE_MODULE_ORDER = ['sizeModule', 'colorModule', 'forceModule', 'velocityModule', 'limitModule', 'rotationModule', 'textureModule', 'noiseModule'];
      var PARTICLE_MODULE_PROPERTY = ['_colorOverLifetimeModule', '_shapeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule', '_noiseModule', '_trailModule'];
      var ParticleModuleBase = function () {
        function ParticleModuleBase() {
          this.target = null;
          this.needUpdate = false;
          this.needAnimate = true;
          this.name = void 0;
        }

        var _proto2 = ParticleModuleBase.prototype;

        _proto2.bindTarget = function bindTarget(target) {
          this.target = target;
        };

        _proto2.update = function update(space, trans) {};

        return ParticleModuleBase;
      }();

      var Space = Enum({
        World: 0,
        Local: 1,
        Custom: 2
      });
      var CullingMode = Enum({
        Pause: 0,
        PauseAndCatchup: 1,
        AlwaysSimulate: 2
      });
      var AlignmentSpace = Enum({
        World: 0,
        Local: 1,
        View: 2
      });
      var RenderMode$1 = Enum({
        Billboard: 0,
        StrecthedBillboard: 1,
        HorizontalBillboard: 2,
        VerticalBillboard: 3,
        Mesh: 4
      });
      var ShapeType = Enum({
        Box: 0,
        Circle: 1,
        Cone: 2,
        Sphere: 3,
        Hemisphere: 4
      });
      var EmitLocation = Enum({
        Base: 0,
        Edge: 1,
        Shell: 2,
        Volume: 3
      });
      var ArcMode = Enum({
        Random: 0,
        Loop: 1,
        PingPong: 2
      });
      var TrailMode = Enum({
        Particles: 0
      });
      var TextureMode = Enum({
        Stretch: 0
      });
      var ModuleRandSeed = {
        LIMIT: 23541,
        SIZE: 39825,
        TEXTURE: 90794,
        COLOR: 91041,
        FORCE: 212165,
        ROTATION: 125292,
        VELOCITY_X: 197866,
        VELOCITY_Y: 156497,
        VELOCITY_Z: 984136
      };

      var _dec$R, _dec2$z, _dec3$v, _dec4$s, _class$S, _class2$K, _descriptor$G, _descriptor2$z, _temp$M;
      var COLOR_OVERTIME_RAND_OFFSET = ModuleRandSeed.COLOR;
      var ColorOvertimeModule = (_dec$R = ccclass('cc.ColorOvertimeModule'), _dec2$z = displayOrder(), _dec3$v = type(GradientRange), _dec4$s = displayOrder(), _dec$R(_class$S = (_class2$K = (_temp$M = function (_ParticleModuleBase) {
        _inheritsLoose(ColorOvertimeModule, _ParticleModuleBase);

        function ColorOvertimeModule() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_enable", _descriptor$G, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "color", _descriptor2$z, _assertThisInitialized(_this));

          _this.name = PARTICLE_MODULE_NAME.COLOR;
          return _this;
        }

        var _proto = ColorOvertimeModule.prototype;

        _proto.animate = function animate(particle) {
          particle.color.set(particle.startColor);
          particle.color.multiply(this.color.evaluate(1.0 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + COLOR_OVERTIME_RAND_OFFSET)));
        };

        _createClass(ColorOvertimeModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (this._enable === val) return;
            this._enable = val;
            if (!this.target) return;
            this.target.enableModule(this.name, val, this);
          }
        }]);

        return ColorOvertimeModule;
      }(ParticleModuleBase), _temp$M), (_descriptor$G = _applyDecoratedDescriptor(_class2$K.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$K.prototype, "enable", [_dec2$z], Object.getOwnPropertyDescriptor(_class2$K.prototype, "enable"), _class2$K.prototype), _descriptor2$z = _applyDecoratedDescriptor(_class2$K.prototype, "color", [_dec3$v, serializable, _dec4$s], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new GradientRange();
        }
      })), _class2$K)) || _class$S);

      var particleEmitZAxis = new Vec3(0, 0, -1);
      function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
        if (moduleSpace !== systemSpace) {
          if (systemSpace === Space.World) {
            Mat4.getRotation(outQuat, worldTransform);
          } else {
            Mat4.invert(worldTransform, worldTransform);
            Mat4.getRotation(outQuat, worldTransform);
          }

          return true;
        } else {
          Quat.set(outQuat, 0, 0, 0, 1);
          return false;
        }
      }
      function fixedAngleUnitVector2(out, theta) {
        Vec2.set(out, Math.cos(theta), Math.sin(theta));
      }
      function randomUnitVector(out) {
        var z = randomRange(-1, 1);
        var a = randomRange(0, 2 * Math.PI);
        var r = Math.sqrt(1 - z * z);
        var x = r * Math.cos(a);
        var y = r * Math.sin(a);
        Vec3.set(out, x, y, z);
      }
      function randomPointBetweenSphere(out, minRadius, maxRadius) {
        randomUnitVector(out);
        Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
      }
      function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
        fixedAngleUnitVector2(out, theta);
        out.z = 0;
        Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
      }
      function randomPointInCube(out, extents) {
        Vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
      }
      function randomSortArray(arr) {
        for (var i = 0; i < arr.length; i++) {
          var transpose = i + randomRangeInt(0, arr.length - i);
          var val = arr[transpose];
          arr[transpose] = arr[i];
          arr[i] = val;
        }
      }
      function randomSign() {
        var sgn = randomRange(-1, 1);

        if (sgn === 0) {
          sgn++;
        }

        return sign$1(sgn);
      }

      var _dec$S, _dec2$A, _dec3$w, _dec4$t, _dec5$q, _dec6$n, _dec7$l, _dec8$j, _dec9$f, _dec10$d, _dec11$b, _dec12$a, _dec13$a, _dec14$8, _dec15$8, _dec16$8, _dec17$7, _class$T, _class2$L, _descriptor$H, _descriptor2$A, _descriptor3$r, _descriptor4$m, _descriptor5$i, _temp$N;
      var FORCE_OVERTIME_RAND_OFFSET = ModuleRandSeed.FORCE;

      var _temp_v3 = new Vec3();

      var ForceOvertimeModule = (_dec$S = ccclass('cc.ForceOvertimeModule'), _dec2$A = displayOrder(), _dec3$w = type(CurveRange), _dec4$t = range(), _dec5$q = displayOrder(), _dec6$n = tooltip(), _dec7$l = type(CurveRange), _dec8$j = range(), _dec9$f = displayOrder(), _dec10$d = tooltip(), _dec11$b = type(CurveRange), _dec12$a = range(), _dec13$a = displayOrder(), _dec14$8 = tooltip(), _dec15$8 = type(Space), _dec16$8 = displayOrder(), _dec17$7 = tooltip(), _dec$S(_class$T = (_class2$L = (_temp$N = function (_ParticleModuleBase) {
        _inheritsLoose(ForceOvertimeModule, _ParticleModuleBase);

        function ForceOvertimeModule() {
          var _this;

          _this = _ParticleModuleBase.call(this) || this;

          _initializerDefineProperty(_this, "_enable", _descriptor$H, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "x", _descriptor2$A, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "y", _descriptor3$r, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "z", _descriptor4$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "space", _descriptor5$i, _assertThisInitialized(_this));

          _this.randomized = false;
          _this.rotation = void 0;
          _this.needTransform = void 0;
          _this.name = PARTICLE_MODULE_NAME.FORCE;
          _this.rotation = new Quat();
          _this.needTransform = false;
          _this.needUpdate = true;
          return _this;
        }

        var _proto = ForceOvertimeModule.prototype;

        _proto.update = function update(space, worldTransform) {
          this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        };

        _proto.animate = function animate(p, dt) {
          var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          var force = Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)));

          if (this.needTransform) {
            Vec3.transformQuat(force, force, this.rotation);
          }

          Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
          Vec3.copy(p.ultimateVelocity, p.velocity);
        };

        _createClass(ForceOvertimeModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (this._enable === val) return;
            this._enable = val;
            if (!this.target) return;
            this.target.enableModule(this.name, val, this);
          }
        }]);

        return ForceOvertimeModule;
      }(ParticleModuleBase), _temp$N), (_descriptor$H = _applyDecoratedDescriptor(_class2$L.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$L.prototype, "enable", [_dec2$A], Object.getOwnPropertyDescriptor(_class2$L.prototype, "enable"), _class2$L.prototype), _descriptor2$A = _applyDecoratedDescriptor(_class2$L.prototype, "x", [_dec3$w, serializable, _dec4$t, _dec5$q, _dec6$n], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor3$r = _applyDecoratedDescriptor(_class2$L.prototype, "y", [_dec7$l, serializable, _dec8$j, _dec9$f, _dec10$d], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor4$m = _applyDecoratedDescriptor(_class2$L.prototype, "z", [_dec11$b, serializable, _dec12$a, _dec13$a, _dec14$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor5$i = _applyDecoratedDescriptor(_class2$L.prototype, "space", [_dec15$8, serializable, _dec16$8, _dec17$7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Space.Local;
        }
      })), _class2$L)) || _class$T);

      var _dec$T, _dec2$B, _dec3$x, _dec4$u, _dec5$r, _dec6$o, _dec7$m, _dec8$k, _dec9$g, _dec10$e, _dec11$c, _dec12$b, _dec13$b, _dec14$9, _dec15$9, _dec16$9, _dec17$8, _dec18$7, _dec19$7, _dec20$7, _dec21$7, _dec22$6, _dec23$5, _dec24$5, _dec25$5, _dec26$5, _dec27$5, _dec28$4, _dec29$4, _class$U, _class2$M, _descriptor$I, _descriptor2$B, _descriptor3$s, _descriptor4$n, _descriptor5$j, _descriptor6$g, _descriptor7$c, _descriptor8$b, _temp$O;
      var LIMIT_VELOCITY_RAND_OFFSET = ModuleRandSeed.LIMIT;

      var _temp_v3$1 = new Vec3();

      var _temp_v3_1 = new Vec3();

      var LimitVelocityOvertimeModule = (_dec$T = ccclass('cc.LimitVelocityOvertimeModule'), _dec2$B = displayOrder(), _dec3$x = type(CurveRange), _dec4$u = range(), _dec5$r = displayOrder(), _dec6$o = tooltip(), _dec7$m = visible(), _dec8$k = type(CurveRange), _dec9$g = range(), _dec10$e = displayOrder(), _dec11$c = tooltip(), _dec12$b = visible(), _dec13$b = type(CurveRange), _dec14$9 = range(), _dec15$9 = displayOrder(), _dec16$9 = tooltip(), _dec17$8 = visible(), _dec18$7 = type(CurveRange), _dec19$7 = range(), _dec20$7 = displayOrder(), _dec21$7 = tooltip(), _dec22$6 = visible(), _dec23$5 = displayOrder(), _dec24$5 = tooltip(), _dec25$5 = displayOrder(), _dec26$5 = tooltip(), _dec27$5 = type(Space), _dec28$4 = displayOrder(), _dec29$4 = tooltip(), _dec$T(_class$U = (_class2$M = (_temp$O = function (_ParticleModuleBase) {
        _inheritsLoose(LimitVelocityOvertimeModule, _ParticleModuleBase);

        function LimitVelocityOvertimeModule() {
          var _this;

          _this = _ParticleModuleBase.call(this) || this;

          _initializerDefineProperty(_this, "_enable", _descriptor$I, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "limitX", _descriptor2$B, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "limitY", _descriptor3$s, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "limitZ", _descriptor4$n, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "limit", _descriptor5$j, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "dampen", _descriptor6$g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "separateAxes", _descriptor7$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "space", _descriptor8$b, _assertThisInitialized(_this));

          _this.drag = null;
          _this.multiplyDragByParticleSize = false;
          _this.multiplyDragByParticleVelocity = false;
          _this.name = PARTICLE_MODULE_NAME.LIMIT;
          _this.rotation = void 0;
          _this.needTransform = void 0;
          _this.rotation = new Quat();
          _this.needTransform = false;
          _this.needUpdate = true;
          return _this;
        }

        var _proto = LimitVelocityOvertimeModule.prototype;

        _proto.update = function update(space, worldTransform) {
          this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        };

        _proto.animate = function animate(p, dt) {
          var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          var dampedVel = _temp_v3$1;

          if (this.separateAxes) {
            Vec3.set(_temp_v3_1, this.limitX.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.limitY.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.limitZ.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)));

            if (this.needTransform) {
              Vec3.transformQuat(_temp_v3_1, _temp_v3_1, this.rotation);
            }

            Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, _temp_v3_1.x, this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, _temp_v3_1.y, this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, _temp_v3_1.z, this.dampen));
          } else {
            Vec3.normalize(dampedVel, p.ultimateVelocity);
            Vec3.multiplyScalar(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.length(), this.limit.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.dampen));
          }

          Vec3.copy(p.ultimateVelocity, dampedVel);
        };

        _createClass(LimitVelocityOvertimeModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (this._enable === val) return;
            this._enable = val;
            if (!this.target) return;
            this.target.enableModule(this.name, val, this);
          }
        }]);

        return LimitVelocityOvertimeModule;
      }(ParticleModuleBase), _temp$O), (_descriptor$I = _applyDecoratedDescriptor(_class2$M.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$M.prototype, "enable", [_dec2$B], Object.getOwnPropertyDescriptor(_class2$M.prototype, "enable"), _class2$M.prototype), _descriptor2$B = _applyDecoratedDescriptor(_class2$M.prototype, "limitX", [_dec3$x, serializable, _dec4$u, _dec5$r, _dec6$o, _dec7$m], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor3$s = _applyDecoratedDescriptor(_class2$M.prototype, "limitY", [_dec8$k, serializable, _dec9$g, _dec10$e, _dec11$c, _dec12$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor4$n = _applyDecoratedDescriptor(_class2$M.prototype, "limitZ", [_dec13$b, serializable, _dec14$9, _dec15$9, _dec16$9, _dec17$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor5$j = _applyDecoratedDescriptor(_class2$M.prototype, "limit", [_dec18$7, serializable, _dec19$7, _dec20$7, _dec21$7, _dec22$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor6$g = _applyDecoratedDescriptor(_class2$M.prototype, "dampen", [serializable, _dec23$5, _dec24$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 3;
        }
      }), _descriptor7$c = _applyDecoratedDescriptor(_class2$M.prototype, "separateAxes", [serializable, _dec25$5, _dec26$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor8$b = _applyDecoratedDescriptor(_class2$M.prototype, "space", [_dec27$5, serializable, _dec28$4, _dec29$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Space.Local;
        }
      })), _class2$M)) || _class$U);

      function dampenBeyondLimit(vel, limit, dampen) {
        var sgn = Math.sign(vel);
        var abs = Math.abs(vel);

        if (abs > limit) {
          abs = lerp(abs, limit, dampen);
        }

        return abs * sgn;
      }

      var _dec$U, _dec2$C, _dec3$y, _dec4$v, _dec5$s, _dec6$p, _dec7$n, _dec8$l, _dec9$h, _dec10$f, _dec11$d, _dec12$c, _dec13$c, _dec14$a, _dec15$a, _dec16$a, _dec17$9, _dec18$8, _class$V, _class2$N, _descriptor$J, _descriptor2$C, _descriptor3$t, _descriptor4$o, _descriptor5$k, _temp$P;
      var ROTATION_OVERTIME_RAND_OFFSET = ModuleRandSeed.ROTATION;
      var RotationOvertimeModule = (_dec$U = ccclass('cc.RotationOvertimeModule'), _dec2$C = displayOrder(), _dec3$y = displayOrder(), _dec4$v = tooltip(), _dec5$s = type(CurveRange), _dec6$p = range(), _dec7$n = displayOrder(), _dec8$l = tooltip(), _dec9$h = visible(), _dec10$f = type(CurveRange), _dec11$d = range(), _dec12$c = displayOrder(), _dec13$c = tooltip(), _dec14$a = visible(), _dec15$a = type(CurveRange), _dec16$a = range(), _dec17$9 = displayOrder(), _dec18$8 = tooltip(), _dec$U(_class$V = (_class2$N = (_temp$P = function (_ParticleModuleBase) {
        _inheritsLoose(RotationOvertimeModule, _ParticleModuleBase);

        function RotationOvertimeModule() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_enable", _descriptor$J, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_separateAxes", _descriptor2$C, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "x", _descriptor3$t, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "y", _descriptor4$o, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "z", _descriptor5$k, _assertThisInitialized(_this));

          _this.name = PARTICLE_MODULE_NAME.ROTATION;
          _this._startMat = new Mat4();
          _this._matRot = new Mat4();
          _this._quatRot = new Quat();
          _this._otherEuler = new Vec3();
          return _this;
        }

        var _proto = RotationOvertimeModule.prototype;

        _proto._processRotation = function _processRotation(p, r2d) {
          var renderMode = p.particleSystem.processor.getInfo().renderMode;

          if (renderMode !== RenderMode$1.Mesh) {
            if (renderMode === RenderMode$1.StrecthedBillboard) {
              this._quatRot.set(0, 0, 0, 1);
            }
          }

          Quat.normalize(this._quatRot, this._quatRot);

          if (this._quatRot.w < 0.0) {
            this._quatRot.x += Particle.INDENTIFY_NEG_QUAT;
          }
        };

        _proto.animate = function animate(p, dt) {
          var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          var rotationRand = pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET);
          var renderMode = p.particleSystem.processor.getInfo().renderMode;

          if (!this._separateAxes || renderMode === RenderMode$1.VerticalBillboard || renderMode === RenderMode$1.HorizontalBillboard) {
            Quat.fromEuler(p.deltaQuat, 0, 0, this.z.evaluate(normalizedTime, rotationRand) * dt * Particle.R2D);
          } else {
            Quat.fromEuler(p.deltaQuat, this.x.evaluate(normalizedTime, rotationRand) * dt * Particle.R2D, this.y.evaluate(normalizedTime, rotationRand) * dt * Particle.R2D, this.z.evaluate(normalizedTime, rotationRand) * dt * Particle.R2D);
          }

          p.deltaMat = Mat4.fromQuat(p.deltaMat, p.deltaQuat);
          p.localMat = p.localMat.multiply(p.deltaMat);

          if (!p.startRotated) {
            if (renderMode !== RenderMode$1.Mesh) {
              if (renderMode === RenderMode$1.StrecthedBillboard) {
                p.startEuler.set(0, 0, 0);
              } else if (renderMode !== RenderMode$1.Billboard) {
                p.startEuler.set(0, 0, p.startEuler.z);
              }
            }

            Quat.fromEuler(p.startRotation, p.startEuler.x * Particle.R2D, p.startEuler.y * Particle.R2D, p.startEuler.z * Particle.R2D);
            p.startRotated = true;
          }

          this._startMat = Mat4.fromQuat(this._startMat, p.startRotation);
          this._matRot = this._startMat.multiply(p.localMat);
          Mat4.getRotation(this._quatRot, this._matRot);

          this._processRotation(p, Particle.R2D);

          p.rotation.set(this._quatRot.x, this._quatRot.y, this._quatRot.z);
        };

        _createClass(RotationOvertimeModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (this._enable === val) return;
            this._enable = val;
            if (!this.target) return;
            this.target.enableModule(this.name, val, this);
          }
        }, {
          key: "separateAxes",
          get: function get() {
            return this._separateAxes;
          },
          set: function set(val) {
            this._separateAxes = val;
          }
        }]);

        return RotationOvertimeModule;
      }(ParticleModuleBase), _temp$P), (_descriptor$J = _applyDecoratedDescriptor(_class2$N.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$N.prototype, "enable", [_dec2$C], Object.getOwnPropertyDescriptor(_class2$N.prototype, "enable"), _class2$N.prototype), _descriptor2$C = _applyDecoratedDescriptor(_class2$N.prototype, "_separateAxes", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$N.prototype, "separateAxes", [_dec3$y, _dec4$v], Object.getOwnPropertyDescriptor(_class2$N.prototype, "separateAxes"), _class2$N.prototype), _descriptor3$t = _applyDecoratedDescriptor(_class2$N.prototype, "x", [_dec5$s, serializable, _dec6$p, radian, _dec7$n, _dec8$l, _dec9$h], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor4$o = _applyDecoratedDescriptor(_class2$N.prototype, "y", [_dec10$f, serializable, _dec11$d, radian, _dec12$c, _dec13$c, _dec14$a], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor5$k = _applyDecoratedDescriptor(_class2$N.prototype, "z", [_dec15$a, serializable, _dec16$a, radian, _dec17$9, _dec18$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      })), _class2$N)) || _class$V);

      var _dec$V, _dec2$D, _dec3$z, _dec4$w, _dec5$t, _dec6$q, _dec7$o, _dec8$m, _dec9$i, _dec10$g, _dec11$e, _dec12$d, _dec13$d, _dec14$b, _dec15$b, _dec16$b, _dec17$a, _dec18$9, _dec19$8, _dec20$8, _dec21$8, _dec22$7, _dec23$6, _dec24$6, _class$W, _class2$O, _descriptor$K, _descriptor2$D, _descriptor3$u, _descriptor4$p, _descriptor5$l, _descriptor6$h, _temp$Q;
      var SIZE_OVERTIME_RAND_OFFSET = ModuleRandSeed.SIZE;
      var SizeOvertimeModule = (_dec$V = ccclass('cc.SizeOvertimeModule'), _dec2$D = displayOrder(), _dec3$z = displayOrder(), _dec4$w = tooltip(), _dec5$t = type(CurveRange), _dec6$q = range(), _dec7$o = displayOrder(), _dec8$m = tooltip(), _dec9$i = visible(), _dec10$g = type(CurveRange), _dec11$e = range(), _dec12$d = displayOrder(), _dec13$d = tooltip(), _dec14$b = visible(), _dec15$b = type(CurveRange), _dec16$b = range(), _dec17$a = displayOrder(), _dec18$9 = tooltip(), _dec19$8 = visible(), _dec20$8 = type(CurveRange), _dec21$8 = range(), _dec22$7 = displayOrder(), _dec23$6 = tooltip(), _dec24$6 = visible(), _dec$V(_class$W = (_class2$O = (_temp$Q = function (_ParticleModuleBase) {
        _inheritsLoose(SizeOvertimeModule, _ParticleModuleBase);

        function SizeOvertimeModule() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_enable", _descriptor$K, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "separateAxes", _descriptor2$D, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "size", _descriptor3$u, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "x", _descriptor4$p, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "y", _descriptor5$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "z", _descriptor6$h, _assertThisInitialized(_this));

          _this.name = PARTICLE_MODULE_NAME.SIZE;
          return _this;
        }

        var _proto = SizeOvertimeModule.prototype;

        _proto.animate = function animate(particle, dt) {
          if (!this.separateAxes) {
            Vec3.multiplyScalar(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET)));
          } else {
            var currLifetime = 1 - particle.remainingLifetime / particle.startLifetime;
            var sizeRand = pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET);
            particle.size.x = particle.startSize.x * this.x.evaluate(currLifetime, sizeRand);
            particle.size.y = particle.startSize.y * this.y.evaluate(currLifetime, sizeRand);
            particle.size.z = particle.startSize.z * this.z.evaluate(currLifetime, sizeRand);
          }
        };

        _createClass(SizeOvertimeModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (this._enable === val) return;
            this._enable = val;
            if (!this.target) return;
            this.target.enableModule(this.name, val, this);
          }
        }]);

        return SizeOvertimeModule;
      }(ParticleModuleBase), _temp$Q), (_descriptor$K = _applyDecoratedDescriptor(_class2$O.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$O.prototype, "enable", [_dec2$D], Object.getOwnPropertyDescriptor(_class2$O.prototype, "enable"), _class2$O.prototype), _descriptor2$D = _applyDecoratedDescriptor(_class2$O.prototype, "separateAxes", [serializable, _dec3$z, _dec4$w], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor3$u = _applyDecoratedDescriptor(_class2$O.prototype, "size", [_dec5$t, serializable, _dec6$q, _dec7$o, _dec8$m, _dec9$i], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor4$p = _applyDecoratedDescriptor(_class2$O.prototype, "x", [_dec10$g, serializable, _dec11$e, _dec12$d, _dec13$d, _dec14$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor5$l = _applyDecoratedDescriptor(_class2$O.prototype, "y", [_dec15$b, serializable, _dec16$b, _dec17$a, _dec18$9, _dec19$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor6$h = _applyDecoratedDescriptor(_class2$O.prototype, "z", [_dec20$8, serializable, _dec21$8, _dec22$7, _dec23$6, _dec24$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      })), _class2$O)) || _class$W);

      var _dec$W, _dec2$E, _dec3$A, _dec4$x, _dec5$u, _dec6$r, _dec7$p, _dec8$n, _dec9$j, _dec10$h, _dec11$f, _dec12$e, _dec13$e, _dec14$c, _dec15$c, _dec16$c, _dec17$b, _dec18$a, _dec19$9, _dec20$9, _dec21$9, _dec22$8, _dec23$7, _dec24$7, _dec25$6, _dec26$6, _dec27$6, _dec28$5, _dec29$5, _class$X, _class2$P, _descriptor$L, _descriptor2$E, _descriptor3$v, _descriptor4$q, _descriptor5$m, _descriptor6$i, _descriptor7$d, _descriptor8$c, _descriptor9$9, _descriptor10$8, _descriptor11$5, _descriptor12$5, _descriptor13$5, _temp$R;
      var TEXTURE_ANIMATION_RAND_OFFSET = ModuleRandSeed.TEXTURE;
      var Mode$3 = Enum({
        Grid: 0
      });
      var Animation$1 = Enum({
        WholeSheet: 0,
        SingleRow: 1
      });
      var TextureAnimationModule = (_dec$W = ccclass('cc.TextureAnimationModule'), _dec2$E = formerlySerializedAs('numTilesX'), _dec3$A = formerlySerializedAs('numTilesY'), _dec4$x = displayOrder(), _dec5$u = type(Mode$3), _dec6$r = type(Mode$3), _dec7$p = displayOrder(), _dec8$n = tooltip(), _dec9$j = displayOrder(), _dec10$h = tooltip(), _dec11$f = displayOrder(), _dec12$e = tooltip(), _dec13$e = type(Animation$1), _dec14$c = displayOrder(), _dec15$c = tooltip(), _dec16$c = type(CurveRange), _dec17$b = range(), _dec18$a = displayOrder(), _dec19$9 = tooltip(), _dec20$9 = type(CurveRange), _dec21$9 = range(), _dec22$8 = displayOrder(), _dec23$7 = tooltip(), _dec24$7 = displayOrder(), _dec25$6 = tooltip(), _dec26$6 = displayOrder(), _dec27$6 = tooltip(), _dec28$5 = displayOrder(), _dec29$5 = tooltip(), _dec$W(_class$X = (_class2$P = (_temp$R = function (_ParticleModuleBase) {
        _inheritsLoose(TextureAnimationModule, _ParticleModuleBase);

        function TextureAnimationModule() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_enable", _descriptor$L, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_numTilesX", _descriptor2$E, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_numTilesY", _descriptor3$v, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mode", _descriptor4$q, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "animation", _descriptor5$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "frameOverTime", _descriptor6$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startFrame", _descriptor7$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "cycleCount", _descriptor8$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_flipU", _descriptor9$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_flipV", _descriptor10$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_uvChannelMask", _descriptor11$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "randomRow", _descriptor12$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "rowIndex", _descriptor13$5, _assertThisInitialized(_this));

          _this.name = PARTICLE_MODULE_NAME.TEXTURE;
          return _this;
        }

        var _proto = TextureAnimationModule.prototype;

        _proto.init = function init(p) {
          p.startRow = Math.floor(Math.random() * this.numTilesY);
        };

        _proto.animate = function animate(p, dt) {
          var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          var startFrame = this.startFrame.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) / (this.numTilesX * this.numTilesY);

          if (this.animation === Animation$1.WholeSheet) {
            p.frameIndex = repeat$1(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1);
          } else if (this.animation === Animation$1.SingleRow) {
            var rowLength = 1 / this.numTilesY;

            if (this.randomRow) {
              var f = repeat$1(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1);
              var from = p.startRow * rowLength;
              var to = from + rowLength;
              p.frameIndex = lerp(from, to, f);
            } else {
              var _from = this.rowIndex * rowLength;

              var _to = _from + rowLength;

              p.frameIndex = lerp(_from, _to, repeat$1(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1));
            }
          }
        };

        _createClass(TextureAnimationModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (this._enable === val) return;
            this._enable = val;
            if (!this.target) return;
            this.target.updateMaterialParams();
            this.target.enableModule(this.name, val, this);
          }
        }, {
          key: "mode",
          get: function get() {
            return this._mode;
          },
          set: function set(val) {
            if (val !== Mode$3.Grid) {
              console.error('particle texture animation\'s sprites is not supported!');
            }
          }
        }, {
          key: "numTilesX",
          get: function get() {
            return this._numTilesX;
          },
          set: function set(val) {
            if (this._numTilesX !== val) {
              this._numTilesX = val;
              this.target.updateMaterialParams();
            }
          }
        }, {
          key: "numTilesY",
          get: function get() {
            return this._numTilesY;
          },
          set: function set(val) {
            if (this._numTilesY !== val) {
              this._numTilesY = val;
              this.target.updateMaterialParams();
            }
          }
        }, {
          key: "flipU",
          get: function get() {
            return this._flipU;
          },
          set: function set(val) {
            console.error('particle texture animation\'s flipU is not supported!');
          }
        }, {
          key: "flipV",
          get: function get() {
            return this._flipV;
          },
          set: function set(val) {
            console.error('particle texture animation\'s flipV is not supported!');
          }
        }, {
          key: "uvChannelMask",
          get: function get() {
            return this._uvChannelMask;
          },
          set: function set(val) {
            console.error('particle texture animation\'s uvChannelMask is not supported!');
          }
        }]);

        return TextureAnimationModule;
      }(ParticleModuleBase), _temp$R), (_descriptor$L = _applyDecoratedDescriptor(_class2$P.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor2$E = _applyDecoratedDescriptor(_class2$P.prototype, "_numTilesX", [_dec2$E], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor3$v = _applyDecoratedDescriptor(_class2$P.prototype, "_numTilesY", [_dec3$A], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$P.prototype, "enable", [_dec4$x], Object.getOwnPropertyDescriptor(_class2$P.prototype, "enable"), _class2$P.prototype), _descriptor4$q = _applyDecoratedDescriptor(_class2$P.prototype, "_mode", [_dec5$u], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Mode$3.Grid;
        }
      }), _applyDecoratedDescriptor(_class2$P.prototype, "mode", [_dec6$r, _dec7$p, _dec8$n], Object.getOwnPropertyDescriptor(_class2$P.prototype, "mode"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "numTilesX", [_dec9$j, _dec10$h], Object.getOwnPropertyDescriptor(_class2$P.prototype, "numTilesX"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "numTilesY", [_dec11$f, _dec12$e], Object.getOwnPropertyDescriptor(_class2$P.prototype, "numTilesY"), _class2$P.prototype), _descriptor5$m = _applyDecoratedDescriptor(_class2$P.prototype, "animation", [_dec13$e, serializable, _dec14$c, _dec15$c], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Animation$1.WholeSheet;
        }
      }), _descriptor6$i = _applyDecoratedDescriptor(_class2$P.prototype, "frameOverTime", [_dec16$c, serializable, _dec17$b, _dec18$a, _dec19$9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor7$d = _applyDecoratedDescriptor(_class2$P.prototype, "startFrame", [_dec20$9, serializable, _dec21$9, _dec22$8, _dec23$7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor8$c = _applyDecoratedDescriptor(_class2$P.prototype, "cycleCount", [serializable, _dec24$7, _dec25$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor9$9 = _applyDecoratedDescriptor(_class2$P.prototype, "_flipU", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor10$8 = _applyDecoratedDescriptor(_class2$P.prototype, "_flipV", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor11$5 = _applyDecoratedDescriptor(_class2$P.prototype, "_uvChannelMask", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -1;
        }
      }), _descriptor12$5 = _applyDecoratedDescriptor(_class2$P.prototype, "randomRow", [serializable, _dec26$6, _dec27$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor13$5 = _applyDecoratedDescriptor(_class2$P.prototype, "rowIndex", [serializable, _dec28$5, _dec29$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$P)) || _class$X);

      var _dec$X, _dec2$F, _dec3$B, _dec4$y, _dec5$v, _dec6$s, _dec7$q, _dec8$o, _dec9$k, _dec10$i, _dec11$g, _dec12$f, _dec13$f, _dec14$d, _dec15$d, _dec16$d, _dec17$c, _dec18$b, _dec19$a, _dec20$a, _dec21$a, _class$Y, _class2$Q, _descriptor$M, _descriptor2$F, _descriptor3$w, _descriptor4$r, _descriptor5$n, _descriptor6$j, _temp$S;
      var VELOCITY_X_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_X;
      var VELOCITY_Y_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_Y;
      var VELOCITY_Z_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_Z;

      var _temp_v3$2 = new Vec3();

      var VelocityOvertimeModule = (_dec$X = ccclass('cc.VelocityOvertimeModule'), _dec2$F = displayOrder(), _dec3$B = type(CurveRange), _dec4$y = range(), _dec5$v = displayOrder(), _dec6$s = tooltip(), _dec7$q = type(CurveRange), _dec8$o = range(), _dec9$k = displayOrder(), _dec10$i = tooltip(), _dec11$g = type(CurveRange), _dec12$f = range(), _dec13$f = displayOrder(), _dec14$d = tooltip(), _dec15$d = type(CurveRange), _dec16$d = range(), _dec17$c = displayOrder(), _dec18$b = tooltip(), _dec19$a = type(Space), _dec20$a = displayOrder(), _dec21$a = tooltip(), _dec$X(_class$Y = (_class2$Q = (_temp$S = function (_ParticleModuleBase) {
        _inheritsLoose(VelocityOvertimeModule, _ParticleModuleBase);

        function VelocityOvertimeModule() {
          var _this;

          _this = _ParticleModuleBase.call(this) || this;

          _initializerDefineProperty(_this, "_enable", _descriptor$M, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "x", _descriptor2$F, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "y", _descriptor3$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "z", _descriptor4$r, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "speedModifier", _descriptor5$n, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "space", _descriptor6$j, _assertThisInitialized(_this));

          _this.rotation = void 0;
          _this.needTransform = void 0;
          _this.name = PARTICLE_MODULE_NAME.VELOCITY;
          _this.rotation = new Quat();
          _this.speedModifier.constant = 1;
          _this.needTransform = false;
          _this.needUpdate = true;
          return _this;
        }

        var _proto = VelocityOvertimeModule.prototype;

        _proto.update = function update(space, worldTransform) {
          this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        };

        _proto.animate = function animate(p, dt) {
          var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          var vel = Vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_X_OVERTIME_RAND_OFFSET)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_Y_OVERTIME_RAND_OFFSET)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_Z_OVERTIME_RAND_OFFSET)));

          if (this.needTransform) {
            Vec3.transformQuat(vel, vel, this.rotation);
          }

          Vec3.add(p.animatedVelocity, p.animatedVelocity, vel);
          Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity);
          Vec3.multiplyScalar(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed + VELOCITY_X_OVERTIME_RAND_OFFSET)));
        };

        _createClass(VelocityOvertimeModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (this._enable === val) return;
            this._enable = val;
            if (!this.target) return;
            this.target.enableModule(this.name, val, this);
          }
        }]);

        return VelocityOvertimeModule;
      }(ParticleModuleBase), _temp$S), (_descriptor$M = _applyDecoratedDescriptor(_class2$Q.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$Q.prototype, "enable", [_dec2$F], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "enable"), _class2$Q.prototype), _descriptor2$F = _applyDecoratedDescriptor(_class2$Q.prototype, "x", [_dec3$B, serializable, _dec4$y, _dec5$v, _dec6$s], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor3$w = _applyDecoratedDescriptor(_class2$Q.prototype, "y", [_dec7$q, serializable, _dec8$o, _dec9$k, _dec10$i], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor4$r = _applyDecoratedDescriptor(_class2$Q.prototype, "z", [_dec11$g, serializable, _dec12$f, _dec13$f, _dec14$d], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor5$n = _applyDecoratedDescriptor(_class2$Q.prototype, "speedModifier", [_dec15$d, serializable, _dec16$d, _dec17$c, _dec18$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor6$j = _applyDecoratedDescriptor(_class2$Q.prototype, "space", [_dec19$a, serializable, _dec20$a, _dec21$a], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Space.Local;
        }
      })), _class2$Q)) || _class$Y);

      var _dec$Y, _dec2$G, _dec3$C, _class$Z, _class2$R, _descriptor$N, _descriptor2$G, _descriptor3$x, _descriptor4$s, _temp$T;
      var Burst = exports('Burst', (_dec$Y = ccclass('cc.Burst'), _dec2$G = type(CurveRange), _dec3$C = range(), _dec$Y(_class$Z = (_class2$R = (_temp$T = function () {
        function Burst() {
          _initializerDefineProperty(this, "_time", _descriptor$N, this);

          _initializerDefineProperty(this, "_repeatCount", _descriptor2$G, this);

          _initializerDefineProperty(this, "repeatInterval", _descriptor3$x, this);

          _initializerDefineProperty(this, "count", _descriptor4$s, this);

          this._remainingCount = void 0;
          this._curTime = void 0;
          this._remainingCount = 0;
          this._curTime = 0.0;
        }

        var _proto = Burst.prototype;

        _proto.update = function update(psys, dt) {
          if (this._remainingCount === 0) {
            this._remainingCount = this._repeatCount;
            this._curTime = this._time;
          }

          if (this._remainingCount > 0) {
            var preFrameTime = repeat$1(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
            preFrameTime = preFrameTime > 0.0 ? preFrameTime : 0.0;
            var curFrameTime = repeat$1(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);

            if (this._curTime >= preFrameTime && this._curTime < curFrameTime) {
              psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime));
              this._curTime += this.repeatInterval;
              --this._remainingCount;
            }
          }
        };

        _proto.reset = function reset() {
          this._remainingCount = 0;
          this._curTime = 0.0;
        };

        _proto.getMaxCount = function getMaxCount(psys) {
          return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
        };

        _createClass(Burst, [{
          key: "time",
          get: function get() {
            return this._time;
          },
          set: function set(val) {
            this._time = val;
            this._curTime = val;
          }
        }, {
          key: "repeatCount",
          get: function get() {
            return this._repeatCount;
          },
          set: function set(val) {
            this._repeatCount = val;
            this._remainingCount = val;
          }
        }]);

        return Burst;
      }(), _temp$T), (_descriptor$N = _applyDecoratedDescriptor(_class2$R.prototype, "_time", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$R.prototype, "time", [editable], Object.getOwnPropertyDescriptor(_class2$R.prototype, "time"), _class2$R.prototype), _descriptor2$G = _applyDecoratedDescriptor(_class2$R.prototype, "_repeatCount", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _applyDecoratedDescriptor(_class2$R.prototype, "repeatCount", [editable], Object.getOwnPropertyDescriptor(_class2$R.prototype, "repeatCount"), _class2$R.prototype), _descriptor3$x = _applyDecoratedDescriptor(_class2$R.prototype, "repeatInterval", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor4$s = _applyDecoratedDescriptor(_class2$R.prototype, "count", [_dec2$G, serializable, _dec3$C], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      })), _class2$R)) || _class$Z));

      var _dec$Z, _dec2$H, _dec3$D, _dec4$z, _dec5$w, _dec6$t, _dec7$r, _dec8$p, _dec9$l, _dec10$j, _dec11$h, _dec12$g, _dec13$g, _dec14$e, _dec15$e, _dec16$e, _dec17$d, _dec18$c, _dec19$b, _dec20$b, _dec21$b, _dec22$9, _dec23$8, _dec24$8, _dec25$7, _dec26$7, _dec27$7, _dec28$6, _dec29$6, _dec30$4, _dec31$4, _dec32$3, _dec33$2, _dec34$2, _dec35$2, _dec36$2, _dec37$2, _dec38$2, _dec39$2, _dec40$2, _dec41$2, _dec42$2, _dec43$2, _dec44$2, _dec45$2, _dec46$1, _dec47$1, _dec48$1, _dec49$1, _dec50$1, _dec51$1, _dec52$1, _dec53$1, _dec54$1, _dec55$1, _dec56$1, _dec57$1, _class$_, _class2$S, _descriptor$O, _descriptor2$H, _descriptor3$y, _descriptor4$t, _descriptor5$o, _descriptor6$k, _descriptor7$e, _descriptor8$d, _descriptor9$a, _descriptor10$9, _descriptor11$6, _descriptor12$6, _descriptor13$6, _descriptor14$2, _descriptor15$2, _descriptor16$2, _descriptor17$1, _descriptor18, _descriptor19, _temp$U;

      var _intermediVec = new Vec3(0, 0, 0);

      var _intermediArr = [];

      var _unitBoxExtent = new Vec3(0.5, 0.5, 0.5);

      var ShapeModule = (_dec$Z = ccclass('cc.ShapeModule'), _dec2$H = displayOrder(), _dec3$D = tooltip(), _dec4$z = displayOrder(), _dec5$w = tooltip(), _dec6$t = displayOrder(), _dec7$r = tooltip(), _dec8$p = displayOrder(), _dec9$l = tooltip(), _dec10$j = visible(), _dec11$h = displayOrder(), _dec12$g = tooltip(), _dec13$g = visible(), _dec14$e = displayOrder(), _dec15$e = type(ShapeType), _dec16$e = formerlySerializedAs('shapeType'), _dec17$d = displayOrder(), _dec18$c = type(ShapeType), _dec19$b = tooltip(), _dec20$b = type(EmitLocation), _dec21$b = displayOrder(), _dec22$9 = tooltip(), _dec23$8 = visible(), _dec24$8 = displayOrder(), _dec25$7 = tooltip(), _dec26$7 = displayOrder(), _dec27$7 = tooltip(), _dec28$6 = displayOrder(), _dec29$6 = tooltip(), _dec30$4 = displayOrder(), _dec31$4 = tooltip(), _dec32$3 = displayOrder(), _dec33$2 = tooltip(), _dec34$2 = visible(), _dec35$2 = displayOrder(), _dec36$2 = tooltip(), _dec37$2 = visible(), _dec38$2 = type(ArcMode), _dec39$2 = displayOrder(), _dec40$2 = tooltip(), _dec41$2 = visible(), _dec42$2 = visible(), _dec43$2 = displayOrder(), _dec44$2 = tooltip(), _dec45$2 = visible(), _dec46$1 = type(CurveRange), _dec47$1 = visible(), _dec48$1 = range(), _dec49$1 = displayOrder(), _dec50$1 = tooltip(), _dec51$1 = visible(), _dec52$1 = displayOrder(), _dec53$1 = tooltip(), _dec54$1 = visible(), _dec55$1 = displayOrder(), _dec56$1 = tooltip(), _dec57$1 = visible(), _dec$Z(_class$_ = (_class2$S = (_temp$U = function () {
        function ShapeModule() {
          _initializerDefineProperty(this, "_enable", _descriptor$O, this);

          _initializerDefineProperty(this, "_shapeType", _descriptor2$H, this);

          _initializerDefineProperty(this, "emitFrom", _descriptor3$y, this);

          _initializerDefineProperty(this, "alignToDirection", _descriptor4$t, this);

          _initializerDefineProperty(this, "randomDirectionAmount", _descriptor5$o, this);

          _initializerDefineProperty(this, "sphericalDirectionAmount", _descriptor6$k, this);

          _initializerDefineProperty(this, "randomPositionAmount", _descriptor7$e, this);

          _initializerDefineProperty(this, "radius", _descriptor8$d, this);

          _initializerDefineProperty(this, "radiusThickness", _descriptor9$a, this);

          _initializerDefineProperty(this, "arcMode", _descriptor10$9, this);

          _initializerDefineProperty(this, "arcSpread", _descriptor11$6, this);

          _initializerDefineProperty(this, "arcSpeed", _descriptor12$6, this);

          _initializerDefineProperty(this, "length", _descriptor13$6, this);

          _initializerDefineProperty(this, "boxThickness", _descriptor14$2, this);

          _initializerDefineProperty(this, "_position", _descriptor15$2, this);

          _initializerDefineProperty(this, "_rotation", _descriptor16$2, this);

          _initializerDefineProperty(this, "_scale", _descriptor17$1, this);

          _initializerDefineProperty(this, "_arc", _descriptor18, this);

          _initializerDefineProperty(this, "_angle", _descriptor19, this);

          this.mat = void 0;
          this.quat = void 0;
          this.particleSystem = void 0;
          this.lastTime = void 0;
          this.totalAngle = void 0;
          this.mat = new Mat4();
          this.quat = new Quat();
          this.particleSystem = null;
          this.lastTime = 0;
          this.totalAngle = 0;
        }

        var _proto = ShapeModule.prototype;

        _proto.onInit = function onInit(ps) {
          this.particleSystem = ps;
          this.constructMat();
          this.lastTime = this.particleSystem._time;
        };

        _proto.emit = function emit(p) {
          switch (this.shapeType) {
            case ShapeType.Box:
              boxEmit(this.emitFrom, this.boxThickness, p.position, p.velocity);
              break;

            case ShapeType.Circle:
              circleEmit(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
              break;

            case ShapeType.Cone:
              coneEmit(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
              break;

            case ShapeType.Sphere:
              sphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
              break;

            case ShapeType.Hemisphere:
              hemisphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
              break;

            default:
              console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
          }

          if (this.randomPositionAmount > 0) {
            p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
            p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
            p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
          }

          Vec3.transformQuat(p.velocity, p.velocity, this.quat);
          Vec3.transformMat4(p.position, p.position, this.mat);

          if (this.sphericalDirectionAmount > 0) {
            var sphericalVel = Vec3.normalize(_intermediVec, p.position);
            Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
          }

          this.lastTime = this.particleSystem._time;
        };

        _proto.constructMat = function constructMat() {
          Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z);
          Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
        };

        _proto.generateArcAngle = function generateArcAngle() {
          if (this.arcMode === ArcMode.Random) {
            return randomRange(0, this._arc);
          }

          var angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
          this.totalAngle = angle;

          if (this.arcSpread !== 0) {
            angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread;
          }

          switch (this.arcMode) {
            case ArcMode.Loop:
              return repeat$1(angle, this._arc);

            case ArcMode.PingPong:
              return pingPong(angle, this._arc);

            default:
              return repeat$1(angle, this._arc);
          }
        };

        _createClass(ShapeModule, [{
          key: "position",
          get: function get() {
            return this._position;
          },
          set: function set(val) {
            this._position = val;
            this.constructMat();
          }
        }, {
          key: "rotation",
          get: function get() {
            return this._rotation;
          },
          set: function set(val) {
            this._rotation = val;
            this.constructMat();
          }
        }, {
          key: "scale",
          get: function get() {
            return this._scale;
          },
          set: function set(val) {
            this._scale = val;
            this.constructMat();
          }
        }, {
          key: "arc",
          get: function get() {
            return toDegree(this._arc);
          },
          set: function set(val) {
            this._arc = toRadian(val);
          }
        }, {
          key: "angle",
          get: function get() {
            return Math.round(toDegree(this._angle) * 100) / 100;
          },
          set: function set(val) {
            this._angle = toRadian(val);
          }
        }, {
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            this._enable = val;
          }
        }, {
          key: "shapeType",
          get: function get() {
            return this._shapeType;
          },
          set: function set(val) {
            this._shapeType = val;

            switch (this._shapeType) {
              case ShapeType.Box:
                if (this.emitFrom === EmitLocation.Base) {
                  this.emitFrom = EmitLocation.Volume;
                }

                break;

              case ShapeType.Cone:
                if (this.emitFrom === EmitLocation.Edge) {
                  this.emitFrom = EmitLocation.Base;
                }

                break;

              case ShapeType.Sphere:
              case ShapeType.Hemisphere:
                if (this.emitFrom === EmitLocation.Base || this.emitFrom === EmitLocation.Edge) {
                  this.emitFrom = EmitLocation.Volume;
                }

                break;
            }
          }
        }]);

        return ShapeModule;
      }(), _temp$U), (_applyDecoratedDescriptor(_class2$S.prototype, "position", [_dec2$H, _dec3$D], Object.getOwnPropertyDescriptor(_class2$S.prototype, "position"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "rotation", [_dec4$z, _dec5$w], Object.getOwnPropertyDescriptor(_class2$S.prototype, "rotation"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "scale", [_dec6$t, _dec7$r], Object.getOwnPropertyDescriptor(_class2$S.prototype, "scale"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "arc", [_dec8$p, _dec9$l, _dec10$j], Object.getOwnPropertyDescriptor(_class2$S.prototype, "arc"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "angle", [_dec11$h, _dec12$g, _dec13$g], Object.getOwnPropertyDescriptor(_class2$S.prototype, "angle"), _class2$S.prototype), _descriptor$O = _applyDecoratedDescriptor(_class2$S.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$S.prototype, "enable", [_dec14$e], Object.getOwnPropertyDescriptor(_class2$S.prototype, "enable"), _class2$S.prototype), _descriptor2$H = _applyDecoratedDescriptor(_class2$S.prototype, "_shapeType", [_dec15$e, _dec16$e, _dec17$d], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ShapeType.Cone;
        }
      }), _applyDecoratedDescriptor(_class2$S.prototype, "shapeType", [_dec18$c, _dec19$b], Object.getOwnPropertyDescriptor(_class2$S.prototype, "shapeType"), _class2$S.prototype), _descriptor3$y = _applyDecoratedDescriptor(_class2$S.prototype, "emitFrom", [_dec20$b, serializable, _dec21$b, _dec22$9, _dec23$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return EmitLocation.Volume;
        }
      }), _descriptor4$t = _applyDecoratedDescriptor(_class2$S.prototype, "alignToDirection", [serializable, _dec24$8, _dec25$7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor5$o = _applyDecoratedDescriptor(_class2$S.prototype, "randomDirectionAmount", [serializable, _dec26$7, _dec27$7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor6$k = _applyDecoratedDescriptor(_class2$S.prototype, "sphericalDirectionAmount", [serializable, _dec28$6, _dec29$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$e = _applyDecoratedDescriptor(_class2$S.prototype, "randomPositionAmount", [serializable, _dec30$4, _dec31$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8$d = _applyDecoratedDescriptor(_class2$S.prototype, "radius", [serializable, _dec32$3, _dec33$2, _dec34$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor9$a = _applyDecoratedDescriptor(_class2$S.prototype, "radiusThickness", [serializable, _dec35$2, _dec36$2, _dec37$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor10$9 = _applyDecoratedDescriptor(_class2$S.prototype, "arcMode", [_dec38$2, serializable, _dec39$2, _dec40$2, _dec41$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ArcMode.Random;
        }
      }), _descriptor11$6 = _applyDecoratedDescriptor(_class2$S.prototype, "arcSpread", [_dec42$2, serializable, _dec43$2, _dec44$2, _dec45$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor12$6 = _applyDecoratedDescriptor(_class2$S.prototype, "arcSpeed", [_dec46$1, _dec47$1, _dec48$1, serializable, _dec49$1, _dec50$1, _dec51$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor13$6 = _applyDecoratedDescriptor(_class2$S.prototype, "length", [serializable, _dec52$1, _dec53$1, _dec54$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 5;
        }
      }), _descriptor14$2 = _applyDecoratedDescriptor(_class2$S.prototype, "boxThickness", [serializable, _dec55$1, _dec56$1, _dec57$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(0, 0, 0);
        }
      }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$S.prototype, "_position", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(0, 0, 0);
        }
      }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$S.prototype, "_rotation", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(0, 0, 0);
        }
      }), _descriptor17$1 = _applyDecoratedDescriptor(_class2$S.prototype, "_scale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(1, 1, 1);
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class2$S.prototype, "_arc", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return toRadian(360);
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class2$S.prototype, "_angle", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return toRadian(25);
        }
      })), _class2$S)) || _class$_);

      function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
        switch (emitFrom) {
          case EmitLocation.Volume:
            randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);
            Vec3.normalize(dir, pos);
            break;

          case EmitLocation.Shell:
            randomUnitVector(pos);
            Vec3.multiplyScalar(pos, pos, radius);
            Vec3.normalize(dir, pos);
            break;

          default:
            console.warn(emitFrom + " is not supported for sphere emitter.");
        }
      }

      function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
        switch (emitFrom) {
          case EmitLocation.Volume:
            randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);

            if (pos.z > 0) {
              pos.z *= -1;
            }

            Vec3.normalize(dir, pos);
            break;

          case EmitLocation.Shell:
            randomUnitVector(pos);
            Vec3.multiplyScalar(pos, pos, radius);

            if (pos.z > 0) {
              pos.z *= -1;
            }

            Vec3.normalize(dir, pos);
            break;

          default:
            console.warn(emitFrom + " is not supported for hemisphere emitter.");
        }
      }

      function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
        switch (emitFrom) {
          case EmitLocation.Base:
            randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
            Vec2.multiplyScalar(dir, pos, Math.sin(angle));
            dir.z = -Math.cos(angle) * radius;
            Vec3.normalize(dir, dir);
            pos.z = 0;
            break;

          case EmitLocation.Shell:
            fixedAngleUnitVector2(pos, theta);
            Vec2.multiplyScalar(dir, pos, Math.sin(angle));
            dir.z = -Math.cos(angle);
            Vec3.normalize(dir, dir);
            Vec2.multiplyScalar(pos, pos, radius);
            pos.z = 0;
            break;

          case EmitLocation.Volume:
            randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
            Vec2.multiplyScalar(dir, pos, Math.sin(angle));
            dir.z = -Math.cos(angle) * radius;
            Vec3.normalize(dir, dir);
            pos.z = 0;
            Vec3.add(pos, pos, Vec3.multiplyScalar(_intermediVec, dir, length * random() / -dir.z));
            break;

          default:
            console.warn(emitFrom + " is not supported for cone emitter.");
        }
      }

      function boxEmit(emitFrom, boxThickness, pos, dir) {
        switch (emitFrom) {
          case EmitLocation.Volume:
            randomPointInCube(pos, _unitBoxExtent);
            break;

          case EmitLocation.Shell:
            _intermediArr.splice(0, _intermediArr.length);

            _intermediArr.push(randomRange(-0.5, 0.5));

            _intermediArr.push(randomRange(-0.5, 0.5));

            _intermediArr.push(randomSign() * 0.5);

            randomSortArray(_intermediArr);
            applyBoxThickness(_intermediArr, boxThickness);
            Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
            break;

          case EmitLocation.Edge:
            _intermediArr.splice(0, _intermediArr.length);

            _intermediArr.push(randomRange(-0.5, 0.5));

            _intermediArr.push(randomSign() * 0.5);

            _intermediArr.push(randomSign() * 0.5);

            randomSortArray(_intermediArr);
            applyBoxThickness(_intermediArr, boxThickness);
            Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
            break;

          default:
            console.warn(emitFrom + " is not supported for box emitter.");
        }

        Vec3.copy(dir, particleEmitZAxis);
      }

      function circleEmit(radius, radiusThickness, theta, pos, dir) {
        randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
        Vec3.normalize(dir, pos);
      }

      function applyBoxThickness(pos, thickness) {
        if (thickness.x > 0) {
          pos[0] += 0.5 * randomRange(-thickness.x, thickness.x);
          pos[0] = clamp$1(pos[0], -0.5, 0.5);
        }

        if (thickness.y > 0) {
          pos[1] += 0.5 * randomRange(-thickness.y, thickness.y);
          pos[1] = clamp$1(pos[1], -0.5, 0.5);
        }

        if (thickness.z > 0) {
          pos[2] += 0.5 * randomRange(-thickness.z, thickness.z);
          pos[2] = clamp$1(pos[2], -0.5, 0.5);
        }
      }

      var _uvs$1 = [0, 0, 1, 0, 0, 1, 1, 1];
      var _uvs_ins = [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0];

      var ParticleBatchModel = function (_scene$Model) {
        _inheritsLoose(ParticleBatchModel, _scene$Model);

        function ParticleBatchModel() {
          var _this;

          _this = _scene$Model.call(this) || this;
          _this._capacity = void 0;
          _this._vertAttrs = void 0;
          _this._vertAttribSize = void 0;
          _this._vBuffer = void 0;
          _this._vertAttrsFloatCount = void 0;
          _this._vdataF32 = void 0;
          _this._vdataUint32 = void 0;
          _this._iaInfo = void 0;
          _this._iaInfoBuffer = void 0;
          _this._subMeshData = void 0;
          _this._mesh = void 0;
          _this._vertCount = 0;
          _this._indexCount = 0;
          _this._startTimeOffset = 0;
          _this._lifeTimeOffset = 0;
          _this._material = null;
          _this._vertAttribSizeStatic = void 0;
          _this._vertStaticAttrsFloatCount = void 0;
          _this._insBuffers = void 0;
          _this._insIndices = void 0;
          _this._useInstance = void 0;

          _this.type = ModelType.PARTICLE_BATCH;
          _this._capacity = 0;
          _this._vertAttrs = null;
          _this._vertAttribSize = 0;
          _this._vBuffer = null;
          _this._vertAttrsFloatCount = 0;
          _this._vdataF32 = null;
          _this._vdataUint32 = null;
          _this._vertAttribSizeStatic = 0;
          _this._vertStaticAttrsFloatCount = 0;
          _this._insBuffers = [];
          _this._insIndices = null;

          if (!deviceManager.gfxDevice.hasFeature(Feature.INSTANCED_ARRAYS)) {
            _this._useInstance = false;
          } else {
            _this._useInstance = true;
          }

          _this._iaInfo = new IndirectBuffer([new DrawInfo()]);
          _this._iaInfoBuffer = _this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
          _this._subMeshData = null;
          _this._mesh = null;
          return _this;
        }

        var _proto = ParticleBatchModel.prototype;

        _proto.setCapacity = function setCapacity(capacity) {
          var capChanged = this._capacity !== capacity;
          this._capacity = capacity;

          if (this._subMeshData && capChanged) {
            this.rebuild();
          }
        };

        _proto.setVertexAttributes = function setVertexAttributes(mesh, attrs) {
          if (!this._useInstance) {
            if (this._mesh === mesh && this._vertAttrs === attrs) {
              return;
            }

            this._mesh = mesh;
            this._vertAttrs = attrs;
            this._vertAttribSize = 0;

            for (var _iterator = _createForOfIteratorHelperLoose(this._vertAttrs), _step; !(_step = _iterator()).done;) {
              var a = _step.value;
              a.offset = this._vertAttribSize;
              this._vertAttribSize += FormatInfos[a.format].size;
            }

            this._vertAttrsFloatCount = this._vertAttribSize / 4;
            this.rebuild();
          } else {
            this.setVertexAttributesIns(mesh, attrs);
          }
        };

        _proto.setVertexAttributesIns = function setVertexAttributesIns(mesh, attrs) {
          if (this._mesh === mesh && this._vertAttrs === attrs) {
            return;
          }

          this._mesh = mesh;
          this._vertAttrs = attrs;
          this._vertAttribSize = 0;
          this._vertAttribSizeStatic = 0;

          for (var _iterator2 = _createForOfIteratorHelperLoose(this._vertAttrs), _step2; !(_step2 = _iterator2()).done;) {
            var a = _step2.value;

            if (a.stream === 0) {
              a.offset = this._vertAttribSize;
              this._vertAttribSize += FormatInfos[a.format].size;
            } else if (a.stream === 1) {
              a.offset = this._vertAttribSizeStatic;
              this._vertAttribSizeStatic += FormatInfos[a.format].size;
            }
          }

          this._vertAttrsFloatCount = this._vertAttribSize / 4;
          this._vertStaticAttrsFloatCount = this._vertAttribSizeStatic / 4;
          this.rebuild();
        };

        _proto.createSubMeshData = function createSubMeshData() {
          this.destroySubMeshData();
          this._vertCount = 4;
          this._indexCount = 6;

          if (this._mesh) {
            this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count;
            this._indexCount = this._mesh.struct.primitives[0].indexView.count;
          }

          var vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSize * this._capacity * this._vertCount, this._vertAttribSize));

          var vBuffer = new ArrayBuffer(this._vertAttribSize * this._capacity * this._vertCount);

          if (this._mesh && this._capacity > 0) {
            var vOffset = this._vertAttrs[this._vertAttrs.findIndex(function (val) {
              return val.name === AttributeName.ATTR_TEX_COORD;
            })].offset;

            this._mesh.copyAttribute(0, AttributeName.ATTR_TEX_COORD, vBuffer, this._vertAttribSize, vOffset);

            var vIdx = this._vertAttrs.findIndex(function (val) {
              return val.name === AttributeName.ATTR_TEX_COORD3;
            });

            vOffset = this._vertAttrs[vIdx++].offset;

            this._mesh.copyAttribute(0, AttributeName.ATTR_POSITION, vBuffer, this._vertAttribSize, vOffset);

            vOffset = this._vertAttrs[vIdx++].offset;

            this._mesh.copyAttribute(0, AttributeName.ATTR_NORMAL, vBuffer, this._vertAttribSize, vOffset);

            vOffset = this._vertAttrs[vIdx++].offset;

            if (!this._mesh.copyAttribute(0, AttributeName.ATTR_COLOR, vBuffer, this._vertAttribSize, vOffset)) {
              var vb = new Uint32Array(vBuffer);

              for (var iVertex = 0; iVertex < this._vertCount; ++iVertex) {
                vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = Color.WHITE._val;
              }
            }

            var vbFloatArray = new Float32Array(vBuffer);

            for (var i = 1; i < this._capacity; i++) {
              vbFloatArray.copyWithin(i * this._vertAttribSize * this._vertCount / 4, 0, this._vertAttribSize * this._vertCount / 4);
            }
          }

          vertexBuffer.update(vBuffer);
          var indices = new Uint16Array(this._capacity * this._indexCount);

          if (this._mesh && this._capacity > 0) {
            this._mesh.copyIndices(0, indices);

            for (var _i = 1; _i < this._capacity; _i++) {
              for (var j = 0; j < this._indexCount; j++) {
                indices[_i * this._indexCount + j] = indices[j] + _i * this._vertCount;
              }
            }
          } else {
            var dst = 0;

            for (var _i2 = 0; _i2 < this._capacity; ++_i2) {
              var baseIdx = 4 * _i2;
              indices[dst++] = baseIdx;
              indices[dst++] = baseIdx + 1;
              indices[dst++] = baseIdx + 2;
              indices[dst++] = baseIdx + 3;
              indices[dst++] = baseIdx + 2;
              indices[dst++] = baseIdx + 1;
            }
          }

          var indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

          indexBuffer.update(indices);
          this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount;
          this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount;

          if (!this._iaInfoBuffer) {
            this._iaInfoBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
          }

          this._iaInfoBuffer.update(this._iaInfo);

          this._subMeshData = new RenderingSubMesh([vertexBuffer], this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
          this.initSubModel(0, this._subMeshData, this._material);
          return vBuffer;
        };

        _proto.createSubMeshDataInsDynamic = function createSubMeshDataInsDynamic() {
          this.destroySubMeshData();

          var vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSize * this._capacity, this._vertAttribSize));

          var vBuffer = new ArrayBuffer(this._vertAttribSize * this._capacity);
          vertexBuffer.update(vBuffer);

          this._insBuffers.push(vertexBuffer);

          return vBuffer;
        };

        _proto.createSubMeshDataInsStatic = function createSubMeshDataInsStatic() {
          this._vertCount = 4;
          this._indexCount = 6;

          if (this._mesh) {
            this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count;
            this._indexCount = this._mesh.struct.primitives[0].indexView.count;
          }

          var vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSizeStatic * this._vertCount, this._vertAttribSizeStatic));

          var vBuffer = new ArrayBuffer(this._vertAttribSizeStatic * this._vertCount);

          if (this._mesh) {
            var vIdx = this._vertAttrs.findIndex(function (val) {
              return val.name === AttributeName.ATTR_TEX_COORD;
            });

            var vOffset = this._vertAttrs[vIdx].offset;

            this._mesh.copyAttribute(0, AttributeName.ATTR_TEX_COORD, vBuffer, this._vertAttribSizeStatic, vOffset);

            vIdx = this._vertAttrs.findIndex(function (val) {
              return val.name === AttributeName.ATTR_TEX_COORD3;
            });
            vOffset = this._vertAttrs[vIdx++].offset;

            this._mesh.copyAttribute(0, AttributeName.ATTR_POSITION, vBuffer, this._vertAttribSizeStatic, vOffset);

            vOffset = this._vertAttrs[vIdx++].offset;

            this._mesh.copyAttribute(0, AttributeName.ATTR_NORMAL, vBuffer, this._vertAttribSizeStatic, vOffset);

            vOffset = this._vertAttrs[vIdx++].offset;

            if (!this._mesh.copyAttribute(0, AttributeName.ATTR_COLOR, vBuffer, this._vertAttribSizeStatic, vOffset)) {
              var vb = new Uint32Array(vBuffer);

              for (var iVertex = 0; iVertex < this._vertCount; ++iVertex) {
                vb[iVertex * this._vertStaticAttrsFloatCount + vOffset / 4] = Color.WHITE._val;
              }
            }
          } else {
            var vbFloatArray = new Float32Array(vBuffer);

            for (var i = 0; i < _uvs_ins.length; ++i) {
              vbFloatArray[i] = _uvs_ins[i];
            }
          }

          vertexBuffer.update(vBuffer);
          var indices = new Uint16Array(this._indexCount);

          if (this._mesh) {
            this._mesh.copyIndices(0, indices);
          } else {
            indices[0] = 0;
            indices[1] = 1;
            indices[2] = 2;
            indices[3] = 3;
            indices[4] = 2;
            indices[5] = 1;
          }

          var indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

          indexBuffer.update(indices);
          this._insIndices = indexBuffer;
          this._iaInfo.drawInfos[0].vertexCount = this._vertCount;
          this._iaInfo.drawInfos[0].indexCount = this._indexCount;

          if (!this._iaInfoBuffer) {
            this._iaInfoBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
          }

          this._iaInfoBuffer.update(this._iaInfo);

          this._insBuffers.push(vertexBuffer);
        };

        _proto.createInsSubmesh = function createInsSubmesh() {
          this._subMeshData = new RenderingSubMesh(this._insBuffers, this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, this._insIndices, this._iaInfoBuffer);
          this.initSubModel(0, this._subMeshData, this._material);
        };

        _proto.updateMaterial = function updateMaterial(mat) {
          this._material = mat;
          this.setSubModelMaterial(0, mat);
        };

        _proto.addParticleVertexData = function addParticleVertexData(index, pvdata) {
          if (!this._useInstance) {
            if (!this._mesh) {
              var offset = index * this._vertAttrsFloatCount;
              this._vdataF32[offset++] = pvdata[0].x;
              this._vdataF32[offset++] = pvdata[0].y;
              this._vdataF32[offset++] = pvdata[0].z;
              this._vdataF32[offset++] = pvdata[1].x;
              this._vdataF32[offset++] = pvdata[1].y;
              this._vdataF32[offset++] = pvdata[1].z;
              this._vdataF32[offset++] = pvdata[2].x;
              this._vdataF32[offset++] = pvdata[2].y;
              this._vdataF32[offset++] = pvdata[2].z;
              this._vdataF32[offset++] = pvdata[3].x;
              this._vdataF32[offset++] = pvdata[3].y;
              this._vdataF32[offset++] = pvdata[3].z;
              this._vdataUint32[offset++] = pvdata[4];

              if (pvdata[5]) {
                this._vdataF32[offset++] = pvdata[5].x;
                this._vdataF32[offset++] = pvdata[5].y;
                this._vdataF32[offset++] = pvdata[5].z;
              }
            } else {
              for (var i = 0; i < this._vertCount; i++) {
                var _offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;

                this._vdataF32[_offset++] = pvdata[0].x;
                this._vdataF32[_offset++] = pvdata[0].y;
                this._vdataF32[_offset++] = pvdata[0].z;
                _offset += 2;
                this._vdataF32[_offset++] = pvdata[1].z;
                this._vdataF32[_offset++] = pvdata[2].x;
                this._vdataF32[_offset++] = pvdata[2].y;
                this._vdataF32[_offset++] = pvdata[2].z;
                this._vdataF32[_offset++] = pvdata[3].x;
                this._vdataF32[_offset++] = pvdata[3].y;
                this._vdataF32[_offset++] = pvdata[3].z;
                this._vdataUint32[_offset++] = pvdata[4];
              }
            }
          } else {
            this.addParticleVertexDataIns(index, pvdata);
          }
        };

        _proto.addParticleVertexDataIns = function addParticleVertexDataIns(index, pvdata) {
          var offset = index * this._vertAttrsFloatCount;

          if (!this._mesh) {
            this._vdataF32[offset++] = pvdata[0].x;
            this._vdataF32[offset++] = pvdata[0].y;
            this._vdataF32[offset++] = pvdata[0].z;
            this._vdataF32[offset++] = pvdata[1].z;
            this._vdataF32[offset++] = pvdata[2].x;
            this._vdataF32[offset++] = pvdata[2].y;
            this._vdataF32[offset++] = pvdata[2].z;
            this._vdataF32[offset++] = pvdata[3].x;
            this._vdataF32[offset++] = pvdata[3].y;
            this._vdataF32[offset++] = pvdata[3].z;
            this._vdataUint32[offset++] = pvdata[4];

            if (pvdata[5]) {
              this._vdataF32[offset++] = pvdata[5].x;
              this._vdataF32[offset++] = pvdata[5].y;
              this._vdataF32[offset++] = pvdata[5].z;
            }
          } else {
            this._vdataF32[offset++] = pvdata[0].x;
            this._vdataF32[offset++] = pvdata[0].y;
            this._vdataF32[offset++] = pvdata[0].z;
            this._vdataF32[offset++] = pvdata[1].z;
            this._vdataF32[offset++] = pvdata[2].x;
            this._vdataF32[offset++] = pvdata[2].y;
            this._vdataF32[offset++] = pvdata[2].z;
            this._vdataF32[offset++] = pvdata[3].x;
            this._vdataF32[offset++] = pvdata[3].y;
            this._vdataF32[offset++] = pvdata[3].z;
            this._vdataUint32[offset++] = pvdata[4];
          }
        };

        _proto.addGPUParticleVertexData = function addGPUParticleVertexData(p, num, time) {
          if (!this._useInstance) {
            var offset = num * this._vertAttrsFloatCount * this._vertCount;

            for (var i = 0; i < this._vertCount; i++) {
              var idx = offset;
              this._vdataF32[idx++] = p.position.x;
              this._vdataF32[idx++] = p.position.y;
              this._vdataF32[idx++] = p.position.z;
              this._vdataF32[idx++] = time;
              this._vdataF32[idx++] = p.startSize.x;
              this._vdataF32[idx++] = p.startSize.y;
              this._vdataF32[idx++] = p.startSize.z;
              this._vdataF32[idx++] = _uvs$1[2 * i];
              this._vdataF32[idx++] = p.rotation.x;
              this._vdataF32[idx++] = p.rotation.y;
              this._vdataF32[idx++] = p.rotation.z;
              this._vdataF32[idx++] = _uvs$1[2 * i + 1];
              this._vdataF32[idx++] = p.startColor.r / 255.0;
              this._vdataF32[idx++] = p.startColor.g / 255.0;
              this._vdataF32[idx++] = p.startColor.b / 255.0;
              this._vdataF32[idx++] = p.startColor.a / 255.0;
              this._vdataF32[idx++] = p.velocity.x;
              this._vdataF32[idx++] = p.velocity.y;
              this._vdataF32[idx++] = p.velocity.z;
              this._vdataF32[idx++] = p.startLifetime;
              this._vdataF32[idx++] = p.randomSeed;
              offset += this._vertAttrsFloatCount;
            }
          } else {
            this.addGPUParticleVertexDataIns(p, num, time);
          }
        };

        _proto.addGPUParticleVertexDataIns = function addGPUParticleVertexDataIns(p, num, time) {
          var offset = num * this._vertAttrsFloatCount;
          var idx = offset;
          this._vdataF32[idx++] = p.position.x;
          this._vdataF32[idx++] = p.position.y;
          this._vdataF32[idx++] = p.position.z;
          this._vdataF32[idx++] = time;
          this._vdataF32[idx++] = p.startSize.x;
          this._vdataF32[idx++] = p.startSize.y;
          this._vdataF32[idx++] = p.startSize.z;
          this._vdataF32[idx++] = p.frameIndex;
          this._vdataF32[idx++] = p.rotation.x;
          this._vdataF32[idx++] = p.rotation.y;
          this._vdataF32[idx++] = p.rotation.z;
          this._vdataF32[idx++] = p.randomSeed;
          this._vdataF32[idx++] = p.startColor.r / 255.0;
          this._vdataF32[idx++] = p.startColor.g / 255.0;
          this._vdataF32[idx++] = p.startColor.b / 255.0;
          this._vdataF32[idx++] = p.startColor.a / 255.0;
          this._vdataF32[idx++] = p.velocity.x;
          this._vdataF32[idx++] = p.velocity.y;
          this._vdataF32[idx++] = p.velocity.z;
          this._vdataF32[idx++] = p.startLifetime;
          offset += this._vertAttrsFloatCount;
        };

        _proto.updateGPUParticles = function updateGPUParticles(num, time, dt) {
          if (!this._useInstance) {
            var pSize = this._vertAttrsFloatCount * this._vertCount;
            var pBaseIndex = 0;
            var startTime = 0;
            var lifeTime = 0;
            var lastBaseIndex = 0;
            var interval = 0;

            for (var i = 0; i < num; ++i) {
              pBaseIndex = i * pSize;
              startTime = this._vdataF32[pBaseIndex + this._startTimeOffset];
              lifeTime = this._vdataF32[pBaseIndex + this._lifeTimeOffset];
              interval = time - startTime;

              if (lifeTime - interval < dt) {
                lastBaseIndex = --num * pSize;

                this._vdataF32.copyWithin(pBaseIndex, lastBaseIndex, lastBaseIndex + pSize);

                i--;
              }
            }

            return num;
          } else {
            return this.updateGPUParticlesIns(num, time, dt);
          }
        };

        _proto.updateGPUParticlesIns = function updateGPUParticlesIns(num, time, dt) {
          var pSize = this._vertAttrsFloatCount;
          var pBaseIndex = 0;
          var startTime = 0;
          var lifeTime = 0;
          var lastBaseIndex = 0;
          var interval = 0;

          for (var i = 0; i < num; ++i) {
            pBaseIndex = i * pSize;
            startTime = this._vdataF32[pBaseIndex + this._startTimeOffset];
            lifeTime = this._vdataF32[pBaseIndex + this._lifeTimeOffset];
            interval = time - startTime;

            if (lifeTime - interval < dt) {
              lastBaseIndex = --num * pSize;

              this._vdataF32.copyWithin(pBaseIndex, lastBaseIndex, lastBaseIndex + pSize);

              i--;
            }
          }

          return num;
        };

        _proto.constructAttributeIndex = function constructAttributeIndex() {
          if (!this._vertAttrs) {
            return;
          }

          var vIdx = this._vertAttrs.findIndex(function (val) {
            return val.name === 'a_position_starttime';
          });

          var vOffset = this._vertAttrs[vIdx].offset;
          this._startTimeOffset = vOffset / 4 + 3;
          vIdx = this._vertAttrs.findIndex(function (val) {
            return val.name === 'a_dir_life';
          });
          vOffset = this._vertAttrs[vIdx].offset;
          this._lifeTimeOffset = vOffset / 4 + 3;
        };

        _proto.updateIA = function updateIA(count) {
          if (!this._useInstance) {
            if (count <= 0) {
              return;
            }

            var ia = this._subModels[0].inputAssembler;
            ia.vertexBuffers[0].update(this._vdataF32);
            this._iaInfo.drawInfos[0].firstIndex = 0;
            this._iaInfo.drawInfos[0].indexCount = this._indexCount * count;

            this._iaInfoBuffer.update(this._iaInfo);
          } else {
            this.updateIAIns(count);
          }
        };

        _proto.updateIAIns = function updateIAIns(count) {
          if (count <= 0) {
            return;
          }

          var ia = this._subModels[0].inputAssembler;
          ia.vertexBuffers[0].update(this._vdataF32);
          ia.instanceCount = count;
          this._iaInfo.drawInfos[0].firstIndex = 0;
          this._iaInfo.drawInfos[0].indexCount = this._indexCount;
          this._iaInfo.drawInfos[0].instanceCount = count;

          this._iaInfoBuffer.update(this._iaInfo);
        };

        _proto.clear = function clear() {
          if (!this._useInstance) {
            this._subModels[0].inputAssembler.indexCount = 0;
          } else {
            this.clearIns();
          }
        };

        _proto.clearIns = function clearIns() {
          this._subModels[0].inputAssembler.instanceCount = 0;
        };

        _proto.destroy = function destroy() {
          _scene$Model.prototype.destroy.call(this);

          this.doDestroy();
        };

        _proto.doDestroy = function doDestroy() {
          this._vBuffer = null;
          this._vdataF32 = null;
          this._vdataUint32 = null;
          this._insBuffers = [];
          this._insIndices = null;
          this._vertAttrs = null;
          this._material = null;
          this._mesh = null;
          this.destroySubMeshData();
        };

        _proto.rebuild = function rebuild() {
          if (!this._useInstance) {
            this._vBuffer = this.createSubMeshData();
            this._vdataF32 = new Float32Array(this._vBuffer);
            this._vdataUint32 = new Uint32Array(this._vBuffer);
          } else {
            this.rebuildIns();
          }
        };

        _proto.rebuildIns = function rebuildIns() {
          this._vBuffer = this.createSubMeshDataInsDynamic();
          this._vdataF32 = new Float32Array(this._vBuffer);
          this._vdataUint32 = new Uint32Array(this._vBuffer);
          this.createSubMeshDataInsStatic();
          this.createInsSubmesh();
        };

        _proto.destroySubMeshData = function destroySubMeshData() {
          if (this._subMeshData) {
            this._subMeshData.destroy();

            this._subMeshData = null;
          }

          if (this._iaInfoBuffer) {
            this._iaInfoBuffer = null;
          }
        };

        _createClass(ParticleBatchModel, [{
          key: "useInstance",
          get: function get() {
            return this._useInstance;
          },
          set: function set(value) {
            if (this._useInstance !== value) {
              this._useInstance = value;
            }
          }
        }]);

        return ParticleBatchModel;
      }(Model);

      var ParticleSystemRendererBase = function () {
        function ParticleSystemRendererBase(info) {
          this._particleSystem = null;
          this._model = null;
          this._renderInfo = null;
          this._vertAttrs = [];
          this._useInstance = void 0;
          this._renderInfo = info;

          if (!deviceManager.gfxDevice.hasFeature(Feature.INSTANCED_ARRAYS)) {
            this._useInstance = false;
          } else {
            this._useInstance = true;
          }
        }

        var _proto = ParticleSystemRendererBase.prototype;

        _proto.getUseInstance = function getUseInstance() {
          return this._useInstance;
        };

        _proto.getInfo = function getInfo() {
          return this._renderInfo;
        };

        _proto.onInit = function onInit(ps) {
          this._particleSystem = ps;
        };

        _proto.onEnable = function onEnable() {
          if (!this._particleSystem) {
            return;
          }

          this.attachToScene();
          var model = this._model;

          if (model) {
            model.node = model.transform = this._particleSystem.node;
          }
        };

        _proto.onDisable = function onDisable() {
          this.detachFromScene();
        };

        _proto.onDestroy = function onDestroy() {
          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
          }
        };

        _proto.attachToScene = function attachToScene() {
          if (this._model) {
            if (this._model.scene) {
              this.detachFromScene();
            }

            this._particleSystem._getRenderScene().addModel(this._model);
          }
        };

        _proto.detachFromScene = function detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        };

        _proto.setVertexAttributes = function setVertexAttributes() {
          if (this._model) {
            this.updateVertexAttrib();

            this._model.setVertexAttributes(this._renderInfo.renderMode === RenderMode$1.Mesh ? this._renderInfo.mesh : null, this._vertAttrs);
          }
        };

        _proto.clear = function clear() {
          if (this._model) this._model.enabled = false;
        };

        _proto.getModel = function getModel() {
          return this._model;
        };

        _proto._initModel = function _initModel() {
          if (!this._model) {
            this._model = legacyCC.director.root.createModel(ParticleBatchModel);

            this._model.setCapacity(this._particleSystem.capacity);

            this._model.visFlags = this._particleSystem.visibility;
          }
        };

        _proto.updateTrailMaterial = function updateTrailMaterial() {};

        _proto.getDefaultTrailMaterial = function getDefaultTrailMaterial() {
          return null;
        };

        return ParticleSystemRendererBase;
      }();

      var ParticleNoise = function () {
        function ParticleNoise(permutation) {
          this.permutation = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
          this.accSpeed = new Vec3();
          this.noiseSpeed = new Vec3();
          this.noiseFrequency = 0.0;
          this.noiseAbs = new Vec3();
          this.noiseAmplitude = new Vec3();
          this.octaves = new Vec3();
          this.dt = 0.0;
          this.point = new Vec3();
          this.result = new Vec3();
          this.mixOut = new Vec2();

          if (permutation) {
            this.permutation = permutation;
          }
        }

        var _proto = ParticleNoise.prototype;

        _proto.noise = function noise(x, y, z, min, max) {
          if (min === void 0) {
            min = 0;
          }

          if (max === void 0) {
            max = 1;
          }

          var p = new Array(512);

          for (var i = 0; i < 256; i++) {
            p[256 + i] = p[i] = this.permutation[i];
          }

          var X = Math.floor(x) & 255;
          var Y = Math.floor(y) & 255;
          var Z = Math.floor(z) & 255;
          x -= Math.floor(x);
          y -= Math.floor(y);
          z -= Math.floor(z);
          var u = this.fade(x);
          var v = this.fade(y);
          var w = this.fade(z);
          var A = p[X] + Y;
          var AA = p[A] + Z;
          var AB = p[A + 1] + Z;
          var B = p[X + 1] + Y;
          var BA = p[B] + Z;
          var BB = p[B + 1] + Z;
          var val = this.scale(this.lerp(w, this.lerp(v, this.lerp(u, this.grad(p[AA], x, y, z), this.grad(p[BA], x - 1, y, z)), this.lerp(u, this.grad(p[AB], x, y - 1, z), this.grad(p[BB], x - 1, y - 1, z))), this.lerp(v, this.lerp(u, this.grad(p[AA + 1], x, y, z - 1), this.grad(p[BA + 1], x - 1, y, z - 1)), this.lerp(u, this.grad(p[AB + 1], x, y - 1, z - 1), this.grad(p[BB + 1], x - 1, y - 1, z - 1)))));
          return min + val * (max - min);
        };

        _proto.fade = function fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10);
        };

        _proto.lerp = function lerp(t, a, b) {
          return a + t * (b - a);
        };

        _proto.grad = function grad(hash, x, y, z) {
          var h = hash & 15;
          var u = h < 8 ? x : y;
          var v = h < 4 ? y : h === 12 || h === 14 ? x : z;
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        };

        _proto.scale = function scale(n) {
          return (1 + n) / 2;
        };

        _proto.setSpeed = function setSpeed(x, y, z) {
          this.noiseSpeed.set(x, y, z);
        };

        _proto.setFrequency = function setFrequency(f) {
          this.noiseFrequency = f;
        };

        _proto.setAbs = function setAbs(x, y, z) {
          this.noiseAbs.set(x, y, z);
        };

        _proto.setAmplititude = function setAmplititude(x, y, z) {
          this.noiseAmplitude.set(x, y, z);
        };

        _proto.setOctaves = function setOctaves(x, y, z) {
          this.octaves.set(x, y, z);
        };

        _proto.setTime = function setTime(t) {
          this.dt = t;
        };

        _proto.setSamplePoint = function setSamplePoint(p) {
          this.point.set(p);
        };

        _proto.getResult = function getResult() {
          return this.result;
        };

        _proto.getNoise = function getNoise(sx, sy, sz, time, offset, noiseFrequency, octaves) {
          var frequency = noiseFrequency;
          var sum = 0.0;
          sum += this.noise(sx * frequency, sy * frequency, sz * frequency, -1.0, 1.0);

          if (octaves.x === 1) {
            return sum;
          }

          var amplitude = 1.0;
          var range = 1.0;

          for (var i = 1; i < octaves.x; ++i) {
            amplitude *= octaves.y;
            frequency *= octaves.z;
            range += amplitude;
            sum += this.noise(sx * frequency, sy * frequency, sz * frequency, -1.0, 1.0) * amplitude;
          }

          return sum / range;
        };

        _proto.getNoiseMix = function getNoiseMix(out, point, time, offSpeed, noiseFrequency, octaves) {
          out.x = this.getNoise(point.x, point.y, point.z, time, offSpeed, noiseFrequency, octaves);
          out.y = this.getNoise(point.y, point.z, point.x, time, offSpeed, noiseFrequency, octaves);
        };

        _proto.getNoiseParticle = function getNoiseParticle() {
          this.accSpeed.set(this.noiseSpeed.x * this.dt, this.noiseSpeed.y * this.dt, this.noiseSpeed.z * this.dt);
          var axisOffset = 1000.0;
          var sampX = this.getNoise(this.point.z + this.accSpeed.x, this.point.y, this.point.x, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
          var sampY = this.getNoise(this.point.x + axisOffset, this.point.z + this.accSpeed.y, this.point.y, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
          var sampZ = this.getNoise(this.point.y, this.point.x + axisOffset, this.point.z + this.accSpeed.z, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
          this.result.set(sampX * this.noiseAmplitude.x, sampY * this.noiseAmplitude.y, sampZ * this.noiseAmplitude.z);
        };

        _proto.getPreview = function getPreview(out, width, height) {
          for (var h = 0; h < height; ++h) {
            for (var w = 0; w < width; ++w) {
              var sampx = (w - width * 0.5) / width + this.noiseSpeed.x * this.dt;
              var sampy = (h - height * 0.5) / height + this.noiseSpeed.y * this.dt;
              var pix = this.getNoise(sampx, sampy, 0.0, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
              out[h * width + w] = (pix + 1.0) * 0.5;
            }
          }
        };

        return ParticleNoise;
      }();

      var _tempAttribUV = new Vec3();

      var _tempWorldTrans = new Mat4();

      var _tempParentInverse = new Mat4();

      var _node_rot = new Quat();

      var _node_euler = new Vec3();

      var _anim_module = ['_colorOverLifetimeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule', '_noiseModule'];
      var _uvs$2 = [0, 0, 1, 0, 0, 1, 1, 1];
      var CC_USE_WORLD_SPACE$1 = 'CC_USE_WORLD_SPACE';
      var CC_RENDER_MODE = 'CC_RENDER_MODE';
      var ROTATION_OVER_TIME_MODULE_ENABLE = 'ROTATION_OVER_TIME_MODULE_ENABLE';
      var INSTANCE_PARTICLE = 'CC_INSTANCE_PARTICLE';
      var RENDER_MODE_BILLBOARD = 0;
      var RENDER_MODE_STRETCHED_BILLBOARD = 1;
      var RENDER_MODE_HORIZONTAL_BILLBOARD = 2;
      var RENDER_MODE_VERTICAL_BILLBOARD = 3;
      var RENDER_MODE_MESH = 4;
      var _vertex_attrs$1 = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
      var _vertex_attrs_stretch = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_COLOR1, Format.RGB32F)];
      var _vertex_attrs_mesh = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true)];
      var _vertex_attrs_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1)];
      var _vertex_attrs_stretch_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_COLOR1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1)];
      var _vertex_attrs_mesh_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true, 1)];
      var _matInsInfo$1 = {
        parent: null,
        owner: null,
        subModelIdx: 0
      };

      var ParticleSystemRendererCPU = function (_ParticleSystemRender) {
        _inheritsLoose(ParticleSystemRendererCPU, _ParticleSystemRender);

        function ParticleSystemRendererCPU(info) {
          var _this;

          _this = _ParticleSystemRender.call(this, info) || this;
          _this._defines = void 0;
          _this._trailDefines = void 0;
          _this._frameTile_velLenScale = void 0;
          _this._tmp_velLenScale = void 0;
          _this._defaultMat = null;
          _this._node_scale = void 0;
          _this._attrs = void 0;
          _this._particles = null;
          _this._defaultTrailMat = null;
          _this._updateList = new Map();
          _this._animateList = new Map();
          _this._runAnimateList = new Array();
          _this._fillDataFunc = null;
          _this._uScaleHandle = 0;
          _this._uLenHandle = 0;
          _this._uNodeRotHandle = 0;
          _this._alignSpace = AlignmentSpace.View;
          _this._inited = false;
          _this._localMat = new Mat4();
          _this._gravity = new Vec4();
          _this.noise = new ParticleNoise();
          _this._model = null;
          _this._frameTile_velLenScale = new Vec4(1, 1, 0, 0);
          _this._tmp_velLenScale = _this._frameTile_velLenScale.clone();
          _this._node_scale = new Vec4();
          _this._attrs = new Array(7);
          _this._defines = {
            CC_USE_WORLD_SPACE: true,
            CC_USE_BILLBOARD: true,
            CC_USE_STRETCHED_BILLBOARD: false,
            CC_USE_HORIZONTAL_BILLBOARD: false,
            CC_USE_VERTICAL_BILLBOARD: false
          };
          _this._trailDefines = {
            CC_USE_WORLD_SPACE: true
          };
          return _this;
        }

        var _proto = ParticleSystemRendererCPU.prototype;

        _proto.onInit = function onInit(ps) {
          var _this2 = this;

          _ParticleSystemRender.prototype.onInit.call(this, ps);

          this._particles = new RecyclePool(function () {
            return new Particle(_this2);
          }, 16);

          this._setVertexAttrib();

          this._setFillFunc();

          this._initModuleList();

          this._initModel();

          this.updateMaterialParams();
          this.updateTrailMaterial();
          this.setVertexAttributes();
          this._inited = true;
        };

        _proto.clear = function clear() {
          _ParticleSystemRender.prototype.clear.call(this);

          this._particles.reset();

          if (this._particleSystem._trailModule) {
            this._particleSystem._trailModule.clear();
          }

          this.updateRenderData();
          this._model.enabled = false;
        };

        _proto.updateRenderMode = function updateRenderMode() {
          this._setVertexAttrib();

          this._setFillFunc();

          this.updateMaterialParams();
          this.setVertexAttributes();
        };

        _proto.onDestroy = function onDestroy() {
          var _this$_particles;

          (_this$_particles = this._particles) === null || _this$_particles === void 0 ? void 0 : _this$_particles.destroy();

          _ParticleSystemRender.prototype.onDestroy.call(this);
        };

        _proto.getFreeParticle = function getFreeParticle() {
          if (this._particles.length >= this._particleSystem.capacity) {
            return null;
          }

          return this._particles.add();
        };

        _proto.getDefaultTrailMaterial = function getDefaultTrailMaterial() {
          return this._defaultTrailMat;
        };

        _proto.setNewParticle = function setNewParticle(p) {};

        _proto._initModuleList = function _initModuleList() {
          var _this3 = this;

          _anim_module.forEach(function (val) {
            var pm = _this3._particleSystem[val];

            if (pm && pm.enable) {
              if (pm.needUpdate) {
                _this3._updateList[pm.name] = pm;
              }

              if (pm.needAnimate) {
                _this3._animateList[pm.name] = pm;
              }
            }
          });

          this._runAnimateList.length = 0;

          for (var i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
            var p = this._animateList[PARTICLE_MODULE_ORDER[i]];

            if (p) {
              this._runAnimateList.push(p);
            }
          }
        };

        _proto.enableModule = function enableModule(name, val, pm) {
          if (val) {
            if (pm.needUpdate) {
              this._updateList[pm.name] = pm;
            }

            if (pm.needAnimate) {
              this._animateList[pm.name] = pm;
            }
          } else {
            delete this._animateList[name];
            delete this._updateList[name];
          }

          this._runAnimateList.length = 0;

          for (var i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
            var p = this._animateList[PARTICLE_MODULE_ORDER[i]];

            if (p) {
              this._runAnimateList.push(p);
            }
          }

          this.updateMaterialParams();
        };

        _proto.updateAlignSpace = function updateAlignSpace(space) {
          this._alignSpace = space;
        };

        _proto.getDefaultMaterial = function getDefaultMaterial() {
          return this._defaultMat;
        };

        _proto.updateRotation = function updateRotation(pass) {
          if (pass) {
            this.doUpdateRotation(pass);
          }
        };

        _proto.doUpdateRotation = function doUpdateRotation(pass) {
          var mode = this._renderInfo.renderMode;

          if (mode !== RenderMode$1.Mesh && this._alignSpace === AlignmentSpace.View) {
            return;
          }

          if (this._alignSpace === AlignmentSpace.Local) {
            this._particleSystem.node.getRotation(_node_rot);
          } else if (this._alignSpace === AlignmentSpace.World) {
            this._particleSystem.node.getWorldRotation(_node_rot);
          } else if (this._alignSpace === AlignmentSpace.View) {
            var _this$_particleSystem;

            _node_rot.set(0.0, 0.0, 0.0, 1.0);

            var cameraLst = (_this$_particleSystem = this._particleSystem.node.scene.renderScene) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem.cameras;

            if (cameraLst !== undefined) {
              for (var i = 0; i < (cameraLst === null || cameraLst === void 0 ? void 0 : cameraLst.length); ++i) {
                var camera = cameraLst[i];
                var checkCamera =  (camera.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer ;

                if (checkCamera) {
                  Quat.fromViewUp(_node_rot, camera.forward);
                  break;
                }
              }
            }
          } else {
            _node_rot.set(0.0, 0.0, 0.0, 1.0);
          }

          pass.setUniform(this._uNodeRotHandle, _node_rot);
        };

        _proto.updateScale = function updateScale(pass) {
          if (pass) {
            this.doUpdateScale(pass);
          }
        };

        _proto.doUpdateScale = function doUpdateScale(pass) {
          switch (this._particleSystem.scaleSpace) {
            case Space.Local:
              this._particleSystem.node.getScale(this._node_scale);

              break;

            case Space.World:
              this._particleSystem.node.getWorldScale(this._node_scale);

              break;
          }

          pass.setUniform(this._uScaleHandle, this._node_scale);
        };

        _proto.updateParticles = function updateParticles(dt) {
          var _this4 = this;

          var ps = this._particleSystem;

          if (!ps) {
            return this._particles.length;
          }

          ps.node.getWorldMatrix(_tempWorldTrans);

          var mat = ps.getMaterialInstance(0) || this._defaultMat;

          var pass = mat.passes[0];
          this.doUpdateScale(pass);
          this.doUpdateRotation(pass);

          this._updateList.forEach(function (value, key) {
            value.update(ps._simulationSpace, _tempWorldTrans);
          });

          var trailModule = ps._trailModule;
          var trailEnable = trailModule && trailModule.enable;

          if (trailEnable) {
            trailModule.update();
          }

          if (ps.simulationSpace === Space.Local) {
            var r = ps.node.getRotation();
            Mat4.fromQuat(this._localMat, r);

            this._localMat.transpose();
          }

          if (ps.node.parent) {
            ps.node.parent.getWorldMatrix(_tempParentInverse);

            _tempParentInverse.invert();
          }

          var _loop = function _loop(_i) {
            var p = _this4._particles.data[_i];
            p.remainingLifetime -= dt;
            Vec3.set(p.animatedVelocity, 0, 0, 0);

            if (p.remainingLifetime < 0.0) {
              if (trailEnable) {
                trailModule.removeParticle(p);
              }

              _this4._particles.removeAt(_i);

              --_i;
              i = _i;
              return "continue";
            }

            if (ps.simulationSpace === Space.Local) {
              var gravityFactor = -ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * 9.8 * dt;
              _this4._gravity.x = 0.0;
              _this4._gravity.y = gravityFactor;
              _this4._gravity.z = 0.0;
              _this4._gravity.w = 1.0;

              if (!approx(gravityFactor, 0.0, EPSILON$2)) {
                if (ps.node.parent) {
                  _this4._gravity = _this4._gravity.transformMat4(_tempParentInverse);
                }

                _this4._gravity = _this4._gravity.transformMat4(_this4._localMat);
                p.velocity.x += _this4._gravity.x;
                p.velocity.y += _this4._gravity.y;
                p.velocity.z += _this4._gravity.z;
              }
            } else {
              p.velocity.y -= ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * 9.8 * dt;
            }

            Vec3.copy(p.ultimateVelocity, p.velocity);

            _this4._runAnimateList.forEach(function (value) {
              value.animate(p, dt);
            });

            Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);

            if (trailEnable) {
              trailModule.animate(p, dt);
            }

            i = _i;
          };

          for (var i = 0; i < this._particles.length; ++i) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
          }

          this._model.enabled = this._particles.length > 0;
          return this._particles.length;
        };

        _proto.getNoisePreview = function getNoisePreview(out, width, height) {
          var _this5 = this;

          this._runAnimateList.forEach(function (value) {
            if (value.name === PARTICLE_MODULE_NAME.NOISE) {
              var m = value;
              m.getNoisePreview(out, _this5._particleSystem, width, height);
            }
          });
        };

        _proto.updateRenderData = function updateRenderData() {
          var idx = 0;

          for (var _i2 = 0; _i2 < this._particles.length; ++_i2) {
            var p = this._particles.data[_i2];
            var fi = 0;
            var textureModule = this._particleSystem._textureAnimationModule;

            if (textureModule && textureModule.enable) {
              fi = p.frameIndex;
            }

            idx = _i2 * 4;

            this._fillDataFunc(p, idx, fi);
          }
        };

        _proto.beforeRender = function beforeRender() {
          this._model.updateIA(this._particles.length);
        };

        _proto.getParticleCount = function getParticleCount() {
          return this._particles.length;
        };

        _proto.onMaterialModified = function onMaterialModified(index, material) {
          if (!this._inited) {
            return;
          }

          if (index === 0) {
            this.updateMaterialParams();
          } else {
            this.updateTrailMaterial();
          }
        };

        _proto.onRebuildPSO = function onRebuildPSO(index, material) {
          if (this._model && index === 0) {
            this._model.setSubModelMaterial(0, material);
          }

          var trailModule = this._particleSystem._trailModule;

          if (trailModule && trailModule._trailModel && index === 1) {
            trailModule._trailModel.setSubModelMaterial(0, material);
          }
        };

        _proto._setFillFunc = function _setFillFunc() {
          if (this._renderInfo.renderMode === RenderMode$1.Mesh) {
            this._fillDataFunc = this._fillMeshData;
          } else if (this._renderInfo.renderMode === RenderMode$1.StrecthedBillboard) {
            this._fillDataFunc = this._fillStrecthedData;
          } else {
            this._fillDataFunc = this._fillNormalData;
          }
        };

        _proto._fillMeshData = function _fillMeshData(p, idx, fi) {
          var i = idx / 4;
          this._attrs[0] = p.position;
          _tempAttribUV.z = fi;
          this._attrs[1] = _tempAttribUV;
          this._attrs[2] = p.size;
          this._attrs[3] = p.rotation;
          this._attrs[4] = p.color._val;

          this._model.addParticleVertexData(i, this._attrs);
        };

        _proto._fillStrecthedData = function _fillStrecthedData(p, idx, fi) {
          if (!this._useInstance) {
            for (var j = 0; j < 4; ++j) {
              this._attrs[0] = p.position;
              _tempAttribUV.x = _uvs$2[2 * j];
              _tempAttribUV.y = _uvs$2[2 * j + 1];
              _tempAttribUV.z = fi;
              this._attrs[1] = _tempAttribUV;
              this._attrs[2] = p.size;
              this._attrs[3] = p.rotation;
              this._attrs[4] = p.color._val;
              this._attrs[5] = p.ultimateVelocity;
              this._attrs[6] = null;

              this._model.addParticleVertexData(idx++, this._attrs);
            }
          } else {
            this._fillStrecthedDataIns(p, idx, fi);
          }
        };

        _proto._fillStrecthedDataIns = function _fillStrecthedDataIns(p, idx, fi) {
          var i = idx / 4;
          this._attrs[0] = p.position;
          _tempAttribUV.z = fi;
          this._attrs[1] = _tempAttribUV;
          this._attrs[2] = p.size;
          this._attrs[3] = p.rotation;
          this._attrs[4] = p.color._val;
          this._attrs[5] = p.ultimateVelocity;

          this._model.addParticleVertexData(i, this._attrs);
        };

        _proto._fillNormalData = function _fillNormalData(p, idx, fi) {
          if (!this._useInstance) {
            for (var j = 0; j < 4; ++j) {
              this._attrs[0] = p.position;
              _tempAttribUV.x = _uvs$2[2 * j];
              _tempAttribUV.y = _uvs$2[2 * j + 1];
              _tempAttribUV.z = fi;
              this._attrs[1] = _tempAttribUV;
              this._attrs[2] = p.size;
              this._attrs[3] = p.rotation;
              this._attrs[4] = p.color._val;
              this._attrs[5] = null;

              this._model.addParticleVertexData(idx++, this._attrs);
            }
          } else {
            this._fillNormalDataIns(p, idx, fi);
          }
        };

        _proto._fillNormalDataIns = function _fillNormalDataIns(p, idx, fi) {
          var i = idx / 4;
          this._attrs[0] = p.position;
          _tempAttribUV.z = fi;
          this._attrs[1] = _tempAttribUV;
          this._attrs[2] = p.size;
          this._attrs[3] = p.rotation;
          this._attrs[4] = p.color._val;
          this._attrs[5] = null;

          this._model.addParticleVertexData(i, this._attrs);
        };

        _proto.updateVertexAttrib = function updateVertexAttrib() {
          if (this._renderInfo.renderMode !== RenderMode$1.Mesh) {
            return;
          }

          if (this._renderInfo.mesh) {
            var format = this._renderInfo.mesh.readAttributeFormat(0, AttributeName.ATTR_COLOR);

            if (format) {
              var type = Format.RGBA8;

              for (var _i3 = 0; _i3 < FormatInfos.length; ++_i3) {
                if (FormatInfos[_i3].name === format.name) {
                  type = _i3;
                  break;
                }
              }

              this._vertAttrs[7] = new Attribute(AttributeName.ATTR_COLOR1, type, true, !this._useInstance ? 0 : 1);
            } else {
              var _type = Format.RGBA8;
              this._vertAttrs[7] = new Attribute(AttributeName.ATTR_COLOR1, _type, true, !this._useInstance ? 0 : 1);
            }
          }
        };

        _proto._setVertexAttrib = function _setVertexAttrib() {
          if (!this._useInstance) {
            switch (this._renderInfo.renderMode) {
              case RenderMode$1.StrecthedBillboard:
                this._vertAttrs = _vertex_attrs_stretch.slice();
                break;

              case RenderMode$1.Mesh:
                this._vertAttrs = _vertex_attrs_mesh.slice();
                break;

              default:
                this._vertAttrs = _vertex_attrs$1.slice();
            }
          } else {
            this._setVertexAttribIns();
          }
        };

        _proto._setVertexAttribIns = function _setVertexAttribIns() {
          switch (this._renderInfo.renderMode) {
            case RenderMode$1.StrecthedBillboard:
              this._vertAttrs = _vertex_attrs_stretch_ins.slice();
              break;

            case RenderMode$1.Mesh:
              this._vertAttrs = _vertex_attrs_mesh_ins.slice();
              break;

            default:
              this._vertAttrs = _vertex_attrs_ins.slice();
          }
        };

        _proto.updateMaterialParams = function updateMaterialParams() {
          if (!this._particleSystem) {
            return;
          }

          var ps = this._particleSystem;
          var shareMaterial = ps.sharedMaterial;

          if (shareMaterial != null) {
            var effectName = shareMaterial._effectAsset._name;
            this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);
          }

          if (ps.sharedMaterial == null && this._defaultMat == null) {
            _matInsInfo$1.parent = builtinResMgr.get('default-particle-material');
            _matInsInfo$1.owner = this._particleSystem;
            _matInsInfo$1.subModelIdx = 0;
            this._defaultMat = new MaterialInstance(_matInsInfo$1);
            _matInsInfo$1.parent = null;
            _matInsInfo$1.owner = null;
            _matInsInfo$1.subModelIdx = 0;

            if (this._renderInfo.mainTexture !== null) {
              this._defaultMat.setProperty('mainTexture', this._renderInfo.mainTexture);
            }
          }

          var mat = ps.getMaterialInstance(0) || this._defaultMat;

          if (ps._simulationSpace === Space.World) {
            this._defines[CC_USE_WORLD_SPACE$1] = true;
          } else {
            this._defines[CC_USE_WORLD_SPACE$1] = false;
          }

          var pass = mat.passes[0];
          this._uScaleHandle = pass.getHandle('scale');
          this._uLenHandle = pass.getHandle('frameTile_velLenScale');
          this._uNodeRotHandle = pass.getHandle('nodeRotation');
          var renderMode = this._renderInfo.renderMode;
          var vlenScale = this._frameTile_velLenScale;

          if (renderMode === RenderMode$1.Billboard) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_BILLBOARD;
          } else if (renderMode === RenderMode$1.StrecthedBillboard) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_STRETCHED_BILLBOARD;
            vlenScale.z = this._renderInfo.velocityScale;
            vlenScale.w = this._renderInfo.lengthScale;
          } else if (renderMode === RenderMode$1.HorizontalBillboard) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_HORIZONTAL_BILLBOARD;
          } else if (renderMode === RenderMode$1.VerticalBillboard) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_VERTICAL_BILLBOARD;
          } else if (renderMode === RenderMode$1.Mesh) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_MESH;
          } else {
            console.warn("particle system renderMode " + renderMode + " not support.");
          }

          var textureModule = ps._textureAnimationModule;

          if (textureModule && textureModule.enable) {
            Vec4.copy(this._tmp_velLenScale, vlenScale);
            Vec2.set(this._tmp_velLenScale, textureModule.numTilesX, textureModule.numTilesY);
            pass.setUniform(this._uLenHandle, this._tmp_velLenScale);
          } else {
            pass.setUniform(this._uLenHandle, vlenScale);
          }

          var enable = false;
          var roationModule = this._particleSystem._rotationOvertimeModule;
          enable = roationModule && roationModule.enable;
          this._defines[ROTATION_OVER_TIME_MODULE_ENABLE] = enable;
          this._defines[INSTANCE_PARTICLE] = this._useInstance;
          mat.recompileShaders(this._defines);

          if (this._model) {
            this._model.updateMaterial(mat);
          }
        };

        _proto.updateTrailMaterial = function updateTrailMaterial() {
          if (!this._particleSystem) {
            return;
          }

          var ps = this._particleSystem;
          var trailModule = ps._trailModule;

          if (trailModule && trailModule.enable) {
            if (ps.simulationSpace === Space.World || trailModule.space === Space.World) {
              this._trailDefines[CC_USE_WORLD_SPACE$1] = true;
            } else {
              this._trailDefines[CC_USE_WORLD_SPACE$1] = false;
            }

            var mat = ps.getMaterialInstance(1);

            if (mat === null && this._defaultTrailMat === null) {
              _matInsInfo$1.parent = builtinResMgr.get('default-trail-material');
              _matInsInfo$1.owner = this._particleSystem;
              _matInsInfo$1.subModelIdx = 1;
              this._defaultTrailMat = new MaterialInstance(_matInsInfo$1);
              _matInsInfo$1.parent = null;
              _matInsInfo$1.owner = null;
              _matInsInfo$1.subModelIdx = 0;
            }

            mat = mat || this._defaultTrailMat;
            mat.recompileShaders(this._trailDefines);
            trailModule.updateMaterial();
          }
        };

        _proto.setUseInstance = function setUseInstance(value) {
          if (this._useInstance === value) {
            return;
          }

          this._useInstance = value;

          if (this._model) {
            this._model.useInstance = value;

            this._model.doDestroy();
          }

          this.updateRenderMode();
        };

        return ParticleSystemRendererCPU;
      }(ParticleSystemRendererBase);

      var _tempWorldTrans$1 = new Mat4();

      var _tempVec4 = new Vec4();

      var _world_rot = new Quat();

      var _node_rot$1 = new Quat();

      var _node_euler$1 = new Vec3();

      var _sample_num = 32;

      var _sample_interval = 1.0 / _sample_num;

      var CC_USE_WORLD_SPACE$2 = 'CC_USE_WORLD_SPACE';
      var CC_RENDER_MODE$1 = 'CC_RENDER_MODE';
      var RENDER_MODE_BILLBOARD$1 = 0;
      var RENDER_MODE_STRETCHED_BILLBOARD$1 = 1;
      var RENDER_MODE_HORIZONTAL_BILLBOARD$1 = 2;
      var RENDER_MODE_VERTICAL_BILLBOARD$1 = 3;
      var RENDER_MODE_MESH$1 = 4;
      var COLOR_OVER_TIME_MODULE_ENABLE = 'COLOR_OVER_TIME_MODULE_ENABLE';
      var ROTATION_OVER_TIME_MODULE_ENABLE$1 = 'ROTATION_OVER_TIME_MODULE_ENABLE';
      var SIZE_OVER_TIME_MODULE_ENABLE = 'SIZE_OVER_TIME_MODULE_ENABLE';
      var VELOCITY_OVER_TIME_MODULE_ENABLE = 'VELOCITY_OVER_TIME_MODULE_ENABLE';
      var FORCE_OVER_TIME_MODULE_ENABLE = 'FORCE_OVER_TIME_MODULE_ENABLE';
      var TEXTURE_ANIMATION_MODULE_ENABLE = 'TEXTURE_ANIMATION_MODULE_ENABLE';
      var USE_VK_SHADER = 'USE_VK_SHADER';
      var INSTANCE_PARTICLE$1 = 'CC_INSTANCE_PARTICLE';
      var _vert_attr_name = {
        POSITION_STARTTIME: 'a_position_starttime',
        VERT_SIZE_UV: 'a_size_uv',
        VERT_ROTATION_UV: 'a_rotation_uv',
        COLOR: 'a_color',
        DIR_LIFE: 'a_dir_life',
        RANDOM_SEED: 'a_rndSeed',
        VERT_SIZE_FID: 'a_size_fid',
        VERT_ROTATION_RND: 'a_rotation_rnd',
        VERT_UV: 'a_uv'
      };
      var _gpu_vert_attr = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_SIZE_UV, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_ROTATION_UV, Format.RGBA32F), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F)];
      var _gpu_vert_attr_mesh = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_SIZE_UV, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_ROTATION_UV, Format.RGBA32F), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true)];
      var _gpu_vert_attr_ins = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_SIZE_FID, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_ROTATION_RND, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_UV, Format.RGB32F, false, 1)];
      var _gpu_vert_attr_mesh_ins = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_SIZE_FID, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_ROTATION_RND, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true, 1)];
      var _matInsInfo$2 = {
        parent: null,
        owner: null,
        subModelIdx: 0
      };

      var ParticleSystemRendererGPU = function (_ParticleSystemRender) {
        _inheritsLoose(ParticleSystemRendererGPU, _ParticleSystemRender);

        function ParticleSystemRendererGPU(info) {
          var _this;

          _this = _ParticleSystemRender.call(this, info) || this;
          _this._defines = void 0;
          _this._frameTile_velLenScale = void 0;
          _this._unifrom_velLenScale = void 0;
          _this._tmp_velLenScale = void 0;
          _this._node_scale = void 0;
          _this._vertAttrs = [];
          _this._defaultMat = null;
          _this._particleNum = 0;
          _this._tempParticle = null;
          _this._colorTexture = null;
          _this._forceTexture = null;
          _this._velocityTexture = null;
          _this._rotationTexture = null;
          _this._sizeTexture = null;
          _this._animTexture = null;
          _this._colorData = null;
          _this._forceData = null;
          _this._velocityData = null;
          _this._rotationData = null;
          _this._sizeData = null;
          _this._animData = null;
          _this._uTimeHandle = 0;
          _this._uRotHandle = 0;
          _this._uNodeRotHandle = 0;
          _this._alignSpace = AlignmentSpace.View;
          _this._inited = false;
          _this._frameTile_velLenScale = new Vec4(1, 1, 0, 0);
          _this._unifrom_velLenScale = _this._frameTile_velLenScale.clone();
          _this._tmp_velLenScale = _this._frameTile_velLenScale.clone();
          _this._node_scale = new Vec4();
          _this._defines = {
            CC_USE_WORLD_SPACE: true,
            CC_USE_BILLBOARD: true,
            CC_USE_STRETCHED_BILLBOARD: false,
            CC_USE_HORIZONTAL_BILLBOARD: false,
            CC_USE_VERTICAL_BILLBOARD: false,
            COLOR_OVER_TIME_MODULE_ENABLE: false
          };
          _this._tempParticle = new Particle(null);
          _this._particleNum = 0;
          return _this;
        }

        var _proto = ParticleSystemRendererGPU.prototype;

        _proto.onInit = function onInit(ps) {
          _ParticleSystemRender.prototype.onInit.call(this, ps);

          this._setVertexAttrib();

          this._initModel();

          this.updateMaterialParams();
          this.setVertexAttributes();
          this._inited = true;
        };

        _proto.updateRenderMode = function updateRenderMode() {
          this._setVertexAttrib();

          this.updateMaterialParams();
          this.setVertexAttributes();
        };

        _proto.setVertexAttributes = function setVertexAttributes() {
          _ParticleSystemRender.prototype.setVertexAttributes.call(this);

          this._model.constructAttributeIndex();
        };

        _proto.clear = function clear() {
          _ParticleSystemRender.prototype.clear.call(this);

          this._particleNum = 0;
          this.updateRenderData();
        };

        _proto.onDestroy = function onDestroy() {
          _ParticleSystemRender.prototype.onDestroy.call(this);

          if (this._forceTexture) this._forceTexture.destroy();
          if (this._velocityTexture) this._velocityTexture.destroy();
          if (this._colorTexture) this._colorTexture.destroy();
          if (this._sizeTexture) this._sizeTexture.destroy();
          if (this._rotationTexture) this._rotationTexture.destroy();
          if (this._animTexture) this._animTexture.destroy();
          this._forceData = null;
          this._velocityData = null;
          this._colorData = null;
          this._sizeData = null;
          this._rotationData = null;
          this._animData = null;
        };

        _proto.enableModule = function enableModule(name, val, pm) {
          var mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

          if (!mat) {
            return;
          }

          this.initShaderUniform(mat);
          mat.recompileShaders(this._defines);

          if (this._model) {
            this._model.setSubModelMaterial(0, mat);
          }
        };

        _proto.getFreeParticle = function getFreeParticle() {
          if (this._particleNum >= this._particleSystem._capacity) {
            return null;
          }

          return this._tempParticle;
        };

        _proto.setNewParticle = function setNewParticle(p) {
          this._model.addGPUParticleVertexData(p, this._particleNum, this._particleSystem._time);

          this._particleNum++;
        };

        _proto.getDefaultMaterial = function getDefaultMaterial() {
          return this._defaultMat;
        };

        _proto.updateRotation = function updateRotation(pass) {
          if (pass) {
            this.doUpdateRotation(pass);
          }
        };

        _proto.doUpdateRotation = function doUpdateRotation(pass) {
          var mode = this._renderInfo.renderMode;

          if (mode !== RenderMode$1.Mesh && this._alignSpace === AlignmentSpace.View) {
            return;
          }

          if (this._alignSpace === AlignmentSpace.Local) {
            this._particleSystem.node.getRotation(_node_rot$1);
          } else if (this._alignSpace === AlignmentSpace.World) {
            this._particleSystem.node.getWorldRotation(_node_rot$1);
          } else if (this._alignSpace === AlignmentSpace.View) {
            var _this$_particleSystem;

            _node_rot$1.set(0.0, 0.0, 0.0, 1.0);

            var cameraLst = (_this$_particleSystem = this._particleSystem.node.scene.renderScene) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem.cameras;

            if (cameraLst !== undefined) {
              for (var i = 0; i < (cameraLst === null || cameraLst === void 0 ? void 0 : cameraLst.length); ++i) {
                var camera = cameraLst[i];
                var checkCamera =  (camera.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer ;

                if (checkCamera) {
                  Quat.fromViewUp(_node_rot$1, camera.forward);
                  break;
                }
              }
            }
          } else {
            _node_rot$1.set(0.0, 0.0, 0.0, 1.0);
          }

          pass.setUniform(this._uNodeRotHandle, _node_rot$1);
        };

        _proto.updateScale = function updateScale(pass) {
          if (pass) {
            this.doUpdateScale(pass);
          }
        };

        _proto.doUpdateScale = function doUpdateScale(pass) {
          switch (this._particleSystem.scaleSpace) {
            case Space.Local:
              this._particleSystem.node.getScale(this._node_scale);

              break;

            case Space.World:
              this._particleSystem.node.getWorldScale(this._node_scale);

              break;
          }

          pass.setUniform(pass.getHandle('scale'), this._node_scale);
        };

        _proto.updateParticles = function updateParticles(dt) {

          this._particleNum = this._model.updateGPUParticles(this._particleNum, this._particleSystem._time, dt);
          this.updateShaderUniform(dt);
          this._model.enabled = this._particleNum > 0;
          return this._particleNum;
        };

        _proto.updateRenderData = function updateRenderData() {};

        _proto.beforeRender = function beforeRender() {
          this._model.updateIA(this._particleNum);
        };

        _proto.updateAlignSpace = function updateAlignSpace(space) {
          this._alignSpace = space;
        };

        _proto.updateShaderUniform = function updateShaderUniform(dt) {
          var mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

          if (!mat) {
            return;
          }

          var pass = mat.passes[0];
          _tempVec4.x = this._particleSystem._time;
          _tempVec4.y = dt;
          pass.setUniform(this._uTimeHandle, _tempVec4);

          this._particleSystem.node.getWorldRotation(_world_rot);

          pass.setUniform(this._uRotHandle, _world_rot);
          this.doUpdateRotation(pass);
        };

        _proto.initShaderUniform = function initShaderUniform(mat) {
          var pass = mat.passes[0];
          this._uTimeHandle = pass.getHandle('u_timeDelta');
          this._uRotHandle = pass.getHandle('u_worldRot');
          this._uNodeRotHandle = pass.getHandle('nodeRotation');
          this.doUpdateScale(pass);
          pass.setUniform(pass.getHandle('frameTile_velLenScale'), this._unifrom_velLenScale);
          _tempVec4.x = _sample_num;
          _tempVec4.y = _sample_interval;
          pass.setUniform(pass.getHandle('u_sampleInfo'), _tempVec4);
          var enable = false;
          var forceModule = this._particleSystem._forceOvertimeModule;
          enable = forceModule && forceModule.enable;
          this._defines[FORCE_OVER_TIME_MODULE_ENABLE] = enable;

          if (enable) {
            var packed = packCurveRangeXYZ(this._forceTexture, this._forceData, _sample_num, forceModule.x, forceModule.y, forceModule.z);
            this._forceTexture = packed.texture;
            this._forceData = packed.texdata;
            var handle = pass.getHandle('force_over_time_tex0');
            var binding = Pass.getBindingFromHandle(handle);
            pass.bindSampler(binding, this._forceTexture.getGFXSampler());
            pass.bindTexture(binding, this._forceTexture.getGFXTexture());
            var spaceHandle = pass.getHandle('u_force_space');
            pass.setUniform(spaceHandle, forceModule.space);
            var modeHandle = pass.getHandle('u_force_mode');
            pass.setUniform(modeHandle, this._forceTexture.height);
          }

          var velocityModule = this._particleSystem._velocityOvertimeModule;
          enable = velocityModule && velocityModule.enable;
          this._defines[VELOCITY_OVER_TIME_MODULE_ENABLE] = enable;

          if (enable) {
            var _packed = packCurveRangeXYZW(this._velocityTexture, this._velocityData, _sample_num, velocityModule.x, velocityModule.y, velocityModule.z, velocityModule.speedModifier);

            this._velocityTexture = _packed.texture;
            this._velocityData = _packed.texdata;

            var _handle = pass.getHandle('velocity_over_time_tex0');

            var _binding = Pass.getBindingFromHandle(_handle);

            pass.bindSampler(_binding, this._velocityTexture.getGFXSampler());
            pass.bindTexture(_binding, this._velocityTexture.getGFXTexture());

            var _spaceHandle = pass.getHandle('u_velocity_space');

            pass.setUniform(_spaceHandle, velocityModule.space);

            var _modeHandle = pass.getHandle('u_velocity_mode');

            pass.setUniform(_modeHandle, this._velocityTexture.height);
          }

          var colorModule = this._particleSystem._colorOverLifetimeModule;
          enable = colorModule && colorModule.enable;
          this._defines[COLOR_OVER_TIME_MODULE_ENABLE] = enable;

          if (enable) {
            var _packed2 = packGradientRange(this._colorTexture, this._colorData, _sample_num, colorModule.color);

            this._colorTexture = _packed2.texture;
            this._colorData = _packed2.texdata;

            var _handle2 = pass.getHandle('color_over_time_tex0');

            var _binding2 = Pass.getBindingFromHandle(_handle2);

            pass.bindSampler(_binding2, this._colorTexture.getGFXSampler());
            pass.bindTexture(_binding2, this._colorTexture.getGFXTexture());

            var _modeHandle2 = pass.getHandle('u_color_mode');

            pass.setUniform(_modeHandle2, this._colorTexture.height);
          }

          var roationModule = this._particleSystem._rotationOvertimeModule;
          enable = roationModule && roationModule.enable;
          this._defines[ROTATION_OVER_TIME_MODULE_ENABLE$1] = enable;

          if (enable) {
            var _packed3;

            if (roationModule.separateAxes) {
              _packed3 = packCurveRangeXYZ(this._rotationTexture, this._rotationData, _sample_num, roationModule.x, roationModule.y, roationModule.z);
            } else {
              _packed3 = packCurveRangeZ(this._rotationTexture, this._rotationData, _sample_num, roationModule.z);
            }

            this._rotationTexture = _packed3.texture;
            this._rotationData = _packed3.texdata;

            if (this._rotationTexture) {
              var _handle3 = pass.getHandle('rotation_over_time_tex0');

              var _binding3 = Pass.getBindingFromHandle(_handle3);

              pass.bindSampler(_binding3, this._rotationTexture.getGFXSampler());
              pass.bindTexture(_binding3, this._rotationTexture.getGFXTexture());

              var _modeHandle3 = pass.getHandle('u_rotation_mode');

              pass.setUniform(_modeHandle3, this._rotationTexture.height);
            }
          }

          var sizeModule = this._particleSystem._sizeOvertimeModule;
          enable = sizeModule && sizeModule.enable;
          this._defines[SIZE_OVER_TIME_MODULE_ENABLE] = enable;

          if (enable) {
            var _packed4;

            if (sizeModule.separateAxes) {
              _packed4 = packCurveRangeXYZ(this._sizeTexture, this._sizeData, _sample_num, sizeModule.x, sizeModule.y, sizeModule.z, true);
            } else {
              _packed4 = packCurveRangeN(this._sizeTexture, this._sizeData, _sample_num, sizeModule.size, true);
            }

            this._sizeTexture = _packed4.texture;
            this._sizeData = _packed4.texdata;

            if (this._sizeTexture) {
              var _handle4 = pass.getHandle('size_over_time_tex0');

              var _binding4 = Pass.getBindingFromHandle(_handle4);

              pass.bindSampler(_binding4, this._sizeTexture.getGFXSampler());
              pass.bindTexture(_binding4, this._sizeTexture.getGFXTexture());

              var _modeHandle4 = pass.getHandle('u_size_mode');

              pass.setUniform(_modeHandle4, this._sizeTexture.height);
            }
          }

          var textureModule = this._particleSystem._textureAnimationModule;
          enable = textureModule && textureModule.enable;
          this._defines[TEXTURE_ANIMATION_MODULE_ENABLE] = enable;

          if (enable) {
            var _packed5 = packCurveRangeXY(this._animTexture, this._animData, _sample_num, textureModule.startFrame, textureModule.frameOverTime, true);

            this._animTexture = _packed5.texture;
            this._animData = _packed5.texdata;

            var _handle5 = pass.getHandle('texture_animation_tex0');

            var _binding5 = Pass.getBindingFromHandle(_handle5);

            pass.bindSampler(_binding5, this._animTexture.getGFXSampler());
            pass.bindTexture(_binding5, this._animTexture.getGFXTexture());
            var infoHandle = pass.getHandle('u_anim_info');
            _tempVec4.x = this._animTexture.height;
            _tempVec4.y = textureModule.numTilesX * textureModule.numTilesY;
            _tempVec4.z = textureModule.cycleCount;
            pass.setUniform(infoHandle, _tempVec4);
          }

          this._defines[USE_VK_SHADER] = deviceManager.gfxDevice.gfxAPI === API.VULKAN;
          this._defines[INSTANCE_PARTICLE$1] = this._useInstance;
        };

        _proto.getParticleCount = function getParticleCount() {
          return this._particleNum;
        };

        _proto.onMaterialModified = function onMaterialModified(index, material) {
          if (!this._inited) {
            return;
          }

          this.updateMaterialParams();
        };

        _proto.onRebuildPSO = function onRebuildPSO(index, material) {
          if (this._model && index === 0) {
            this._model.setSubModelMaterial(0, material);
          }
        };

        _proto.updateVertexAttrib = function updateVertexAttrib() {
          if (this._renderInfo.renderMode !== RenderMode$1.Mesh) {
            return;
          }

          if (this._renderInfo.mesh) {
            var format = this._renderInfo.mesh.readAttributeFormat(0, AttributeName.ATTR_COLOR);

            if (format) {
              var type = Format.RGBA8;

              for (var i = 0; i < FormatInfos.length; ++i) {
                if (FormatInfos[i].name === format.name) {
                  type = i;
                  break;
                }
              }

              this._vertAttrs[9] = new Attribute(AttributeName.ATTR_COLOR1, type, true, !this._useInstance ? 0 : 1);
            } else {
              var _type = Format.RGBA8;
              this._vertAttrs[9] = new Attribute(AttributeName.ATTR_COLOR1, _type, true, !this._useInstance ? 0 : 1);
            }
          }
        };

        _proto._setVertexAttrib = function _setVertexAttrib() {
          if (!this._useInstance) {
            switch (this._renderInfo.renderMode) {
              case RenderMode$1.StrecthedBillboard:
                this._vertAttrs = _gpu_vert_attr.slice();
                break;

              case RenderMode$1.Mesh:
                this._vertAttrs = _gpu_vert_attr_mesh.slice();
                break;

              default:
                this._vertAttrs = _gpu_vert_attr.slice();
            }
          } else {
            this._setVertexAttribIns();
          }
        };

        _proto._setVertexAttribIns = function _setVertexAttribIns() {
          switch (this._renderInfo.renderMode) {
            case RenderMode$1.StrecthedBillboard:
              this._vertAttrs = _gpu_vert_attr_ins.slice();
              break;

            case RenderMode$1.Mesh:
              this._vertAttrs = _gpu_vert_attr_mesh_ins.slice();
              break;

            default:
              this._vertAttrs = _gpu_vert_attr_ins.slice();
          }
        };

        _proto.updateMaterialParams = function updateMaterialParams() {
          if (!this._particleSystem) {
            return;
          }

          var ps = this._particleSystem;
          var shareMaterial = ps.sharedMaterial;

          if (shareMaterial !== null) {
            var effectName = shareMaterial._effectAsset._name;
            this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);
          }

          if (ps.sharedMaterial == null && this._defaultMat == null) {
            _matInsInfo$2.parent = builtinResMgr.get('default-particle-gpu-material');
            _matInsInfo$2.owner = ps;
            _matInsInfo$2.subModelIdx = 0;
            this._defaultMat = new MaterialInstance(_matInsInfo$2);
            _matInsInfo$2.parent = null;
            _matInsInfo$2.owner = null;
            _matInsInfo$2.subModelIdx = 0;

            if (this._renderInfo.mainTexture !== null) {
              this._defaultMat.setProperty('mainTexture', this._renderInfo.mainTexture);
            }
          }

          var mat = ps.getMaterialInstance(0) || this._defaultMat;

          ps.node.getWorldMatrix(_tempWorldTrans$1);

          if (ps._simulationSpace === Space.World) {
            this._defines[CC_USE_WORLD_SPACE$2] = true;
          } else {
            this._defines[CC_USE_WORLD_SPACE$2] = false;
          }

          var renderMode = this._renderInfo.renderMode;

          if (renderMode === RenderMode$1.Billboard) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_BILLBOARD$1;
          } else if (renderMode === RenderMode$1.StrecthedBillboard) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_STRETCHED_BILLBOARD$1;
            this._frameTile_velLenScale.z = this._renderInfo.velocityScale;
            this._frameTile_velLenScale.w = this._renderInfo.lengthScale;
          } else if (renderMode === RenderMode$1.HorizontalBillboard) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_HORIZONTAL_BILLBOARD$1;
          } else if (renderMode === RenderMode$1.VerticalBillboard) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_VERTICAL_BILLBOARD$1;
          } else if (renderMode === RenderMode$1.Mesh) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_MESH$1;
          } else {
            console.warn("particle system renderMode " + renderMode + " not support.");
          }

          var textureModule = ps._textureAnimationModule;

          if (textureModule && textureModule.enable) {
            Vec2.set(this._frameTile_velLenScale, textureModule.numTilesX, textureModule.numTilesY);
            Vec4.copy(this._unifrom_velLenScale, this._frameTile_velLenScale);
          } else {
            this._tmp_velLenScale.z = this._frameTile_velLenScale.z;
            this._tmp_velLenScale.w = this._frameTile_velLenScale.w;
            Vec4.copy(this._unifrom_velLenScale, this._tmp_velLenScale);
          }

          this.initShaderUniform(mat);
          mat.recompileShaders(this._defines);

          if (this._model) {
            this._model.updateMaterial(mat);
          }
        };

        _proto.setUseInstance = function setUseInstance(value) {
          if (this._useInstance === value) {
            return;
          }

          this._useInstance = value;

          if (this._model) {
            this._model.useInstance = value;

            this._model.doDestroy();
          }

          this.updateRenderMode();
        };

        _proto.getNoisePreview = function getNoisePreview(out, width, height) {};

        return ParticleSystemRendererGPU;
      }(ParticleSystemRendererBase);

      var _dec$_, _dec2$I, _dec3$E, _dec4$A, _dec5$x, _dec6$u, _dec7$s, _dec8$q, _dec9$m, _dec10$k, _dec11$i, _dec12$h, _dec13$h, _dec14$f, _dec15$f, _dec16$f, _dec17$e, _dec18$d, _dec19$c, _dec20$c, _dec21$c, _dec22$a, _dec23$9, _dec24$9, _dec25$8, _dec26$8, _dec27$8, _dec28$7, _dec29$7, _dec30$5, _dec31$5, _class$$, _class2$T, _descriptor$P, _descriptor2$I, _descriptor3$z, _descriptor4$u, _descriptor5$p, _descriptor6$l, _descriptor7$f, _descriptor8$e, _descriptor9$b, _class3$a, _temp$V;

      function isSupportGPUParticle() {
        var device = director.root.device;

        if (device.capabilities.maxVertexTextureUnits >= 8 && device.getFormatFeatures(Format.RGBA32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) {
          return true;
        }

        legacyCC.warn('Maybe the device has restrictions on vertex textures or does not support float textures.');
        return false;
      }

      var ParticleSystemRenderer = (_dec$_ = ccclass('cc.ParticleSystemRenderer'), _dec2$I = type(RenderMode$1), _dec3$E = displayOrder(), _dec4$A = tooltip(), _dec5$x = displayOrder(), _dec6$u = tooltip(), _dec7$s = displayOrder(), _dec8$q = tooltip(), _dec9$m = type(RenderMode$1), _dec10$k = type(Mesh), _dec11$i = displayOrder(), _dec12$h = tooltip(), _dec13$h = type(Material), _dec14$f = displayOrder(), _dec15$f = visible(), _dec16$f = tooltip(), _dec17$e = type(Material), _dec18$d = displayOrder(), _dec19$c = visible(), _dec20$c = type(Material), _dec21$c = displayOrder(), _dec22$a = visible(), _dec23$9 = type(Material), _dec24$9 = displayOrder(), _dec25$8 = visible(), _dec26$8 = tooltip(), _dec27$8 = displayOrder(), _dec28$7 = tooltip(), _dec29$7 = type(AlignmentSpace), _dec30$5 = displayOrder(), _dec31$5 = tooltip(), _dec$_(_class$$ = (_class2$T = (_temp$V = _class3$a = function () {
        function ParticleSystemRenderer() {
          _initializerDefineProperty(this, "_renderMode", _descriptor$P, this);

          _initializerDefineProperty(this, "_velocityScale", _descriptor2$I, this);

          _initializerDefineProperty(this, "_lengthScale", _descriptor3$z, this);

          _initializerDefineProperty(this, "_mesh", _descriptor4$u, this);

          _initializerDefineProperty(this, "_cpuMaterial", _descriptor5$p, this);

          _initializerDefineProperty(this, "_gpuMaterial", _descriptor6$l, this);

          _initializerDefineProperty(this, "_mainTexture", _descriptor7$f, this);

          _initializerDefineProperty(this, "_useGPU", _descriptor8$e, this);

          _initializerDefineProperty(this, "_alignSpace", _descriptor9$b, this);

          this._particleSystem = null;
        }

        var _proto = ParticleSystemRenderer.prototype;

        _proto.create = function create(ps) {
          if (this._particleSystem === null) {
            this._particleSystem = ps;
          } else if (this._particleSystem !== ps) {
            errorID(6033);
          }
        };

        _proto.onInit = function onInit(ps) {
          this.create(ps);
          var useGPU = this._useGPU && isSupportGPUParticle();

          if (!this._particleSystem.processor) {
            this._particleSystem.processor = useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this);

            this._particleSystem.processor.updateAlignSpace(this.alignSpace);

            this._particleSystem.processor.onInit(ps);
          } else {
            errorID(6034);
          }

          if (!useGPU) {
            if (this.particleMaterial && this.particleMaterial.effectName.indexOf('particle-gpu') !== -1) {
              this.particleMaterial = null;
              warnID(6035);
            }

            this.cpuMaterial = this.particleMaterial;
          } else {
            this.gpuMaterial = this.particleMaterial;
          }
        };

        _proto._switchProcessor = function _switchProcessor() {
          if (!this._particleSystem) {
            return;
          }

          if (this._particleSystem.processor) {
            this._particleSystem.processor.detachFromScene();

            this._particleSystem.processor.clear();

            this._particleSystem.processor = null;
          }

          var useGPU = this._useGPU && isSupportGPUParticle();

          if (!useGPU && this.cpuMaterial) {
            this.particleMaterial = this.cpuMaterial;
          }

          if (useGPU && this.gpuMaterial) {
            this.particleMaterial = this.gpuMaterial;
          }

          this._particleSystem.processor = useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this);

          this._particleSystem.processor.updateAlignSpace(this.alignSpace);

          this._particleSystem.processor.onInit(this._particleSystem);

          this._particleSystem.processor.onEnable();

          this._particleSystem.bindModule();
        };

        _createClass(ParticleSystemRenderer, [{
          key: "renderMode",
          get: function get() {
            return this._renderMode;
          },
          set: function set(val) {
            if (this._renderMode === val) {
              return;
            }

            this._renderMode = val;

            if (this._particleSystem) {
              this._particleSystem.processor.updateRenderMode();
            }
          }
        }, {
          key: "velocityScale",
          get: function get() {
            return this._velocityScale;
          },
          set: function set(val) {
            this._velocityScale = val;

            if (this._particleSystem) {
              this._particleSystem.processor.updateMaterialParams();
            }
          }
        }, {
          key: "lengthScale",
          get: function get() {
            return this._lengthScale;
          },
          set: function set(val) {
            this._lengthScale = val;

            if (this._particleSystem) {
              this._particleSystem.processor.updateMaterialParams();
            }
          }
        }, {
          key: "mesh",
          get: function get() {
            return this._mesh;
          },
          set: function set(val) {
            this._mesh = val;

            if (this._particleSystem) {
              this._particleSystem.processor.setVertexAttributes();
            }
          }
        }, {
          key: "particleMaterial",
          get: function get() {
            if (!this._particleSystem) {
              return null;
            }

            return this._particleSystem.getMaterial(0);
          },
          set: function set(val) {
            if (this._particleSystem) {
              this._particleSystem.setMaterial(val, 0);
            }
          }
        }, {
          key: "cpuMaterial",
          get: function get() {
            return this._cpuMaterial;
          },
          set: function set(val) {
            if (val === null) {
              return;
            } else {
              var effectName = val.effectName;

              if (effectName.indexOf('particle') === -1 || effectName.indexOf('particle-gpu') !== -1) {
                warnID(6035);
                return;
              }
            }

            this._cpuMaterial = val;
            this.particleMaterial = this._cpuMaterial;
          }
        }, {
          key: "gpuMaterial",
          get: function get() {
            return this._gpuMaterial;
          },
          set: function set(val) {
            if (val === null) {
              return;
            } else {
              var effectName = val.effectName;

              if (effectName.indexOf('particle-gpu') === -1) {
                warnID(6035);
                return;
              }
            }

            this._gpuMaterial = val;
            this.particleMaterial = this._gpuMaterial;
          }
        }, {
          key: "trailMaterial",
          get: function get() {
            if (!this._particleSystem) {
              return null;
            }

            return this._particleSystem.getMaterial(1);
          },
          set: function set(val) {
            if (this._particleSystem) {
              this._particleSystem.setMaterial(val, 1);
            }
          }
        }, {
          key: "mainTexture",
          get: function get() {
            return this._mainTexture;
          },
          set: function set(val) {
            this._mainTexture = val;
          }
        }, {
          key: "useGPU",
          get: function get() {
            return this._useGPU;
          },
          set: function set(val) {
            if (this._useGPU === val) {
              return;
            }

            if (!isSupportGPUParticle()) {
              this._useGPU = false;
            } else {
              this._useGPU = val;
            }

            this._switchProcessor();
          }
        }, {
          key: "alignSpace",
          get: function get() {
            return this._alignSpace;
          },
          set: function set(val) {
            this._alignSpace = val;

            this._particleSystem.processor.updateAlignSpace(this._alignSpace);
          }
        }]);

        return ParticleSystemRenderer;
      }(), _class3$a.AlignmentSpace = AlignmentSpace, _temp$V), (_applyDecoratedDescriptor(_class2$T.prototype, "renderMode", [_dec2$I, _dec3$E, _dec4$A], Object.getOwnPropertyDescriptor(_class2$T.prototype, "renderMode"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "velocityScale", [_dec5$x, _dec6$u], Object.getOwnPropertyDescriptor(_class2$T.prototype, "velocityScale"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "lengthScale", [_dec7$s, _dec8$q], Object.getOwnPropertyDescriptor(_class2$T.prototype, "lengthScale"), _class2$T.prototype), _descriptor$P = _applyDecoratedDescriptor(_class2$T.prototype, "_renderMode", [_dec9$m, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return RenderMode$1.Billboard;
        }
      }), _descriptor2$I = _applyDecoratedDescriptor(_class2$T.prototype, "_velocityScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor3$z = _applyDecoratedDescriptor(_class2$T.prototype, "_lengthScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor4$u = _applyDecoratedDescriptor(_class2$T.prototype, "_mesh", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$T.prototype, "mesh", [_dec10$k, _dec11$i, _dec12$h], Object.getOwnPropertyDescriptor(_class2$T.prototype, "mesh"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "particleMaterial", [_dec13$h, _dec14$f, disallowAnimation, _dec15$f, _dec16$f], Object.getOwnPropertyDescriptor(_class2$T.prototype, "particleMaterial"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "cpuMaterial", [_dec17$e, _dec18$d, disallowAnimation, _dec19$c], Object.getOwnPropertyDescriptor(_class2$T.prototype, "cpuMaterial"), _class2$T.prototype), _descriptor5$p = _applyDecoratedDescriptor(_class2$T.prototype, "_cpuMaterial", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$T.prototype, "gpuMaterial", [_dec20$c, _dec21$c, disallowAnimation, _dec22$a], Object.getOwnPropertyDescriptor(_class2$T.prototype, "gpuMaterial"), _class2$T.prototype), _descriptor6$l = _applyDecoratedDescriptor(_class2$T.prototype, "_gpuMaterial", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$T.prototype, "trailMaterial", [_dec23$9, _dec24$9, disallowAnimation, _dec25$8, _dec26$8], Object.getOwnPropertyDescriptor(_class2$T.prototype, "trailMaterial"), _class2$T.prototype), _descriptor7$f = _applyDecoratedDescriptor(_class2$T.prototype, "_mainTexture", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8$e = _applyDecoratedDescriptor(_class2$T.prototype, "_useGPU", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$T.prototype, "useGPU", [_dec27$8, _dec28$7], Object.getOwnPropertyDescriptor(_class2$T.prototype, "useGPU"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "alignSpace", [_dec29$7, _dec30$5, _dec31$5], Object.getOwnPropertyDescriptor(_class2$T.prototype, "alignSpace"), _class2$T.prototype), _descriptor9$b = _applyDecoratedDescriptor(_class2$T.prototype, "_alignSpace", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AlignmentSpace.View;
        }
      })), _class2$T)) || _class$$);

      var _dec$$, _dec2$J, _dec3$F, _dec4$B, _dec5$y, _dec6$v, _dec7$t, _dec8$r, _dec9$n, _dec10$l, _dec11$j, _dec12$i, _dec13$i, _dec14$g, _dec15$g, _dec16$g, _dec17$f, _dec18$e, _dec19$d, _dec20$d, _dec21$d, _dec22$b, _dec23$a, _dec24$a, _dec25$9, _dec26$9, _dec27$9, _dec28$8, _dec29$8, _dec30$6, _dec31$6, _dec32$4, _class$10, _class2$U, _descriptor$Q, _descriptor2$J, _descriptor3$A, _descriptor4$v, _descriptor5$q, _descriptor6$m, _descriptor7$g, _descriptor8$f, _descriptor9$c, _descriptor10$a, _descriptor11$7, _descriptor12$7, _descriptor13$7, _temp$W;
      var PRE_TRIANGLE_INDEX = 1;
      var NEXT_TRIANGLE_INDEX = 1 << 2;
      var DIRECTION_THRESHOLD = Math.cos(toRadian(100));
      var _temp_trailEle = {
        position: new Vec3(),
        velocity: new Vec3()
      };

      var _temp_quat = new Quat();

      var _temp_xform = new Mat4();

      var _temp_vec3 = new Vec3();

      var _temp_vec3_1 = new Vec3();

      var _temp_color = new Color();

      var TrailSegment = function () {
        function TrailSegment(maxTrailElementNum) {
          this.start = void 0;
          this.end = void 0;
          this.trailElements = void 0;
          this.start = -1;
          this.end = -1;
          this.trailElements = [];

          while (maxTrailElementNum--) {
            this.trailElements.push({
              position: new Vec3(),
              lifetime: 0,
              width: 0,
              velocity: new Vec3(),
              direction: 0,
              color: new Color()
            });
          }
        }

        var _proto = TrailSegment.prototype;

        _proto.getElement = function getElement(idx) {
          if (this.start === -1) {
            return null;
          }

          if (idx < 0) {
            idx = (idx + this.trailElements.length) % this.trailElements.length;
          }

          if (idx >= this.trailElements.length) {
            idx %= this.trailElements.length;
          }

          return this.trailElements[idx];
        };

        _proto.addElement = function addElement() {
          if (this.trailElements.length === 0) {
            return null;
          }

          if (this.start === -1) {
            this.start = 0;
            this.end = 1;
            return this.trailElements[0];
          }

          if (this.start === this.end) {
            this.trailElements.splice(this.end, 0, {
              position: new Vec3(),
              lifetime: 0,
              width: 0,
              velocity: new Vec3(),
              direction: 0,
              color: new Color()
            });
            this.start++;
            this.start %= this.trailElements.length;
          }

          var newEleLoc = this.end++;
          this.end %= this.trailElements.length;
          return this.trailElements[newEleLoc];
        };

        _proto.iterateElement = function iterateElement(target, f, p, dt) {
          var end = this.start >= this.end ? this.end + this.trailElements.length : this.end;

          for (var i = this.start; i < end; i++) {
            if (f(target, this.trailElements[i % this.trailElements.length], p, dt)) {
              this.start++;
              this.start %= this.trailElements.length;
            }
          }

          if (this.start === end) {
            this.start = -1;
            this.end = -1;
          }
        };

        _proto.count = function count() {
          if (this.start < this.end) {
            return this.end - this.start;
          } else {
            return this.trailElements.length + this.end - this.start;
          }
        };

        _proto.clear = function clear() {
          this.start = -1;
          this.end = -1;
        };

        return TrailSegment;
      }();

      var TrailModule = (_dec$$ = ccclass('cc.TrailModule'), _dec2$J = displayOrder(), _dec3$F = type(TrailMode), _dec4$B = displayOrder(), _dec5$y = tooltip(), _dec6$v = type(CurveRange), _dec7$t = range(), _dec8$r = displayOrder(), _dec9$n = tooltip(), _dec10$l = displayOrder(), _dec11$j = tooltip(), _dec12$i = type(Space), _dec13$i = displayOrder(), _dec14$g = tooltip(), _dec15$g = type(TextureMode), _dec16$g = displayOrder(), _dec17$f = tooltip(), _dec18$e = displayOrder(), _dec19$d = tooltip(), _dec20$d = type(CurveRange), _dec21$d = range(), _dec22$b = displayOrder(), _dec23$a = tooltip(), _dec24$a = displayOrder(), _dec25$9 = tooltip(), _dec26$9 = type(GradientRange), _dec27$9 = displayOrder(), _dec28$8 = tooltip(), _dec29$8 = type(GradientRange), _dec30$6 = displayOrder(), _dec31$6 = tooltip(), _dec32$4 = type(Space), _dec$$(_class$10 = (_class2$U = (_temp$W = function () {
        var _proto2 = TrailModule.prototype;

        _proto2.getModel = function getModel() {
          return this._trailModel;
        };

        function TrailModule() {
          _initializerDefineProperty(this, "_enable", _descriptor$Q, this);

          _initializerDefineProperty(this, "mode", _descriptor2$J, this);

          _initializerDefineProperty(this, "lifeTime", _descriptor3$A, this);

          _initializerDefineProperty(this, "_minParticleDistance", _descriptor4$v, this);

          _initializerDefineProperty(this, "existWithParticles", _descriptor5$q, this);

          _initializerDefineProperty(this, "textureMode", _descriptor6$m, this);

          _initializerDefineProperty(this, "widthFromParticle", _descriptor7$g, this);

          _initializerDefineProperty(this, "widthRatio", _descriptor8$f, this);

          _initializerDefineProperty(this, "colorFromParticle", _descriptor9$c, this);

          _initializerDefineProperty(this, "colorOverTrail", _descriptor10$a, this);

          _initializerDefineProperty(this, "colorOvertime", _descriptor11$7, this);

          _initializerDefineProperty(this, "_space", _descriptor12$7, this);

          _initializerDefineProperty(this, "_particleSystem", _descriptor13$7, this);

          this._minSquaredDistance = 0;
          this._vertSize = void 0;
          this._trailNum = 0;
          this._trailLifetime = 0;
          this.vbOffset = 0;
          this.ibOffset = 0;
          this._trailSegments = null;
          this._particleTrail = void 0;
          this._trailModel = null;
          this._iaInfo = void 0;
          this._iaInfoBuffer = null;
          this._subMeshData = null;
          this._vertAttrs = void 0;
          this._vbF32 = null;
          this._vbUint32 = null;
          this._iBuffer = null;
          this._needTransform = false;
          this._material = null;
          this._iaInfo = new IndirectBuffer([new DrawInfo()]);
          this._vertAttrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGBA32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
          this._vertSize = 0;

          for (var _iterator = _createForOfIteratorHelperLoose(this._vertAttrs), _step; !(_step = _iterator()).done;) {
            var a = _step.value;
            this._vertSize += FormatInfos[a.format].size;
          }

          this._particleTrail = new Map();
        }

        _proto2.onInit = function onInit(ps) {
          this._particleSystem = ps;
          this.minParticleDistance = this._minParticleDistance;
          var burstCount = 0;
          var psTime = ps.startLifetime.getMax();
          var psRate = ps.rateOverTime.getMax();
          var duration = ps.duration;

          for (var i = 0, len = ps.bursts.length; i < len; i++) {
            var b = ps.bursts[i];
            burstCount += b.getMaxCount(ps) * Math.ceil(psTime / duration);
          }

          if (this.lifeTime.getMax() < 1.0) {
            warnID(6036);
          }

          this._trailNum = Math.ceil(psTime * Math.ceil(this.lifeTime.getMax()) * 60 * (psRate * duration + burstCount));
          this._trailSegments = new Pool(function () {
            return new TrailSegment(10);
          }, Math.ceil(psRate * duration), function (obj) {
            return obj.trailElements.length = 0;
          });

          if (this._enable) {
            this.enable = this._enable;
          }
        };

        _proto2.onEnable = function onEnable() {
          this._attachToScene();
        };

        _proto2.onDisable = function onDisable() {
          this._particleTrail.clear();

          this._detachFromScene();
        };

        _proto2._attachToScene = function _attachToScene() {
          if (this._trailModel) {
            if (this._trailModel.scene) {
              this._detachFromScene();
            }

            this._particleSystem._getRenderScene().addModel(this._trailModel);
          }
        };

        _proto2._detachFromScene = function _detachFromScene() {
          if (this._trailModel && this._trailModel.scene) {
            this._trailModel.scene.removeModel(this._trailModel);
          }
        };

        _proto2.destroy = function destroy() {
          this.destroySubMeshData();

          if (this._trailModel) {
            director.root.destroyModel(this._trailModel);
            this._trailModel = null;
          }

          if (this._trailSegments) {
            this._trailSegments.destroy();

            this._trailSegments = null;
          }
        };

        _proto2.play = function play() {
          if (this._trailModel && this._enable) {
            this._trailModel.enabled = true;
          }
        };

        _proto2.clear = function clear() {
          if (this.enable) {
            var trailIter = this._particleTrail.values();

            var trail = trailIter.next();

            while (!trail.done) {
              trail.value.clear();
              trail = trailIter.next();
            }

            this._particleTrail.clear();

            this.updateRenderData();
            if (this._trailModel) this._trailModel.enabled = false;
          }
        };

        _proto2.updateMaterial = function updateMaterial() {
          if (this._particleSystem) {
            this._material = this._particleSystem.getMaterialInstance(1) || this._particleSystem.processor._defaultTrailMat;

            if (this._trailModel) {
              this._trailModel.setSubModelMaterial(0, this._material);
            }
          }
        };

        _proto2.update = function update() {
          this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1);

          if (this.space === Space.World && this._particleSystem._simulationSpace === Space.Local) {
            this._needTransform = true;

            this._particleSystem.node.getWorldMatrix(_temp_xform);

            this._particleSystem.node.getWorldRotation(_temp_quat);
          } else {
            this._needTransform = false;
          }
        };

        _proto2.animate = function animate(p, scaledDt) {
          if (!this._trailSegments) {
            return;
          }

          if (p.loopCount > p.lastLoop) {
            if (p.trailDelay > 1) {
              p.lastLoop = p.loopCount;
              p.trailDelay = 0;
            } else {
              p.trailDelay++;
            }

            return;
          }

          var trail = this._particleTrail.get(p);

          if (!trail) {
            trail = this._trailSegments.alloc();

            this._particleTrail.set(p, trail);

            return;
          }

          var lastSeg = trail.getElement(trail.end - 1);

          if (this._needTransform) {
            Vec3.transformMat4(_temp_vec3, p.position, _temp_xform);
          } else {
            Vec3.copy(_temp_vec3, p.position);
          }

          if (lastSeg) {
            trail.iterateElement(this, this._updateTrailElement, p, scaledDt);

            if (Vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance) {
              return;
            }
          }

          lastSeg = trail.addElement();

          if (!lastSeg) {
            return;
          }

          Vec3.copy(lastSeg.position, _temp_vec3);
          lastSeg.lifetime = 0;

          if (this.widthFromParticle) {
            lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1);
          } else {
            lastSeg.width = this.widthRatio.evaluate(0, 1);
          }

          var trailNum = trail.count();

          if (trailNum === 2) {
            var lastSecondTrail = trail.getElement(trail.end - 2);
            Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
          } else if (trailNum > 2) {
            var _lastSecondTrail = trail.getElement(trail.end - 2);

            var lastThirdTrail = trail.getElement(trail.end - 3);
            Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail.position);
            Vec3.subtract(_temp_vec3_1, lastSeg.position, _lastSecondTrail.position);
            Vec3.subtract(_lastSecondTrail.velocity, _temp_vec3_1, _temp_vec3);

            if (Vec3.equals(Vec3.ZERO, _lastSecondTrail.velocity)) {
              Vec3.copy(_lastSecondTrail.velocity, _temp_vec3);
            }

            Vec3.normalize(_lastSecondTrail.velocity, _lastSecondTrail.velocity);

            this._checkDirectionReverse(_lastSecondTrail, lastThirdTrail);
          }

          if (this.colorFromParticle) {
            lastSeg.color.set(p.color);
          } else {
            lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
          }
        };

        _proto2.removeParticle = function removeParticle(p) {
          var trail = this._particleTrail.get(p);

          if (trail && this._trailSegments) {
            trail.clear();

            this._trailSegments.free(trail);

            this._particleTrail["delete"](p);
          }
        };

        _proto2.updateRenderData = function updateRenderData() {
          this.vbOffset = 0;
          this.ibOffset = 0;

          for (var _iterator2 = _createForOfIteratorHelperLoose(this._particleTrail.keys()), _step2; !(_step2 = _iterator2()).done;) {
            var p = _step2.value;

            var trailSeg = this._particleTrail.get(p);

            if (trailSeg.start === -1) {
              continue;
            }

            var indexOffset = this.vbOffset * 4 / this._vertSize;
            var end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end;
            var trailNum = end - trailSeg.start;
            var textCoordSeg = 1 / trailNum;
            var startSegEle = trailSeg.trailElements[trailSeg.start];

            this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, NEXT_TRIANGLE_INDEX);

            for (var i = trailSeg.start + 1; i < end; i++) {
              var segEle = trailSeg.trailElements[i % trailSeg.trailElements.length];
              var j = i - trailSeg.start;

              this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);
            }

            if (this._needTransform) {
              Vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform);
            } else {
              Vec3.copy(_temp_trailEle.position, p.position);
            }

            var trailModel = this._trailModel;

            if (trailModel) {
              trailModel.node.invalidateChildren(TransformBit.POSITION);
            }

            if (trailNum === 1 || trailNum === 2) {
              var lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
              Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position);
              this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x;
              this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y;
              this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z;
              this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x;
              this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y;
              this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z;
              Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);

              this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
            } else if (trailNum > 2) {
              var _lastSecondTrail2 = trailSeg.getElement(trailSeg.end - 1);

              var lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
              Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail2.position);
              Vec3.subtract(_temp_vec3_1, _temp_trailEle.position, _lastSecondTrail2.position);
              Vec3.normalize(_temp_vec3, _temp_vec3);
              Vec3.normalize(_temp_vec3_1, _temp_vec3_1);
              Vec3.subtract(_lastSecondTrail2.velocity, _temp_vec3_1, _temp_vec3);
              Vec3.normalize(_lastSecondTrail2.velocity, _lastSecondTrail2.velocity);

              this._checkDirectionReverse(_lastSecondTrail2, lastThirdTrail);

              this.vbOffset -= this._vertSize / 4 * 2;
              this.ibOffset -= 6;

              this._fillVertexBuffer(_lastSecondTrail2, this.colorOverTrail.evaluate(textCoordSeg, 1), indexOffset, textCoordSeg, trailNum - 1, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);

              Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, _lastSecondTrail2.position);
              Vec3.normalize(_temp_trailEle.velocity, _temp_trailEle.velocity);

              this._checkDirectionReverse(_temp_trailEle, _lastSecondTrail2);
            }

            if (this.widthFromParticle) {
              _temp_trailEle.width = p.size.x * this.widthRatio.evaluate(0, 1);
            } else {
              _temp_trailEle.width = this.widthRatio.evaluate(0, 1);
            }

            _temp_trailEle.color = p.color;

            if (Vec3.equals(_temp_trailEle.velocity, Vec3.ZERO)) {
              this.ibOffset -= 3;
            } else {
              this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, PRE_TRIANGLE_INDEX);
            }
          }

          if (this._trailModel) {
            this._trailModel.enabled = this.ibOffset > 0;
          }
        };

        _proto2.updateIA = function updateIA(count) {
          var subModels = this._trailModel && this._trailModel.subModels;

          if (subModels && subModels.length > 0) {
            var subModel = subModels[0];
            subModel.inputAssembler.vertexBuffers[0].update(this._vbF32);
            subModel.inputAssembler.indexBuffer.update(this._iBuffer);
            this._iaInfo.drawInfos[0].firstIndex = 0;
            this._iaInfo.drawInfos[0].indexCount = count;

            this._iaInfoBuffer.update(this._iaInfo);
          }
        };

        _proto2.beforeRender = function beforeRender() {
          this.updateIA(this.ibOffset);
        };

        _proto2._createModel = function _createModel() {
          if (this._trailModel) {
            return;
          }

          this._trailModel = legacyCC.director.root.createModel(Model);
        };

        _proto2.rebuild = function rebuild() {
          var device = director.root.device;
          var vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertSize * (this._trailNum + 1) * 2, this._vertSize));
          var vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
          this._vbF32 = new Float32Array(vBuffer);
          this._vbUint32 = new Uint32Array(vBuffer);
          vertexBuffer.update(vBuffer);
          var indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, Math.max(1, this._trailNum) * 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
          this._iBuffer = new Uint16Array(Math.max(1, this._trailNum) * 6);
          indexBuffer.update(this._iBuffer);
          this._iaInfoBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
          this._iaInfo.drawInfos[0].vertexCount = (this._trailNum + 1) * 2;
          this._iaInfo.drawInfos[0].indexCount = this._trailNum * 6;

          this._iaInfoBuffer.update(this._iaInfo);

          this._subMeshData = new RenderingSubMesh([vertexBuffer], this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
          var trailModel = this._trailModel;

          if (trailModel && this._material) {
            trailModel.node = trailModel.transform = this._particleSystem.node;
            trailModel.visFlags = this._particleSystem.visibility;
            trailModel.initSubModel(0, this._subMeshData, this._material);
            trailModel.enabled = true;
          }
        };

        _proto2._updateTrailElement = function _updateTrailElement(module, trailEle, p, dt) {
          trailEle.lifetime += dt;

          if (module.colorFromParticle) {
            trailEle.color.set(p.color);
            trailEle.color.multiply(module.colorOvertime.evaluate(1.0 - p.remainingLifetime / p.startLifetime, 1));
          } else {
            trailEle.color.set(module.colorOvertime.evaluate(1.0 - p.remainingLifetime / p.startLifetime, 1));
          }

          if (module.widthFromParticle) {
            trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1);
          } else {
            trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1);
          }

          return trailEle.lifetime > module._trailLifetime;
        };

        _proto2._fillVertexBuffer = function _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
          this._vbF32[this.vbOffset++] = trailSeg.position.x;
          this._vbF32[this.vbOffset++] = trailSeg.position.y;
          this._vbF32[this.vbOffset++] = trailSeg.position.z;
          this._vbF32[this.vbOffset++] = trailSeg.direction;
          this._vbF32[this.vbOffset++] = trailSeg.width;
          this._vbF32[this.vbOffset++] = xTexCoord;
          this._vbF32[this.vbOffset++] = 0;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.z;

          _temp_color.set(trailSeg.color);

          _temp_color.multiply(colorModifer);

          this._vbUint32[this.vbOffset++] = _temp_color._val;
          this._vbF32[this.vbOffset++] = trailSeg.position.x;
          this._vbF32[this.vbOffset++] = trailSeg.position.y;
          this._vbF32[this.vbOffset++] = trailSeg.position.z;
          this._vbF32[this.vbOffset++] = 1 - trailSeg.direction;
          this._vbF32[this.vbOffset++] = trailSeg.width;
          this._vbF32[this.vbOffset++] = xTexCoord;
          this._vbF32[this.vbOffset++] = 1;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.z;
          this._vbUint32[this.vbOffset++] = _temp_color._val;

          if (indexSet & PRE_TRIANGLE_INDEX) {
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1;
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
          }

          if (indexSet & NEXT_TRIANGLE_INDEX) {
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2;
          }
        };

        _proto2._checkDirectionReverse = function _checkDirectionReverse(currElement, prevElement) {
          if (Vec3.dot(currElement.velocity, prevElement.velocity) < DIRECTION_THRESHOLD) {
            currElement.direction = 1 - prevElement.direction;
          } else {
            currElement.direction = prevElement.direction;
          }
        };

        _proto2.destroySubMeshData = function destroySubMeshData() {
          if (this._subMeshData) {
            this._subMeshData.destroy();

            this._subMeshData = null;
          }
        };

        _createClass(TrailModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (val === this._enable && this._trailModel) {
              return;
            }

            if (val && !this._enable) {
              this._enable = val;
              if (this._particleSystem.processor) this._particleSystem.processor.updateTrailMaterial();
            }

            if (val && !this._trailModel) {
              this._createModel();

              this.rebuild();
            }

            this._enable = val;

            if (this._trailModel) {
              this._trailModel.enabled = val;
            }

            if (val) this.onEnable();else this.onDisable();
          }
        }, {
          key: "minParticleDistance",
          get: function get() {
            return this._minParticleDistance;
          },
          set: function set(val) {
            this._minParticleDistance = val;
            this._minSquaredDistance = val * val;
          }
        }, {
          key: "space",
          get: function get() {
            return this._space;
          },
          set: function set(val) {
            this._space = val;
            var ps = this._particleSystem;

            if (ps && ps.processor) {
              ps.processor.updateTrailMaterial();
            }
          }
        }]);

        return TrailModule;
      }(), _temp$W), (_applyDecoratedDescriptor(_class2$U.prototype, "enable", [_dec2$J], Object.getOwnPropertyDescriptor(_class2$U.prototype, "enable"), _class2$U.prototype), _descriptor$Q = _applyDecoratedDescriptor(_class2$U.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor2$J = _applyDecoratedDescriptor(_class2$U.prototype, "mode", [_dec3$F, serializable, _dec4$B, _dec5$y], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return TrailMode.Particles;
        }
      }), _descriptor3$A = _applyDecoratedDescriptor(_class2$U.prototype, "lifeTime", [_dec6$v, serializable, _dec7$t, _dec8$r, _dec9$n], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor4$v = _applyDecoratedDescriptor(_class2$U.prototype, "_minParticleDistance", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _applyDecoratedDescriptor(_class2$U.prototype, "minParticleDistance", [_dec10$l, _dec11$j], Object.getOwnPropertyDescriptor(_class2$U.prototype, "minParticleDistance"), _class2$U.prototype), _applyDecoratedDescriptor(_class2$U.prototype, "space", [_dec12$i, _dec13$i, _dec14$g], Object.getOwnPropertyDescriptor(_class2$U.prototype, "space"), _class2$U.prototype), _descriptor5$q = _applyDecoratedDescriptor(_class2$U.prototype, "existWithParticles", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor6$m = _applyDecoratedDescriptor(_class2$U.prototype, "textureMode", [_dec15$g, serializable, _dec16$g, _dec17$f], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return TextureMode.Stretch;
        }
      }), _descriptor7$g = _applyDecoratedDescriptor(_class2$U.prototype, "widthFromParticle", [serializable, _dec18$e, _dec19$d], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor8$f = _applyDecoratedDescriptor(_class2$U.prototype, "widthRatio", [_dec20$d, serializable, _dec21$d, _dec22$b, _dec23$a], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor9$c = _applyDecoratedDescriptor(_class2$U.prototype, "colorFromParticle", [serializable, _dec24$a, _dec25$9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor10$a = _applyDecoratedDescriptor(_class2$U.prototype, "colorOverTrail", [_dec26$9, serializable, _dec27$9, _dec28$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new GradientRange();
        }
      }), _descriptor11$7 = _applyDecoratedDescriptor(_class2$U.prototype, "colorOvertime", [_dec29$8, serializable, _dec30$6, _dec31$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new GradientRange();
        }
      }), _descriptor12$7 = _applyDecoratedDescriptor(_class2$U.prototype, "_space", [_dec32$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Space.World;
        }
      }), _descriptor13$7 = _applyDecoratedDescriptor(_class2$U.prototype, "_particleSystem", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$U)) || _class$10);

      var _node_mat = new Mat4();

      var _node_parent_inv = new Mat4();

      var _node_rol = new Quat();

      var _node_scale = new Vec3();

      var _anim_module$1 = ['_colorOverLifetimeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule'];
      var ParticleCuller = function () {
        function ParticleCuller(ps) {
          this._particleSystem = void 0;
          this._processor = void 0;
          this._node = void 0;
          this._particlesAll = void 0;
          this._updateList = new Map();
          this._animateList = new Map();
          this._runAnimateList = new Array();
          this._localMat = new Mat4();
          this._gravity = new Vec4();
          this.minPos = new Vec3();
          this.maxPos = new Vec3();
          this._nodePos = new Vec3();
          this._nodeSize = new Vec3();
          this._particleSystem = ps;
          this._processor = this._particleSystem.processor;
          this._node = ps.node;
          this._particlesAll = [];

          this._initModuleList();
        }

        var _proto = ParticleCuller.prototype;

        _proto._updateBoundingNode = function _updateBoundingNode() {
          this._nodeSize.set(this.maxPos.x - this.minPos.x, this.maxPos.y - this.minPos.y, this.maxPos.z - this.minPos.z);

          this._nodePos.set(this.minPos.x + this._nodeSize.x * 0.5, this.minPos.y + this._nodeSize.y * 0.5, this.minPos.z + this._nodeSize.z * 0.5);
        };

        _proto.setBoundingBoxSize = function setBoundingBoxSize(halfExt) {
          this.maxPos.x = this._nodePos.x + halfExt.x;
          this.maxPos.y = this._nodePos.y + halfExt.y;
          this.maxPos.z = this._nodePos.z + halfExt.z;
          this.minPos.x = this._nodePos.x - halfExt.x;
          this.minPos.y = this._nodePos.y - halfExt.y;
          this.minPos.z = this._nodePos.z - halfExt.z;

          this._updateBoundingNode();
        };

        _proto.setBoundingBoxCenter = function setBoundingBoxCenter(px, py, pz) {
          this.maxPos.x = px + this._nodeSize.x * 0.5;
          this.maxPos.y = py + this._nodeSize.y * 0.5;
          this.maxPos.z = pz + this._nodeSize.z * 0.5;
          this.minPos.x = px - this._nodeSize.x * 0.5;
          this.minPos.y = py - this._nodeSize.y * 0.5;
          this.minPos.z = pz - this._nodeSize.z * 0.5;

          this._updateBoundingNode();
        };

        _proto._initModuleList = function _initModuleList() {
          var _this = this;

          _anim_module$1.forEach(function (val) {
            var pm = _this._particleSystem[val];

            if (pm && pm.enable) {
              if (pm.needUpdate) {
                _this._updateList[pm.name] = pm;
              }

              if (pm.needAnimate) {
                _this._animateList[pm.name] = pm;
              }
            }
          });

          this._runAnimateList.length = 0;

          for (var i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
            var p = this._animateList[PARTICLE_MODULE_ORDER[i]];

            if (p) {
              this._runAnimateList.push(p);
            }
          }
        };

        _proto._emit = function _emit(count, dt, particleLst) {
          var ps = this._particleSystem;
          var node = this._node;
          var loopDelta = ps.time % ps.duration / ps.duration;
          node.invalidateChildren(TransformBit.POSITION);

          if (ps.simulationSpace === Space.World) {
            node.getWorldMatrix(_node_mat);
            node.getWorldRotation(_node_rol);
          }

          for (var i = 0; i < count; ++i) {
            var particle = new Particle(ps);
            particle.particleSystem = ps;
            particle.reset();
            var rand = pseudoRandom(randomRangeInt(0, INT_MAX));

            if (ps._shapeModule && ps._shapeModule.enable) {
              ps._shapeModule.emit(particle);
            } else {
              Vec3.set(particle.position, 0, 0, 0);
              Vec3.copy(particle.velocity, particleEmitZAxis);
            }

            if (ps._textureAnimationModule && ps._textureAnimationModule.enable) {
              ps._textureAnimationModule.init(particle);
            }

            var curveStartSpeed = ps.startSpeed.evaluate(loopDelta, rand);
            Vec3.multiplyScalar(particle.velocity, particle.velocity, curveStartSpeed);

            if (ps.simulationSpace === Space.World) {
              Vec3.transformMat4(particle.position, particle.position, _node_mat);
              Vec3.transformQuat(particle.velocity, particle.velocity, _node_rol);
            }

            Vec3.copy(particle.ultimateVelocity, particle.velocity);
            Vec3.set(particle.rotation, 0, 0, 0);

            if (ps.startSize3D) {
              Vec3.set(particle.startSize, ps.startSizeX.evaluate(loopDelta, rand), ps.startSizeY.evaluate(loopDelta, rand), ps.startSizeZ.evaluate(loopDelta, rand));
            } else {
              Vec3.set(particle.startSize, ps.startSizeX.evaluate(loopDelta, rand), 1, 1);
              particle.startSize.y = particle.startSize.x;
            }

            Vec3.copy(particle.size, particle.startSize);
            particle.startLifetime = ps.startLifetime.evaluate(loopDelta, rand) + dt;
            particle.remainingLifetime = particle.startLifetime;
            particleLst.push(particle);
          }
        };

        _proto._updateParticles = function _updateParticles(dt, particleLst) {
          var _this2 = this;

          var ps = this._particleSystem;
          ps.node.getWorldMatrix(_node_mat);

          switch (ps.scaleSpace) {
            case Space.Local:
              ps.node.getScale(_node_scale);
              break;

            case Space.World:
              ps.node.getWorldScale(_node_scale);
              break;
          }

          this._updateList.forEach(function (value, key) {
            value.update(ps.simulationSpace, _node_mat);
          });

          if (ps.simulationSpace === Space.Local) {
            var r = ps.node.getRotation();
            Mat4.fromQuat(this._localMat, r);

            this._localMat.transpose();
          }

          if (ps.node.parent) {
            ps.node.parent.getWorldMatrix(_node_parent_inv);

            _node_parent_inv.invert();
          }

          var _loop = function _loop(i) {
            var p = particleLst[i];
            p.remainingLifetime -= dt;
            Vec3.set(p.animatedVelocity, 0, 0, 0);

            if (ps.simulationSpace === Space.Local) {
              var gravityFactor = -ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * 9.8 * dt;
              _this2._gravity.x = 0.0;
              _this2._gravity.y = gravityFactor;
              _this2._gravity.z = 0.0;
              _this2._gravity.w = 1.0;

              if (!approx(gravityFactor, 0.0, EPSILON$2)) {
                if (ps.node.parent) {
                  _this2._gravity = _this2._gravity.transformMat4(_node_parent_inv);
                }

                _this2._gravity = _this2._gravity.transformMat4(_this2._localMat);
                p.velocity.x += _this2._gravity.x;
                p.velocity.y += _this2._gravity.y;
                p.velocity.z += _this2._gravity.z;
              }
            } else {
              p.velocity.y -= ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * 9.8 * dt;
            }

            Vec3.copy(p.ultimateVelocity, p.velocity);

            _this2._runAnimateList.forEach(function (value) {
              value.animate(p, dt);
            });

            Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);
          };

          for (var i = 0; i < particleLst.length; ++i) {
            _loop(i);
          }
        };

        _proto._calculateBounding = function _calculateBounding(isInit) {
          var size = new Vec3();
          var position = new Vec3();
          var subPos = new Vec3();
          var addPos = new Vec3();
          var meshSize = new Vec3(1.0, 1.0, 1.0);

          if (this._processor.getInfo().renderMode === RenderMode$1.Mesh) {
            var mesh = this._processor.getInfo().mesh;

            if (mesh && mesh.struct.minPosition && mesh.struct.maxPosition) {
              var meshAABB = new AABB();
              AABB.fromPoints(meshAABB, mesh.struct.minPosition, mesh.struct.maxPosition);
              var meshMax = Math.max(meshAABB.halfExtents.x, meshAABB.halfExtents.y, meshAABB.halfExtents.z);
              meshSize.set(meshMax, meshMax, meshMax);
            }
          }

          var worldMat = this._particleSystem.node.worldMatrix;

          for (var i = 0; i < this._particlesAll.length; ++i) {
            var p = this._particlesAll[i];
            Vec3.multiply(size, _node_scale, p.size);
            Vec3.multiply(size, size, meshSize);
            position.set(p.position);

            if (this._particleSystem.simulationSpace !== Space.World) {
              Vec3.transformMat4(position, position, worldMat);
            }

            if (isInit && i === 0) {
              Vec3.subtract(this.minPos, position, size);
              Vec3.add(this.maxPos, position, size);
            } else {
              Vec3.subtract(subPos, position, size);
              Vec3.add(addPos, position, size);
              Vec3.min(this.minPos, this.minPos, subPos);
              Vec3.max(this.maxPos, this.maxPos, addPos);
            }
          }
        };

        _proto.calculatePositions = function calculatePositions() {
          this._emit(this._particleSystem.capacity, 0, this._particlesAll);

          var rand = pseudoRandom(randomRangeInt(0, INT_MAX));

          this._updateParticles(0, this._particlesAll);

          this._calculateBounding(true);

          this._updateParticles(this._particleSystem.startLifetime.evaluate(0, rand), this._particlesAll);

          this._calculateBounding(false);

          this._updateBoundingNode();
        };

        _proto.clear = function clear() {
          this._particlesAll.length = 0;
        };

        _proto.destroy = function destroy() {};

        return ParticleCuller;
      }();

      var _dec$10, _dec2$K, _dec3$G, _dec4$C, _dec5$z, _dec6$w, _dec7$u, _dec8$s, _dec9$o, _dec10$m, _dec11$k, _dec12$j, _dec13$j, _dec14$h, _dec15$h, _dec16$h, _dec17$g, _dec18$f, _dec19$e, _dec20$e, _dec21$e, _dec22$c, _dec23$b, _dec24$b, _dec25$a, _dec26$a, _dec27$a, _dec28$9, _dec29$9, _dec30$7, _dec31$7, _dec32$5, _dec33$3, _dec34$3, _dec35$3, _dec36$3, _dec37$3, _dec38$3, _dec39$3, _dec40$3, _dec41$3, _dec42$3, _dec43$3, _dec44$3, _dec45$3, _dec46$2, _dec47$2, _dec48$2, _dec49$2, _dec50$2, _dec51$2, _dec52$2, _dec53$2, _class$11, _class2$V, _descriptor$R, _descriptor2$K, _descriptor3$B, _descriptor4$w, _descriptor5$r, _descriptor6$n, _descriptor7$h, _descriptor8$g, _descriptor9$d, _descriptor10$b, _descriptor11$8, _descriptor12$8, _descriptor13$8, _descriptor14$3, _temp$X;
      var NoiseModule = (_dec$10 = ccclass('cc.NoiseModule'), _dec2$K = displayOrder(), _dec3$G = type(CCFloat), _dec4$C = range(), _dec5$z = displayOrder(), _dec6$w = type(CCFloat), _dec7$u = range(), _dec8$s = displayOrder(), _dec9$o = type(CCFloat), _dec10$m = range(), _dec11$k = displayOrder(), _dec12$j = type(CCFloat), _dec13$j = range(), _dec14$h = displayOrder(), _dec15$h = type(CCFloat), _dec16$h = range(), _dec17$g = displayOrder(), _dec18$f = type(CCFloat), _dec19$e = range(), _dec20$e = displayOrder(), _dec21$e = type(CCFloat), _dec22$c = range(), _dec23$b = rangeStep(), _dec24$b = displayOrder(), _dec25$a = visible(), _dec26$a = type(CCFloat), _dec27$a = range(), _dec28$9 = rangeStep(), _dec29$9 = displayOrder(), _dec30$7 = visible(), _dec31$7 = type(CCFloat), _dec32$5 = range(), _dec33$3 = rangeStep(), _dec34$3 = displayOrder(), _dec35$3 = visible(), _dec36$3 = type(CCFloat), _dec37$3 = range(), _dec38$3 = rangeStep(), _dec39$3 = displayOrder(), _dec40$3 = type(CCInteger), _dec41$3 = range(), _dec42$3 = rangeStep(), _dec43$3 = displayOrder(), _dec44$3 = visible(), _dec45$3 = type(CCFloat), _dec46$2 = range(), _dec47$2 = rangeStep(), _dec48$2 = displayOrder(), _dec49$2 = visible(), _dec50$2 = type(CCFloat), _dec51$2 = range(), _dec52$2 = rangeStep(), _dec53$2 = displayOrder(), _dec$10(_class$11 = (_class2$V = (_temp$X = function (_ParticleModuleBase) {
        _inheritsLoose(NoiseModule, _ParticleModuleBase);

        function NoiseModule() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ParticleModuleBase.call.apply(_ParticleModuleBase, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_enable", _descriptor$R, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_strengthX", _descriptor2$K, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_strengthY", _descriptor3$B, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_strengthZ", _descriptor4$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_noiseSpeedX", _descriptor5$r, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_noiseSpeedY", _descriptor6$n, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_noiseSpeedZ", _descriptor7$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_noiseFrequency", _descriptor8$g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_remapX", _descriptor9$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_remapY", _descriptor10$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_remapZ", _descriptor11$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_octaves", _descriptor12$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_octaveMultiplier", _descriptor13$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_octaveScale", _descriptor14$3, _assertThisInitialized(_this));

          _this.name = PARTICLE_MODULE_NAME.NOISE;
          _this.noise = new ParticleNoise();
          _this.samplePosition = new Vec3();
          return _this;
        }

        var _proto = NoiseModule.prototype;

        _proto.animate = function animate(particle, dt) {
          this.noise.setTime(particle.particleSystem.time);
          this.noise.setSpeed(this.noiseSpeedX, this.noiseSpeedY, this.noiseSpeedZ);
          this.noise.setFrequency(this.noiseFrequency);
          this.noise.setAbs(this.remapX, this.remapY, this.remapZ);
          this.noise.setAmplititude(this.strengthX, this.strengthY, this.strengthZ);
          this.noise.setOctaves(this.octaves, this.octaveMultiplier, this.octaveScale);
          this.samplePosition.set(particle.position);
          this.samplePosition.add3f(Math.random() * 1.0, Math.random() * 1.0, Math.random() * 1.0);
          this.noise.setSamplePoint(this.samplePosition);
          this.noise.getNoiseParticle();
          var noisePosition = this.noise.getResult();
          noisePosition.multiply3f(Math.random(), Math.random(), Math.random());
          Vec3.add(particle.position, particle.position, noisePosition.multiplyScalar(dt));
        };

        _proto.getNoisePreview = function getNoisePreview(out, ps, width, height) {
          this.noise.setTime(ps.time);
          this.noise.setSpeed(this.noiseSpeedX, this.noiseSpeedY, this.noiseSpeedZ);
          this.noise.setFrequency(this.noiseFrequency);
          this.noise.setAbs(this.remapX, this.remapY, this.remapZ);
          this.noise.setAmplititude(this.strengthX, this.strengthY, this.strengthZ);
          this.noise.setOctaves(this.octaves, this.octaveMultiplier, this.octaveScale);
          this.noise.getNoiseParticle();
          this.noise.getPreview(out, width, height);
        };

        _createClass(NoiseModule, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(val) {
            if (this._enable === val) return;
            this._enable = val;
            if (!this.target) return;
            this.target.enableModule(this.name, val, this);
          }
        }, {
          key: "strengthX",
          get: function get() {
            return this._strengthX;
          },
          set: function set(value) {
            this._strengthX = value;
          }
        }, {
          key: "strengthY",
          get: function get() {
            return this._strengthY;
          },
          set: function set(value) {
            this._strengthY = value;
          }
        }, {
          key: "strengthZ",
          get: function get() {
            return this._strengthZ;
          },
          set: function set(value) {
            this._strengthZ = value;
          }
        }, {
          key: "noiseSpeedX",
          get: function get() {
            return this._noiseSpeedX;
          },
          set: function set(value) {
            this._noiseSpeedX = value;
          }
        }, {
          key: "noiseSpeedY",
          get: function get() {
            return this._noiseSpeedY;
          },
          set: function set(value) {
            this._noiseSpeedY = value;
          }
        }, {
          key: "noiseSpeedZ",
          get: function get() {
            return this._noiseSpeedZ;
          },
          set: function set(value) {
            this._noiseSpeedZ = value;
          }
        }, {
          key: "noiseFrequency",
          get: function get() {
            return this._noiseFrequency;
          },
          set: function set(value) {
            this._noiseFrequency = value;
          }
        }, {
          key: "remapX",
          get: function get() {
            return this._remapX;
          },
          set: function set(value) {
            this._remapX = value;
          }
        }, {
          key: "remapY",
          get: function get() {
            return this._remapY;
          },
          set: function set(value) {
            this._remapY = value;
          }
        }, {
          key: "remapZ",
          get: function get() {
            return this._remapZ;
          },
          set: function set(value) {
            this._remapZ = value;
          }
        }, {
          key: "octaves",
          get: function get() {
            return this._octaves;
          },
          set: function set(value) {
            this._octaves = value;
          }
        }, {
          key: "octaveMultiplier",
          get: function get() {
            return this._octaveMultiplier;
          },
          set: function set(value) {
            this._octaveMultiplier = value;
          }
        }, {
          key: "octaveScale",
          get: function get() {
            return this._octaveScale;
          },
          set: function set(value) {
            this._octaveScale = value;
          }
        }]);

        return NoiseModule;
      }(ParticleModuleBase), _temp$X), (_descriptor$R = _applyDecoratedDescriptor(_class2$V.prototype, "_enable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "enable", [_dec2$K], Object.getOwnPropertyDescriptor(_class2$V.prototype, "enable"), _class2$V.prototype), _applyDecoratedDescriptor(_class2$V.prototype, "strengthX", [_dec3$G, _dec4$C, _dec5$z, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "strengthX"), _class2$V.prototype), _descriptor2$K = _applyDecoratedDescriptor(_class2$V.prototype, "_strengthX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "strengthY", [_dec6$w, _dec7$u, _dec8$s, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "strengthY"), _class2$V.prototype), _descriptor3$B = _applyDecoratedDescriptor(_class2$V.prototype, "_strengthY", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "strengthZ", [_dec9$o, _dec10$m, _dec11$k, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "strengthZ"), _class2$V.prototype), _descriptor4$w = _applyDecoratedDescriptor(_class2$V.prototype, "_strengthZ", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "noiseSpeedX", [_dec12$j, _dec13$j, slide, _dec14$h], Object.getOwnPropertyDescriptor(_class2$V.prototype, "noiseSpeedX"), _class2$V.prototype), _descriptor5$r = _applyDecoratedDescriptor(_class2$V.prototype, "_noiseSpeedX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "noiseSpeedY", [_dec15$h, _dec16$h, _dec17$g, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "noiseSpeedY"), _class2$V.prototype), _descriptor6$n = _applyDecoratedDescriptor(_class2$V.prototype, "_noiseSpeedY", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "noiseSpeedZ", [_dec18$f, _dec19$e, _dec20$e, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "noiseSpeedZ"), _class2$V.prototype), _descriptor7$h = _applyDecoratedDescriptor(_class2$V.prototype, "_noiseSpeedZ", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "noiseFrequency", [_dec21$e, _dec22$c, _dec23$b, _dec24$b, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "noiseFrequency"), _class2$V.prototype), _descriptor8$g = _applyDecoratedDescriptor(_class2$V.prototype, "_noiseFrequency", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "remapX", [_dec25$a, _dec26$a, _dec27$a, _dec28$9, _dec29$9, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "remapX"), _class2$V.prototype), _descriptor9$d = _applyDecoratedDescriptor(_class2$V.prototype, "_remapX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "remapY", [_dec30$7, _dec31$7, _dec32$5, _dec33$3, _dec34$3, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "remapY"), _class2$V.prototype), _descriptor10$b = _applyDecoratedDescriptor(_class2$V.prototype, "_remapY", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "remapZ", [_dec35$3, _dec36$3, _dec37$3, _dec38$3, _dec39$3, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "remapZ"), _class2$V.prototype), _descriptor11$8 = _applyDecoratedDescriptor(_class2$V.prototype, "_remapZ", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "octaves", [_dec40$3, _dec41$3, _dec42$3, _dec43$3, slide], Object.getOwnPropertyDescriptor(_class2$V.prototype, "octaves"), _class2$V.prototype), _descriptor12$8 = _applyDecoratedDescriptor(_class2$V.prototype, "_octaves", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "octaveMultiplier", [_dec44$3, _dec45$3, _dec46$2, _dec47$2, _dec48$2], Object.getOwnPropertyDescriptor(_class2$V.prototype, "octaveMultiplier"), _class2$V.prototype), _descriptor13$8 = _applyDecoratedDescriptor(_class2$V.prototype, "_octaveMultiplier", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "octaveScale", [_dec49$2, _dec50$2, _dec51$2, _dec52$2, _dec53$2], Object.getOwnPropertyDescriptor(_class2$V.prototype, "octaveScale"), _class2$V.prototype), _descriptor14$3 = _applyDecoratedDescriptor(_class2$V.prototype, "_octaveScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      })), _class2$V)) || _class$11);

      var _dec$11, _dec2$L, _dec3$H, _dec4$D, _dec5$A, _dec6$x, _dec7$v, _dec8$t, _dec9$p, _dec10$n, _dec11$l, _dec12$k, _dec13$k, _dec14$i, _dec15$i, _dec16$i, _dec17$h, _dec18$g, _dec19$f, _dec20$f, _dec21$f, _dec22$d, _dec23$c, _dec24$c, _dec25$b, _dec26$b, _dec27$b, _dec28$a, _dec29$a, _dec30$8, _dec31$8, _dec32$6, _dec33$4, _dec34$4, _dec35$4, _dec36$4, _dec37$4, _dec38$4, _dec39$4, _dec40$4, _dec41$4, _dec42$4, _dec43$4, _dec44$4, _dec45$4, _dec46$3, _dec47$3, _dec48$3, _dec49$3, _dec50$3, _dec51$3, _dec52$3, _dec53$3, _dec54$2, _dec55$2, _dec56$2, _dec57$2, _dec58$1, _dec59$1, _dec60$1, _dec61, _dec62, _dec63, _dec64, _dec65, _dec66, _dec67, _dec68, _dec69, _dec70, _dec71, _dec72, _dec73, _dec74, _dec75, _dec76, _dec77, _dec78, _dec79, _dec80, _dec81, _dec82, _dec83, _dec84, _dec85, _dec86, _dec87, _dec88, _dec89, _dec90, _dec91, _dec92, _dec93, _dec94, _dec95, _dec96, _dec97, _dec98, _dec99, _dec100, _dec101, _dec102, _dec103, _dec104, _dec105, _dec106, _dec107, _dec108, _dec109, _dec110, _dec111, _dec112, _dec113, _dec114, _dec115, _dec116, _dec117, _dec118, _dec119, _dec120, _dec121, _dec122, _dec123, _dec124, _dec125, _dec126, _dec127, _dec128, _dec129, _dec130, _dec131, _dec132, _dec133, _dec134, _dec135, _dec136, _dec137, _dec138, _dec139, _dec140, _dec141, _dec142, _dec143, _dec144, _dec145, _dec146, _dec147, _dec148, _dec149, _dec150, _dec151, _class$12, _class2$W, _descriptor$S, _descriptor2$L, _descriptor3$C, _descriptor4$x, _descriptor5$s, _descriptor6$o, _descriptor7$i, _descriptor8$h, _descriptor9$e, _descriptor10$c, _descriptor11$9, _descriptor12$9, _descriptor13$9, _descriptor14$4, _descriptor15$3, _descriptor16$3, _descriptor17$2, _descriptor18$1, _descriptor19$1, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _descriptor33, _descriptor34, _descriptor35, _descriptor36, _descriptor37, _descriptor38, _descriptor39, _descriptor40, _descriptor41, _class3$b, _temp$Y;

      var _world_mat = new Mat4();

      var _world_rol = new Quat();

      var superMaterials = Object.getOwnPropertyDescriptor(Renderer.prototype, 'sharedMaterials');
      var ParticleSystem = function (v) { return exports({ ParticleSystem: v, ParticleSystemComponent: v }), v; }((_dec$11 = ccclass('cc.ParticleSystem'), _dec2$L = help(), _dec3$H = menu(), _dec4$D = executionOrder(99), _dec5$A = range(), _dec6$x = displayOrder(), _dec7$v = tooltip(), _dec8$t = type(GradientRange), _dec9$p = displayOrder(), _dec10$n = tooltip(), _dec11$l = type(Space), _dec12$k = displayOrder(), _dec13$k = tooltip(), _dec14$i = displayOrder(), _dec15$i = tooltip(), _dec16$i = formerlySerializedAs('startSize'), _dec17$h = range(), _dec18$g = type(CurveRange), _dec19$f = displayOrder(), _dec20$f = tooltip(), _dec21$f = type(CurveRange), _dec22$d = range(), _dec23$c = displayOrder(), _dec24$c = tooltip(), _dec25$b = visible(), _dec26$b = type(CurveRange), _dec27$b = range(), _dec28$a = displayOrder(), _dec29$a = tooltip(), _dec30$8 = visible(), _dec31$8 = type(CurveRange), _dec32$6 = range(), _dec33$4 = displayOrder(), _dec34$4 = tooltip(), _dec35$4 = displayOrder(), _dec36$4 = tooltip(), _dec37$4 = type(CurveRange), _dec38$4 = range(), _dec39$4 = displayOrder(), _dec40$4 = tooltip(), _dec41$4 = visible(), _dec42$4 = type(CurveRange), _dec43$4 = range(), _dec44$4 = displayOrder(), _dec45$4 = tooltip(), _dec46$3 = visible(), _dec47$3 = type(CurveRange), _dec48$3 = formerlySerializedAs('startRotation'), _dec49$3 = range(), _dec50$3 = displayOrder(), _dec51$3 = tooltip(), _dec52$3 = visible(), _dec53$3 = type(CurveRange), _dec54$2 = range(), _dec55$2 = displayOrder(), _dec56$2 = tooltip(), _dec57$2 = type(CurveRange), _dec58$1 = range(), _dec59$1 = displayOrder(), _dec60$1 = tooltip(), _dec61 = displayOrder(), _dec62 = tooltip(), _dec63 = displayOrder(), _dec64 = tooltip(), _dec65 = displayOrder(), _dec66 = tooltip(), _dec67 = type(Space), _dec68 = displayOrder(), _dec69 = tooltip(), _dec70 = displayOrder(), _dec71 = tooltip(), _dec72 = displayOrder(), _dec73 = tooltip(), _dec74 = type(CurveRange), _dec75 = range(), _dec76 = displayOrder(), _dec77 = tooltip(), _dec78 = type(CurveRange), _dec79 = range(), _dec80 = displayOrder(), _dec81 = tooltip(), _dec82 = type(CurveRange), _dec83 = range(), _dec84 = displayOrder(), _dec85 = tooltip(), _dec86 = type([Burst]), _dec87 = displayOrder(), _dec88 = tooltip(), _dec89 = type(CCBoolean), _dec90 = displayOrder(), _dec91 = tooltip(), _dec92 = type(CullingMode), _dec93 = displayOrder(), _dec94 = tooltip(), _dec95 = type(CCFloat), _dec96 = displayOrder(), _dec97 = tooltip(), _dec98 = type(CCFloat), _dec99 = displayOrder(), _dec100 = tooltip(), _dec101 = type(CCFloat), _dec102 = displayOrder(), _dec103 = tooltip(), _dec104 = displayOrder(), _dec105 = tooltip(), _dec106 = formerlySerializedAs('enableCulling'), _dec107 = visible(), _dec108 = type(Material), _dec109 = displayName(), _dec110 = type(ColorOvertimeModule), _dec111 = type(ColorOvertimeModule), _dec112 = displayOrder(), _dec113 = tooltip(), _dec114 = type(ShapeModule), _dec115 = type(ShapeModule), _dec116 = displayOrder(), _dec117 = tooltip(), _dec118 = type(SizeOvertimeModule), _dec119 = type(SizeOvertimeModule), _dec120 = displayOrder(), _dec121 = tooltip(), _dec122 = type(VelocityOvertimeModule), _dec123 = type(VelocityOvertimeModule), _dec124 = displayOrder(), _dec125 = tooltip(), _dec126 = type(ForceOvertimeModule), _dec127 = type(ForceOvertimeModule), _dec128 = displayOrder(), _dec129 = tooltip(), _dec130 = type(LimitVelocityOvertimeModule), _dec131 = type(LimitVelocityOvertimeModule), _dec132 = displayOrder(), _dec133 = tooltip(), _dec134 = type(RotationOvertimeModule), _dec135 = type(RotationOvertimeModule), _dec136 = displayOrder(), _dec137 = tooltip(), _dec138 = type(TextureAnimationModule), _dec139 = type(TextureAnimationModule), _dec140 = displayOrder(), _dec141 = tooltip(), _dec142 = type(NoiseModule), _dec143 = type(NoiseModule), _dec144 = displayOrder(), _dec145 = type(TrailModule), _dec146 = type(TrailModule), _dec147 = displayOrder(), _dec148 = tooltip(), _dec149 = type(ParticleSystemRenderer), _dec150 = displayOrder(), _dec151 = tooltip(), _dec$11(_class$12 = _dec2$L(_class$12 = _dec3$H(_class$12 = _dec4$D(_class$12 = executeInEditMode(_class$12 = (_class2$W = (_temp$Y = _class3$b = function (_ModelRenderer) {
        _inheritsLoose(ParticleSystem, _ModelRenderer);

        function ParticleSystem() {
          var _this;

          _this = _ModelRenderer.call(this) || this;

          _initializerDefineProperty(_this, "startColor", _descriptor$S, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "scaleSpace", _descriptor2$L, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startSize3D", _descriptor3$C, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startSizeX", _descriptor4$x, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startSizeY", _descriptor5$s, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startSizeZ", _descriptor6$o, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startSpeed", _descriptor7$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startRotation3D", _descriptor8$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startRotationX", _descriptor9$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startRotationY", _descriptor10$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startRotationZ", _descriptor11$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startDelay", _descriptor12$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "startLifetime", _descriptor13$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "duration", _descriptor14$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "loop", _descriptor15$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "simulationSpeed", _descriptor16$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "playOnAwake", _descriptor17$2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "gravityModifier", _descriptor18$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "rateOverTime", _descriptor19$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "rateOverDistance", _descriptor20, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "bursts", _descriptor21, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_renderCulling", _descriptor22, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cullingMode", _descriptor23, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_aabbHalfX", _descriptor24, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_aabbHalfY", _descriptor25, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_aabbHalfZ", _descriptor26, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_dataCulling", _descriptor27, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_colorOverLifetimeModule", _descriptor28, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shapeModule", _descriptor29, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_sizeOvertimeModule", _descriptor30, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_velocityOvertimeModule", _descriptor31, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_forceOvertimeModule", _descriptor32, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_limitVelocityOvertimeModule", _descriptor33, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_rotationOvertimeModule", _descriptor34, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_textureAnimationModule", _descriptor35, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_noiseModule", _descriptor36, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_trailModule", _descriptor37, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "renderer", _descriptor38, _assertThisInitialized(_this));

          _this._isPlaying = void 0;
          _this._isPaused = void 0;
          _this._isStopped = void 0;
          _this._isEmitting = void 0;
          _this._needRefresh = void 0;
          _this._time = void 0;
          _this._emitRateTimeCounter = void 0;
          _this._emitRateDistanceCounter = void 0;
          _this._oldWPos = void 0;
          _this._curWPos = void 0;
          _this._boundingBox = void 0;
          _this._culler = void 0;
          _this._oldPos = void 0;
          _this._curPos = void 0;
          _this._isCulled = void 0;
          _this._isSimulating = void 0;
          _this._customData1 = void 0;
          _this._customData2 = void 0;
          _this._subEmitters = void 0;
          _this._needAttach = void 0;

          _initializerDefineProperty(_this, "_prewarm", _descriptor39, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_capacity", _descriptor40, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_simulationSpace", _descriptor41, _assertThisInitialized(_this));

          _this.processor = null;
          _this.rateOverTime.constant = 10;
          _this.startLifetime.constant = 5;
          _this.startSizeX.constant = 1;
          _this.startSpeed.constant = 5;
          _this._isPlaying = false;
          _this._isPaused = false;
          _this._isStopped = true;
          _this._isEmitting = false;
          _this._needRefresh = true;
          _this._needAttach = false;
          _this._time = 0.0;
          _this._emitRateTimeCounter = 0.0;
          _this._emitRateDistanceCounter = 0.0;
          _this._oldWPos = new Vec3();
          _this._curWPos = new Vec3();
          _this._boundingBox = null;
          _this._culler = null;
          _this._oldPos = null;
          _this._curPos = null;
          _this._isCulled = false;
          _this._isSimulating = true;
          _this._customData1 = new Vec2();
          _this._customData2 = new Vec2();
          _this._subEmitters = [];
          return _this;
        }

        var _proto = ParticleSystem.prototype;

        _proto.onFocusInEditor = function onFocusInEditor() {
          this.renderer.create(this);
        };

        _proto.onLoad = function onLoad() {
          this.renderer.onInit(this);
          if (this._shapeModule) this._shapeModule.onInit(this);

          if (this._trailModule && !this.renderer.useGPU) {
            this._trailModule.onInit(this);
          }

          this.bindModule();

          this._resetPosition();
        };

        _proto._onMaterialModified = function _onMaterialModified(index, material) {
          if (this.processor !== null) {
            this.processor.onMaterialModified(index, material);
          }
        };

        _proto._onRebuildPSO = function _onRebuildPSO(index, material) {
          this.processor.onRebuildPSO(index, material);
        };

        _proto._collectModels = function _collectModels() {
          this._models.length = 0;

          this._models.push(this.processor._model);

          if (this._trailModule && this._trailModule.enable && this._trailModule._trailModel) {
            this._models.push(this._trailModule._trailModel);
          }

          return this._models;
        };

        _proto._attachToScene = function _attachToScene() {
          this.processor.attachToScene();

          if (this._trailModule && this._trailModule.enable) {
            this._trailModule._attachToScene();
          }
        };

        _proto._detachFromScene = function _detachFromScene() {
          this.processor.detachFromScene();

          if (this._trailModule && this._trailModule.enable) {
            this._trailModule._detachFromScene();
          }

          if (this._boundingBox) {
            this._boundingBox = null;
          }

          if (this._culler) {
            this._culler.clear();

            this._culler.destroy();

            this._culler = null;
          }
        };

        _proto.bindModule = function bindModule() {
          if (this._colorOverLifetimeModule) this._colorOverLifetimeModule.bindTarget(this.processor);
          if (this._sizeOvertimeModule) this._sizeOvertimeModule.bindTarget(this.processor);
          if (this._rotationOvertimeModule) this._rotationOvertimeModule.bindTarget(this.processor);
          if (this._forceOvertimeModule) this._forceOvertimeModule.bindTarget(this.processor);
          if (this._limitVelocityOvertimeModule) this._limitVelocityOvertimeModule.bindTarget(this.processor);
          if (this._velocityOvertimeModule) this._velocityOvertimeModule.bindTarget(this.processor);
          if (this._textureAnimationModule) this._textureAnimationModule.bindTarget(this.processor);
          if (this._noiseModule) this._noiseModule.bindTarget(this.processor);
        };

        _proto.play = function play() {
          if (this._isPaused) {
            this._isPaused = false;
          }

          if (this._isStopped) {
            this._isStopped = false;
          }

          this._isPlaying = true;
          this._isEmitting = true;

          this._resetPosition();

          if (this._prewarm) {
            this._prewarmSystem();
          }

          if (this._trailModule) {
            this._trailModule.play();
          }

          if (this.processor) {
            var model = this.processor.getModel();

            if (model) {
              model.enabled = this.enabledInHierarchy;
            }
          }
        };

        _proto.pause = function pause() {
          if (this._isStopped) {
            console.warn('pause(): particle system is already stopped.');
            return;
          }

          if (this._isPlaying) {
            this._isPlaying = false;
          }

          this._isPaused = true;
        };

        _proto.stopEmitting = function stopEmitting() {
          this._isEmitting = false;
        };

        _proto.stop = function stop() {
          if (this._isPlaying || this._isPaused) {
            this.clear();
          }

          if (this._isPlaying) {
            this._isPlaying = false;
          }

          if (this._isPaused) {
            this._isPaused = false;
          }

          if (this._isEmitting) {
            this._isEmitting = false;
          }

          this._time = 0.0;
          this._emitRateTimeCounter = 0.0;
          this._emitRateDistanceCounter = 0.0;
          this._isStopped = true;
          this._needRefresh = true;

          for (var _iterator = _createForOfIteratorHelperLoose(this.bursts), _step; !(_step = _iterator()).done;) {
            var burst = _step.value;
            burst.reset();
          }
        };

        _proto.clear = function clear() {
          if (this.enabledInHierarchy) {
            this.processor.clear();
            if (this._trailModule) this._trailModule.clear();
          }

          this._calculateBounding(false);
        };

        _proto.getParticleCount = function getParticleCount() {
          return this.processor.getParticleCount();
        };

        _proto.setCustomData1 = function setCustomData1(x, y) {
          Vec2.set(this._customData1, x, y);
        };

        _proto.setCustomData2 = function setCustomData2(x, y) {
          Vec2.set(this._customData2, x, y);
        };

        _proto.onDestroy = function onDestroy() {
          var _this$processor$getMo;

          this.stop();

          if ((_this$processor$getMo = this.processor.getModel()) === null || _this$processor$getMo === void 0 ? void 0 : _this$processor$getMo.scene) {
            this.processor.detachFromScene();

            if (this._trailModule && this._trailModule.enable) {
              this._trailModule._detachFromScene();
            }
          }

          legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
          this.processor.onDestroy();
          if (this._trailModule) this._trailModule.destroy();

          if (this._culler) {
            this._culler.clear();

            this._culler.destroy();

            this._culler = null;
          }
        };

        _proto.onEnable = function onEnable() {
          _ModelRenderer.prototype.onEnable.call(this);

          legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);

          if (this.playOnAwake && (!EDITOR )) {
            this.play();
          }

          this.processor.onEnable();
          if (this._trailModule) this._trailModule.onEnable();
        };

        _proto.onDisable = function onDisable() {
          legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
          this.processor.onDisable();
          if (this._trailModule) this._trailModule.onDisable();

          if (this._boundingBox) {
            this._boundingBox = null;
          }

          if (this._culler) {
            this._culler.clear();

            this._culler.destroy();

            this._culler = null;
          }
        };

        _proto._calculateBounding = function _calculateBounding(forceRefresh) {
          if (this._boundingBox) {
            if (!this._culler) {
              this._culler = new ParticleCuller(this);
            }

            this._culler.calculatePositions();

            AABB.fromPoints(this._boundingBox, this._culler.minPos, this._culler.maxPos);

            if (forceRefresh) {
              this.aabbHalfX = this._boundingBox.halfExtents.x;
              this.aabbHalfY = this._boundingBox.halfExtents.y;
              this.aabbHalfZ = this._boundingBox.halfExtents.z;
            } else {
              if (this.aabbHalfX) {
                this.setBoundingX(this.aabbHalfX);
              } else {
                this.aabbHalfX = this._boundingBox.halfExtents.x;
              }

              if (this.aabbHalfY) {
                this.setBoundingY(this.aabbHalfY);
              } else {
                this.aabbHalfY = this._boundingBox.halfExtents.y;
              }

              if (this.aabbHalfZ) {
                this.setBoundingZ(this.aabbHalfZ);
              } else {
                this.aabbHalfZ = this._boundingBox.halfExtents.z;
              }
            }

            this._culler.clear();
          }
        };

        _proto.update = function update(dt) {
          var scaledDeltaTime = dt * this.simulationSpeed;

          if (!this.renderCulling) {
            if (this._boundingBox) {
              this._boundingBox = null;
            }

            if (this._culler) {
              this._culler.clear();

              this._culler.destroy();

              this._culler = null;
            }

            this._isSimulating = true;
          } else {
            var _this$node$scene$rend;

            if (!this._boundingBox) {
              this._boundingBox = new AABB();

              this._calculateBounding(false);
            }

            if (!this._curPos) {
              this._curPos = new Vec3();
            }

            this.node.getWorldPosition(this._curPos);

            if (!this._oldPos) {
              this._oldPos = new Vec3();

              this._oldPos.set(this._curPos);
            }

            if (!this._curPos.equals(this._oldPos) && this._boundingBox && this._culler) {
              var dx = this._curPos.x - this._oldPos.x;
              var dy = this._curPos.y - this._oldPos.y;
              var dz = this._curPos.z - this._oldPos.z;
              var center = this._boundingBox.center;
              center.x += dx;
              center.y += dy;
              center.z += dz;

              this._culler.setBoundingBoxCenter(center.x, center.y, center.z);

              this._oldPos.set(this._curPos);
            }

            var cameraLst = (_this$node$scene$rend = this.node.scene.renderScene) === null || _this$node$scene$rend === void 0 ? void 0 : _this$node$scene$rend.cameras;
            var culled = true;

            if (cameraLst !== undefined && this._boundingBox) {
              for (var i = 0; i < cameraLst.length; ++i) {
                var camera = cameraLst[i];
                var visibility = camera.visibility;

                if ((visibility & this.node.layer) === this.node.layer) {
                  if (intersect.aabbFrustum(this._boundingBox, camera.frustum)) {
                    culled = false;
                    break;
                  }
                }
              }
            }

            if (culled) {
              if (this._cullingMode !== CullingMode.AlwaysSimulate) {
                this._isSimulating = false;
              }

              if (!this._isCulled) {
                this.processor.detachFromScene();
                this._isCulled = true;
              }

              if (this._trailModule && this._trailModule.enable) {
                this._trailModule._detachFromScene();
              }

              if (this._cullingMode === CullingMode.PauseAndCatchup) {
                this._time += scaledDeltaTime;
              }

              if (this._cullingMode !== CullingMode.AlwaysSimulate) {
                return;
              }
            } else {
              if (this._isCulled) {
                this._attachToScene();

                this._isCulled = false;
              }

              if (!this._isSimulating) {
                this._isSimulating = true;
              }
            }

            if (!this._isSimulating) {
              return;
            }
          }

          if (this._isPlaying) {
            this._time += scaledDeltaTime;

            this._emit(scaledDeltaTime);

            if (this.processor.updateParticles(scaledDeltaTime) === 0 && !this._isEmitting) {
              this.stop();
            }
          } else {
            var mat = this.getMaterialInstance(0) || this.processor.getDefaultMaterial();
            var pass = mat.passes[0];
            this.processor.updateRotation(pass);
            this.processor.updateScale(pass);
          }

          this.processor.updateRenderData();

          if (this._trailModule && this._trailModule.enable) {
            this._trailModule.updateRenderData();
          }

          if (this._needAttach) {
            if (this.getParticleCount() > 0) {
              if (!this._isCulled) {
                var _this$processor$getMo2;

                if (!((_this$processor$getMo2 = this.processor.getModel()) === null || _this$processor$getMo2 === void 0 ? void 0 : _this$processor$getMo2.scene)) {
                  this.processor.attachToScene();
                }

                if (this._trailModule && this._trailModule.enable) {
                  var _this$_trailModule$ge;

                  if (!((_this$_trailModule$ge = this._trailModule.getModel()) === null || _this$_trailModule$ge === void 0 ? void 0 : _this$_trailModule$ge.scene)) {
                    this._trailModule._attachToScene();
                  }
                }

                this._needAttach = false;
              }
            }
          }
        };

        _proto.beforeRender = function beforeRender() {
          var _this$processor$getMo4;

          if (!this._isPlaying) return;
          this.processor.beforeRender();

          if (this._trailModule && this._trailModule.enable) {
            this._trailModule.beforeRender();
          }

          if (this.getParticleCount() <= 0) {
            var _this$processor$getMo3;

            if ((_this$processor$getMo3 = this.processor.getModel()) === null || _this$processor$getMo3 === void 0 ? void 0 : _this$processor$getMo3.scene) {
              this.processor.detachFromScene();

              if (this._trailModule && this._trailModule.enable) {
                this._trailModule._detachFromScene();
              }

              this._needAttach = false;
            }
          } else if (!((_this$processor$getMo4 = this.processor.getModel()) === null || _this$processor$getMo4 === void 0 ? void 0 : _this$processor$getMo4.scene)) {
            this._needAttach = true;
          }
        };

        _proto._onVisibilityChange = function _onVisibilityChange(val) {
          if (this.processor._model) {
            this.processor._model.visFlags = val;
          }
        };

        _proto.emit = function emit(count, dt) {
          var loopDelta = this._time % this.duration / this.duration;

          if (this._needRefresh) {
            this.node.invalidateChildren(TransformBit.POSITION);
            this._needRefresh = false;
          }

          if (this._simulationSpace === Space.World) {
            this.node.getWorldMatrix(_world_mat);
            this.node.getWorldRotation(_world_rol);
          }

          for (var i = 0; i < count; ++i) {
            var particle = this.processor.getFreeParticle();

            if (particle === null) {
              return;
            }

            particle.particleSystem = this;
            particle.reset();
            var rand = pseudoRandom(randomRangeInt(0, INT_MAX));

            if (this._shapeModule && this._shapeModule.enable) {
              this._shapeModule.emit(particle);
            } else {
              Vec3.set(particle.position, 0, 0, 0);
              Vec3.copy(particle.velocity, particleEmitZAxis);
            }

            if (this._textureAnimationModule && this._textureAnimationModule.enable) {
              this._textureAnimationModule.init(particle);
            }

            var curveStartSpeed = this.startSpeed.evaluate(loopDelta, rand);
            Vec3.multiplyScalar(particle.velocity, particle.velocity, curveStartSpeed);

            if (this._simulationSpace === Space.World) {
              Vec3.transformMat4(particle.position, particle.position, _world_mat);
              Vec3.transformQuat(particle.velocity, particle.velocity, _world_rol);
            }

            Vec3.copy(particle.ultimateVelocity, particle.velocity);

            if (this.startRotation3D) {
              particle.startEuler.set(this.startRotationX.evaluate(loopDelta, rand), this.startRotationY.evaluate(loopDelta, rand), this.startRotationZ.evaluate(loopDelta, rand));
            } else {
              particle.startEuler.set(0, 0, this.startRotationZ.evaluate(loopDelta, rand));
            }

            particle.rotation.set(particle.startEuler);

            if (this.startSize3D) {
              Vec3.set(particle.startSize, this.startSizeX.evaluate(loopDelta, rand), this.startSizeY.evaluate(loopDelta, rand), this.startSizeZ.evaluate(loopDelta, rand));
            } else {
              Vec3.set(particle.startSize, this.startSizeX.evaluate(loopDelta, rand), 1, 1);
              particle.startSize.y = particle.startSize.x;
            }

            Vec3.copy(particle.size, particle.startSize);
            particle.startColor.set(this.startColor.evaluate(loopDelta, rand));
            particle.color.set(particle.startColor);
            particle.startLifetime = this.startLifetime.evaluate(loopDelta, rand) + dt;
            particle.remainingLifetime = particle.startLifetime;
            particle.randomSeed = randomRangeInt(0, 233280);
            particle.loopCount++;
            this.processor.setNewParticle(particle);
          }
        };

        _proto._prewarmSystem = function _prewarmSystem() {
          this.startDelay.mode = Mode.Constant;
          this.startDelay.constant = 0;
          var dt = 1.0;
          var cnt = this.duration / dt;

          for (var i = 0; i < cnt; ++i) {
            this._time += dt;

            this._emit(dt);

            this.processor.updateParticles(dt);
          }
        };

        _proto._emit = function _emit(dt) {
          var startDelay = this.startDelay.evaluate(0, 1);

          if (this._time > startDelay) {
            if (this._time > this.duration + startDelay) {
              if (!this.loop) {
                this._isEmitting = false;
              }
            }

            if (!this._isEmitting) return;
            this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt;

            if (this._emitRateTimeCounter > 1) {
              var emitNum = Math.floor(this._emitRateTimeCounter);
              this._emitRateTimeCounter -= emitNum;
              this.emit(emitNum, dt);
            }

            this.node.getWorldPosition(this._curWPos);
            var distance = Vec3.distance(this._curWPos, this._oldWPos);
            Vec3.copy(this._oldWPos, this._curWPos);
            this._emitRateDistanceCounter += distance * this.rateOverDistance.evaluate(this._time / this.duration, 1);

            if (this._emitRateDistanceCounter > 1) {
              var _emitNum = Math.floor(this._emitRateDistanceCounter);

              this._emitRateDistanceCounter -= _emitNum;
              this.emit(_emitNum, dt);
            }

            for (var _iterator2 = _createForOfIteratorHelperLoose(this.bursts), _step2; !(_step2 = _iterator2()).done;) {
              var burst = _step2.value;
              burst.update(this, dt);
            }
          }
        };

        _proto._resetPosition = function _resetPosition() {
          this.node.getWorldPosition(this._oldWPos);
          Vec3.copy(this._curWPos, this._oldWPos);
        };

        _proto.addSubEmitter = function addSubEmitter(subEmitter) {
          this._subEmitters.push(subEmitter);
        };

        _proto.removeSubEmitter = function removeSubEmitter(idx) {
          this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
        };

        _proto.addBurst = function addBurst(burst) {
          this.bursts.push(burst);
        };

        _proto.removeBurst = function removeBurst(idx) {
          this.bursts.splice(this.bursts.indexOf(idx), 1);
        };

        _proto.getBoundingX = function getBoundingX() {
          return this._aabbHalfX;
        };

        _proto.getBoundingY = function getBoundingY() {
          return this._aabbHalfY;
        };

        _proto.getBoundingZ = function getBoundingZ() {
          return this._aabbHalfZ;
        };

        _proto.setBoundingX = function setBoundingX(value) {
          if (this._boundingBox && this._culler) {
            this._boundingBox.halfExtents.x = value;

            this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

            this._aabbHalfX = value;
          }
        };

        _proto.setBoundingY = function setBoundingY(value) {
          if (this._boundingBox && this._culler) {
            this._boundingBox.halfExtents.y = value;

            this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

            this._aabbHalfY = value;
          }
        };

        _proto.setBoundingZ = function setBoundingZ(value) {
          if (this._boundingBox && this._culler) {
            this._boundingBox.halfExtents.z = value;

            this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

            this._aabbHalfZ = value;
          }
        };

        _proto._onBeforeSerialize = function _onBeforeSerialize(props) {
          var _this2 = this;

          return this.dataCulling ? props.filter(function (p) {
            return !PARTICLE_MODULE_PROPERTY.includes(p) || _this2[p] && _this2[p].enable;
          }) : props;
        };

        _proto.getNoisePreview = function getNoisePreview(width, height) {
          var out = [];

          if (this.processor) {
            this.processor.getNoisePreview(out, width, height);
          }

          return out;
        };

        _createClass(ParticleSystem, [{
          key: "capacity",
          get: function get() {
            return this._capacity;
          },
          set: function set(val) {
            this._capacity = Math.floor(val > 0 ? val : 0);

            if (this.processor && this.processor._model) {
              this.processor._model.setCapacity(this._capacity);
            }
          }
        }, {
          key: "prewarm",
          get: function get() {
            return this._prewarm;
          },
          set: function set(val) {
            if (val === true && this.loop === false) ;

            this._prewarm = val;
          }
        }, {
          key: "simulationSpace",
          get: function get() {
            return this._simulationSpace;
          },
          set: function set(val) {
            if (val !== this._simulationSpace) {
              this._simulationSpace = val;

              if (this.processor) {
                this.processor.updateMaterialParams();
                this.processor.updateTrailMaterial();
              }
            }
          }
        }, {
          key: "renderCulling",
          get: function get() {
            return this._renderCulling;
          },
          set: function set(value) {
            this._renderCulling = value;

            if (value) {
              if (!this._boundingBox) {
                this._boundingBox = new AABB();

                this._calculateBounding(false);
              }
            }
          }
        }, {
          key: "cullingMode",
          get: function get() {
            return this._cullingMode;
          },
          set: function set(value) {
            this._cullingMode = value;
          }
        }, {
          key: "aabbHalfX",
          get: function get() {
            var res = this.getBoundingX();

            if (res) {
              return res;
            } else {
              return 0;
            }
          },
          set: function set(value) {
            this.setBoundingX(value);
          }
        }, {
          key: "aabbHalfY",
          get: function get() {
            var res = this.getBoundingY();

            if (res) {
              return res;
            } else {
              return 0;
            }
          },
          set: function set(value) {
            this.setBoundingY(value);
          }
        }, {
          key: "aabbHalfZ",
          get: function get() {
            var res = this.getBoundingZ();

            if (res) {
              return res;
            } else {
              return 0;
            }
          },
          set: function set(value) {
            this.setBoundingZ(value);
          }
        }, {
          key: "dataCulling",
          get: function get() {
            return this._dataCulling;
          },
          set: function set(value) {
            this._dataCulling = value;
          }
        }, {
          key: "sharedMaterials",
          get: function get() {
            return superMaterials.get.call(this);
          },
          set: function set(val) {
            superMaterials.set.call(this, val);
          }
        }, {
          key: "colorOverLifetimeModule",
          get: function get() {

            return this._colorOverLifetimeModule;
          },
          set: function set(val) {
            if (!val) return;
            this._colorOverLifetimeModule = val;
          }
        }, {
          key: "shapeModule",
          get: function get() {

            return this._shapeModule;
          },
          set: function set(val) {
            if (!val) return;
            this._shapeModule = val;
          }
        }, {
          key: "sizeOvertimeModule",
          get: function get() {

            return this._sizeOvertimeModule;
          },
          set: function set(val) {
            if (!val) return;
            this._sizeOvertimeModule = val;
          }
        }, {
          key: "velocityOvertimeModule",
          get: function get() {

            return this._velocityOvertimeModule;
          },
          set: function set(val) {
            if (!val) return;
            this._velocityOvertimeModule = val;
          }
        }, {
          key: "forceOvertimeModule",
          get: function get() {

            return this._forceOvertimeModule;
          },
          set: function set(val) {
            if (!val) return;
            this._forceOvertimeModule = val;
          }
        }, {
          key: "limitVelocityOvertimeModule",
          get: function get() {

            return this._limitVelocityOvertimeModule;
          },
          set: function set(val) {
            if (!val) return;
            this._limitVelocityOvertimeModule = val;
          }
        }, {
          key: "rotationOvertimeModule",
          get: function get() {

            return this._rotationOvertimeModule;
          },
          set: function set(val) {
            if (!val) return;
            this._rotationOvertimeModule = val;
          }
        }, {
          key: "textureAnimationModule",
          get: function get() {

            return this._textureAnimationModule;
          },
          set: function set(val) {
            if (!val) return;
            this._textureAnimationModule = val;
          }
        }, {
          key: "noiseModule",
          get: function get() {

            return this._noiseModule;
          },
          set: function set(val) {
            if (!val) return;
            this._noiseModule = val;
          }
        }, {
          key: "trailModule",
          get: function get() {

            return this._trailModule;
          },
          set: function set(val) {
            if (!val) return;
            this._trailModule = val;
          }
        }, {
          key: "isPlaying",
          get: function get() {
            return this._isPlaying;
          }
        }, {
          key: "isPaused",
          get: function get() {
            return this._isPaused;
          }
        }, {
          key: "isStopped",
          get: function get() {
            return this._isStopped;
          }
        }, {
          key: "isEmitting",
          get: function get() {
            return this._isEmitting;
          }
        }, {
          key: "time",
          get: function get() {
            return this._time;
          }
        }]);

        return ParticleSystem;
      }(ModelRenderer), _class3$b.CullingMode = CullingMode, _temp$Y), (_applyDecoratedDescriptor(_class2$W.prototype, "capacity", [_dec5$A, _dec6$x, _dec7$v], Object.getOwnPropertyDescriptor(_class2$W.prototype, "capacity"), _class2$W.prototype), _descriptor$S = _applyDecoratedDescriptor(_class2$W.prototype, "startColor", [_dec8$t, serializable, _dec9$p, _dec10$n], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new GradientRange();
        }
      }), _descriptor2$L = _applyDecoratedDescriptor(_class2$W.prototype, "scaleSpace", [_dec11$l, serializable, _dec12$k, _dec13$k], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Space.Local;
        }
      }), _descriptor3$C = _applyDecoratedDescriptor(_class2$W.prototype, "startSize3D", [serializable, _dec14$i, _dec15$i], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor4$x = _applyDecoratedDescriptor(_class2$W.prototype, "startSizeX", [_dec16$i, _dec17$h, _dec18$g, _dec19$f, _dec20$f], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor5$s = _applyDecoratedDescriptor(_class2$W.prototype, "startSizeY", [_dec21$f, serializable, _dec22$d, _dec23$c, _dec24$c, _dec25$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor6$o = _applyDecoratedDescriptor(_class2$W.prototype, "startSizeZ", [_dec26$b, serializable, _dec27$b, _dec28$a, _dec29$a, _dec30$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor7$i = _applyDecoratedDescriptor(_class2$W.prototype, "startSpeed", [_dec31$8, serializable, _dec32$6, _dec33$4, _dec34$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor8$h = _applyDecoratedDescriptor(_class2$W.prototype, "startRotation3D", [serializable, _dec35$4, _dec36$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor9$e = _applyDecoratedDescriptor(_class2$W.prototype, "startRotationX", [_dec37$4, serializable, _dec38$4, radian, _dec39$4, _dec40$4, _dec41$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor10$c = _applyDecoratedDescriptor(_class2$W.prototype, "startRotationY", [_dec42$4, serializable, _dec43$4, radian, _dec44$4, _dec45$4, _dec46$3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor11$9 = _applyDecoratedDescriptor(_class2$W.prototype, "startRotationZ", [_dec47$3, _dec48$3, _dec49$3, radian, _dec50$3, _dec51$3, _dec52$3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor12$9 = _applyDecoratedDescriptor(_class2$W.prototype, "startDelay", [_dec53$3, serializable, _dec54$2, _dec55$2, _dec56$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor13$9 = _applyDecoratedDescriptor(_class2$W.prototype, "startLifetime", [_dec57$2, serializable, _dec58$1, _dec59$1, _dec60$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor14$4 = _applyDecoratedDescriptor(_class2$W.prototype, "duration", [serializable, _dec61, _dec62], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 5.0;
        }
      }), _descriptor15$3 = _applyDecoratedDescriptor(_class2$W.prototype, "loop", [serializable, _dec63, _dec64], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "prewarm", [_dec65, _dec66], Object.getOwnPropertyDescriptor(_class2$W.prototype, "prewarm"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "simulationSpace", [_dec67, serializable, _dec68, _dec69], Object.getOwnPropertyDescriptor(_class2$W.prototype, "simulationSpace"), _class2$W.prototype), _descriptor16$3 = _applyDecoratedDescriptor(_class2$W.prototype, "simulationSpeed", [serializable, _dec70, _dec71], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      }), _descriptor17$2 = _applyDecoratedDescriptor(_class2$W.prototype, "playOnAwake", [serializable, _dec72, _dec73], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor18$1 = _applyDecoratedDescriptor(_class2$W.prototype, "gravityModifier", [_dec74, serializable, _dec75, _dec76, _dec77], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor19$1 = _applyDecoratedDescriptor(_class2$W.prototype, "rateOverTime", [_dec78, serializable, _dec79, _dec80, _dec81], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor20 = _applyDecoratedDescriptor(_class2$W.prototype, "rateOverDistance", [_dec82, serializable, _dec83, _dec84, _dec85], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CurveRange();
        }
      }), _descriptor21 = _applyDecoratedDescriptor(_class2$W.prototype, "bursts", [_dec86, serializable, _dec87, _dec88], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "renderCulling", [_dec89, _dec90, _dec91], Object.getOwnPropertyDescriptor(_class2$W.prototype, "renderCulling"), _class2$W.prototype), _descriptor22 = _applyDecoratedDescriptor(_class2$W.prototype, "_renderCulling", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "cullingMode", [_dec92, _dec93, _dec94], Object.getOwnPropertyDescriptor(_class2$W.prototype, "cullingMode"), _class2$W.prototype), _descriptor23 = _applyDecoratedDescriptor(_class2$W.prototype, "_cullingMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return CullingMode.Pause;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "aabbHalfX", [_dec95, _dec96, _dec97], Object.getOwnPropertyDescriptor(_class2$W.prototype, "aabbHalfX"), _class2$W.prototype), _descriptor24 = _applyDecoratedDescriptor(_class2$W.prototype, "_aabbHalfX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "aabbHalfY", [_dec98, _dec99, _dec100], Object.getOwnPropertyDescriptor(_class2$W.prototype, "aabbHalfY"), _class2$W.prototype), _descriptor25 = _applyDecoratedDescriptor(_class2$W.prototype, "_aabbHalfY", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "aabbHalfZ", [_dec101, _dec102, _dec103], Object.getOwnPropertyDescriptor(_class2$W.prototype, "aabbHalfZ"), _class2$W.prototype), _descriptor26 = _applyDecoratedDescriptor(_class2$W.prototype, "_aabbHalfZ", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "dataCulling", [_dec104, _dec105], Object.getOwnPropertyDescriptor(_class2$W.prototype, "dataCulling"), _class2$W.prototype), _descriptor27 = _applyDecoratedDescriptor(_class2$W.prototype, "_dataCulling", [serializable, _dec106], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "sharedMaterials", [override, _dec107, _dec108, serializable, _dec109], Object.getOwnPropertyDescriptor(_class2$W.prototype, "sharedMaterials"), _class2$W.prototype), _descriptor28 = _applyDecoratedDescriptor(_class2$W.prototype, "_colorOverLifetimeModule", [_dec110], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "colorOverLifetimeModule", [_dec111, _dec112, _dec113], Object.getOwnPropertyDescriptor(_class2$W.prototype, "colorOverLifetimeModule"), _class2$W.prototype), _descriptor29 = _applyDecoratedDescriptor(_class2$W.prototype, "_shapeModule", [_dec114], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "shapeModule", [_dec115, _dec116, _dec117], Object.getOwnPropertyDescriptor(_class2$W.prototype, "shapeModule"), _class2$W.prototype), _descriptor30 = _applyDecoratedDescriptor(_class2$W.prototype, "_sizeOvertimeModule", [_dec118], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "sizeOvertimeModule", [_dec119, _dec120, _dec121], Object.getOwnPropertyDescriptor(_class2$W.prototype, "sizeOvertimeModule"), _class2$W.prototype), _descriptor31 = _applyDecoratedDescriptor(_class2$W.prototype, "_velocityOvertimeModule", [_dec122], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "velocityOvertimeModule", [_dec123, _dec124, _dec125], Object.getOwnPropertyDescriptor(_class2$W.prototype, "velocityOvertimeModule"), _class2$W.prototype), _descriptor32 = _applyDecoratedDescriptor(_class2$W.prototype, "_forceOvertimeModule", [_dec126], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "forceOvertimeModule", [_dec127, _dec128, _dec129], Object.getOwnPropertyDescriptor(_class2$W.prototype, "forceOvertimeModule"), _class2$W.prototype), _descriptor33 = _applyDecoratedDescriptor(_class2$W.prototype, "_limitVelocityOvertimeModule", [_dec130], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "limitVelocityOvertimeModule", [_dec131, _dec132, _dec133], Object.getOwnPropertyDescriptor(_class2$W.prototype, "limitVelocityOvertimeModule"), _class2$W.prototype), _descriptor34 = _applyDecoratedDescriptor(_class2$W.prototype, "_rotationOvertimeModule", [_dec134], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "rotationOvertimeModule", [_dec135, _dec136, _dec137], Object.getOwnPropertyDescriptor(_class2$W.prototype, "rotationOvertimeModule"), _class2$W.prototype), _descriptor35 = _applyDecoratedDescriptor(_class2$W.prototype, "_textureAnimationModule", [_dec138], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "textureAnimationModule", [_dec139, _dec140, _dec141], Object.getOwnPropertyDescriptor(_class2$W.prototype, "textureAnimationModule"), _class2$W.prototype), _descriptor36 = _applyDecoratedDescriptor(_class2$W.prototype, "_noiseModule", [_dec142], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "noiseModule", [_dec143, _dec144], Object.getOwnPropertyDescriptor(_class2$W.prototype, "noiseModule"), _class2$W.prototype), _descriptor37 = _applyDecoratedDescriptor(_class2$W.prototype, "_trailModule", [_dec145], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$W.prototype, "trailModule", [_dec146, _dec147, _dec148], Object.getOwnPropertyDescriptor(_class2$W.prototype, "trailModule"), _class2$W.prototype), _descriptor38 = _applyDecoratedDescriptor(_class2$W.prototype, "renderer", [_dec149, serializable, _dec150, _dec151], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new ParticleSystemRenderer();
        }
      }), _descriptor39 = _applyDecoratedDescriptor(_class2$W.prototype, "_prewarm", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor40 = _applyDecoratedDescriptor(_class2$W.prototype, "_capacity", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _descriptor41 = _applyDecoratedDescriptor(_class2$W.prototype, "_simulationSpace", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Space.Local;
        }
      })), _class2$W)) || _class$12) || _class$12) || _class$12) || _class$12) || _class$12));

      var ParticleUtils = exports('ParticleUtils', function () {
        function ParticleUtils() {}

        ParticleUtils.instantiate = function instantiate$1(prefab) {
          if (!this.registeredSceneEvent) {
            director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this);
            this.registeredSceneEvent = true;
          }

          if (!this.particleSystemPool.has(prefab._uuid)) {
            this.particleSystemPool.set(prefab._uuid, new Pool(function () {
              return instantiate(prefab) || new Node();
            }, 1, function (prefab) {
              return prefab.destroy();
            }));
          }

          return this.particleSystemPool.get(prefab._uuid).alloc();
        };

        ParticleUtils.destroy = function destroy(prefab) {
          if (this.particleSystemPool.has(prefab._prefab.asset._uuid)) {
            this.stop(prefab);
            this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab);
          }
        };

        ParticleUtils.play = function play(rootNode) {
          for (var _iterator = _createForOfIteratorHelperLoose(rootNode.getComponentsInChildren(ParticleSystem)), _step; !(_step = _iterator()).done;) {
            var ps = _step.value;
            ps.play();
          }
        };

        ParticleUtils.stop = function stop(rootNode) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(rootNode.getComponentsInChildren(ParticleSystem)), _step2; !(_step2 = _iterator2()).done;) {
            var ps = _step2.value;
            ps.stop();
          }
        };

        ParticleUtils.onSceneUnload = function onSceneUnload() {
          this.particleSystemPool.forEach(function (value) {
            return value.destroy();
          });
          this.particleSystemPool.clear();
        };

        return ParticleUtils;
      }());
      ParticleUtils.particleSystemPool = new Map();
      ParticleUtils.registeredSceneEvent = false;

      removeProperty(Burst.prototype, 'Burst.prototype', [{
        name: 'minCount'
      }, {
        name: 'maxCount'
      }]);
      replaceProperty(ParticleSystem.prototype, 'ParticleSystem.prototype', [{
        name: 'enableCulling',
        newName: 'dataCulling'
      }]);
      legacyCC.ParticleSystemComponent = ParticleSystem;
      js.setClassAlias(ParticleSystem, 'cc.ParticleSystemComponent');
      legacyCC.BillboardComponent = Billboard;
      js.setClassAlias(Billboard, 'cc.BillboardComponent');
      legacyCC.LineComponent = Line;
      js.setClassAlias(Line, 'cc.LineComponent');

      legacyCC.ParticleUtils = ParticleUtils;

      var ERigidBodyType;

      (function (ERigidBodyType) {
        ERigidBodyType[ERigidBodyType["DYNAMIC"] = 1] = "DYNAMIC";
        ERigidBodyType[ERigidBodyType["STATIC"] = 2] = "STATIC";
        ERigidBodyType[ERigidBodyType["KINEMATIC"] = 4] = "KINEMATIC";
      })(ERigidBodyType || (ERigidBodyType = exports('ERigidBodyType', {})));

      Enum(ERigidBodyType);
      var EAxisDirection;

      (function (EAxisDirection) {
        EAxisDirection[EAxisDirection["X_AXIS"] = 0] = "X_AXIS";
        EAxisDirection[EAxisDirection["Y_AXIS"] = 1] = "Y_AXIS";
        EAxisDirection[EAxisDirection["Z_AXIS"] = 2] = "Z_AXIS";
      })(EAxisDirection || (EAxisDirection = exports('EAxisDirection', {})));

      Enum(EAxisDirection);
      var ESimplexType;

      (function (ESimplexType) {
        ESimplexType[ESimplexType["VERTEX"] = 1] = "VERTEX";
        ESimplexType[ESimplexType["LINE"] = 2] = "LINE";
        ESimplexType[ESimplexType["TRIANGLE"] = 3] = "TRIANGLE";
        ESimplexType[ESimplexType["TETRAHEDRON"] = 4] = "TETRAHEDRON";
      })(ESimplexType || (ESimplexType = {}));

      Enum(ESimplexType);
      var EColliderType;

      (function (EColliderType) {
        EColliderType[EColliderType["BOX"] = 0] = "BOX";
        EColliderType[EColliderType["SPHERE"] = 1] = "SPHERE";
        EColliderType[EColliderType["CAPSULE"] = 2] = "CAPSULE";
        EColliderType[EColliderType["CYLINDER"] = 3] = "CYLINDER";
        EColliderType[EColliderType["CONE"] = 4] = "CONE";
        EColliderType[EColliderType["MESH"] = 5] = "MESH";
        EColliderType[EColliderType["PLANE"] = 6] = "PLANE";
        EColliderType[EColliderType["SIMPLEX"] = 7] = "SIMPLEX";
        EColliderType[EColliderType["TERRAIN"] = 8] = "TERRAIN";
      })(EColliderType || (EColliderType = {}));

      Enum(EColliderType);
      var EConstraintType;

      (function (EConstraintType) {
        EConstraintType[EConstraintType["POINT_TO_POINT"] = 0] = "POINT_TO_POINT";
        EConstraintType[EConstraintType["HINGE"] = 1] = "HINGE";
        EConstraintType[EConstraintType["CONE_TWIST"] = 2] = "CONE_TWIST";
      })(EConstraintType || (EConstraintType = {}));

      Enum(EConstraintType);
      var PhysicsGroup;

      (function (PhysicsGroup) {
        PhysicsGroup[PhysicsGroup["DEFAULT"] = 1] = "DEFAULT";
      })(PhysicsGroup || (PhysicsGroup = {}));

      Enum(PhysicsGroup);

      function updateLegacyMacro(id) {
        legacyCC._global.CC_PHYSICS_BUILTIN = id === 'builtin';
        legacyCC._global.CC_PHYSICS_CANNON = id === 'cannon.js';
        legacyCC._global.CC_PHYSICS_AMMO = id === 'bullet';
      }

      function register(id, wrapper) {
        console.info("[PHYSICS]: register " + id + ".");
        selector.backend[id] = wrapper;

        if (!selector.physicsWorld || selector.id === id) {
          updateLegacyMacro(id);
          var mutableSelector = selector;
          mutableSelector.id = id;
          mutableSelector.wrapper = wrapper;
        }
      }

      var worldInitData;

      function switchTo(id) {
        if (!selector.runInEditor) return;
        var mutableSelector = selector;

        if (selector.physicsWorld && id !== selector.id && selector.backend[id] != null) {
          selector.physicsWorld.destroy();
          console.info("[PHYSICS]: switch from " + selector.id + " to " + id + ".");
          updateLegacyMacro(id);
          mutableSelector.id = id;
          mutableSelector.wrapper = selector.backend[id];
          mutableSelector.physicsWorld = createPhysicsWorld();
        } else {
          console.info("[PHYSICS]: using " + id + ".");
          mutableSelector.physicsWorld = createPhysicsWorld();
        }

        if (worldInitData) {
          var world = mutableSelector.physicsWorld;
          world.setGravity(worldInitData.gravity);
          world.setAllowSleep(worldInitData.allowSleep);
        }
      }

      var selector = {
        id: '',
        switchTo: switchTo,
        register: register,
        wrapper: {},
        backend: {},
        physicsWorld: null,
        runInEditor: !EDITOR
      };
      function constructDefaultWorld(data) {
        if (!worldInitData) worldInitData = data;
        if (!selector.runInEditor) return;

        if (!selector.physicsWorld) {
          console.info("[PHYSICS]: using " + selector.id + ".");
          var mutableSelector = selector;
          var world = mutableSelector.physicsWorld = createPhysicsWorld();
          world.setGravity(worldInitData.gravity);
          world.setAllowSleep(worldInitData.allowSleep);
        }
      }

      var FUNC = function FUNC() {
        return 0;
      };

      var ENTIRE_WORLD = {
        impl: null,
        setGravity: FUNC,
        setAllowSleep: FUNC,
        setDefaultMaterial: FUNC,
        step: FUNC,
        syncAfterEvents: FUNC,
        syncSceneToPhysics: FUNC,
        raycast: FUNC,
        raycastClosest: FUNC,
        emitEvents: FUNC,
        destroy: FUNC
      };
      var ECheckType;

      (function (ECheckType) {
        ECheckType[ECheckType["World"] = 0] = "World";
        ECheckType[ECheckType["RigidBody"] = 1] = "RigidBody";
        ECheckType[ECheckType["BoxCollider"] = 2] = "BoxCollider";
        ECheckType[ECheckType["SphereCollider"] = 3] = "SphereCollider";
        ECheckType[ECheckType["CapsuleCollider"] = 4] = "CapsuleCollider";
        ECheckType[ECheckType["MeshCollider"] = 5] = "MeshCollider";
        ECheckType[ECheckType["CylinderCollider"] = 6] = "CylinderCollider";
        ECheckType[ECheckType["ConeCollider"] = 7] = "ConeCollider";
        ECheckType[ECheckType["TerrainCollider"] = 8] = "TerrainCollider";
        ECheckType[ECheckType["SimplexCollider"] = 9] = "SimplexCollider";
        ECheckType[ECheckType["PlaneCollider"] = 10] = "PlaneCollider";
        ECheckType[ECheckType["PointToPointConstraint"] = 11] = "PointToPointConstraint";
        ECheckType[ECheckType["HingeConstraint"] = 12] = "HingeConstraint";
        ECheckType[ECheckType["ConeTwistConstraint"] = 13] = "ConeTwistConstraint";
      })(ECheckType || (ECheckType = {}));

      function check(obj, type) {
        if (obj == null) {
          if (selector.id) {
            warn(selector.id + " physics does not support " + ECheckType[type]);
          } else {
            errorID(9600);
          }

          return true;
        }

        return false;
      }

      function createPhysicsWorld() {
        if (check(selector.wrapper.PhysicsWorld, ECheckType.World)) {
          return ENTIRE_WORLD;
        }

        return new selector.wrapper.PhysicsWorld();
      }
      var ENTIRE_RIGID_BODY = {
        impl: null,
        rigidBody: null,
        isAwake: false,
        isSleepy: false,
        isSleeping: false,
        initialize: FUNC,
        onEnable: FUNC,
        onDisable: FUNC,
        onDestroy: FUNC,
        setType: FUNC,
        setMass: FUNC,
        setLinearDamping: FUNC,
        setAngularDamping: FUNC,
        useGravity: FUNC,
        setLinearFactor: FUNC,
        setAngularFactor: FUNC,
        setAllowSleep: FUNC,
        wakeUp: FUNC,
        sleep: FUNC,
        clearState: FUNC,
        clearForces: FUNC,
        clearVelocity: FUNC,
        setSleepThreshold: FUNC,
        getSleepThreshold: FUNC,
        getLinearVelocity: FUNC,
        setLinearVelocity: FUNC,
        getAngularVelocity: FUNC,
        setAngularVelocity: FUNC,
        applyForce: FUNC,
        applyLocalForce: FUNC,
        applyImpulse: FUNC,
        applyLocalImpulse: FUNC,
        applyTorque: FUNC,
        applyLocalTorque: FUNC,
        setGroup: FUNC,
        getGroup: FUNC,
        addGroup: FUNC,
        removeGroup: FUNC,
        setMask: FUNC,
        getMask: FUNC,
        addMask: FUNC,
        removeMask: FUNC,
        isUsingCCD: FUNC,
        useCCD: FUNC
      };
      function createRigidBody() {
        if (check(selector.wrapper.RigidBody, ECheckType.RigidBody)) {
          return ENTIRE_RIGID_BODY;
        }

        return new selector.wrapper.RigidBody();
      }
      var CREATE_COLLIDER_PROXY = {
        INITED: false
      };
      var ENTIRE_SHAPE = {
        impl: null,
        collider: null,
        attachedRigidBody: null,
        initialize: FUNC,
        onLoad: FUNC,
        onEnable: FUNC,
        onDisable: FUNC,
        onDestroy: FUNC,
        setGroup: FUNC,
        getGroup: FUNC,
        addGroup: FUNC,
        removeGroup: FUNC,
        setMask: FUNC,
        getMask: FUNC,
        addMask: FUNC,
        removeMask: FUNC,
        setMaterial: FUNC,
        setAsTrigger: FUNC,
        setCenter: FUNC,
        getAABB: FUNC,
        getBoundingSphere: FUNC,
        updateSize: FUNC,
        updateRadius: FUNC,
        setRadius: FUNC,
        setCylinderHeight: FUNC,
        setDirection: FUNC,
        setHeight: FUNC,
        setShapeType: FUNC,
        setVertices: FUNC,
        setMesh: FUNC,
        setTerrain: FUNC,
        setNormal: FUNC,
        setConstant: FUNC,
        updateEventListener: FUNC
      };
      function createShape(type) {
        initColliderProxy();
        return CREATE_COLLIDER_PROXY[type]();
      }

      function initColliderProxy() {
        if (CREATE_COLLIDER_PROXY.INITED) return;
        CREATE_COLLIDER_PROXY.INITED = true;

        CREATE_COLLIDER_PROXY[EColliderType.BOX] = function createBoxShape() {
          if (check(selector.wrapper.BoxShape, ECheckType.BoxCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.BoxShape();
        };

        CREATE_COLLIDER_PROXY[EColliderType.SPHERE] = function createSphereShape() {
          if (check(selector.wrapper.SphereShape, ECheckType.SphereCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.SphereShape();
        };

        CREATE_COLLIDER_PROXY[EColliderType.CAPSULE] = function createCapsuleShape() {
          if (check(selector.wrapper.CapsuleShape, ECheckType.CapsuleCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.CapsuleShape();
        };

        CREATE_COLLIDER_PROXY[EColliderType.CYLINDER] = function createCylinderShape() {
          if (check(selector.wrapper.CylinderShape, ECheckType.CylinderCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.CylinderShape();
        };

        CREATE_COLLIDER_PROXY[EColliderType.CONE] = function createConeShape() {
          if (check(selector.wrapper.ConeShape, ECheckType.ConeCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.ConeShape();
        };

        CREATE_COLLIDER_PROXY[EColliderType.MESH] = function createTrimeshShape() {
          if (check(selector.wrapper.TrimeshShape, ECheckType.MeshCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.TrimeshShape();
        };

        CREATE_COLLIDER_PROXY[EColliderType.TERRAIN] = function createTerrainShape() {
          if (check(selector.wrapper.TerrainShape, ECheckType.TerrainCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.TerrainShape();
        };

        CREATE_COLLIDER_PROXY[EColliderType.SIMPLEX] = function createSimplexShape() {
          if (check(selector.wrapper.SimplexShape, ECheckType.SimplexCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.SimplexShape();
        };

        CREATE_COLLIDER_PROXY[EColliderType.PLANE] = function createPlaneShape() {
          if (check(selector.wrapper.PlaneShape, ECheckType.PlaneCollider)) {
            return ENTIRE_SHAPE;
          }

          return new selector.wrapper.PlaneShape();
        };
      }

      var CREATE_CONSTRAINT_PROXY = {
        INITED: false
      };
      var ENTIRE_CONSTRAINT = {
        impl: null,
        initialize: FUNC,
        onLoad: FUNC,
        onEnable: FUNC,
        onDisable: FUNC,
        onDestroy: FUNC,
        setEnableCollision: FUNC,
        setConnectedBody: FUNC,
        setPivotA: FUNC,
        setPivotB: FUNC,
        setAxis: FUNC
      };
      function createConstraint(type) {
        initConstraintProxy();
        return CREATE_CONSTRAINT_PROXY[type]();
      }

      function initConstraintProxy() {
        if (CREATE_CONSTRAINT_PROXY.INITED) return;
        CREATE_CONSTRAINT_PROXY.INITED = true;

        CREATE_CONSTRAINT_PROXY[EConstraintType.POINT_TO_POINT] = function createPointToPointConstraint() {
          if (check(selector.wrapper.PointToPointConstraint, ECheckType.PointToPointConstraint)) {
            return ENTIRE_CONSTRAINT;
          }

          return new selector.wrapper.PointToPointConstraint();
        };

        CREATE_CONSTRAINT_PROXY[EConstraintType.HINGE] = function createHingeConstraint() {
          if (check(selector.wrapper.HingeConstraint, ECheckType.HingeConstraint)) {
            return ENTIRE_CONSTRAINT;
          }

          return new selector.wrapper.HingeConstraint();
        };

        CREATE_CONSTRAINT_PROXY[EConstraintType.CONE_TWIST] = function createConeTwistConstraint() {
          if (check(selector.wrapper.ConeTwistConstraint, ECheckType.ConeTwistConstraint)) {
            return ENTIRE_CONSTRAINT;
          }

          return new selector.wrapper.ConeTwistConstraint();
        };
      }

      var TriggerEventObject = {
        type: 'onTriggerEnter',
        selfCollider: null,
        otherCollider: null,
        impl: null
      };
      var CollisionEventObject = {
        type: 'onCollisionEnter',
        selfCollider: null,
        otherCollider: null,
        contacts: [],
        impl: null
      };
      var BulletCache = function () {
        function BulletCache() {
          this.BT_TRANSFORM_0 = bt.Transform_new();
          this.BT_TRANSFORM_1 = bt.Transform_new();
          this.BT_V3_0 = bt.Vec3_new(0, 0, 0);
          this.BT_V3_1 = bt.Vec3_new(0, 0, 0);
          this.BT_V3_2 = bt.Vec3_new(0, 0, 0);
          this.BT_QUAT_0 = bt.Quat_new(0, 0, 0, 1);
        }

        BulletCache.setWrapper = function setWrapper(impl, type, wrap) {
          if (!this.ROOT[type]) this.ROOT[type] = {};
          this.ROOT[type][impl] = wrap;
        };

        BulletCache.delWrapper = function delWrapper(impl, type) {
          delete this.ROOT[type][impl];
        };

        BulletCache.getWrapper = function getWrapper(ptr, type) {
          return this.ROOT[type][ptr];
        };

        BulletCache.isNotEmptyShape = function isNotEmptyShape(ptr) {
          return ptr !== bt.EmptyShape_static();
        };

        _createClass(BulletCache, null, [{
          key: "instance",
          get: function get() {
            if (BulletCache._instance == null) BulletCache._instance = new BulletCache();
            return BulletCache._instance;
          }
        }]);

        return BulletCache;
      }();
      BulletCache._instance = void 0;
      BulletCache.ROOT = {};
      var CC_V3_0 = new Vec3();
      var CC_V3_1 = new Vec3();
      var CC_QUAT_0 = new Quat();
      bt.CACHE = BulletCache;

      function cocos2BulletVec3(out, v) {
        bt.Vec3_set(out, v.x, v.y, v.z);
        return out;
      }
      function bullet2CocosVec3(out, v) {
        out.x = bt.Vec3_x(v);
        out.y = bt.Vec3_y(v);
        out.z = bt.Vec3_z(v);
        return out;
      }
      function cocos2BulletQuat(out, q) {
        bt.Quat_set(out, q.x, q.y, q.z, q.w);
        return out;
      }
      function bullet2CocosQuat(out, q) {
        out.x = bt.Quat_x(q);
        out.y = bt.Quat_y(q);
        out.z = bt.Quat_z(q);
        out.w = bt.Quat_w(q);
        return out;
      }
      function cocos2BulletTriMesh(out, mesh) {
        var len = mesh.renderingSubMeshes.length;

        for (var i = 0; i < len; i++) {
          var subMesh = mesh.renderingSubMeshes[i];
          var geoInfo = subMesh.geometricInfo;

          if (geoInfo) {
            var primitiveMode = subMesh.primitiveMode;
            var vb = geoInfo.positions;
            var ib = geoInfo.indices;
            var v0 = BulletCache.instance.BT_V3_0;
            var v1 = BulletCache.instance.BT_V3_1;
            var v2 = BulletCache.instance.BT_V3_2;

            if (primitiveMode === PrimitiveMode.TRIANGLE_LIST) {
              var cnt = ib.length;

              for (var j = 0; j < cnt; j += 3) {
                var i0 = ib[j] * 3;
                var i1 = ib[j + 1] * 3;
                var i2 = ib[j + 2] * 3;
                bt.Vec3_set(v0, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                bt.Vec3_set(v1, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                bt.Vec3_set(v2, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                bt.TriangleMesh_addTriangle(out, v0, v1, v2);
              }
            } else if (primitiveMode === PrimitiveMode.TRIANGLE_STRIP) {
              var _cnt = ib.length - 2;

              var rev = 0;

              for (var _j = 0; _j < _cnt; _j += 1) {
                var _i = ib[_j - rev] * 3;

                var _i2 = ib[_j + rev + 1] * 3;

                var _i3 = ib[_j + 2] * 3;

                rev = ~rev;
                bt.Vec3_set(v0, vb[_i], vb[_i + 1], vb[_i + 2]);
                bt.Vec3_set(v1, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]);
                bt.Vec3_set(v2, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
                bt.TriangleMesh_addTriangle(out, v0, v1, v2);
              }
            } else if (primitiveMode === PrimitiveMode.TRIANGLE_FAN) {
              var _cnt2 = ib.length - 1;

              var _i4 = ib[0] * 3;

              bt.Vec3_set(v0, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);

              for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                var _i5 = ib[_j2] * 3;

                var _i6 = ib[_j2 + 1] * 3;

                bt.Vec3_set(v1, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
                bt.Vec3_set(v2, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);
                bt.TriangleMesh_addTriangle(out, v0, v1, v2);
              }
            }
          }
        }

        return out;
      }

      var _dec$12, _class$13, _class2$X, _descriptor$T, _descriptor2$M, _descriptor3$D, _descriptor4$y, _class3$c, _temp$Z;
      var PhysicsMaterial = function (v) { return exports({ PhysicsMaterial: v, PhysicMaterial: v }), v; }((_dec$12 = ccclass('cc.PhysicsMaterial'), _dec$12(_class$13 = (_class2$X = (_temp$Z = _class3$c = function (_Asset) {
        _inheritsLoose(PhysicsMaterial, _Asset);

        function PhysicsMaterial() {
          var _this;

          _this = _Asset.call(this) || this;
          _this.id = void 0;

          _initializerDefineProperty(_this, "_friction", _descriptor$T, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_rollingFriction", _descriptor2$M, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spinningFriction", _descriptor3$D, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_restitution", _descriptor4$y, _assertThisInitialized(_this));

          PhysicsMaterial.allMaterials.push(_assertThisInitialized(_this));
          _this.id = PhysicsMaterial._idCounter++;
          if (!_this._uuid) _this._uuid = "pm_" + _this.id;
          return _this;
        }

        var _proto = PhysicsMaterial.prototype;

        _proto.clone = function clone() {
          var c = new PhysicsMaterial();
          c._friction = this._friction;
          c._restitution = this._restitution;
          c._rollingFriction = this._rollingFriction;
          c._spinningFriction = this._spinningFriction;
          return c;
        };

        _proto.destroy = function destroy() {
          if (_Asset.prototype.destroy.call(this)) {
            var idx = PhysicsMaterial.allMaterials.indexOf(this);

            if (idx >= 0) {
              PhysicsMaterial.allMaterials.splice(idx, 1);
            }

            return true;
          }

          return false;
        };

        _proto.setValues = function setValues(friction, rollingFriction, spinningFriction, restitution) {
          var emitUpdate = this._friction !== friction || this._rollingFriction !== rollingFriction || this._spinningFriction !== spinningFriction || this._restitution !== restitution;
          this._friction = friction;
          this._rollingFriction = rollingFriction;
          this._spinningFriction = spinningFriction;
          this._restitution = restitution;
          if (emitUpdate) this.emit(PhysicsMaterial.EVENT_UPDATE);
        };

        _createClass(PhysicsMaterial, [{
          key: "friction",
          get: function get() {
            return this._friction;
          },
          set: function set(value) {
            if (!equals$1(this._friction, value)) {
              this._friction = value;
              this.emit(PhysicsMaterial.EVENT_UPDATE);
            }
          }
        }, {
          key: "rollingFriction",
          get: function get() {
            return this._rollingFriction;
          },
          set: function set(value) {
            if (!equals$1(this._rollingFriction, value)) {
              this._rollingFriction = value;
              this.emit(PhysicsMaterial.EVENT_UPDATE);
            }
          }
        }, {
          key: "spinningFriction",
          get: function get() {
            return this._spinningFriction;
          },
          set: function set(value) {
            if (!equals$1(this._spinningFriction, value)) {
              this._spinningFriction = value;
              this.emit(PhysicsMaterial.EVENT_UPDATE);
            }
          }
        }, {
          key: "restitution",
          get: function get() {
            return this._restitution;
          },
          set: function set(value) {
            if (!equals$1(this._restitution, value)) {
              this._restitution = value;
              this.emit(PhysicsMaterial.EVENT_UPDATE);
            }
          }
        }]);

        return PhysicsMaterial;
      }(Asset), _class3$c.allMaterials = [], _class3$c.EVENT_UPDATE = 'event_update', _class3$c._idCounter = 0, _temp$Z), (_applyDecoratedDescriptor(_class2$X.prototype, "friction", [editable], Object.getOwnPropertyDescriptor(_class2$X.prototype, "friction"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "rollingFriction", [editable], Object.getOwnPropertyDescriptor(_class2$X.prototype, "rollingFriction"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "spinningFriction", [editable], Object.getOwnPropertyDescriptor(_class2$X.prototype, "spinningFriction"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "restitution", [editable], Object.getOwnPropertyDescriptor(_class2$X.prototype, "restitution"), _class2$X.prototype), _descriptor$T = _applyDecoratedDescriptor(_class2$X.prototype, "_friction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.6;
        }
      }), _descriptor2$M = _applyDecoratedDescriptor(_class2$X.prototype, "_rollingFriction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _descriptor3$D = _applyDecoratedDescriptor(_class2$X.prototype, "_spinningFriction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _descriptor4$y = _applyDecoratedDescriptor(_class2$X.prototype, "_restitution", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      })), _class2$X)) || _class$13));

      var PhysicsRayResult = exports('PhysicsRayResult', function () {
        function PhysicsRayResult() {
          this._hitPoint = new Vec3();
          this._hitNormal = new Vec3();
          this._distance = 0;
          this._collider = null;
        }

        var _proto = PhysicsRayResult.prototype;

        _proto._assign = function _assign(hitPoint, distance, collider, hitNormal) {
          Vec3.copy(this._hitPoint, hitPoint);
          Vec3.copy(this._hitNormal, hitNormal);
          this._distance = distance;
          this._collider = collider;
        };

        _proto.clone = function clone() {
          var c = new PhysicsRayResult();
          Vec3.copy(c._hitPoint, this._hitPoint);
          Vec3.copy(c._hitNormal, this._hitNormal);
          c._distance = this._distance;
          c._collider = this._collider;
          return c;
        };

        _createClass(PhysicsRayResult, [{
          key: "hitPoint",
          get: function get() {
            return this._hitPoint;
          }
        }, {
          key: "distance",
          get: function get() {
            return this._distance;
          }
        }, {
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }, {
          key: "hitNormal",
          get: function get() {
            return this._hitNormal;
          }
        }]);

        return PhysicsRayResult;
      }());

      var CollisionMatrix = function CollisionMatrix(strategy) {
        if (strategy === 1) {
          var self = this;

          var _loop = function _loop(i) {
            var key = "_" + (1 << i);
            self[key] = 0;
            self.updateArray = [];
            Object.defineProperty(self, 1 << i, {
              get: function get() {
                return this[key];
              },
              set: function set(v) {
                if (this[key] !== v) {
                  this[key] = v;

                  if (this.updateArray.indexOf(i) < 0) {
                    this.updateArray.push(i);
                  }
                }
              }
            });
          };

          for (var i = 0; i < 32; i++) {
            _loop(i);
          }

          this['_1'] = PhysicsGroup.DEFAULT;
        } else {
          for (var _i = 0; _i < 32; _i++) {
            var key = 1 << _i;
            this["" + key] = 0;
          }

          this['1'] = PhysicsGroup.DEFAULT;
        }
      };

      legacyCC.internal.PhysicsGroup = PhysicsGroup;
      var PhysicsSystem = exports('PhysicsSystem', function (_System) {
        _inheritsLoose(PhysicsSystem, _System);

        var _proto = PhysicsSystem.prototype;

        _proto.initDefaultMaterial = function initDefaultMaterial() {
          if (this._material != null) {
            return;
          }

          this._material = builtinResMgr.get('default-physics-material');

          if (this._material != null) {
            this.physicsWorld.setDefaultMaterial(this._material);

            this._material.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

            this.setDefaultMaterial(this._materialConfig);
          } else {
            console.error('PhysicsSystem initDefaultMaterial failed');
          }
        };

        function PhysicsSystem() {
          var _this;

          _this = _System.call(this) || this;
          _this.raycastClosestResult = new PhysicsRayResult();
          _this.raycastResults = [];
          _this.collisionMatrix = new CollisionMatrix(1);
          _this.minVolumeSize = 1e-5;
          _this.useNodeChains = false;
          _this._enable = true;
          _this._allowSleep = true;
          _this._maxSubSteps = 1;
          _this._subStepCount = 0;
          _this._fixedTimeStep = 1.0 / 60.0;
          _this._autoSimulation = true;
          _this._accumulator = 0;
          _this._sleepThreshold = 0.1;
          _this._gravity = new Vec3(0, -10, 0);
          _this._materialConfig = new PhysicsMaterial();
          _this.raycastOptions = {
            group: -1,
            mask: -1,
            queryTrigger: true,
            maxDistance: 10000000
          };
          _this.raycastResultPool = new RecyclePool(function () {
            return new PhysicsRayResult();
          }, 1);
          return _this;
        }

        _proto.postUpdate = function postUpdate(deltaTime) {
          if (!this.physicsWorld) return;

          if (!this._enable) {
            this.physicsWorld.syncSceneToPhysics();
            return;
          }

          if (this._autoSimulation) {
            this._subStepCount = 0;
            this._accumulator += deltaTime;
            director.emit(Director.EVENT_BEFORE_PHYSICS);

            while (this._subStepCount < this._maxSubSteps) {
              if (this._accumulator >= this._fixedTimeStep) {
                this.physicsWorld.syncSceneToPhysics();
                this.physicsWorld.step(this._fixedTimeStep);
                this.physicsWorld.emitEvents();
                this.physicsWorld.syncAfterEvents();
                this._accumulator -= this._fixedTimeStep;
                this._subStepCount++;
              } else {
                this.physicsWorld.syncSceneToPhysics();
                break;
              }
            }

            director.emit(Director.EVENT_AFTER_PHYSICS);
          }
        };

        _proto.resetConfiguration = function resetConfiguration(config) {
          var allowSleep = config ? config.allowSleep : settings.querySettings(Settings.Category.PHYSICS, 'allowSleep');
          if (typeof allowSleep === 'boolean') this._allowSleep = allowSleep;
          var fixedTimeStep = config ? config.fixedTimeStep : settings.querySettings(Settings.Category.PHYSICS, 'fixedTimeStep');
          if (typeof fixedTimeStep === 'number') this._fixedTimeStep = fixedTimeStep;
          var maxSubSteps = config ? config.maxSubSteps : settings.querySettings(Settings.Category.PHYSICS, 'maxSubSteps');
          if (typeof maxSubSteps === 'number') this._maxSubSteps = maxSubSteps;
          var sleepThreshold = config ? config.sleepThreshold : settings.querySettings(Settings.Category.PHYSICS, 'sleepThreshold');
          if (typeof sleepThreshold === 'number') this._sleepThreshold = sleepThreshold;
          var autoSimulation = config ? config.autoSimulation : settings.querySettings(Settings.Category.PHYSICS, 'autoSimulation');
          if (typeof autoSimulation === 'boolean') this.autoSimulation = autoSimulation;
          var gravity = config ? config.gravity : settings.querySettings(Settings.Category.PHYSICS, 'gravity');
          if (gravity) Vec3.copy(this._gravity, gravity);
          var defaultMaterialConfig = config ? config.defaultMaterial : settings.querySettings(Settings.Category.PHYSICS, 'defaultMaterial');
          this._materialConfig = defaultMaterialConfig;
          var collisionMatrix = config ? config.collisionMatrix : settings.querySettings(Settings.Category.PHYSICS, 'collisionMatrix');

          if (collisionMatrix) {
            for (var i in collisionMatrix) {
              this.collisionMatrix["" + (1 << parseInt(i))] = collisionMatrix[i];
            }
          }

          var collisionGroups = config ? config.collisionGroups : settings.querySettings(Settings.Category.PHYSICS, 'collisionGroups');

          if (collisionGroups) {
            var cg = collisionGroups;

            if (cg instanceof Array) {
              cg.forEach(function (v) {
                PhysicsGroup[v.name] = 1 << v.index;
              });
              Enum.update(PhysicsGroup);
            }
          }

          if (this.physicsWorld) {
            this.physicsWorld.setGravity(this._gravity);
            this.physicsWorld.setAllowSleep(this._allowSleep);
          }
        };

        _proto.setDefaultMaterial = function setDefaultMaterial(materialConfig) {
          if (!this._material) return;
          if (!materialConfig) return;

          this._material.setValues(materialConfig.friction, materialConfig.rollingFriction, materialConfig.spinningFriction, materialConfig.restitution);
        };

        _proto.resetAccumulator = function resetAccumulator(time) {
          if (time === void 0) {
            time = 0;
          }

          this._accumulator = time;
        };

        _proto.step = function step(fixedTimeStep, deltaTime, maxSubSteps) {
          if (this.physicsWorld) this.physicsWorld.step(fixedTimeStep, deltaTime, maxSubSteps);
        };

        _proto.syncSceneToPhysics = function syncSceneToPhysics() {
          if (this.physicsWorld) this.physicsWorld.syncSceneToPhysics();
        };

        _proto.emitEvents = function emitEvents() {
          if (this.physicsWorld) this.physicsWorld.emitEvents();
        };

        _proto.raycast = function raycast(worldRay, mask, maxDistance, queryTrigger) {
          if (mask === void 0) {
            mask = 0xffffffff;
          }

          if (maxDistance === void 0) {
            maxDistance = 10000000;
          }

          if (queryTrigger === void 0) {
            queryTrigger = true;
          }

          if (!this.physicsWorld) return false;
          this.raycastResultPool.reset();
          this.raycastResults.length = 0;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.raycast(worldRay, this.raycastOptions, this.raycastResultPool, this.raycastResults);
        };

        _proto.raycastClosest = function raycastClosest(worldRay, mask, maxDistance, queryTrigger) {
          if (mask === void 0) {
            mask = 0xffffffff;
          }

          if (maxDistance === void 0) {
            maxDistance = 10000000;
          }

          if (queryTrigger === void 0) {
            queryTrigger = true;
          }

          if (!this.physicsWorld) return false;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.raycastClosest(worldRay, this.raycastOptions, this.raycastClosestResult);
        };

        _proto._updateMaterial = function _updateMaterial() {
          if (this.physicsWorld) this.physicsWorld.setDefaultMaterial(this._material);
        };

        PhysicsSystem.constructAndRegister = function constructAndRegister() {
          if (!PhysicsSystem._instance) {
            var sys = new PhysicsSystem();
            sys.resetConfiguration();
            constructDefaultWorld(sys);
            PhysicsSystem._instance = sys;
            director.registerSystem(PhysicsSystem.ID, sys, sys.priority);

            if (!builtinResMgr.get('default-physics-material')) {
              game.onPostProjectInitDelegate.add(sys.initDefaultMaterial.bind(sys));
            } else {
              sys.initDefaultMaterial();
            }
          }
        };

        _createClass(PhysicsSystem, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(value) {
            this._enable = value;
          }
        }, {
          key: "allowSleep",
          get: function get() {
            return this._allowSleep;
          },
          set: function set(v) {
            this._allowSleep = v;

            if (this.physicsWorld) {
              this.physicsWorld.setAllowSleep(v);
            }
          }
        }, {
          key: "maxSubSteps",
          get: function get() {
            return this._maxSubSteps;
          },
          set: function set(value) {
            this._maxSubSteps = value;
          }
        }, {
          key: "fixedTimeStep",
          get: function get() {
            return this._fixedTimeStep;
          },
          set: function set(value) {
            this._fixedTimeStep = value;
          }
        }, {
          key: "gravity",
          get: function get() {
            return this._gravity;
          },
          set: function set(gravity) {
            this._gravity.set(gravity);

            if (this.physicsWorld) {
              this.physicsWorld.setGravity(gravity);
            }
          }
        }, {
          key: "sleepThreshold",
          get: function get() {
            return this._sleepThreshold;
          },
          set: function set(v) {
            this._sleepThreshold = v;
          }
        }, {
          key: "autoSimulation",
          get: function get() {
            return this._autoSimulation;
          },
          set: function set(value) {
            this._autoSimulation = value;
          }
        }, {
          key: "defaultMaterial",
          get: function get() {
            return this._material;
          }
        }, {
          key: "physicsWorld",
          get: function get() {
            return selector.physicsWorld;
          }
        }], [{
          key: "PHYSICS_NONE",
          get: function get() {
            return !selector.id;
          }
        }, {
          key: "PHYSICS_BUILTIN",
          get: function get() {
            return selector.id === 'builtin';
          }
        }, {
          key: "PHYSICS_CANNON",
          get: function get() {
            return selector.id === 'cannon.js';
          }
        }, {
          key: "PHYSICS_BULLET",
          get: function get() {
            return selector.id === 'bullet';
          }
        }, {
          key: "PHYSICS_PHYSX",
          get: function get() {
            return selector.id === 'physx';
          }
        }, {
          key: "PhysicsGroup",
          get: function get() {
            return PhysicsGroup;
          }
        }, {
          key: "instance",
          get: function get() {
            return PhysicsSystem._instance;
          }
        }]);

        return PhysicsSystem;
      }(System));
      PhysicsSystem.ID = 'PHYSICS';
      PhysicsSystem._instance = null;
      director.once(Director.EVENT_INIT, function () {
        PhysicsSystem.constructAndRegister();
      });

      var _dec$13, _dec2$M, _dec3$I, _dec4$E, _dec5$B, _dec6$y, _dec7$w, _dec8$u, _dec9$q, _dec10$o, _dec11$m, _dec12$l, _dec13$l, _dec14$j, _dec15$j, _dec16$j, _dec17$i, _dec18$h, _dec19$g, _dec20$g, _dec21$g, _dec22$e, _dec23$d, _dec24$d, _dec25$c, _dec26$c, _dec27$c, _dec28$b, _dec29$b, _dec30$9, _dec31$9, _class$14, _class2$Y, _descriptor$U, _descriptor2$N, _descriptor3$E, _descriptor4$z, _descriptor5$t, _descriptor6$p, _descriptor7$j, _descriptor8$i, _descriptor9$f, _class3$d, _temp$_;
      var RigidBody = function (v) { return exports({ RigidBody: v, RigidBodyComponent: v }), v; }((_dec$13 = ccclass('cc.RigidBody'), _dec2$M = help(), _dec3$I = menu(), _dec4$E = executionOrder(-1), _dec5$B = type(PhysicsSystem.PhysicsGroup), _dec6$y = displayOrder(), _dec7$w = tooltip(), _dec8$u = type(ERigidBodyType), _dec9$q = displayOrder(), _dec10$o = tooltip(), _dec11$m = visible(), _dec12$l = displayOrder(), _dec13$l = tooltip(), _dec14$j = visible(), _dec15$j = displayOrder(), _dec16$j = tooltip(), _dec17$i = visible(), _dec18$h = displayOrder(), _dec19$g = tooltip(), _dec20$g = visible(), _dec21$g = displayOrder(), _dec22$e = tooltip(), _dec23$d = visible(), _dec24$d = displayOrder(), _dec25$c = tooltip(), _dec26$c = visible(), _dec27$c = displayOrder(), _dec28$b = tooltip(), _dec29$b = visible(), _dec30$9 = displayOrder(), _dec31$9 = tooltip(), _dec$13(_class$14 = _dec2$M(_class$14 = _dec3$I(_class$14 = executeInEditMode(_class$14 = disallowMultiple(_class$14 = _dec4$E(_class$14 = (_class2$Y = (_temp$_ = _class3$d = function (_Component) {
        _inheritsLoose(RigidBody, _Component);

        function RigidBody() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._body = null;

          _initializerDefineProperty(_this, "_group", _descriptor$U, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_type", _descriptor2$N, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mass", _descriptor3$E, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_allowSleep", _descriptor4$z, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_linearDamping", _descriptor5$t, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_angularDamping", _descriptor6$p, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_useGravity", _descriptor7$j, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_linearFactor", _descriptor8$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_angularFactor", _descriptor9$f, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = RigidBody.prototype;

        _proto.onLoad = function onLoad() {
          if (!selector.runInEditor) return;
          this._body = createRigidBody();

          this._body.initialize(this);
        };

        _proto.onEnable = function onEnable() {
          if (this._body) this._body.onEnable();
        };

        _proto.onDisable = function onDisable() {
          if (this._body) this._body.onDisable();
        };

        _proto.onDestroy = function onDestroy() {
          if (this._body) this._body.onDestroy();
        };

        _proto.applyForce = function applyForce(force, relativePoint) {
          if (this._isInitialized) this._body.applyForce(force, relativePoint);
        };

        _proto.applyLocalForce = function applyLocalForce(force, localPoint) {
          if (this._isInitialized) this._body.applyLocalForce(force, localPoint);
        };

        _proto.applyImpulse = function applyImpulse(impulse, relativePoint) {
          if (this._isInitialized) this._body.applyImpulse(impulse, relativePoint);
        };

        _proto.applyLocalImpulse = function applyLocalImpulse(impulse, localPoint) {
          if (this._isInitialized) this._body.applyLocalImpulse(impulse, localPoint);
        };

        _proto.applyTorque = function applyTorque(torque) {
          if (this._isInitialized) this._body.applyTorque(torque);
        };

        _proto.applyLocalTorque = function applyLocalTorque(torque) {
          if (this._isInitialized) this._body.applyLocalTorque(torque);
        };

        _proto.wakeUp = function wakeUp() {
          if (this._isInitialized) this._body.wakeUp();
        };

        _proto.sleep = function sleep() {
          if (this._isInitialized) this._body.sleep();
        };

        _proto.clearState = function clearState() {
          if (this._isInitialized) this._body.clearState();
        };

        _proto.clearForces = function clearForces() {
          if (this._isInitialized) this._body.clearForces();
        };

        _proto.clearVelocity = function clearVelocity() {
          if (this._isInitialized) this._body.clearVelocity();
        };

        _proto.getLinearVelocity = function getLinearVelocity(out) {
          if (this._isInitialized) this._body.getLinearVelocity(out);
        };

        _proto.setLinearVelocity = function setLinearVelocity(value) {
          if (this._isInitialized) this._body.setLinearVelocity(value);
        };

        _proto.getAngularVelocity = function getAngularVelocity(out) {
          if (this._isInitialized) this._body.getAngularVelocity(out);
        };

        _proto.setAngularVelocity = function setAngularVelocity(value) {
          if (this._isInitialized) this._body.setAngularVelocity(value);
        };

        _proto.getGroup = function getGroup() {
          if (this._isInitialized) return this._body.getGroup();
          return 0;
        };

        _proto.setGroup = function setGroup(v) {
          if (this._isInitialized) this._body.setGroup(v);
        };

        _proto.addGroup = function addGroup(v) {
          if (this._isInitialized) this._body.addGroup(v);
        };

        _proto.removeGroup = function removeGroup(v) {
          if (this._isInitialized) this._body.removeGroup(v);
        };

        _proto.getMask = function getMask() {
          if (this._isInitialized) return this._body.getMask();
          return 0;
        };

        _proto.setMask = function setMask(v) {
          if (this._isInitialized) this._body.setMask(v);
        };

        _proto.addMask = function addMask(v) {
          if (this._isInitialized) this._body.addMask(v);
        };

        _proto.removeMask = function removeMask(v) {
          if (this._isInitialized) this._body.removeMask(v);
        };

        _createClass(RigidBody, [{
          key: "group",
          get: function get() {
            return this._group;
          },
          set: function set(v) {
            if ( !Number.isInteger(Math.log2(v >>> 0))) warn('[Physics]: The group should only have one bit.');
            this._group = v;

            if (this._body) {
              if (this._body.getGroup() !== v) this._body.setGroup(v);
            }
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(v) {
            if (this._type === v) return;
            this._type = v;
            if (this._body) this._body.setType(v);
          }
        }, {
          key: "mass",
          get: function get() {
            return this._mass;
          },
          set: function set(value) {
            if ( value <= 0) warn('[Physics]: The mass should be greater than zero.');
            if (this._mass === value) return;
            value = value <= 0 ? 0.0001 : value;
            this._mass = value;
            if (this._body) this._body.setMass(value);
          }
        }, {
          key: "allowSleep",
          get: function get() {
            return this._allowSleep;
          },
          set: function set(v) {
            this._allowSleep = v;
            if (this._body) this._body.setAllowSleep(v);
          }
        }, {
          key: "linearDamping",
          get: function get() {
            return this._linearDamping;
          },
          set: function set(value) {
            if ( (value < 0 || value > 1)) warn('[Physics]: The damping should be between zero to one.');
            this._linearDamping = value;
            if (this._body) this._body.setLinearDamping(value);
          }
        }, {
          key: "angularDamping",
          get: function get() {
            return this._angularDamping;
          },
          set: function set(value) {
            if ( (value < 0 || value > 1)) warn('[Physics]: The damping should be between zero to one.');
            this._angularDamping = value;
            if (this._body) this._body.setAngularDamping(value);
          }
        }, {
          key: "useGravity",
          get: function get() {
            return this._useGravity;
          },
          set: function set(value) {
            this._useGravity = value;
            if (this._body) this._body.useGravity(value);
          }
        }, {
          key: "linearFactor",
          get: function get() {
            return this._linearFactor;
          },
          set: function set(value) {
            Vec3.copy(this._linearFactor, value);

            if (this._body) {
              this._body.setLinearFactor(this._linearFactor);
            }
          }
        }, {
          key: "angularFactor",
          get: function get() {
            return this._angularFactor;
          },
          set: function set(value) {
            Vec3.copy(this._angularFactor, value);

            if (this._body) {
              this._body.setAngularFactor(this._angularFactor);
            }
          }
        }, {
          key: "sleepThreshold",
          get: function get() {
            if (this._isInitialized) {
              return this._body.getSleepThreshold();
            }

            return 0.1;
          },
          set: function set(v) {
            if (this._isInitialized) {
              this._body.setSleepThreshold(v);
            }
          }
        }, {
          key: "useCCD",
          get: function get() {
            if (this._isInitialized) {
              return this._body.isUsingCCD();
            }

            return false;
          },
          set: function set(v) {
            if (this._isInitialized) {
              this._body.useCCD(v);
            }
          }
        }, {
          key: "isAwake",
          get: function get() {
            if (this._isInitialized) return this._body.isAwake;
            return false;
          }
        }, {
          key: "isSleepy",
          get: function get() {
            if (this._isInitialized) return this._body.isSleepy;
            return false;
          }
        }, {
          key: "isSleeping",
          get: function get() {
            if (this._isInitialized) return this._body.isSleeping;
            return false;
          }
        }, {
          key: "isStatic",
          get: function get() {
            return this._type === ERigidBodyType.STATIC;
          },
          set: function set(v) {
            if (v && this.isStatic || !v && !this.isStatic) return;
            this.type = v ? ERigidBodyType.STATIC : ERigidBodyType.DYNAMIC;
          }
        }, {
          key: "isDynamic",
          get: function get() {
            return this._type === ERigidBodyType.DYNAMIC;
          },
          set: function set(v) {
            if (v && this.isDynamic || !v && !this.isDynamic) return;
            this.type = v ? ERigidBodyType.DYNAMIC : ERigidBodyType.KINEMATIC;
          }
        }, {
          key: "isKinematic",
          get: function get() {
            return this._type === ERigidBodyType.KINEMATIC;
          },
          set: function set(v) {
            if (v && this.isKinematic || !v && !this.isKinematic) return;
            this.type = v ? ERigidBodyType.KINEMATIC : ERigidBodyType.DYNAMIC;
          }
        }, {
          key: "body",
          get: function get() {
            return this._body;
          }
        }, {
          key: "_isInitialized",
          get: function get() {
            var r = this._body === null;

            if (r) {
              error('[Physics]: This component has not been call onLoad yet, please make sure the node has been added to the scene.');
            }

            return !r;
          }
        }]);

        return RigidBody;
      }(Component), _class3$d.Type = ERigidBodyType, _temp$_), (_applyDecoratedDescriptor(_class2$Y.prototype, "group", [_dec5$B, _dec6$y, _dec7$w], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "group"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "type", [_dec8$u, _dec9$q, _dec10$o], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "type"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "mass", [_dec11$m, _dec12$l, _dec13$l], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "mass"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "allowSleep", [_dec14$j, _dec15$j, _dec16$j], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "allowSleep"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "linearDamping", [_dec17$i, _dec18$h, _dec19$g], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "linearDamping"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "angularDamping", [_dec20$g, _dec21$g, _dec22$e], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "angularDamping"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "useGravity", [_dec23$d, _dec24$d, _dec25$c], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "useGravity"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "linearFactor", [_dec26$c, _dec27$c, _dec28$b], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "linearFactor"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "angularFactor", [_dec29$b, _dec30$9, _dec31$9], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "angularFactor"), _class2$Y.prototype), _descriptor$U = _applyDecoratedDescriptor(_class2$Y.prototype, "_group", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PhysicsSystem.PhysicsGroup.DEFAULT;
        }
      }), _descriptor2$N = _applyDecoratedDescriptor(_class2$Y.prototype, "_type", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ERigidBodyType.DYNAMIC;
        }
      }), _descriptor3$E = _applyDecoratedDescriptor(_class2$Y.prototype, "_mass", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor4$z = _applyDecoratedDescriptor(_class2$Y.prototype, "_allowSleep", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor5$t = _applyDecoratedDescriptor(_class2$Y.prototype, "_linearDamping", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor6$p = _applyDecoratedDescriptor(_class2$Y.prototype, "_angularDamping", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor7$j = _applyDecoratedDescriptor(_class2$Y.prototype, "_useGravity", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor8$i = _applyDecoratedDescriptor(_class2$Y.prototype, "_linearFactor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(1, 1, 1);
        }
      }), _descriptor9$f = _applyDecoratedDescriptor(_class2$Y.prototype, "_angularFactor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(1, 1, 1);
        }
      })), _class2$Y)) || _class$14) || _class$14) || _class$14) || _class$14) || _class$14) || _class$14));

      (function (_RigidBody) {})(RigidBody || (RigidBody = function (v) { return exports({ RigidBody: v, RigidBodyComponent: v }), v; }({})));

      var _dec$14, _dec2$N, _dec3$J, _dec4$F, _dec5$C, _dec6$z, _dec7$x, _dec8$v, _dec9$r, _dec10$p, _dec11$n, _dec12$m, _dec13$m, _dec14$k, _dec15$k, _class$15, _class2$Z, _descriptor$V, _descriptor2$O, _descriptor3$F, _class3$e, _temp$$;
      var Collider = function (v) { return exports({ Collider: v, ColliderComponent: v }), v; }((_dec$14 = ccclass('cc.Collider'), _dec2$N = type(RigidBody), _dec3$J = displayName(), _dec4$F = displayOrder(), _dec5$C = tooltip(), _dec6$z = type(PhysicsMaterial), _dec7$x = displayName(), _dec8$v = displayOrder(), _dec9$r = tooltip(), _dec10$p = displayOrder(), _dec11$n = tooltip(), _dec12$m = type(Vec3), _dec13$m = displayOrder(), _dec14$k = tooltip(), _dec15$k = type(PhysicsMaterial), _dec$14(_class$15 = (_class2$Z = (_temp$$ = _class3$e = function (_Eventify) {
        _inheritsLoose(Collider, _Eventify);

        function Collider(type) {
          var _this;

          _this = _Eventify.call(this) || this;
          _this.type = void 0;
          _this._shape = null;
          _this._aabb = null;
          _this._boundingSphere = null;
          _this._isSharedMaterial = true;
          _this._needTriggerEvent = false;
          _this._needCollisionEvent = false;

          _initializerDefineProperty(_this, "_material", _descriptor$V, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isTrigger", _descriptor2$O, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_center", _descriptor3$F, _assertThisInitialized(_this));

          _this.type = type;
          return _this;
        }

        var _proto = Collider.prototype;

        _proto.on = function on(type, callback, target, once) {
          var ret = _Eventify.prototype.on.call(this, type, callback, target, once);

          this._updateNeedEvent(type);

          return ret;
        };

        _proto.off = function off(type, callback, target) {
          _Eventify.prototype.off.call(this, type, callback, target);

          this._updateNeedEvent();
        };

        _proto.once = function once(type, callback, target) {
          var ret = _Eventify.prototype.once.call(this, type, callback, target);

          this._updateNeedEvent(type);

          return ret;
        };

        _proto.removeAll = function removeAll(typeOrTarget) {
          _Eventify.prototype.removeAll.call(this, typeOrTarget);

          this._updateNeedEvent();
        };

        _proto.getGroup = function getGroup() {
          if (this._isInitialized) {
            return this._shape.getGroup();
          }

          return 0;
        };

        _proto.setGroup = function setGroup(v) {
          if (this._isInitialized) {
            this._shape.setGroup(v);
          }
        };

        _proto.addGroup = function addGroup(v) {
          if (this._isInitialized) {
            this._shape.addGroup(v);
          }
        };

        _proto.removeGroup = function removeGroup(v) {
          if (this._isInitialized) {
            this._shape.removeGroup(v);
          }
        };

        _proto.getMask = function getMask() {
          if (this._isInitialized) {
            return this._shape.getMask();
          }

          return 0;
        };

        _proto.setMask = function setMask(v) {
          if (this._isInitialized) {
            this._shape.setMask(v);
          }
        };

        _proto.addMask = function addMask(v) {
          if (this._isInitialized) {
            this._shape.addMask(v);
          }
        };

        _proto.removeMask = function removeMask(v) {
          if (this._isInitialized) {
            this._shape.removeMask(v);
          }
        };

        _proto.onLoad = function onLoad() {
          if (!selector.runInEditor) return;
          this.sharedMaterial = this._material == null ? PhysicsSystem.instance.defaultMaterial : this._material;
          this._shape = createShape(this.type);

          this._shape.initialize(this);

          this._shape.onLoad();
        };

        _proto.onEnable = function onEnable() {
          if (this._shape) {
            this._shape.onEnable();
          }
        };

        _proto.onDisable = function onDisable() {
          if (this._shape) {
            this._shape.onDisable();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this._shape) {
            this._needTriggerEvent = false;
            this._needCollisionEvent = false;

            this._shape.updateEventListener();

            if (this._material) this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

            this._shape.onDestroy();
          }

          if (this._boundingSphere) this._boundingSphere.destroy();
        };

        _proto._updateMaterial = function _updateMaterial() {
          if (this._shape) this._shape.setMaterial(this._material);
        };

        _proto._updateNeedEvent = function _updateNeedEvent(type) {
          if (this.isValid) {
            if (type !== undefined) {
              if (type === 'onCollisionEnter' || type === 'onCollisionStay' || type === 'onCollisionExit') {
                this._needCollisionEvent = true;
              }

              if (type === 'onTriggerEnter' || type === 'onTriggerStay' || type === 'onTriggerExit') {
                this._needTriggerEvent = true;
              }
            } else {
              if (!(this.hasEventListener('onTriggerEnter') || this.hasEventListener('onTriggerStay') || this.hasEventListener('onTriggerExit'))) {
                this._needTriggerEvent = false;
              }

              if (!(this.hasEventListener('onCollisionEnter') || this.hasEventListener('onCollisionStay') || this.hasEventListener('onCollisionExit'))) {
                this._needCollisionEvent = false;
              }
            }

            if (this._shape) this._shape.updateEventListener();
          }
        };

        _createClass(Collider, [{
          key: "attachedRigidBody",
          get: function get() {
            return findAttachedBody(this.node);
          }
        }, {
          key: "sharedMaterial",
          get: function get() {
            return this._material;
          },
          set: function set(value) {
            {
              this.material = value;
            }
          }
        }, {
          key: "material",
          get: function get() {
            if (this._isSharedMaterial && this._material) {
              this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

              this._material = this._material.clone();

              this._material.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

              this._isSharedMaterial = false;
            }

            return this._material;
          },
          set: function set(value) {
            if (this._shape) {
              if (value && this._material) {
                if (this._material.id !== value.id) {
                  this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                  value.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
                  this._isSharedMaterial = false;
                  this._material = value;
                }
              } else if (value && !this._material) {
                value.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
                this._material = value;
              } else if (!value && this._material) {
                this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                this._material = value;
              }

              this._updateMaterial();
            } else {
              this._material = value;
            }
          }
        }, {
          key: "isTrigger",
          get: function get() {
            return this._isTrigger;
          },
          set: function set(value) {
            this._isTrigger = value;

            if (this._shape) {
              this._shape.setAsTrigger(this._isTrigger);
            }
          }
        }, {
          key: "center",
          get: function get() {
            return this._center;
          },
          set: function set(value) {
            Vec3.copy(this._center, value);

            if (this._shape) {
              this._shape.setCenter(this._center);
            }
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }, {
          key: "worldBounds",
          get: function get() {
            if (this._aabb == null) this._aabb = new AABB();
            if (this._shape) this._shape.getAABB(this._aabb);
            return this._aabb;
          }
        }, {
          key: "boundingSphere",
          get: function get() {
            if (this._boundingSphere == null) this._boundingSphere = new Sphere();
            if (this._shape) this._shape.getBoundingSphere(this._boundingSphere);
            return this._boundingSphere;
          }
        }, {
          key: "needTriggerEvent",
          get: function get() {
            return this._needTriggerEvent;
          }
        }, {
          key: "needCollisionEvent",
          get: function get() {
            return this._needCollisionEvent;
          }
        }, {
          key: "_isInitialized",
          get: function get() {
            var r = this._shape === null;

            if (r) {
              error('[Physics]: This component has not been call onLoad yet, please make sure the node has been added to the scene.');
            }

            return !r;
          }
        }]);

        return Collider;
      }(Eventify(Component)), _class3$e.Type = EColliderType, _class3$e.Axis = EAxisDirection, _temp$$), (_applyDecoratedDescriptor(_class2$Z.prototype, "attachedRigidBody", [_dec2$N, readOnly, _dec3$J, _dec4$F, _dec5$C], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "attachedRigidBody"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "sharedMaterial", [_dec6$z, _dec7$x, _dec8$v, _dec9$r], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "sharedMaterial"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isTrigger", [_dec10$p, _dec11$n], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isTrigger"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "center", [_dec12$m, _dec13$m, _dec14$k], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "center"), _class2$Z.prototype), _descriptor$V = _applyDecoratedDescriptor(_class2$Z.prototype, "_material", [_dec15$k], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$O = _applyDecoratedDescriptor(_class2$Z.prototype, "_isTrigger", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor3$F = _applyDecoratedDescriptor(_class2$Z.prototype, "_center", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      })), _class2$Z)) || _class$15));

      (function (_Collider) {})(Collider || (Collider = function (v) { return exports({ Collider: v, ColliderComponent: v }), v; }({})));

      function findAttachedBody(node) {
        var rb = node.getComponent(RigidBody);

        if (rb && rb.isValid) {
          return rb;
        }

        return null;
      }

      var temp1 = new Vec3();
      var temp2 = new Vec3();
      var temp3 = new Vec3();
      var r = new Vec3();
      var c0 = new Vec3();
      var c1 = new Vec3();
      var c2 = new Vec3();
      var c3 = new Vec3();
      var c4 = new Vec3();
      var c5 = new Vec3();
      var c6 = new Vec3();
      var c7 = new Vec3();

      var temp1$1 = new Vec3(0, 0, 0);
      var temp2$1 = new Vec3(0, 0, 0);
      function cylinder(radiusTop, radiusBottom, height, opts) {
        if (radiusTop === void 0) {
          radiusTop = 0.5;
        }

        if (radiusBottom === void 0) {
          radiusBottom = 0.5;
        }

        if (height === void 0) {
          height = 2;
        }

        if (opts === void 0) {
          opts = {};
        }

        var halfHeight = height * 0.5;
        var radialSegments = opts.radialSegments || 32;
        var heightSegments = opts.heightSegments || 1;
        var capped = opts.capped !== undefined ? opts.capped : true;
        var arc = opts.arc || 2.0 * Math.PI;
        var cntCap = 0;

        if (!capped) {
          if (radiusTop > 0) {
            cntCap++;
          }

          if (radiusBottom > 0) {
            cntCap++;
          }
        }

        var vertCount = (radialSegments + 1) * (heightSegments + 1);

        if (capped) {
          vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap;
        }

        var indexCount = radialSegments * heightSegments * 2 * 3;

        if (capped) {
          indexCount += radialSegments * cntCap * 3;
        }

        var indices = new Array(indexCount);
        var positions = new Array(vertCount * 3);
        var normals = new Array(vertCount * 3);
        var uvs = new Array(vertCount * 2);
        var maxRadius = Math.max(radiusTop, radiusBottom);
        var minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius);
        var maxPos = new Vec3(maxRadius, halfHeight, maxRadius);
        var boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
        var index = 0;
        var indexOffset = 0;
        generateTorso();

        if (capped) {
          if (radiusBottom > 0) {
            generateCap(false);
          }

          if (radiusTop > 0) {
            generateCap(true);
          }
        }

        return {
          positions: positions,
          normals: normals,
          uvs: uvs,
          indices: indices,
          minPos: minPos,
          maxPos: maxPos,
          boundingRadius: boundingRadius
        };

        function generateTorso() {
          var indexArray = [];
          var r = radiusTop - radiusBottom;
          var slope = r * r / height * Math.sign(r);

          for (var y = 0; y <= heightSegments; y++) {
            var indexRow = [];
            var v = y / heightSegments;
            var radius = v * r + radiusBottom;

            for (var x = 0; x <= radialSegments; ++x) {
              var u = x / radialSegments;
              var theta = u * arc;
              var sinTheta = Math.sin(theta);
              var cosTheta = Math.cos(theta);
              positions[3 * index] = radius * sinTheta;
              positions[3 * index + 1] = v * height - halfHeight;
              positions[3 * index + 2] = radius * cosTheta;
              Vec3.normalize(temp1$1, Vec3.set(temp2$1, sinTheta, -slope, cosTheta));
              normals[3 * index] = temp1$1.x;
              normals[3 * index + 1] = temp1$1.y;
              normals[3 * index + 2] = temp1$1.z;
              uvs[2 * index] = (1 - u) * 2 % 1;
              uvs[2 * index + 1] = v;
              indexRow.push(index);
              ++index;
            }

            indexArray.push(indexRow);
          }

          for (var _y = 0; _y < heightSegments; ++_y) {
            for (var _x = 0; _x < radialSegments; ++_x) {
              var i1 = indexArray[_y][_x];
              var i2 = indexArray[_y + 1][_x];
              var i3 = indexArray[_y + 1][_x + 1];
              var i4 = indexArray[_y][_x + 1];
              indices[indexOffset] = i1;
              ++indexOffset;
              indices[indexOffset] = i4;
              ++indexOffset;
              indices[indexOffset] = i2;
              ++indexOffset;
              indices[indexOffset] = i4;
              ++indexOffset;
              indices[indexOffset] = i3;
              ++indexOffset;
              indices[indexOffset] = i2;
              ++indexOffset;
            }
          }
        }

        function generateCap(top) {
          var radius = top ? radiusTop : radiusBottom;
          var sign = top ? 1 : -1;
          var centerIndexStart = index;

          for (var x = 1; x <= radialSegments; ++x) {
            positions[3 * index] = 0;
            positions[3 * index + 1] = halfHeight * sign;
            positions[3 * index + 2] = 0;
            normals[3 * index] = 0;
            normals[3 * index + 1] = sign;
            normals[3 * index + 2] = 0;
            uvs[2 * index] = 0.5;
            uvs[2 * index + 1] = 0.5;
            ++index;
          }

          var centerIndexEnd = index;

          for (var _x2 = 0; _x2 <= radialSegments; ++_x2) {
            var u = _x2 / radialSegments;
            var theta = u * arc;
            var cosTheta = Math.cos(theta);
            var sinTheta = Math.sin(theta);
            positions[3 * index] = radius * sinTheta;
            positions[3 * index + 1] = halfHeight * sign;
            positions[3 * index + 2] = radius * cosTheta;
            normals[3 * index] = 0;
            normals[3 * index + 1] = sign;
            normals[3 * index + 2] = 0;
            uvs[2 * index] = 0.5 - sinTheta * 0.5 * sign;
            uvs[2 * index + 1] = 0.5 + cosTheta * 0.5;
            ++index;
          }

          for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
            var c = centerIndexStart + _x3;
            var i = centerIndexEnd + _x3;

            if (top) {
              indices[indexOffset] = i + 1;
              ++indexOffset;
              indices[indexOffset] = c;
              ++indexOffset;
              indices[indexOffset] = i;
              ++indexOffset;
            } else {
              indices[indexOffset] = c;
              ++indexOffset;
              indices[indexOffset] = i + 1;
              ++indexOffset;
              indices[indexOffset] = i;
              ++indexOffset;
            }
          }
        }
      }

      var temp1$2 = new Vec3(0, 0, 0);
      var temp2$2 = new Vec3(0, 0, 0);
      var temp3$1 = new Vec3(0, 0, 0);
      var r$1 = new Vec3(0, 0, 0);
      var c00 = new Vec3(0, 0, 0);
      var c10 = new Vec3(0, 0, 0);
      var c01 = new Vec3(0, 0, 0);

      var temp1$3 = new Vec3(0, 0, 0);
      var temp2$3 = new Vec3(0, 0, 0);

      function setWrap(object, wrapper) {
        object.__cc_wrapper__ = wrapper;
      }
      function getWrap(object) {
        return object.__cc_wrapper__;
      }
      function maxComponent(v) {
        return Math.max(v.x, Math.max(v.y, v.z));
      }
      var VEC3_0 = new Vec3();
      var TriggerEventObject$1 = {
        type: 'onTriggerEnter',
        selfCollider: null,
        otherCollider: null,
        impl: null
      };
      var CollisionEventObject$1 = {
        type: 'onCollisionEnter',
        selfCollider: null,
        otherCollider: null,
        contacts: [],
        impl: null
      };
      function shrinkPositions(buffer) {
        var pos = [];

        if (buffer.length >= 3) {
          pos[0] = buffer[0], pos[1] = buffer[1], pos[2] = buffer[2];
          var len = buffer.length;

          for (var i = 3; i < len; i += 3) {
            var p0 = buffer[i];
            var p1 = buffer[i + 1];
            var p2 = buffer[i + 2];
            var len2 = pos.length;
            var isNew = true;

            for (var j = 0; j < len2; j += 3) {
              if (equals$1(p0, pos[j]) && equals$1(p1, pos[j + 1]) && equals$1(p2, pos[j + 2])) {
                isNew = false;
                break;
              }
            }

            if (isNew) {
              pos.push(p0);
              pos.push(p1);
              pos.push(p2);
            }
          }
        }

        return pos;
      }
      function absolute(v) {
        v.x = Math.abs(v.x);
        v.y = Math.abs(v.y);
        v.z = Math.abs(v.z);
        return v;
      }

      var util = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setWrap: setWrap,
        getWrap: getWrap,
        maxComponent: maxComponent,
        VEC3_0: VEC3_0,
        TriggerEventObject: TriggerEventObject$1,
        CollisionEventObject: CollisionEventObject$1,
        shrinkPositions: shrinkPositions,
        absolute: absolute,
        cylinder: cylinder
      });

      var _dec$15, _dec2$O, _dec3$K, _dec4$G, _dec5$D, _class$16, _class2$_, _descriptor$W, _temp$10;
      var BoxCollider = function (v) { return exports({ BoxCollider: v, BoxColliderComponent: v }), v; }((_dec$15 = ccclass('cc.BoxCollider'), _dec2$O = help(), _dec3$K = menu(), _dec4$G = type(Vec3), _dec5$D = tooltip(), _dec$15(_class$16 = _dec2$O(_class$16 = _dec3$K(_class$16 = executeInEditMode(_class$16 = (_class2$_ = (_temp$10 = function (_Collider) {
        _inheritsLoose(BoxCollider, _Collider);

        function BoxCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.BOX) || this;

          _initializerDefineProperty(_this, "_size", _descriptor$W, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(BoxCollider, [{
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(value) {
            if (Vec3.strictEquals(this._size, value)) return;
            Vec3.copy(this._size, value);
            absolute(this._size);

            if (this._shape) {
              this.shape.updateSize();
            }
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }]);

        return BoxCollider;
      }(Collider), _temp$10), (_applyDecoratedDescriptor(_class2$_.prototype, "size", [_dec4$G, _dec5$D], Object.getOwnPropertyDescriptor(_class2$_.prototype, "size"), _class2$_.prototype), _descriptor$W = _applyDecoratedDescriptor(_class2$_.prototype, "_size", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(1, 1, 1);
        }
      })), _class2$_)) || _class$16) || _class$16) || _class$16) || _class$16));

      var _dec$16, _dec2$P, _dec3$L, _dec4$H, _class$17, _class2$$, _descriptor$X, _temp$11;
      var SphereCollider = function (v) { return exports({ SphereCollider: v, SphereColliderComponent: v }), v; }((_dec$16 = ccclass('cc.SphereCollider'), _dec2$P = help(), _dec3$L = menu(), _dec4$H = tooltip(), _dec$16(_class$17 = _dec2$P(_class$17 = _dec3$L(_class$17 = executeInEditMode(_class$17 = (_class2$$ = (_temp$11 = function (_Collider) {
        _inheritsLoose(SphereCollider, _Collider);

        function SphereCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.SPHERE) || this;

          _initializerDefineProperty(_this, "_radius", _descriptor$X, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(SphereCollider, [{
          key: "radius",
          get: function get() {
            return this._radius;
          },
          set: function set(value) {
            if (this._radius === value) return;
            this._radius = Math.abs(value);

            if (this._shape) {
              this.shape.updateRadius();
            }
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }]);

        return SphereCollider;
      }(Collider), _temp$11), (_applyDecoratedDescriptor(_class2$$.prototype, "radius", [_dec4$H], Object.getOwnPropertyDescriptor(_class2$$.prototype, "radius"), _class2$$.prototype), _descriptor$X = _applyDecoratedDescriptor(_class2$$.prototype, "_radius", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      })), _class2$$)) || _class$17) || _class$17) || _class$17) || _class$17));

      var _dec$17, _dec2$Q, _dec3$M, _dec4$I, _dec5$E, _dec6$A, _dec7$y, _class$18, _class2$10, _descriptor$Y, _descriptor2$P, _descriptor3$G, _temp$12;
      var CapsuleCollider = function (v) { return exports({ CapsuleCollider: v, CapsuleColliderComponent: v }), v; }((_dec$17 = ccclass('cc.CapsuleCollider'), _dec2$Q = help(), _dec3$M = menu(), _dec4$I = tooltip(), _dec5$E = tooltip(), _dec6$A = type(EAxisDirection), _dec7$y = tooltip(), _dec$17(_class$18 = _dec2$Q(_class$18 = _dec3$M(_class$18 = executeInEditMode(_class$18 = (_class2$10 = (_temp$12 = function (_Collider) {
        _inheritsLoose(CapsuleCollider, _Collider);

        function CapsuleCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.CAPSULE) || this;

          _initializerDefineProperty(_this, "_radius", _descriptor$Y, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cylinderHeight", _descriptor2$P, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$G, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = CapsuleCollider.prototype;

        _proto._getRadiusScale = function _getRadiusScale() {
          if (this.node == null) return 1;
          var ws = this.node.worldScale;
          if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(absMax(ws.x, ws.z));
          if (this._direction === EAxisDirection.X_AXIS) return Math.abs(absMax(ws.y, ws.z));
          return Math.abs(absMax(ws.x, ws.y));
        };

        _proto._getHeightScale = function _getHeightScale() {
          if (this.node == null) return 1;
          var ws = this.node.worldScale;
          if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(ws.y);
          if (this._direction === EAxisDirection.X_AXIS) return Math.abs(ws.x);
          return Math.abs(ws.z);
        };

        _createClass(CapsuleCollider, [{
          key: "radius",
          get: function get() {
            return this._radius;
          },
          set: function set(value) {
            if (this._radius === value) return;
            this._radius = Math.abs(value);

            if (this._shape) {
              this.shape.setRadius(value);
            }
          }
        }, {
          key: "cylinderHeight",
          get: function get() {
            return this._cylinderHeight;
          },
          set: function set(value) {
            if (this._cylinderHeight === value) return;
            this._cylinderHeight = Math.abs(value);

            if (this._shape) {
              this.shape.setCylinderHeight(value);
            }
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            value = Math.floor(value);
            if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
            if (this._direction === value) return;
            this._direction = value;

            if (this._shape) {
              this.shape.setDirection(value);
            }
          }
        }, {
          key: "height",
          get: function get() {
            return this._radius * 2 + this._cylinderHeight;
          },
          set: function set(value) {
            var ch = value - this._radius * 2;
            if (ch < 0) ch = 0;
            this.cylinderHeight = ch;
          }
        }, {
          key: "worldHeight",
          get: function get() {
            return this._radius * 2 * this._getRadiusScale() + this._cylinderHeight * this._getHeightScale();
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }]);

        return CapsuleCollider;
      }(Collider), _temp$12), (_applyDecoratedDescriptor(_class2$10.prototype, "radius", [_dec4$I], Object.getOwnPropertyDescriptor(_class2$10.prototype, "radius"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "cylinderHeight", [_dec5$E], Object.getOwnPropertyDescriptor(_class2$10.prototype, "cylinderHeight"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "direction", [_dec6$A, _dec7$y], Object.getOwnPropertyDescriptor(_class2$10.prototype, "direction"), _class2$10.prototype), _descriptor$Y = _applyDecoratedDescriptor(_class2$10.prototype, "_radius", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor2$P = _applyDecoratedDescriptor(_class2$10.prototype, "_cylinderHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor3$G = _applyDecoratedDescriptor(_class2$10.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return EAxisDirection.Y_AXIS;
        }
      })), _class2$10)) || _class$18) || _class$18) || _class$18) || _class$18));

      var _dec$18, _dec2$R, _dec3$N, _dec4$J, _dec5$F, _dec6$B, _dec7$z, _class$19, _class2$11, _descriptor$Z, _descriptor2$Q, _descriptor3$H, _temp$13;
      var CylinderCollider = function (v) { return exports({ CylinderCollider: v, CylinderColliderComponent: v }), v; }((_dec$18 = ccclass('cc.CylinderCollider'), _dec2$R = help(), _dec3$N = menu(), _dec4$J = tooltip(), _dec5$F = tooltip(), _dec6$B = type(EAxisDirection), _dec7$z = tooltip(), _dec$18(_class$19 = _dec2$R(_class$19 = _dec3$N(_class$19 = executeInEditMode(_class$19 = (_class2$11 = (_temp$13 = function (_Collider) {
        _inheritsLoose(CylinderCollider, _Collider);

        function CylinderCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.CYLINDER) || this;

          _initializerDefineProperty(_this, "_radius", _descriptor$Z, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_height", _descriptor2$Q, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$H, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(CylinderCollider, [{
          key: "radius",
          get: function get() {
            return this._radius;
          },
          set: function set(value) {
            if (this._radius === value) return;
            this._radius = Math.abs(value);

            if (this._shape) {
              this.shape.setRadius(value);
            }
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          },
          set: function set(value) {
            if (this._height === value) return;
            this._height = Math.abs(value);

            if (this._shape) {
              this.shape.setHeight(value);
            }
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) return;
            if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
            this._direction = value;

            if (this._shape) {
              this.shape.setDirection(value);
            }
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }]);

        return CylinderCollider;
      }(Collider), _temp$13), (_applyDecoratedDescriptor(_class2$11.prototype, "radius", [_dec4$J], Object.getOwnPropertyDescriptor(_class2$11.prototype, "radius"), _class2$11.prototype), _applyDecoratedDescriptor(_class2$11.prototype, "height", [_dec5$F], Object.getOwnPropertyDescriptor(_class2$11.prototype, "height"), _class2$11.prototype), _applyDecoratedDescriptor(_class2$11.prototype, "direction", [_dec6$B, _dec7$z], Object.getOwnPropertyDescriptor(_class2$11.prototype, "direction"), _class2$11.prototype), _descriptor$Z = _applyDecoratedDescriptor(_class2$11.prototype, "_radius", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor2$Q = _applyDecoratedDescriptor(_class2$11.prototype, "_height", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _descriptor3$H = _applyDecoratedDescriptor(_class2$11.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return EAxisDirection.Y_AXIS;
        }
      })), _class2$11)) || _class$19) || _class$19) || _class$19) || _class$19));

      var _dec$19, _dec2$S, _dec3$O, _dec4$K, _dec5$G, _dec6$C, _dec7$A, _class$1a, _class2$12, _descriptor$_, _descriptor2$R, _descriptor3$I, _temp$14;
      var ConeCollider = exports('ConeCollider', (_dec$19 = ccclass('cc.ConeCollider'), _dec2$S = help(), _dec3$O = menu(), _dec4$K = tooltip(), _dec5$G = tooltip(), _dec6$C = type(EAxisDirection), _dec7$A = tooltip(), _dec$19(_class$1a = _dec2$S(_class$1a = _dec3$O(_class$1a = executeInEditMode(_class$1a = (_class2$12 = (_temp$14 = function (_Collider) {
        _inheritsLoose(ConeCollider, _Collider);

        function ConeCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.CONE) || this;

          _initializerDefineProperty(_this, "_radius", _descriptor$_, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_height", _descriptor2$R, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$I, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(ConeCollider, [{
          key: "radius",
          get: function get() {
            return this._radius;
          },
          set: function set(value) {
            if (this._radius === value) return;
            this._radius = Math.abs(value);

            if (this._shape) {
              this.shape.setRadius(value);
            }
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          },
          set: function set(value) {
            if (this._height === value) return;
            if (value < 0) value = 0;
            this._height = value;

            if (this._shape) {
              this.shape.setHeight(value);
            }
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) return;
            if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
            this._direction = value;

            if (this._shape) {
              this.shape.setDirection(value);
            }
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }]);

        return ConeCollider;
      }(Collider), _temp$14), (_applyDecoratedDescriptor(_class2$12.prototype, "radius", [_dec4$K], Object.getOwnPropertyDescriptor(_class2$12.prototype, "radius"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "height", [_dec5$G], Object.getOwnPropertyDescriptor(_class2$12.prototype, "height"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "direction", [_dec6$C, _dec7$A], Object.getOwnPropertyDescriptor(_class2$12.prototype, "direction"), _class2$12.prototype), _descriptor$_ = _applyDecoratedDescriptor(_class2$12.prototype, "_radius", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor2$R = _applyDecoratedDescriptor(_class2$12.prototype, "_height", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor3$I = _applyDecoratedDescriptor(_class2$12.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return EAxisDirection.Y_AXIS;
        }
      })), _class2$12)) || _class$1a) || _class$1a) || _class$1a) || _class$1a));

      var _dec$1a, _dec2$T, _dec3$P, _dec4$L, _dec5$H, _dec6$D, _class$1b, _class2$13, _descriptor$$, _descriptor2$S, _temp$15;
      var MeshCollider = function (v) { return exports({ MeshCollider: v, MeshColliderComponent: v }), v; }((_dec$1a = ccclass('cc.MeshCollider'), _dec2$T = help(), _dec3$P = menu(), _dec4$L = type(Mesh), _dec5$H = tooltip(), _dec6$D = tooltip(), _dec$1a(_class$1b = _dec2$T(_class$1b = _dec3$P(_class$1b = executeInEditMode(_class$1b = (_class2$13 = (_temp$15 = function (_Collider) {
        _inheritsLoose(MeshCollider, _Collider);

        function MeshCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.MESH) || this;

          _initializerDefineProperty(_this, "_mesh", _descriptor$$, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_convex", _descriptor2$S, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(MeshCollider, [{
          key: "mesh",
          get: function get() {
            return this._mesh;
          },
          set: function set(value) {
            if (this._mesh === value) return;
            this._mesh = value;
            if (this._shape) this.shape.setMesh(this._mesh);
          }
        }, {
          key: "convex",
          get: function get() {
            return this._convex;
          },
          set: function set(value) {
            if (this._convex === value) return;
            this._convex = value;
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }]);

        return MeshCollider;
      }(Collider), _temp$15), (_applyDecoratedDescriptor(_class2$13.prototype, "mesh", [_dec4$L, _dec5$H], Object.getOwnPropertyDescriptor(_class2$13.prototype, "mesh"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "convex", [editable, _dec6$D], Object.getOwnPropertyDescriptor(_class2$13.prototype, "convex"), _class2$13.prototype), _descriptor$$ = _applyDecoratedDescriptor(_class2$13.prototype, "_mesh", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$S = _applyDecoratedDescriptor(_class2$13.prototype, "_convex", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2$13)) || _class$1b) || _class$1b) || _class$1b) || _class$1b));

      var _dec$1b, _dec2$U, _dec3$Q, _dec4$M, _dec5$I, _dec6$E, _dec7$B, _dec8$w, _dec9$s, _dec10$q, _dec11$o, _dec12$n, _class$1c, _class2$14, _descriptor$10, _descriptor2$T, _descriptor3$J, _descriptor4$A, _temp$16;
      var ConstantForce = exports('ConstantForce', (_dec$1b = ccclass('cc.ConstantForce'), _dec2$U = help(), _dec3$Q = requireComponent(RigidBody), _dec4$M = menu(), _dec5$I = displayOrder(), _dec6$E = tooltip(), _dec7$B = displayOrder(), _dec8$w = tooltip(), _dec9$s = displayOrder(), _dec10$q = tooltip(), _dec11$o = displayOrder(), _dec12$n = tooltip(), _dec$1b(_class$1c = _dec2$U(_class$1c = _dec3$Q(_class$1c = _dec4$M(_class$1c = disallowMultiple(_class$1c = executeInEditMode(_class$1c = (_class2$14 = (_temp$16 = function (_Component) {
        _inheritsLoose(ConstantForce, _Component);

        function ConstantForce() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._rigidBody = null;

          _initializerDefineProperty(_this, "_force", _descriptor$10, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_localForce", _descriptor2$T, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_torque", _descriptor3$J, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_localTorque", _descriptor4$A, _assertThisInitialized(_this));

          _this._mask = 0;
          return _this;
        }

        var _proto = ConstantForce.prototype;

        _proto.onLoad = function onLoad() {
          this._rigidBody = this.node.getComponent(RigidBody);

          this._maskUpdate(this._force, 1);

          this._maskUpdate(this._localForce, 2);

          this._maskUpdate(this._torque, 4);

          this._maskUpdate(this._localTorque, 8);
        };

        _proto.lateUpdate = function lateUpdate(dt) {
          {
            if (this._rigidBody != null && this._mask !== 0) {
              if (this._mask & 1) this._rigidBody.applyForce(this._force);
              if (this._mask & 2) this._rigidBody.applyLocalForce(this.localForce);
              if (this._mask & 4) this._rigidBody.applyTorque(this._torque);
              if (this._mask & 8) this._rigidBody.applyLocalTorque(this._localTorque);
            }
          }
        };

        _proto._maskUpdate = function _maskUpdate(t, m) {
          if (t.strictEquals(Vec3.ZERO)) {
            this._mask &= ~m;
          } else {
            this._mask |= m;
          }
        };

        _createClass(ConstantForce, [{
          key: "force",
          get: function get() {
            return this._force;
          },
          set: function set(value) {
            Vec3.copy(this._force, value);

            this._maskUpdate(this._force, 1);
          }
        }, {
          key: "localForce",
          get: function get() {
            return this._localForce;
          },
          set: function set(value) {
            Vec3.copy(this._localForce, value);

            this._maskUpdate(this.localForce, 2);
          }
        }, {
          key: "torque",
          get: function get() {
            return this._torque;
          },
          set: function set(value) {
            Vec3.copy(this._torque, value);

            this._maskUpdate(this._torque, 4);
          }
        }, {
          key: "localTorque",
          get: function get() {
            return this._localTorque;
          },
          set: function set(value) {
            Vec3.copy(this._localTorque, value);

            this._maskUpdate(this._localTorque, 8);
          }
        }]);

        return ConstantForce;
      }(Component), _temp$16), (_descriptor$10 = _applyDecoratedDescriptor(_class2$14.prototype, "_force", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _descriptor2$T = _applyDecoratedDescriptor(_class2$14.prototype, "_localForce", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _descriptor3$J = _applyDecoratedDescriptor(_class2$14.prototype, "_torque", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _descriptor4$A = _applyDecoratedDescriptor(_class2$14.prototype, "_localTorque", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _applyDecoratedDescriptor(_class2$14.prototype, "force", [_dec5$I, _dec6$E], Object.getOwnPropertyDescriptor(_class2$14.prototype, "force"), _class2$14.prototype), _applyDecoratedDescriptor(_class2$14.prototype, "localForce", [_dec7$B, _dec8$w], Object.getOwnPropertyDescriptor(_class2$14.prototype, "localForce"), _class2$14.prototype), _applyDecoratedDescriptor(_class2$14.prototype, "torque", [_dec9$s, _dec10$q], Object.getOwnPropertyDescriptor(_class2$14.prototype, "torque"), _class2$14.prototype), _applyDecoratedDescriptor(_class2$14.prototype, "localTorque", [_dec11$o, _dec12$n], Object.getOwnPropertyDescriptor(_class2$14.prototype, "localTorque"), _class2$14.prototype)), _class2$14)) || _class$1c) || _class$1c) || _class$1c) || _class$1c) || _class$1c) || _class$1c));

      var _dec$1c, _class$1d, _class2$15, _descriptor$11, _descriptor2$U, _descriptor3$K, _descriptor4$B, _descriptor5$u, _descriptor6$q, _temp$17, _dec2$V, _class4$9, _temp2$9, _dec3$R, _class6$3, _class7$3, _descriptor7$k, _temp3$2;
      var TERRAIN_BLOCK_TILE_COMPLEXITY = 32;
      var TERRAIN_HEIGHT_BASE = 32768;
      var TERRAIN_HEIGHT_FACTORY = 1.0 / 512.0;
      var TERRAIN_DATA_VERSION = 0x01010001;
      var TERRAIN_DATA_VERSION2 = 0x01010002;
      var TERRAIN_DATA_VERSION3 = 0x01010003;
      var TERRAIN_DATA_VERSION4 = 0x01010004;
      var TERRAIN_DATA_VERSION5 = 0x01010005;
      var TERRAIN_DATA_VERSION6 = 0x01010006;
      var TERRAIN_DATA_VERSION_DEFAULT = 0x01010111;

      var TerrainBuffer = function () {
        function TerrainBuffer() {
          this.length = 0;
          this.buffer = new Uint8Array(2048);
          this._buffView = new DataView(this.buffer.buffer);
          this._seekPos = 0;
        }

        var _proto = TerrainBuffer.prototype;

        _proto.reserve = function reserve(size) {
          if (this.buffer.byteLength > size) {
            return;
          }

          var capacity = this.buffer.byteLength;

          while (capacity < size) {
            capacity += capacity;
          }

          var temp = new Uint8Array(capacity);

          for (var i = 0; i < this.length; ++i) {
            temp[i] = this.buffer[i];
          }

          this.buffer = temp;
          this._buffView = new DataView(this.buffer.buffer);
        };

        _proto.assign = function assign(buff) {
          this.buffer = buff;
          this.length = buff.length;
          this._seekPos = buff.byteOffset;
          this._buffView = new DataView(buff.buffer);
        };

        _proto.writeInt8 = function writeInt8(value) {
          this.reserve(this.length + 1);

          this._buffView.setInt8(this.length, value);

          this.length += 1;
        };

        _proto.writeInt16 = function writeInt16(value) {
          this.reserve(this.length + 2);

          this._buffView.setInt16(this.length, value, true);

          this.length += 2;
        };

        _proto.writeInt32 = function writeInt32(value) {
          this.reserve(this.length + 4);

          this._buffView.setInt32(this.length, value, true);

          this.length += 4;
        };

        _proto.writeIntArray = function writeIntArray(value) {
          this.reserve(this.length + 4 * value.length);

          for (var i = 0; i < value.length; ++i) {
            this._buffView.setInt32(this.length + i * 4, value[i], true);
          }

          this.length += 4 * value.length;
        };

        _proto.writeFloat = function writeFloat(value) {
          this.reserve(this.length + 4);

          this._buffView.setFloat32(this.length, value, true);

          this.length += 4;
        };

        _proto.writeFloatArray = function writeFloatArray(value) {
          this.reserve(this.length + 4 * value.length);

          for (var i = 0; i < value.length; ++i) {
            this._buffView.setFloat32(this.length + i * 4, value[i], true);
          }

          this.length += 4 * value.length;
        };

        _proto.writeString = function writeString(value) {
          this.reserve(this.length + value.length + 4);

          this._buffView.setInt32(this.length, value.length, true);

          for (var i = 0; i < value.length; ++i) {
            this._buffView.setInt8(this.length + 4 + i, value.charCodeAt(i));
          }

          this.length += value.length + 4;
        };

        _proto.readInt8 = function readInt8() {
          var value = this._buffView.getInt8(this._seekPos);

          this._seekPos += 1;
          return value;
        };

        _proto.readInt16 = function readInt16() {
          var value = this._buffView.getInt16(this._seekPos, true);

          this._seekPos += 2;
          return value;
        };

        _proto.readInt = function readInt() {
          var value = this._buffView.getInt32(this._seekPos, true);

          this._seekPos += 4;
          return value;
        };

        _proto.readIntArray = function readIntArray(value) {
          for (var i = 0; i < value.length; ++i) {
            value[i] = this._buffView.getInt32(this._seekPos + i * 4, true);
          }

          this._seekPos += 4 * value.length;
          return value;
        };

        _proto.readFloat = function readFloat() {
          var value = this._buffView.getFloat32(this._seekPos, true);

          this._seekPos += 4;
          return value;
        };

        _proto.readFloatArray = function readFloatArray(value) {
          for (var i = 0; i < value.length; ++i) {
            value[i] = this._buffView.getFloat32(this._seekPos + i * 4, true);
          }

          this._seekPos += 4 * value.length;
          return value;
        };

        _proto.readString = function readString() {
          var length = this.readInt();
          var value = '';

          for (var i = 0; i < length; ++i) {
            value += String.fromCharCode(this.readInt8());
          }

          return value;
        };

        return TerrainBuffer;
      }();

      var TerrainLayerInfo = (_dec$1c = ccclass('cc.TerrainLayerInfo'), _dec$1c(_class$1d = (_class2$15 = (_temp$17 = function TerrainLayerInfo() {
        _initializerDefineProperty(this, "slot", _descriptor$11, this);

        _initializerDefineProperty(this, "tileSize", _descriptor2$U, this);

        _initializerDefineProperty(this, "detailMap", _descriptor3$K, this);

        _initializerDefineProperty(this, "normalMap", _descriptor4$B, this);

        _initializerDefineProperty(this, "roughness", _descriptor5$u, this);

        _initializerDefineProperty(this, "metallic", _descriptor6$q, this);
      }, _temp$17), (_descriptor$11 = _applyDecoratedDescriptor(_class2$15.prototype, "slot", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$U = _applyDecoratedDescriptor(_class2$15.prototype, "tileSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor3$K = _applyDecoratedDescriptor(_class2$15.prototype, "detailMap", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4$B = _applyDecoratedDescriptor(_class2$15.prototype, "normalMap", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5$u = _applyDecoratedDescriptor(_class2$15.prototype, "roughness", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor6$q = _applyDecoratedDescriptor(_class2$15.prototype, "metallic", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$15)) || _class$1d);
      var TerrainLayerBinaryInfo = (_dec2$V = ccclass('cc.TerrainLayerBinaryInfo'), _dec2$V(_class4$9 = (_temp2$9 = function TerrainLayerBinaryInfo() {
        this.slot = 0;
        this.tileSize = 1;
        this.roughness = 1;
        this.metallic = 0;
        this.detailMapId = '';
        this.normalMapId = '';
      }, _temp2$9)) || _class4$9);
      var TerrainAsset = (_dec3$R = ccclass('cc.TerrainAsset'), _dec3$R(_class6$3 = (_class7$3 = (_temp3$2 = function (_Asset) {
        _inheritsLoose(TerrainAsset, _Asset);

        function TerrainAsset() {
          var _this;

          _this = _Asset.call(this) || this;
          _this._version = 0;
          _this._data = null;
          _this._tileSize = 1;
          _this._blockCount = [1, 1];
          _this._weightMapSize = 128;
          _this._lightMapSize = 128;
          _this._heights = new Uint16Array();
          _this._normals = new Float32Array();
          _this._weights = new Uint8Array();
          _this._layerBuffer = [-1, -1, -1, -1];
          _this._layerBinaryInfos = [];

          _initializerDefineProperty(_this, "_layerInfos", _descriptor7$k, _assertThisInitialized(_this));

          return _this;
        }

        var _proto2 = TerrainAsset.prototype;

        _proto2.getLayer = function getLayer(xBlock, yBlock, layerId) {
          var blockId = yBlock * this.blockCount[0] + xBlock;
          var index = blockId * 4 + layerId;

          if (xBlock < this.blockCount[0] && yBlock < this.blockCount[1] && index < this._layerBuffer.length) {
            return this._layerBuffer[index];
          }

          return -1;
        };

        _proto2.getHeight = function getHeight(i, j) {
          var vertexCountX = this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
          return (this._heights[j * vertexCountX + i] - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY;
        };

        _proto2.getVertexCountI = function getVertexCountI() {
          if (this._blockCount.length < 1) return 0;
          return this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
        };

        _proto2.getVertexCountJ = function getVertexCountJ() {
          if (this._blockCount.length < 2) return 0;
          return this._blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
        };

        _proto2._setNativeData = function _setNativeData(_nativeData) {
          this._data = _nativeData;
        };

        _proto2._loadNativeData = function _loadNativeData(_nativeData) {
          if (!_nativeData || _nativeData.length === 0) {
            return false;
          }

          var stream = new TerrainBuffer();
          stream.assign(_nativeData);
          this._version = stream.readInt();

          if (this._version === TERRAIN_DATA_VERSION_DEFAULT) {
            return true;
          }

          if (this._version !== TERRAIN_DATA_VERSION && this._version !== TERRAIN_DATA_VERSION2 && this._version !== TERRAIN_DATA_VERSION3 && this._version !== TERRAIN_DATA_VERSION4 && this._version !== TERRAIN_DATA_VERSION5 && this._version !== TERRAIN_DATA_VERSION6) {
            return false;
          }

          this.tileSize = stream.readFloat();
          stream.readIntArray(this._blockCount);
          this.weightMapSize = stream.readInt16();
          this.lightMapSize = stream.readInt16();
          var heightBufferSize = stream.readInt();
          this.heights = new Uint16Array(heightBufferSize);

          for (var i = 0; i < this.heights.length; ++i) {
            this.heights[i] = stream.readInt16();
          }

          if (this._version >= TERRAIN_DATA_VERSION6) {
            var normalBufferSize = stream.readInt();
            this.normals = new Float32Array(normalBufferSize);

            for (var _i = 0; _i < this.normals.length; ++_i) {
              this.normals[_i] = stream.readFloat();
            }
          }

          var WeightBufferSize = stream.readInt();
          this.weights = new Uint8Array(WeightBufferSize);

          for (var _i2 = 0; _i2 < this.weights.length; ++_i2) {
            this.weights[_i2] = stream.readInt8();
          }

          if (this._version >= TERRAIN_DATA_VERSION2) {
            var layerBufferSize = stream.readInt();
            this.layerBuffer = new Array(layerBufferSize);

            for (var _i3 = 0; _i3 < this.layerBuffer.length; ++_i3) {
              this.layerBuffer[_i3] = stream.readInt16();
            }
          }

          if (this._version >= TERRAIN_DATA_VERSION3) {
            var layerInfoSize = stream.readInt();
            this._layerBinaryInfos = new Array(layerInfoSize);

            for (var _i4 = 0; _i4 < this._layerBinaryInfos.length; ++_i4) {
              this._layerBinaryInfos[_i4] = new TerrainLayerBinaryInfo();
              this._layerBinaryInfos[_i4].slot = stream.readInt();
              this._layerBinaryInfos[_i4].tileSize = stream.readFloat();
              this._layerBinaryInfos[_i4].detailMapId = stream.readString();

              if (this._version >= TERRAIN_DATA_VERSION4) {
                this._layerBinaryInfos[_i4].normalMapId = stream.readString();
                this._layerBinaryInfos[_i4].roughness = stream.readFloat();
                this._layerBinaryInfos[_i4].metallic = stream.readFloat();
              }
            }
          }

          return true;
        };

        _proto2._exportNativeData = function _exportNativeData() {
          var stream = new TerrainBuffer();
          stream.writeInt32(TERRAIN_DATA_VERSION6);
          stream.writeFloat(this.tileSize);
          stream.writeIntArray(this._blockCount);
          stream.writeInt16(this.weightMapSize);
          stream.writeInt16(this.lightMapSize);
          stream.writeInt32(this.heights.length);

          for (var i = 0; i < this.heights.length; ++i) {
            stream.writeInt16(this.heights[i]);
          }

          stream.writeInt32(this.normals.length);

          for (var _i5 = 0; _i5 < this.normals.length; ++_i5) {
            stream.writeFloat(this.normals[_i5]);
          }

          stream.writeInt32(this.weights.length);

          for (var _i6 = 0; _i6 < this.weights.length; ++_i6) {
            stream.writeInt8(this.weights[_i6]);
          }

          stream.writeInt32(this.layerBuffer.length);

          for (var _i7 = 0; _i7 < this.layerBuffer.length; ++_i7) {
            stream.writeInt16(this.layerBuffer[_i7]);
          }

          var layerBinaryInfos = [];
          layerBinaryInfos.length = this.layerInfos.length;

          for (var _i8 = 0; _i8 < layerBinaryInfos.length; ++_i8) {
            var layer = this.layerInfos[_i8];
            var binaryLayer = new TerrainLayerBinaryInfo();
            binaryLayer.slot = _i8;
            binaryLayer.tileSize = layer.tileSize;
            binaryLayer.detailMapId = layer.detailMap ? layer.detailMap._uuid : '';
            binaryLayer.normalMapId = layer.normalMap ? layer.normalMap._uuid : '';
            binaryLayer.metallic = layer.metallic;
            binaryLayer.roughness = layer.roughness;
            layerBinaryInfos[_i8] = binaryLayer;
          }

          stream.writeInt32(layerBinaryInfos.length);

          for (var _i9 = 0; _i9 < layerBinaryInfos.length; ++_i9) {
            stream.writeInt32(layerBinaryInfos[_i9].slot);
            stream.writeFloat(layerBinaryInfos[_i9].tileSize);
            stream.writeString(layerBinaryInfos[_i9].detailMapId);
            stream.writeString(layerBinaryInfos[_i9].normalMapId);
            stream.writeFloat(layerBinaryInfos[_i9].roughness);
            stream.writeFloat(layerBinaryInfos[_i9].metallic);
          }

          return stream.buffer;
        };

        _proto2._exportDefaultNativeData = function _exportDefaultNativeData() {
          var stream = new TerrainBuffer();
          stream.writeInt32(TERRAIN_DATA_VERSION_DEFAULT);
          return stream.buffer;
        };

        _createClass(TerrainAsset, [{
          key: "_nativeAsset",
          get: function get() {
            return this._data.buffer;
          },
          set: function set(value) {
            if (this._data && this._data.byteLength === value.byteLength) {
              this._data.set(new Uint8Array(value));
            } else {
              this._data = new Uint8Array(value);
            }

            this._loadNativeData(this._data);
          }
        }, {
          key: "version",
          get: function get() {
            return this._version;
          }
        }, {
          key: "tileSize",
          get: function get() {
            return this._tileSize;
          },
          set: function set(value) {
            this._tileSize = value;
          }
        }, {
          key: "blockCount",
          get: function get() {
            return this._blockCount;
          },
          set: function set(value) {
            this._blockCount = value;
          }
        }, {
          key: "lightMapSize",
          get: function get() {
            return this._lightMapSize;
          },
          set: function set(value) {
            this._lightMapSize = value;
          }
        }, {
          key: "weightMapSize",
          get: function get() {
            return this._weightMapSize;
          },
          set: function set(value) {
            this._weightMapSize = value;
          }
        }, {
          key: "heights",
          get: function get() {
            return this._heights;
          },
          set: function set(value) {
            this._heights = value;
          }
        }, {
          key: "normals",
          get: function get() {
            return this._normals;
          },
          set: function set(value) {
            this._normals = value;
          }
        }, {
          key: "weights",
          get: function get() {
            return this._weights;
          },
          set: function set(value) {
            this._weights = value;
          }
        }, {
          key: "layerBuffer",
          get: function get() {
            return this._layerBuffer;
          },
          set: function set(value) {
            this._layerBuffer = value;
          }
        }, {
          key: "layerInfos",
          get: function get() {
            return this._layerInfos;
          },
          set: function set(value) {
            this._layerInfos = value;
          }
        }, {
          key: "layerBinaryInfos",
          get: function get() {
            return this._layerBinaryInfos;
          }
        }]);

        return TerrainAsset;
      }(Asset), _temp3$2), (_descriptor7$k = _applyDecoratedDescriptor(_class7$3.prototype, "_layerInfos", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class7$3)) || _class6$3);

      var _dec$1d, _dec2$W, _dec3$S, _dec4$N, _dec5$J, _class$1e, _class2$16, _descriptor$12, _temp$18;
      var TerrainCollider = exports('TerrainCollider', (_dec$1d = ccclass('cc.TerrainCollider'), _dec2$W = help(), _dec3$S = menu(), _dec4$N = type(TerrainAsset), _dec5$J = tooltip(), _dec$1d(_class$1e = _dec2$W(_class$1e = _dec3$S(_class$1e = executeInEditMode(_class$1e = (_class2$16 = (_temp$18 = function (_Collider) {
        _inheritsLoose(TerrainCollider, _Collider);

        function TerrainCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.TERRAIN) || this;

          _initializerDefineProperty(_this, "_terrain", _descriptor$12, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(TerrainCollider, [{
          key: "terrain",
          get: function get() {
            return this._terrain;
          },
          set: function set(value) {
            this._terrain = value;
            if (this._shape) this.shape.setTerrain(this._terrain);
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }]);

        return TerrainCollider;
      }(Collider), _temp$18), (_applyDecoratedDescriptor(_class2$16.prototype, "terrain", [_dec4$N, _dec5$J], Object.getOwnPropertyDescriptor(_class2$16.prototype, "terrain"), _class2$16.prototype), _descriptor$12 = _applyDecoratedDescriptor(_class2$16.prototype, "_terrain", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$16)) || _class$1e) || _class$1e) || _class$1e) || _class$1e));

      var _dec$1e, _dec2$X, _dec3$T, _dec4$O, _dec5$K, _dec6$F, _dec7$C, _dec8$x, _dec9$t, _dec10$r, _dec11$p, _dec12$o, _class$1f, _class2$17, _descriptor$13, _descriptor2$V, _class3$f, _temp$19;
      var SimplexCollider = exports('SimplexCollider', (_dec$1e = ccclass('cc.SimplexCollider'), _dec2$X = help(), _dec3$T = menu(), _dec4$O = type(ESimplexType), _dec5$K = tooltip(), _dec6$F = tooltip(), _dec7$C = visible(), _dec8$x = tooltip(), _dec9$t = visible(), _dec10$r = tooltip(), _dec11$p = visible(), _dec12$o = tooltip(), _dec$1e(_class$1f = _dec2$X(_class$1f = _dec3$T(_class$1f = executeInEditMode(_class$1f = (_class2$17 = (_temp$19 = _class3$f = function (_Collider) {
        _inheritsLoose(SimplexCollider, _Collider);

        function SimplexCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.SIMPLEX) || this;

          _initializerDefineProperty(_this, "_shapeType", _descriptor$13, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_vertices", _descriptor2$V, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = SimplexCollider.prototype;

        _proto.updateVertices = function updateVertices() {
          if (this._shape) {
            this.shape.setVertices(this._vertices);
          }
        };

        _createClass(SimplexCollider, [{
          key: "shapeType",
          get: function get() {
            return this._shapeType;
          },
          set: function set(v) {
            this._shapeType = v;

            if (this._shape) {
              this.shape.setShapeType(v);
            }
          }
        }, {
          key: "vertex0",
          get: function get() {
            return this._vertices[0];
          },
          set: function set(v) {
            Vec3.copy(this._vertices[0], v);
            this.updateVertices();
          }
        }, {
          key: "vertex1",
          get: function get() {
            return this._vertices[1];
          },
          set: function set(v) {
            Vec3.copy(this._vertices[1], v);
            this.updateVertices();
          }
        }, {
          key: "vertex2",
          get: function get() {
            return this._vertices[2];
          },
          set: function set(v) {
            Vec3.copy(this._vertices[2], v);
            this.updateVertices();
          }
        }, {
          key: "vertex3",
          get: function get() {
            return this._vertices[3];
          },
          set: function set(v) {
            Vec3.copy(this._vertices[3], v);
            this.updateVertices();
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }, {
          key: "vertices",
          get: function get() {
            return this._vertices;
          }
        }]);

        return SimplexCollider;
      }(Collider), _class3$f.ESimplexType = ESimplexType, _temp$19), (_applyDecoratedDescriptor(_class2$17.prototype, "shapeType", [_dec4$O, _dec5$K], Object.getOwnPropertyDescriptor(_class2$17.prototype, "shapeType"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "vertex0", [editable, _dec6$F], Object.getOwnPropertyDescriptor(_class2$17.prototype, "vertex0"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "vertex1", [_dec7$C, _dec8$x], Object.getOwnPropertyDescriptor(_class2$17.prototype, "vertex1"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "vertex2", [_dec9$t, _dec10$r], Object.getOwnPropertyDescriptor(_class2$17.prototype, "vertex2"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "vertex3", [_dec11$p, _dec12$o], Object.getOwnPropertyDescriptor(_class2$17.prototype, "vertex3"), _class2$17.prototype), _descriptor$13 = _applyDecoratedDescriptor(_class2$17.prototype, "_shapeType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ESimplexType.TETRAHEDRON;
        }
      }), _descriptor2$V = _applyDecoratedDescriptor(_class2$17.prototype, "_vertices", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [new Vec3(0, 0, 0), new Vec3(0, 0, 1), new Vec3(1, 0, 0), new Vec3(0, 1, 0)];
        }
      })), _class2$17)) || _class$1f) || _class$1f) || _class$1f) || _class$1f));

      (function (_SimplexCollider) {})(SimplexCollider || (SimplexCollider = exports('SimplexCollider', {})));

      var _dec$1f, _dec2$Y, _dec3$U, _dec4$P, _dec5$L, _dec6$G, _class$1g, _class2$18, _descriptor$14, _descriptor2$W, _temp$1a;
      var PlaneCollider = exports('PlaneCollider', (_dec$1f = ccclass('cc.PlaneCollider'), _dec2$Y = help(), _dec3$U = menu(), _dec4$P = type(Vec3), _dec5$L = tooltip(), _dec6$G = tooltip(), _dec$1f(_class$1g = _dec2$Y(_class$1g = _dec3$U(_class$1g = executeInEditMode(_class$1g = (_class2$18 = (_temp$1a = function (_Collider) {
        _inheritsLoose(PlaneCollider, _Collider);

        function PlaneCollider() {
          var _this;

          _this = _Collider.call(this, EColliderType.PLANE) || this;

          _initializerDefineProperty(_this, "_normal", _descriptor$14, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_constant", _descriptor2$W, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(PlaneCollider, [{
          key: "normal",
          get: function get() {
            return this._normal;
          },
          set: function set(value) {
            if (Vec3.strictEquals(this._normal, value)) return;
            Vec3.copy(this._normal, value);

            if (this._shape) {
              this.shape.setNormal(this._normal);
            }
          }
        }, {
          key: "constant",
          get: function get() {
            return this._constant;
          },
          set: function set(v) {
            if (this._constant === v) return;
            this._constant = v;

            if (this._shape) {
              this.shape.setConstant(this._constant);
            }
          }
        }, {
          key: "shape",
          get: function get() {
            return this._shape;
          }
        }]);

        return PlaneCollider;
      }(Collider), _temp$1a), (_applyDecoratedDescriptor(_class2$18.prototype, "normal", [_dec4$P, _dec5$L], Object.getOwnPropertyDescriptor(_class2$18.prototype, "normal"), _class2$18.prototype), _applyDecoratedDescriptor(_class2$18.prototype, "constant", [editable, _dec6$G], Object.getOwnPropertyDescriptor(_class2$18.prototype, "constant"), _class2$18.prototype), _descriptor$14 = _applyDecoratedDescriptor(_class2$18.prototype, "_normal", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(0, 1, 0);
        }
      }), _descriptor2$W = _applyDecoratedDescriptor(_class2$18.prototype, "_constant", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$18)) || _class$1g) || _class$1g) || _class$1g) || _class$1g));

      var _dec$1g, _dec2$Z, _dec3$V, _dec4$Q, _dec5$M, _dec6$H, _dec7$D, _dec8$y, _class$1h, _class2$19, _descriptor$15, _descriptor2$X, _class3$g, _temp$1b;
      var Constraint = exports('Constraint', (_dec$1g = ccclass('cc.Constraint'), _dec2$Z = requireComponent(RigidBody), _dec3$V = type(RigidBody), _dec4$Q = displayOrder(), _dec5$M = type(RigidBody), _dec6$H = displayOrder(), _dec7$D = displayOrder(), _dec8$y = type(RigidBody), _dec$1g(_class$1h = _dec2$Z(_class$1h = (_class2$19 = (_temp$1b = _class3$g = function (_Eventify) {
        _inheritsLoose(Constraint, _Eventify);

        function Constraint(type) {
          var _this;

          _this = _Eventify.call(this) || this;
          _this.TYPE = void 0;

          _initializerDefineProperty(_this, "_enableCollision", _descriptor$15, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_connectedBody", _descriptor2$X, _assertThisInitialized(_this));

          _this._constraint = null;
          _this.TYPE = type;
          return _this;
        }

        var _proto = Constraint.prototype;

        _proto.onLoad = function onLoad() {
          if (!selector.runInEditor) return;
          this._constraint = createConstraint(this.TYPE);

          this._constraint.initialize(this);
        };

        _proto.onEnable = function onEnable() {
          if (this._constraint) {
            this._constraint.onEnable();
          }
        };

        _proto.onDisable = function onDisable() {
          if (this._constraint) {
            this._constraint.onDisable();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this._constraint) {
            this._constraint.onDestroy();
          }
        };

        _createClass(Constraint, [{
          key: "attachedBody",
          get: function get() {
            return this.getComponent(RigidBody);
          }
        }, {
          key: "connectedBody",
          get: function get() {
            return this._connectedBody;
          },
          set: function set(v) {
            this._connectedBody = v;

            {
              if (this._constraint) this._constraint.setConnectedBody(v);
            }
          }
        }, {
          key: "enableCollision",
          get: function get() {
            return this._enableCollision;
          },
          set: function set(v) {
            this._enableCollision = v;

            {
              if (this._constraint) this._constraint.setEnableCollision(v);
            }
          }
        }]);

        return Constraint;
      }(Eventify(Component)), _class3$g.Type = EConstraintType, _temp$1b), (_applyDecoratedDescriptor(_class2$19.prototype, "attachedBody", [_dec3$V, readOnly, _dec4$Q], Object.getOwnPropertyDescriptor(_class2$19.prototype, "attachedBody"), _class2$19.prototype), _applyDecoratedDescriptor(_class2$19.prototype, "connectedBody", [_dec5$M, _dec6$H], Object.getOwnPropertyDescriptor(_class2$19.prototype, "connectedBody"), _class2$19.prototype), _applyDecoratedDescriptor(_class2$19.prototype, "enableCollision", [_dec7$D], Object.getOwnPropertyDescriptor(_class2$19.prototype, "enableCollision"), _class2$19.prototype), _descriptor$15 = _applyDecoratedDescriptor(_class2$19.prototype, "_enableCollision", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor2$X = _applyDecoratedDescriptor(_class2$19.prototype, "_connectedBody", [_dec8$y], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$19)) || _class$1h) || _class$1h));

      (function (_Constraint) {})(Constraint || (Constraint = exports('Constraint', {})));

      var _dec$1h, _dec2$_, _dec3$W, _dec4$R, _dec5$N, _dec6$I, _dec7$E, _dec8$z, _dec9$u, _class$1i, _class2$1a, _descriptor$16, _descriptor2$Y, _descriptor3$L, _temp$1c;
      var HingeConstraint = exports('HingeConstraint', (_dec$1h = ccclass('cc.HingeConstraint'), _dec2$_ = help(), _dec3$W = menu(), _dec4$R = type(Vec3), _dec5$N = type(Vec3), _dec6$I = type(Vec3), _dec7$E = formerlySerializedAs('axisA'), _dec8$z = formerlySerializedAs('pivotA'), _dec9$u = formerlySerializedAs('pivotB'), _dec$1h(_class$1i = _dec2$_(_class$1i = _dec3$W(_class$1i = (_class2$1a = (_temp$1c = function (_Constraint) {
        _inheritsLoose(HingeConstraint, _Constraint);

        function HingeConstraint() {
          var _this;

          _this = _Constraint.call(this, EConstraintType.HINGE) || this;

          _initializerDefineProperty(_this, "_axis", _descriptor$16, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pivotA", _descriptor2$Y, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pivotB", _descriptor3$L, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(HingeConstraint, [{
          key: "pivotA",
          get: function get() {
            return this._pivotA;
          },
          set: function set(v) {
            Vec3.copy(this._pivotA, v);

            {
              this.constraint.setPivotA(this._pivotA);
            }
          }
        }, {
          key: "pivotB",
          get: function get() {
            return this._pivotB;
          },
          set: function set(v) {
            Vec3.copy(this._pivotB, v);

            {
              this.constraint.setPivotB(this._pivotB);
            }
          }
        }, {
          key: "axis",
          get: function get() {
            return this._axis;
          },
          set: function set(v) {
            Vec3.copy(this._axis, v);

            {
              this.constraint.setAxis(this._axis);
            }
          }
        }, {
          key: "constraint",
          get: function get() {
            return this._constraint;
          }
        }]);

        return HingeConstraint;
      }(Constraint), _temp$1c), (_applyDecoratedDescriptor(_class2$1a.prototype, "pivotA", [_dec4$R], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "pivotA"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "pivotB", [_dec5$N], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "pivotB"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "axis", [_dec6$I], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "axis"), _class2$1a.prototype), _descriptor$16 = _applyDecoratedDescriptor(_class2$1a.prototype, "_axis", [serializable, _dec7$E], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _descriptor2$Y = _applyDecoratedDescriptor(_class2$1a.prototype, "_pivotA", [serializable, _dec8$z], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _descriptor3$L = _applyDecoratedDescriptor(_class2$1a.prototype, "_pivotB", [serializable, _dec9$u], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      })), _class2$1a)) || _class$1i) || _class$1i) || _class$1i));

      var _dec$1i, _dec2$$, _dec3$X, _dec4$S, _dec5$O, _class$1j, _class2$1b, _descriptor$17, _descriptor2$Z, _temp$1d;
      var PointToPointConstraint = exports('PointToPointConstraint', (_dec$1i = ccclass('cc.PointToPointConstraint'), _dec2$$ = help(), _dec3$X = menu(), _dec4$S = type(Vec3), _dec5$O = type(Vec3), _dec$1i(_class$1j = _dec2$$(_class$1j = _dec3$X(_class$1j = (_class2$1b = (_temp$1d = function (_Constraint) {
        _inheritsLoose(PointToPointConstraint, _Constraint);

        function PointToPointConstraint() {
          var _this;

          _this = _Constraint.call(this, EConstraintType.POINT_TO_POINT) || this;

          _initializerDefineProperty(_this, "_pivotA", _descriptor$17, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pivotB", _descriptor2$Z, _assertThisInitialized(_this));

          return _this;
        }

        _createClass(PointToPointConstraint, [{
          key: "pivotA",
          get: function get() {
            return this._pivotA;
          },
          set: function set(v) {
            Vec3.copy(this._pivotA, v);

            {
              this.constraint.setPivotA(this._pivotA);
            }
          }
        }, {
          key: "pivotB",
          get: function get() {
            return this._pivotB;
          },
          set: function set(v) {
            Vec3.copy(this._pivotB, v);

            {
              this.constraint.setPivotB(this._pivotB);
            }
          }
        }, {
          key: "constraint",
          get: function get() {
            return this._constraint;
          }
        }]);

        return PointToPointConstraint;
      }(Constraint), _temp$1d), (_applyDecoratedDescriptor(_class2$1b.prototype, "pivotA", [_dec4$S], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "pivotA"), _class2$1b.prototype), _applyDecoratedDescriptor(_class2$1b.prototype, "pivotB", [_dec5$O], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "pivotB"), _class2$1b.prototype), _descriptor$17 = _applyDecoratedDescriptor(_class2$1b.prototype, "_pivotA", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _descriptor2$Z = _applyDecoratedDescriptor(_class2$1b.prototype, "_pivotB", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      })), _class2$1b)) || _class$1j) || _class$1j) || _class$1j));

      legacyCC.PhysicsSystem = PhysicsSystem;
      legacyCC.PhysicsMaterial = PhysicsMaterial;
      legacyCC.PhysicsRayResult = PhysicsRayResult;
      legacyCC.ConstantForce = ConstantForce;

      var physics = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PhysicsSystem: PhysicsSystem,
        PhysicsRayResult: PhysicsRayResult,
        get Collider () { return Collider; },
        BoxCollider: BoxCollider,
        SphereCollider: SphereCollider,
        CapsuleCollider: CapsuleCollider,
        MeshCollider: MeshCollider,
        CylinderCollider: CylinderCollider,
        ConeCollider: ConeCollider,
        TerrainCollider: TerrainCollider,
        get SimplexCollider () { return SimplexCollider; },
        PlaneCollider: PlaneCollider,
        get Constraint () { return Constraint; },
        HingeConstraint: HingeConstraint,
        PointToPointConstraint: PointToPointConstraint,
        get RigidBody () { return RigidBody; },
        PhysicsMaterial: PhysicsMaterial,
        ConstantForce: ConstantForce,
        selector: selector,
        utils: util,
        get ERigidBodyType () { return ERigidBodyType; },
        get EAxisDirection () { return EAxisDirection; },
        get ESimplexType () { return ESimplexType; },
        get EColliderType () { return EColliderType; },
        get EConstraintType () { return EConstraintType; },
        get PhysicsGroup () { return PhysicsGroup; }
      });
      exports('physics', physics);

      replaceProperty(PhysicsSystem, 'PhysicsSystem', [{
        name: 'ins',
        newName: 'instance'
      }, {
        name: 'PHYSICS_AMMO',
        newName: 'PHYSICS_BULLET'
      }]);
      replaceProperty(PhysicsSystem.prototype, 'PhysicsSystem.prototype', [{
        name: 'deltaTime',
        newName: 'fixedTimeStep'
      }, {
        name: 'maxSubStep',
        newName: 'maxSubSteps'
      }]);
      removeProperty(PhysicsSystem.prototype, 'PhysicsSystem.prototype', [{
        name: 'useFixedTime'
      }, {
        name: 'useCollisionMatrix'
      }, {
        name: 'updateCollisionMatrix'
      }, {
        name: 'resetCollisionMatrix'
      }, {
        name: 'isCollisionGroup'
      }, {
        name: 'setCollisionGroup'
      }]);
      replaceProperty(Collider.prototype, 'Collider.prototype', [{
        name: 'attachedRigidbody',
        newName: 'attachedRigidBody'
      }, {
        name: 'TYPE',
        newName: 'type'
      }]);
      replaceProperty(Collider, 'Collider', [{
        name: 'EColliderType',
        newName: 'Type'
      }, {
        name: 'EAxisDirection',
        newName: 'Axis'
      }]);
      replaceProperty(Constraint, 'Constraint', [{
        name: 'EConstraintType',
        newName: 'Type'
      }]);
      replaceProperty(BoxCollider.prototype, 'BoxCollider.prototype', [{
        name: 'boxShape',
        newName: 'shape'
      }]);
      replaceProperty(SphereCollider.prototype, 'SphereCollider.prototype', [{
        name: 'sphereShape',
        newName: 'shape'
      }]);
      replaceProperty(CapsuleCollider.prototype, 'CapsuleCollider.prototype', [{
        name: 'capsuleShape',
        newName: 'shape'
      }]);
      replaceProperty(RigidBody.prototype, 'RigidBody.prototype', [{
        name: 'rigidBody',
        newName: 'body'
      }]);
      replaceProperty(RigidBody, 'RigidBody', [{
        name: 'ERigidBodyType',
        newName: 'Type'
      }]);
      removeProperty(RigidBody.prototype, 'RigidBody.prototype', [{
        name: 'fixedRotation'
      }]);
      legacyCC.RigidBodyComponent = RigidBody;
      js.setClassAlias(RigidBody, 'cc.RigidBodyComponent');
      legacyCC.ColliderComponent = Collider;
      js.setClassAlias(Collider, 'cc.ColliderComponent');
      legacyCC.BoxColliderComponent = BoxCollider;
      js.setClassAlias(BoxCollider, 'cc.BoxColliderComponent');
      legacyCC.SphereColliderComponent = SphereCollider;
      js.setClassAlias(SphereCollider, 'cc.SphereColliderComponent');
      js.setClassAlias(CapsuleCollider, 'cc.CapsuleColliderComponent');
      js.setClassAlias(MeshCollider, 'cc.MeshColliderComponent');
      js.setClassAlias(CylinderCollider, 'cc.CylinderColliderComponent');
      legacyCC.PhysicMaterial = PhysicsMaterial;
      js.setClassAlias(PhysicsMaterial, 'cc.PhysicMaterial');

      legacyCC.physics = physics;

      var EBtSharedBodyDirty;

      (function (EBtSharedBodyDirty) {
        EBtSharedBodyDirty[EBtSharedBodyDirty["BODY_RE_ADD"] = 1] = "BODY_RE_ADD";
        EBtSharedBodyDirty[EBtSharedBodyDirty["GHOST_RE_ADD"] = 2] = "GHOST_RE_ADD";
      })(EBtSharedBodyDirty || (EBtSharedBodyDirty = {}));

      var btCollisionFlags;

      (function (btCollisionFlags) {
        btCollisionFlags[btCollisionFlags["CF_STATIC_OBJECT"] = 1] = "CF_STATIC_OBJECT";
        btCollisionFlags[btCollisionFlags["CF_KINEMATIC_OBJECT"] = 2] = "CF_KINEMATIC_OBJECT";
        btCollisionFlags[btCollisionFlags["CF_NO_CONTACT_RESPONSE"] = 4] = "CF_NO_CONTACT_RESPONSE";
        btCollisionFlags[btCollisionFlags["CF_CUSTOM_MATERIAL_CALLBACK"] = 8] = "CF_CUSTOM_MATERIAL_CALLBACK";
        btCollisionFlags[btCollisionFlags["CF_CHARACTER_OBJECT"] = 16] = "CF_CHARACTER_OBJECT";
        btCollisionFlags[btCollisionFlags["CF_DISABLE_VISUALIZE_OBJECT"] = 32] = "CF_DISABLE_VISUALIZE_OBJECT";
        btCollisionFlags[btCollisionFlags["CF_DISABLE_SPU_COLLISION_PROCESSING"] = 64] = "CF_DISABLE_SPU_COLLISION_PROCESSING";
      })(btCollisionFlags || (btCollisionFlags = {}));

      var btCollisionObjectTypes;

      (function (btCollisionObjectTypes) {
        btCollisionObjectTypes[btCollisionObjectTypes["CO_COLLISION_OBJECT"] = 1] = "CO_COLLISION_OBJECT";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_RIGID_BODY"] = 2] = "CO_RIGID_BODY";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_GHOST_OBJECT"] = 4] = "CO_GHOST_OBJECT";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_SOFT_BODY"] = 8] = "CO_SOFT_BODY";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_HF_FLUID"] = 16] = "CO_HF_FLUID";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_USER_TYPE"] = 32] = "CO_USER_TYPE";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_FEATHERSTONE_LINK"] = 64] = "CO_FEATHERSTONE_LINK";
      })(btCollisionObjectTypes || (btCollisionObjectTypes = {}));

      var btCollisionObjectStates;

      (function (btCollisionObjectStates) {
        btCollisionObjectStates[btCollisionObjectStates["ACTIVE_TAG"] = 1] = "ACTIVE_TAG";
        btCollisionObjectStates[btCollisionObjectStates["ISLAND_SLEEPING"] = 2] = "ISLAND_SLEEPING";
        btCollisionObjectStates[btCollisionObjectStates["WANTS_DEACTIVATION"] = 3] = "WANTS_DEACTIVATION";
        btCollisionObjectStates[btCollisionObjectStates["DISABLE_DEACTIVATION"] = 4] = "DISABLE_DEACTIVATION";
        btCollisionObjectStates[btCollisionObjectStates["DISABLE_SIMULATION"] = 5] = "DISABLE_SIMULATION";
      })(btCollisionObjectStates || (btCollisionObjectStates = {}));

      var btRigidBodyFlags;

      (function (btRigidBodyFlags) {
        btRigidBodyFlags[btRigidBodyFlags["BT_DISABLE_WORLD_GRAVITY"] = 1] = "BT_DISABLE_WORLD_GRAVITY";
        btRigidBodyFlags[btRigidBodyFlags["BT_ENABLE_GYROPSCOPIC_FORCE"] = 2] = "BT_ENABLE_GYROPSCOPIC_FORCE";
      })(btRigidBodyFlags || (btRigidBodyFlags = {}));

      var v3_0 = CC_V3_0;
      var v3_1$5 = CC_V3_1;
      var BulletRigidBody = function () {
        var _proto = BulletRigidBody.prototype;

        _proto.setMass = function setMass(value) {
          if (!this._rigidBody.isDynamic) return;
          bt.RigidBody_setMass(this.impl, value);

          this._wakeUpIfSleep();

          this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
        };

        _proto.setType = function setType(v) {
          this._sharedBody.setType(v);
        };

        _proto.setLinearDamping = function setLinearDamping(value) {
          bt.RigidBody_setDamping(this.impl, this._rigidBody.linearDamping, this._rigidBody.angularDamping);
        };

        _proto.setAngularDamping = function setAngularDamping(value) {
          bt.RigidBody_setDamping(this.impl, this._rigidBody.linearDamping, this._rigidBody.angularDamping);
        };

        _proto.useGravity = function useGravity(value) {
          if (!this._rigidBody.isDynamic) return;
          var m_rigidBodyFlag = bt.RigidBody_getFlags(this.impl);

          if (value) {
            m_rigidBodyFlag &= ~btRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
          } else {
            bt.RigidBody_setGravity(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, Vec3.ZERO));
            m_rigidBodyFlag |= btRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
          }

          bt.RigidBody_setFlags(this.impl, m_rigidBodyFlag);

          this._wakeUpIfSleep();

          this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
        };

        _proto.useCCD = function useCCD(value) {
          bt.CollisionObject_setCcdMotionThreshold(this.impl, value ? 0.01 : 0);
          bt.CollisionObject_setCcdSweptSphereRadius(this.impl, value ? 0.1 : 0);
          this._isUsingCCD = value;
        };

        _proto.isUsingCCD = function isUsingCCD() {
          return this._isUsingCCD;
        };

        _proto.setLinearFactor = function setLinearFactor(v) {
          bt.RigidBody_setLinearFactor(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v));

          this._wakeUpIfSleep();
        };

        _proto.setAngularFactor = function setAngularFactor(v) {
          bt.RigidBody_setAngularFactor(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v));

          this._wakeUpIfSleep();
        };

        _proto.setAllowSleep = function setAllowSleep(v) {
          if (!this._rigidBody.isDynamic) return;

          if (v) {
            bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.ACTIVE_TAG);
          } else {
            bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.DISABLE_DEACTIVATION);
          }

          this._wakeUpIfSleep();
        };

        function BulletRigidBody() {
          this.id = void 0;
          this._isEnabled = false;
          this._isUsingCCD = false;
          this.id = BulletRigidBody.idCounter++;
        }

        _proto.clearState = function clearState() {
          bt.RigidBody_clearState(this.impl);
        };

        _proto.clearVelocity = function clearVelocity() {
          this.setLinearVelocity(Vec3.ZERO);
          this.setAngularVelocity(Vec3.ZERO);
        };

        _proto.clearForces = function clearForces() {
          bt.RigidBody_clearForces(this.impl);
        };

        _proto.initialize = function initialize(com) {
          this._rigidBody = com;
          this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._rigidBody.node, this);
          this._sharedBody.reference = true;
        };

        _proto.onEnable = function onEnable() {
          this._isEnabled = true;
          this.setMass(this._rigidBody.mass);
          this.setAllowSleep(this._rigidBody.allowSleep);
          this.setLinearDamping(this._rigidBody.linearDamping);
          this.setAngularDamping(this._rigidBody.angularDamping);
          this.setLinearFactor(this._rigidBody.linearFactor);
          this.setAngularFactor(this._rigidBody.angularFactor);
          this.useGravity(this._rigidBody.useGravity);
          this._sharedBody.bodyEnabled = true;
        };

        _proto.onDisable = function onDisable() {
          this._isEnabled = false;
          this._sharedBody.bodyEnabled = false;
        };

        _proto.onDestroy = function onDestroy() {
          this._sharedBody.reference = false;
          this._rigidBody = null;
          this._sharedBody = null;
        };

        _proto.wakeUp = function wakeUp(force) {
          if (force === void 0) {
            force = true;
          }

          bt.CollisionObject_activate(this.impl, force);
        };

        _proto.sleep = function sleep() {
          return bt.RigidBody_wantsSleeping(this.impl);
        };

        _proto.setSleepThreshold = function setSleepThreshold(v) {
          this._wakeUpIfSleep();

          bt.RigidBody_setSleepingThresholds(this.impl, v, v);
        };

        _proto.getSleepThreshold = function getSleepThreshold() {
          return bt.RigidBody_getLinearSleepingThreshold(this.impl);
        };

        _proto.getLinearVelocity = function getLinearVelocity(out) {
          return bullet2CocosVec3(out, bt.RigidBody_getLinearVelocity(this.impl));
        };

        _proto.setLinearVelocity = function setLinearVelocity(value) {
          this._wakeUpIfSleep();

          cocos2BulletVec3(bt.RigidBody_getLinearVelocity(this.impl), value);
        };

        _proto.getAngularVelocity = function getAngularVelocity(out) {
          return bullet2CocosVec3(out, bt.RigidBody_getAngularVelocity(this.impl));
        };

        _proto.setAngularVelocity = function setAngularVelocity(value) {
          this._wakeUpIfSleep();

          cocos2BulletVec3(bt.RigidBody_getAngularVelocity(this.impl), value);
        };

        _proto.applyLocalForce = function applyLocalForce(force, rel_pos) {
          this._sharedBody.syncSceneToPhysics();

          this._wakeUpIfSleep();

          var quat = this._sharedBody.node.worldRotation;
          var v = Vec3.transformQuat(v3_0, force, quat);
          var rp = rel_pos ? Vec3.transformQuat(v3_1$5, rel_pos, quat) : Vec3.ZERO;
          bt.RigidBody_applyForce(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
        };

        _proto.applyLocalTorque = function applyLocalTorque(torque) {
          this._sharedBody.syncSceneToPhysics();

          this._wakeUpIfSleep();

          Vec3.transformQuat(v3_0, torque, this._sharedBody.node.worldRotation);
          bt.RigidBody_applyTorque(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0));
        };

        _proto.applyLocalImpulse = function applyLocalImpulse(impulse, rel_pos) {
          this._sharedBody.syncSceneToPhysics();

          this._wakeUpIfSleep();

          var quat = this._sharedBody.node.worldRotation;
          var v = Vec3.transformQuat(v3_0, impulse, quat);
          var rp = rel_pos ? Vec3.transformQuat(v3_1$5, rel_pos, quat) : Vec3.ZERO;
          bt.RigidBody_applyImpulse(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
        };

        _proto.applyForce = function applyForce(force, rel_pos) {
          this._sharedBody.syncSceneToPhysics();

          this._wakeUpIfSleep();

          var rp = rel_pos || Vec3.ZERO;
          bt.RigidBody_applyForce(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, force), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
        };

        _proto.applyTorque = function applyTorque(torque) {
          this._sharedBody.syncSceneToPhysics();

          this._wakeUpIfSleep();

          bt.RigidBody_applyTorque(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, torque));
        };

        _proto.applyImpulse = function applyImpulse(impulse, rel_pos) {
          this._sharedBody.syncSceneToPhysics();

          this._wakeUpIfSleep();

          var rp = rel_pos || Vec3.ZERO;
          bt.RigidBody_applyImpulse(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, impulse), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
        };

        _proto.getGroup = function getGroup() {
          return this._sharedBody.collisionFilterGroup;
        };

        _proto.setGroup = function setGroup(v) {
          this._sharedBody.collisionFilterGroup = v;
        };

        _proto.addGroup = function addGroup(v) {
          this._sharedBody.collisionFilterGroup |= v;
        };

        _proto.removeGroup = function removeGroup(v) {
          this._sharedBody.collisionFilterGroup &= ~v;
        };

        _proto.getMask = function getMask() {
          return this._sharedBody.collisionFilterMask;
        };

        _proto.setMask = function setMask(v) {
          this._sharedBody.collisionFilterMask = v;
        };

        _proto.addMask = function addMask(v) {
          this._sharedBody.collisionFilterMask |= v;
        };

        _proto.removeMask = function removeMask(v) {
          this._sharedBody.collisionFilterMask &= ~v;
        };

        _proto._wakeUpIfSleep = function _wakeUpIfSleep() {
          if (!this.isAwake) {
            bt.CollisionObject_activate(this.impl, true);
          }
        };

        _createClass(BulletRigidBody, [{
          key: "isAwake",
          get: function get() {
            var state = bt.CollisionObject_getActivationState(this.impl);
            return state === btCollisionObjectStates.ACTIVE_TAG || state === btCollisionObjectStates.DISABLE_DEACTIVATION;
          }
        }, {
          key: "isSleepy",
          get: function get() {
            var state = bt.CollisionObject_getActivationState(this.impl);
            return state === btCollisionObjectStates.WANTS_DEACTIVATION;
          }
        }, {
          key: "isSleeping",
          get: function get() {
            var state = bt.CollisionObject_getActivationState(this.impl);
            return state === btCollisionObjectStates.ISLAND_SLEEPING;
          }
        }, {
          key: "impl",
          get: function get() {
            return this._sharedBody.body;
          }
        }, {
          key: "rigidBody",
          get: function get() {
            return this._rigidBody;
          }
        }, {
          key: "sharedBody",
          get: function get() {
            return this._sharedBody;
          }
        }, {
          key: "isEnabled",
          get: function get() {
            return this._isEnabled;
          }
        }]);

        return BulletRigidBody;
      }();
      BulletRigidBody.idCounter = 0;

      var v3_0$1 = CC_V3_0;
      var quat_0 = CC_QUAT_0;
      var IDCounter = 0;
      var BulletSharedBody = function () {
        BulletSharedBody.getSharedBody = function getSharedBody(node, wrappedWorld, wrappedBody) {
          var key = node.uuid;
          var newSB;

          if (BulletSharedBody.sharedBodesMap.has(key)) {
            newSB = BulletSharedBody.sharedBodesMap.get(key);
          } else {
            newSB = new BulletSharedBody(node, wrappedWorld);
            var g = PhysicsGroup.DEFAULT;
            var m = PhysicsSystem.instance.collisionMatrix[g];
            newSB._collisionFilterGroup = g;
            newSB._collisionFilterMask = m;
            BulletSharedBody.sharedBodesMap.set(node.uuid, newSB);
          }

          if (wrappedBody) {
            newSB._wrappedBody = wrappedBody;
            var _g = wrappedBody.rigidBody.group;
            var _m = PhysicsSystem.instance.collisionMatrix[_g];
            newSB._collisionFilterGroup = _g;
            newSB._collisionFilterMask = _m;
          }

          return newSB;
        };

        function BulletSharedBody(node, wrappedWorld) {
          this.id = void 0;
          this.node = void 0;
          this.wrappedWorld = void 0;
          this.wrappedJoints0 = [];
          this.wrappedJoints1 = [];
          this.dirty = 0;
          this._collisionFilterGroup = PhysicsSystem.PhysicsGroup.DEFAULT;
          this._collisionFilterMask = -1;
          this.ref = 0;
          this.bodyIndex = -1;
          this.ghostIndex = -1;
          this._wrappedBody = null;
          this.id = BulletSharedBody.idCounter++;
          this.wrappedWorld = wrappedWorld;
          this.node = node;
        }

        var _proto = BulletSharedBody.prototype;

        _proto._instantiateBodyStruct = function _instantiateBodyStruct() {
          if (this._bodyStruct) return;
          var mass = 0;

          if (this._wrappedBody && this._wrappedBody.rigidBody.enabled && this._wrappedBody.rigidBody.isDynamic) {
            mass = this._wrappedBody.rigidBody.mass;
          }

          var trans = BulletCache.instance.BT_TRANSFORM_0;
          var quat = BulletCache.instance.BT_QUAT_0;
          cocos2BulletVec3(bt.Transform_getOrigin(trans), this.node.worldPosition);
          cocos2BulletQuat(quat, this.node.worldRotation);
          bt.Transform_setRotation(trans, quat);
          var motionState = bt.ccMotionState_new(this.id, trans);
          var body = bt.RigidBody_new(mass, motionState);
          var sleepTd = PhysicsSystem.instance.sleepThreshold;
          bt.RigidBody_setSleepingThresholds(body, sleepTd, sleepTd);
          this._bodyStruct = {
            id: IDCounter++,
            body: body,
            motionState: motionState,
            compound: bt.ccCompoundShape_new(),
            wrappedShapes: [],
            useCompound: false
          };
          BulletCache.setWrapper(this.id, bt.BODY_CACHE_NAME, this);
          if (this._ghostStruct) bt.CollisionObject_setIgnoreCollisionCheck(this.ghost, this.body, true);
          if (this._wrappedBody) this.setBodyType(this._wrappedBody.rigidBody.type);
        };

        _proto._instantiateGhostStruct = function _instantiateGhostStruct() {
          if (this._ghostStruct) return;
          var ghost = bt.CollisionObject_new();
          var ghostShape = bt.ccCompoundShape_new();
          bt.CollisionObject_setCollisionShape(ghost, ghostShape);
          bt.CollisionObject_setCollisionFlags(ghost, btCollisionFlags.CF_STATIC_OBJECT | btCollisionFlags.CF_NO_CONTACT_RESPONSE);
          this._ghostStruct = {
            id: IDCounter++,
            ghost: ghost,
            compound: ghostShape,
            wrappedShapes: []
          };
          if (this._bodyStruct) bt.CollisionObject_setIgnoreCollisionCheck(this.body, this.ghost, true);
          if (this._wrappedBody) this.setGhostType(this._wrappedBody.rigidBody.type);
        };

        _proto.setType = function setType(v) {
          this.setBodyType(v);
          this.setGhostType(v);
        };

        _proto.setBodyType = function setBodyType(v) {
          if (this._bodyStruct && this._wrappedBody) {
            var body = this._bodyStruct.body;
            var wrap = this._wrappedBody;
            var com = wrap.rigidBody;
            var m_bcf = bt.CollisionObject_getCollisionFlags(body);
            var localInertia = BulletCache.instance.BT_V3_0;

            switch (v) {
              case ERigidBodyType.DYNAMIC:
                m_bcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                m_bcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(body, m_bcf);
                wrap.setMass(com.mass);
                wrap.useGravity(com.useGravity);
                wrap.setAllowSleep(com.allowSleep);
                break;

              case ERigidBodyType.KINEMATIC:
                bt.Vec3_set(localInertia, 0, 0, 0);
                bt.RigidBody_setMassProps(body, 0, localInertia);
                m_bcf |= btCollisionFlags.CF_KINEMATIC_OBJECT;
                m_bcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(body, m_bcf);
                bt.CollisionObject_forceActivationState(body, btCollisionObjectStates.DISABLE_DEACTIVATION);
                break;

              case ERigidBodyType.STATIC:
              default:
                bt.Vec3_set(localInertia, 0, 0, 0);
                bt.RigidBody_setMassProps(body, 0, localInertia);
                m_bcf |= btCollisionFlags.CF_STATIC_OBJECT;
                m_bcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(body, m_bcf);
                bt.CollisionObject_forceActivationState(body, btCollisionObjectStates.ISLAND_SLEEPING);
                break;
            }

            this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
          }
        };

        _proto.setGhostType = function setGhostType(v) {
          if (this._ghostStruct) {
            var ghost = this._ghostStruct.ghost;
            var m_gcf = bt.CollisionObject_getCollisionFlags(ghost);

            switch (v) {
              case ERigidBodyType.DYNAMIC:
              case ERigidBodyType.KINEMATIC:
                m_gcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                m_gcf |= btCollisionFlags.CF_KINEMATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(ghost, m_gcf);
                bt.CollisionObject_forceActivationState(ghost, btCollisionObjectStates.DISABLE_DEACTIVATION);
                break;

              case ERigidBodyType.STATIC:
              default:
                m_gcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                m_gcf |= btCollisionFlags.CF_STATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(ghost, m_gcf);
                bt.CollisionObject_forceActivationState(ghost, btCollisionObjectStates.ISLAND_SLEEPING);
                break;
            }

            this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
          }
        };

        _proto.addShape = function addShape(v, isTrigger) {
          function switchShape(that, shape) {
            bt.CollisionObject_setCollisionShape(that.body, shape);
            that.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;

            if (that._wrappedBody && that._wrappedBody.isEnabled) {
              that._wrappedBody.setMass(that._wrappedBody.rigidBody.mass);
            }
          }

          if (isTrigger) {
            var index = this.ghostStruct.wrappedShapes.indexOf(v);

            if (index < 0) {
              this.ghostStruct.wrappedShapes.push(v);
              v.setCompound(this.ghostCompoundShape);
              this.ghostEnabled = true;
            }
          } else {
            var _index = this.bodyStruct.wrappedShapes.indexOf(v);

            if (_index < 0) {
              this.bodyStruct.wrappedShapes.push(v);

              if (this.bodyStruct.useCompound) {
                v.setCompound(this.bodyCompoundShape);
              } else {
                var l = this.bodyStruct.wrappedShapes.length;

                if (l === 1 && !v.needCompound()) {
                  switchShape(this, v.impl);
                } else {
                  this.bodyStruct.useCompound = true;

                  for (var i = 0; i < l; i++) {
                    var childShape = this.bodyStruct.wrappedShapes[i];
                    childShape.setCompound(this.bodyCompoundShape);
                  }

                  switchShape(this, this.bodyStruct.compound);
                }
              }

              this.bodyEnabled = true;
            }
          }
        };

        _proto.removeShape = function removeShape(v, isTrigger) {
          if (isTrigger) {
            var index = this.ghostStruct.wrappedShapes.indexOf(v);

            if (index >= 0) {
              fastRemoveAt(this.ghostStruct.wrappedShapes, index);
              v.setCompound(0);
              this.ghostEnabled = false;
            }
          } else {
            var _index2 = this.bodyStruct.wrappedShapes.indexOf(v);

            if (_index2 >= 0) {
              if (this.bodyStruct.useCompound) {
                v.setCompound(0);
              } else {
                bt.CollisionObject_setCollisionShape(this.body, bt.EmptyShape_static());
              }

              bt.CollisionObject_activate(this.body, true);
              this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
              fastRemoveAt(this.bodyStruct.wrappedShapes, _index2);
              this.bodyEnabled = false;
            }
          }
        };

        _proto.addJoint = function addJoint(v, type) {
          if (type) {
            var i = this.wrappedJoints1.indexOf(v);
            if (i < 0) this.wrappedJoints1.push(v);
          } else {
            var _i = this.wrappedJoints0.indexOf(v);

            if (_i < 0) this.wrappedJoints0.push(v);
          }
        };

        _proto.removeJoint = function removeJoint(v, type) {
          if (type) {
            var i = this.wrappedJoints1.indexOf(v);
            if (i >= 0) fastRemoveAt(this.wrappedJoints1, i);
          } else {
            var _i2 = this.wrappedJoints0.indexOf(v);

            if (_i2 >= 0) fastRemoveAt(this.wrappedJoints0, _i2);
          }
        };

        _proto.updateDirty = function updateDirty() {
          if (this.dirty) {
            if (this.bodyIndex >= 0 && this.dirty & EBtSharedBodyDirty.BODY_RE_ADD) this.updateBodyByReAdd();
            if (this.ghostIndex >= 0 && this.dirty & EBtSharedBodyDirty.GHOST_RE_ADD) this.updateGhostByReAdd();
            this.dirty = 0;
          }
        };

        _proto.syncSceneToPhysics = function syncSceneToPhysics() {
          if (this.node.hasChangedFlags) {
            var bt_quat = BulletCache.instance.BT_QUAT_0;
            var bt_transform = bt.CollisionObject_getWorldTransform(this.body);
            cocos2BulletQuat(bt_quat, this.node.worldRotation);
            cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
            bt.Transform_setRotation(bt_transform, bt_quat);

            if (this.node.hasChangedFlags & TransformBit.SCALE) {
              this.syncBodyScale();
            }

            if (bt.CollisionObject_isKinematicObject(this.body)) {
              var ms = bt.RigidBody_getMotionState(this.body);
              if (ms) bt.MotionState_setWorldTransform(ms, bt_transform);
            } else if (this.isBodySleeping()) bt.CollisionObject_activate(this.body);
          }
        };

        _proto.syncPhysicsToScene = function syncPhysicsToScene() {
          if (bt.CollisionObject_isStaticOrKinematicObject(this.body)) return;
          this.syncPhysicsToGraphics();
        };

        _proto.syncPhysicsToGraphics = function syncPhysicsToGraphics() {
          if (this.isBodySleeping()) return;
          var bt_quat = BulletCache.instance.BT_QUAT_0;
          var bt_transform = BulletCache.instance.BT_TRANSFORM_0;
          bt.MotionState_getWorldTransform(bt.RigidBody_getMotionState(this.body), bt_transform);
          bt.Transform_getRotation(bt_transform, bt_quat);
          this.node.worldRotation = bullet2CocosQuat(quat_0, bt_quat);
          this.node.worldPosition = bullet2CocosVec3(v3_0$1, bt.Transform_getOrigin(bt_transform));

          if (this._ghostStruct) {
            var bt_transform1 = bt.CollisionObject_getWorldTransform(this.ghost);
            cocos2BulletVec3(bt.Transform_getOrigin(bt_transform1), this.node.worldPosition);
            cocos2BulletQuat(bt_quat, this.node.worldRotation);
            bt.Transform_setRotation(bt_transform1, bt_quat);
          }
        };

        _proto.syncSceneToGhost = function syncSceneToGhost() {
          if (this.node.hasChangedFlags) {
            var bt_quat = BulletCache.instance.BT_QUAT_0;
            var bt_transform = bt.CollisionObject_getWorldTransform(this.ghost);
            cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
            cocos2BulletQuat(bt_quat, this.node.worldRotation);
            bt.Transform_setRotation(bt_transform, bt_quat);
            if (this.node.hasChangedFlags & TransformBit.SCALE) this.syncGhostScale();
            bt.CollisionObject_activate(this.ghost);
          }
        };

        _proto.syncInitialBody = function syncInitialBody() {
          var bt_quat = BulletCache.instance.BT_QUAT_0;
          var bt_transform = bt.CollisionObject_getWorldTransform(this.body);
          cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
          cocos2BulletQuat(bt_quat, this.node.worldRotation);
          bt.Transform_setRotation(bt_transform, bt_quat);
          this.syncBodyScale();
          bt.CollisionObject_activate(this.body);
        };

        _proto.syncInitialGhost = function syncInitialGhost() {
          var bt_quat = BulletCache.instance.BT_QUAT_0;
          var bt_transform = bt.CollisionObject_getWorldTransform(this.ghost);
          cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
          cocos2BulletQuat(bt_quat, this.node.worldRotation);
          bt.Transform_setRotation(bt_transform, bt_quat);
          this.syncGhostScale();
          bt.CollisionObject_activate(this.body);
        };

        _proto.syncBodyScale = function syncBodyScale() {
          for (var i = 0; i < this.bodyStruct.wrappedShapes.length; i++) {
            this.bodyStruct.wrappedShapes[i].updateScale();
          }

          for (var _i3 = 0; _i3 < this.wrappedJoints0.length; _i3++) {
            this.wrappedJoints0[_i3].updateScale0();
          }

          for (var _i4 = 0; _i4 < this.wrappedJoints1.length; _i4++) {
            this.wrappedJoints1[_i4].updateScale1();
          }
        };

        _proto.syncGhostScale = function syncGhostScale() {
          for (var i = 0; i < this.ghostStruct.wrappedShapes.length; i++) {
            this.ghostStruct.wrappedShapes[i].updateScale();
          }
        };

        _proto.updateBodyByReAdd = function updateBodyByReAdd() {
          if (this.bodyIndex >= 0) {
            this.wrappedWorld.removeSharedBody(this);
            this.bodyIndex = this.wrappedWorld.bodies.length;
            this.wrappedWorld.addSharedBody(this);
          }
        };

        _proto.updateGhostByReAdd = function updateGhostByReAdd() {
          if (this.ghostIndex >= 0) {
            this.wrappedWorld.removeGhostObject(this);
            this.ghostIndex = this.wrappedWorld.ghosts.length;
            this.wrappedWorld.addGhostObject(this);
          }
        };

        _proto.destroy = function destroy() {
          BulletSharedBody.sharedBodesMap["delete"](this.node.uuid);
          this.node = null;
          this.wrappedWorld = null;

          if (this._bodyStruct) {
            var bodyStruct = this._bodyStruct;
            BulletCache.delWrapper(bodyStruct.body, bt.BODY_CACHE_NAME);
            bt.MotionState_del(bodyStruct.motionState);
            bt.CollisionShape_del(bodyStruct.compound);
            bt.CollisionObject_del(bodyStruct.body);
            this._bodyStruct = null;
          }

          if (this._ghostStruct) {
            var ghostStruct = this._ghostStruct;
            bt.CollisionShape_del(ghostStruct.compound);
            bt.CollisionObject_del(ghostStruct.ghost);
            this._ghostStruct = null;
          }
        };

        _proto.isBodySleeping = function isBodySleeping() {
          return bt.CollisionObject_getActivationState(this.body) === btCollisionObjectStates.ISLAND_SLEEPING;
        };

        _createClass(BulletSharedBody, [{
          key: "wrappedBody",
          get: function get() {
            return this._wrappedBody;
          }
        }, {
          key: "bodyCompoundShape",
          get: function get() {
            return this.bodyStruct.compound;
          }
        }, {
          key: "ghostCompoundShape",
          get: function get() {
            return this.ghostStruct.compound;
          }
        }, {
          key: "body",
          get: function get() {
            return this.bodyStruct.body;
          }
        }, {
          key: "ghost",
          get: function get() {
            return this.ghostStruct.ghost;
          }
        }, {
          key: "collisionFilterGroup",
          get: function get() {
            return this._collisionFilterGroup;
          },
          set: function set(v) {
            if (v !== this._collisionFilterGroup) {
              this._collisionFilterGroup = v;
              this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
              this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
            }
          }
        }, {
          key: "collisionFilterMask",
          get: function get() {
            return this._collisionFilterMask;
          },
          set: function set(v) {
            if (v !== this._collisionFilterMask) {
              this._collisionFilterMask = v;
              this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
              this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
            }
          }
        }, {
          key: "bodyStruct",
          get: function get() {
            this._instantiateBodyStruct();

            return this._bodyStruct;
          }
        }, {
          key: "ghostStruct",
          get: function get() {
            this._instantiateGhostStruct();

            return this._ghostStruct;
          }
        }, {
          key: "bodyEnabled",
          set: function set(v) {
            if (v) {
              if (this.bodyIndex < 0) {
                if (this.bodyStruct.wrappedShapes.length === 0) {
                  if (!this.wrappedBody) return;
                  if (!this.wrappedBody.rigidBody.isDynamic) return;
                }

                this.bodyIndex = this.wrappedWorld.bodies.length;
                this.wrappedWorld.addSharedBody(this);
                this.syncInitialBody();
              }
            } else if (this.bodyIndex >= 0) {
              var isRemoveBody = this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody == null || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.isEnabled || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.rigidBody.enabledInHierarchy;

              if (isRemoveBody) {
                bt.RigidBody_clearState(this.body);
                this.bodyIndex = -1;
                this.wrappedWorld.removeSharedBody(this);
              }
            }
          }
        }, {
          key: "ghostEnabled",
          set: function set(v) {
            if (v) {
              if (this.ghostIndex < 0 && this.ghostStruct.wrappedShapes.length > 0) {
                this.ghostIndex = 1;
                this.wrappedWorld.addGhostObject(this);
                this.syncInitialGhost();
              }
            } else if (this.ghostIndex >= 0) {
              var isRemoveGhost = this.ghostStruct.wrappedShapes.length === 0 && this.ghost;

              if (isRemoveGhost) {
                this.ghostIndex = -1;
                this.wrappedWorld.removeGhostObject(this);
              }
            }
          }
        }, {
          key: "reference",
          set: function set(v) {
            v ? this.ref++ : this.ref--;

            if (this.ref === 0) {
              this.destroy();
            }
          }
        }]);

        return BulletSharedBody;
      }();
      BulletSharedBody.idCounter = 0;
      BulletSharedBody.sharedBodesMap = new Map();

      var v3_0$2 = CC_V3_0;
      var ccMaterialBooks = {};
      var BulletShape = function () {
        function BulletShape() {
          this.id = BulletShape.idCounter++;
          this._isEnabled = false;
          this._isTrigger = false;
          this._isInitialized = false;
          this._impl = 0;
          this._compound = 0;
          this.quat = bt.Quat_new(0, 0, 0, 1);
          this.transform = bt.Transform_new();
        }

        var _proto = BulletShape.prototype;

        _proto.updateEventListener = function updateEventListener() {
          this._sharedBody.wrappedWorld.updateNeedEmitEvents(this.collider.needCollisionEvent || this.collider.needTriggerEvent);
        };

        _proto.setMaterial = function setMaterial(v) {
          if (!this._isTrigger && this._isEnabled && v) {
            if (this._compound) {
              if (!ccMaterialBooks[v._uuid]) ccMaterialBooks[v._uuid] = bt.ccMaterial_new();
              var mat = ccMaterialBooks[v._uuid];
              bt.ccMaterial_set(mat, v.restitution, v.friction, v.rollingFriction, v.spinningFriction);
              bt.CollisionShape_setMaterial(this._impl, mat);
            } else {
              bt.CollisionObject_setMaterial(this._sharedBody.body, v.restitution, v.friction, v.rollingFriction, v.spinningFriction);
            }
          }
        };

        _proto.setCenter = function setCenter(v) {
          Vec3.copy(v3_0$2, v);
          v3_0$2.multiply(this._collider.node.worldScale);
          cocos2BulletVec3(bt.Transform_getOrigin(this.transform), v3_0$2);
          this.updateCompoundTransform();
        };

        _proto.setAsTrigger = function setAsTrigger(v) {
          if (this._isTrigger === v) return;

          if (this._isEnabled) {
            this._sharedBody.removeShape(this, !v);

            this._sharedBody.addShape(this, v);
          }

          this._isTrigger = v;
        };

        _proto.getAABB = function getAABB(v) {
          var bt_transform = BulletCache.instance.BT_TRANSFORM_0;
          bt.Transform_setIdentity(bt_transform);
          bt.Transform_setRotation(bt_transform, cocos2BulletQuat(BulletCache.instance.BT_QUAT_0, this._collider.node.worldRotation));
          var MIN = BulletCache.instance.BT_V3_0;
          var MAX = BulletCache.instance.BT_V3_1;
          bt.CollisionShape_getAabb(this._impl, bt_transform, MIN, MAX);
          v.halfExtents.x = (bt.Vec3_x(MAX) - bt.Vec3_x(MIN)) / 2;
          v.halfExtents.y = (bt.Vec3_y(MAX) - bt.Vec3_y(MIN)) / 2;
          v.halfExtents.z = (bt.Vec3_z(MAX) - bt.Vec3_z(MIN)) / 2;
          Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
        };

        _proto.getBoundingSphere = function getBoundingSphere(v) {
          v.radius = bt.CollisionShape_getLocalBoundingSphere(this._impl);
          Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
        };

        _proto.initialize = function initialize(com) {
          this._collider = com;
          this._isInitialized = true;
          this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._collider.node);
          this._sharedBody.reference = true;
          this.onComponentSet();
          this.setWrapper();
        };

        _proto.setWrapper = function setWrapper() {
          if (BulletCache.isNotEmptyShape(this._impl)) {
            bt.CollisionShape_setUserPointer(this._impl, this._impl);
            BulletCache.setWrapper(this._impl, BulletShape.TYPE, this);
          }
        };

        _proto.onLoad = function onLoad() {
          this.setCenter(this._collider.center);
          this.setAsTrigger(this._collider.isTrigger);
        };

        _proto.onEnable = function onEnable() {
          this._isEnabled = true;

          this._sharedBody.addShape(this, this._isTrigger);

          this.setMaterial(this.collider.sharedMaterial);
        };

        _proto.onDisable = function onDisable() {
          this._isEnabled = false;

          this._sharedBody.removeShape(this, this._isTrigger);
        };

        _proto.onDestroy = function onDestroy() {
          this._sharedBody.reference = false;
          this._collider = null;
          bt.Quat_del(this.quat);
          bt.Transform_del(this.transform);
          if (this._compound) bt.CollisionShape_del(this._compound);

          if (BulletCache.isNotEmptyShape(this._impl)) {
            bt.CollisionShape_del(this._impl);
            BulletCache.delWrapper(this._impl, BulletShape.TYPE);
          }
        };

        _proto.updateByReAdd = function updateByReAdd() {
          if (this._isEnabled) {
            this._sharedBody.removeShape(this, this._isTrigger);

            this._sharedBody.addShape(this, this._isTrigger);
          }
        };

        _proto.getGroup = function getGroup() {
          return this._sharedBody.collisionFilterGroup;
        };

        _proto.setGroup = function setGroup(v) {
          this._sharedBody.collisionFilterGroup = v;
        };

        _proto.addGroup = function addGroup(v) {
          this._sharedBody.collisionFilterGroup |= v;
        };

        _proto.removeGroup = function removeGroup(v) {
          this._sharedBody.collisionFilterGroup &= ~v;
        };

        _proto.getMask = function getMask() {
          return this._sharedBody.collisionFilterMask;
        };

        _proto.setMask = function setMask(v) {
          this._sharedBody.collisionFilterMask = v;
        };

        _proto.addMask = function addMask(v) {
          this._sharedBody.collisionFilterMask |= v;
        };

        _proto.removeMask = function removeMask(v) {
          this._sharedBody.collisionFilterMask &= ~v;
        };

        _proto.setCompound = function setCompound(compound) {
          if (this._compound) bt.CompoundShape_removeChildShape(this._compound, this._impl);
          if (compound) bt.CompoundShape_addChildShape(compound, this.transform, this._impl);
          this._compound = compound;
        };

        _proto.updateScale = function updateScale() {
          this.setCenter(this._collider.center);
        };

        _proto.updateCompoundTransform = function updateCompoundTransform() {
          if (this._compound) {
            bt.CompoundShape_updateChildTransform(this._compound, this._impl, this.transform, true);
          } else if (this._isEnabled && !this._isTrigger) {
            if (this._sharedBody && !this._sharedBody.bodyStruct.useCompound) {
              this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
            }
          }
        };

        _proto.needCompound = function needCompound() {
          if (this._collider.type === EColliderType.TERRAIN) {
            return true;
          }

          if (this._collider.center.equals(Vec3.ZERO)) {
            return false;
          }

          return true;
        };

        _createClass(BulletShape, [{
          key: "attachedRigidBody",
          get: function get() {
            if (this._sharedBody.wrappedBody) return this._sharedBody.wrappedBody.rigidBody;
            return null;
          }
        }, {
          key: "impl",
          get: function get() {
            return this._impl;
          }
        }, {
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }, {
          key: "sharedBody",
          get: function get() {
            return this._sharedBody;
          }
        }]);

        return BulletShape;
      }();
      BulletShape.TYPE = 'shape';
      BulletShape.idCounter = 0;

      var ArrayCollisionMatrix = function () {
        function ArrayCollisionMatrix() {
          this.matrix = [];
        }

        var _proto = ArrayCollisionMatrix.prototype;

        _proto.get = function get(i, j) {
          if (j > i) {
            var temp = j;
            j = i;
            i = temp;
          }

          return this.matrix[(i * (i + 1) >> 1) + j - 1];
        };

        _proto.set = function set(i, j, value) {
          if (j > i) {
            var temp = j;
            j = i;
            i = temp;
          }

          this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
        };

        _proto.reset = function reset() {
          this.matrix.length = 0;
        };

        _proto.setNumObjects = function setNumObjects(n) {
          this.matrix.length = n * (n - 1) >> 1;
        };

        return ArrayCollisionMatrix;
      }();

      var TupleDictionary = function () {
        function TupleDictionary() {
          this.data = void 0;
          this.data = {
            keys: []
          };
        }

        var _proto = TupleDictionary.prototype;

        _proto.get = function get(i, j) {
          if (i > j) {
            var temp = j;
            j = i;
            i = temp;
          }

          return this.data[i + "-" + j];
        };

        _proto.set = function set(i, j, value) {
          if (i > j) {
            var temp = j;
            j = i;
            i = temp;
          }

          var key = i + "-" + j;

          if (value == null) {
            var idx = this.data.keys.indexOf(key);

            if (idx !== -1) {
              this.data.keys.splice(idx, 1);
              delete this.data[key];
              return value;
            }
          }

          if (!this.get(i, j)) {
            this.data.keys.push(key);
          }

          this.data[key] = value;
          return this.data[key];
        };

        _proto.reset = function reset() {
          this.data = {
            keys: []
          };
        };

        _proto.getLength = function getLength() {
          return this.data.keys.length;
        };

        _proto.getKeyByIndex = function getKeyByIndex(index) {
          return this.data.keys[index];
        };

        _proto.getDataByKey = function getDataByKey(Key) {
          return this.data[Key];
        };

        return TupleDictionary;
      }();

      var BulletContactData = function () {
        function BulletContactData(event) {
          this.impl = 0;
          this.event = void 0;
          this.event = event;
        }

        var _proto = BulletContactData.prototype;

        _proto.getLocalPointOnA = function getLocalPointOnA(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_localPointA(this.impl));
        };

        _proto.getLocalPointOnB = function getLocalPointOnB(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_localPointB(this.impl));
        };

        _proto.getWorldPointOnA = function getWorldPointOnA(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_positionWorldOnA(this.impl));
        };

        _proto.getWorldPointOnB = function getWorldPointOnB(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_positionWorldOnB(this.impl));
        };

        _proto.getLocalNormalOnA = function getLocalNormalOnA(out) {
          if (this.impl) {
            var bt_rot = BulletCache.instance.BT_QUAT_0;
            var body = bt.PersistentManifold_getBody0(this.event.impl);
            var trans = bt.CollisionObject_getWorldTransform(body);
            bt.Transform_getRotation(trans, bt_rot);
            var inv_rot = CC_QUAT_0;
            bullet2CocosQuat(inv_rot, bt_rot);
            Quat.conjugate(inv_rot, inv_rot);
            bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
            if (!this.isBodyA) Vec3.negate(out, out);
            Vec3.transformQuat(out, out, inv_rot);
          }
        };

        _proto.getLocalNormalOnB = function getLocalNormalOnB(out) {
          if (this.impl) {
            var bt_rot = BulletCache.instance.BT_QUAT_0;
            var body = bt.PersistentManifold_getBody1(this.event.impl);
            var trans = bt.CollisionObject_getWorldTransform(body);
            bt.Transform_getRotation(trans, bt_rot);
            var inv_rot = CC_QUAT_0;
            bullet2CocosQuat(inv_rot, bt_rot);
            Quat.conjugate(inv_rot, inv_rot);
            bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
            Vec3.transformQuat(out, out, inv_rot);
          }
        };

        _proto.getWorldNormalOnA = function getWorldNormalOnA(out) {
          if (this.impl) {
            bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
            if (!this.isBodyA) Vec3.negate(out, out);
          }
        };

        _proto.getWorldNormalOnB = function getWorldNormalOnB(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
        };

        _createClass(BulletContactData, [{
          key: "isBodyA",
          get: function get() {
            var sb = this.event.selfCollider.shape.sharedBody.body;
            return sb === bt.PersistentManifold_getBody0(this.event.impl);
          }
        }]);

        return BulletContactData;
      }();

      var contactsPool = [];
      var v3_0$3 = CC_V3_0;
      var v3_1$6 = CC_V3_1;
      var BulletWorld = function () {
        var _proto = BulletWorld.prototype;

        _proto.setDefaultMaterial = function setDefaultMaterial(v) {};

        _proto.setAllowSleep = function setAllowSleep(v) {
          bt.ccDiscreteDynamicsWorld_setAllowSleep(this._world, v);
        };

        _proto.setGravity = function setGravity(gravity) {
          bt.DynamicsWorld_setGravity(this._world, cocos2BulletVec3(BulletCache.instance.BT_V3_0, gravity));
        };

        _proto.updateNeedEmitEvents = function updateNeedEmitEvents(v) {
          if (!this.ghosts) return;

          if (v) {
            this._needEmitEvents = true;
          } else {
            this._needEmitEvents = false;

            for (var i = 0; i < this.ghosts.length; i++) {
              var ghost = this.ghosts[i];
              var shapes = ghost.ghostStruct.wrappedShapes;

              for (var j = 0; j < shapes.length; j++) {
                var collider = shapes[j].collider;

                if (collider.needCollisionEvent || collider.needTriggerEvent) {
                  this._needEmitEvents = true;
                  return;
                }
              }
            }

            for (var _i = 0; _i < this.bodies.length; _i++) {
              var body = this.bodies[_i];
              var _shapes = body.bodyStruct.wrappedShapes;

              for (var _j = 0; _j < _shapes.length; _j++) {
                var _collider = _shapes[_j].collider;

                if (_collider.needCollisionEvent || _collider.needTriggerEvent) {
                  this._needEmitEvents = true;
                  return;
                }
              }
            }
          }
        };

        function BulletWorld() {
          this._world = void 0;
          this._broadphase = void 0;
          this._solver = void 0;
          this._dispatcher = void 0;
          this._needEmitEvents = false;
          this._needSyncAfterEvents = false;
          this.bodies = [];
          this.ghosts = [];
          this.constraints = [];
          this.triggerArrayMat = new ArrayCollisionMatrix();
          this.collisionArrayMat = new ArrayCollisionMatrix();
          this.contactsDic = new TupleDictionary();
          this.oldContactsDic = new TupleDictionary();
          this._broadphase = bt.DbvtBroadphase_new();
          this._dispatcher = bt.CollisionDispatcher_new();
          this._solver = bt.SequentialImpulseConstraintSolver_new();
          this._world = bt.ccDiscreteDynamicsWorld_new(this._dispatcher, this._broadphase, this._solver);
        }

        _proto.destroy = function destroy() {
          if (this.constraints.length || this.bodies.length) error('You should destroy all physics component first.');
          bt.CollisionWorld_del(this._world);
          bt.DbvtBroadphase_del(this._broadphase);
          bt.CollisionDispatcher_del(this._dispatcher);
          bt.SequentialImpulseConstraintSolver_del(this._solver);
          this.bodies = null;
          this.ghosts = null;
          this.constraints = null;
          this.triggerArrayMat = null;
          this.collisionArrayMat = null;
          this.contactsDic = null;
          this.oldContactsDic = null;
          contactsPool.length = 0;
        };

        _proto.step = function step(deltaTime, timeSinceLastCalled, maxSubStep) {
          if (maxSubStep === void 0) {
            maxSubStep = 0;
          }

          if (!this.bodies.length && !this.ghosts.length) return;
          if (timeSinceLastCalled === undefined) timeSinceLastCalled = deltaTime;
          bt.DynamicsWorld_stepSimulation(this._world, timeSinceLastCalled, maxSubStep, deltaTime);
        };

        _proto.syncSceneToPhysics = function syncSceneToPhysics() {
          for (var i = this.ghosts.length - 1; i >= 0; i--) {
            var ghost = this.ghosts[i];
            ghost.updateDirty();
            ghost.syncSceneToGhost();
          }

          for (var _i2 = this.bodies.length - 1; _i2 >= 0; _i2--) {
            var body = this.bodies[_i2];
            body.updateDirty();
            body.syncSceneToPhysics();
          }
        };

        _proto.syncAfterEvents = function syncAfterEvents() {
          if (!this._needSyncAfterEvents) return;
          this.syncSceneToPhysics();
        };

        _proto.raycast = function raycast(worldRay, options, pool, results) {
          worldRay.computeHit(v3_0$3, options.maxDistance);
          var to = cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$3);
          var from = cocos2BulletVec3(BulletCache.instance.BT_V3_1, worldRay.o);
          var allHitsCB = bt.ccAllRayCallback_static();
          bt.ccAllRayCallback_reset(allHitsCB, from, to, options.mask, options.queryTrigger);
          bt.CollisionWorld_rayTest(this._world, from, to, allHitsCB);

          if (bt.RayCallback_hasHit(allHitsCB)) {
            var posArray = bt.ccAllRayCallback_getHitPointWorld(allHitsCB);
            var normalArray = bt.ccAllRayCallback_getHitNormalWorld(allHitsCB);
            var ptrArray = bt.ccAllRayCallback_getCollisionShapePtrs(allHitsCB);

            for (var i = 0, n = bt.int_array_size(ptrArray); i < n; i++) {
              bullet2CocosVec3(v3_0$3, bt.Vec3_array_at(posArray, i));
              bullet2CocosVec3(v3_1$6, bt.Vec3_array_at(normalArray, i));
              var shape = BulletCache.getWrapper(bt.int_array_at(ptrArray, i), BulletShape.TYPE);
              var r = pool.add();
              results.push(r);

              r._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$6);
            }

            return true;
          }

          return false;
        };

        _proto.raycastClosest = function raycastClosest(worldRay, options, result) {
          worldRay.computeHit(v3_0$3, options.maxDistance);
          var to = cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$3);
          var from = cocos2BulletVec3(BulletCache.instance.BT_V3_1, worldRay.o);
          var closeHitCB = bt.ccClosestRayCallback_static();
          bt.ccClosestRayCallback_reset(closeHitCB, from, to, options.mask, options.queryTrigger);
          bt.CollisionWorld_rayTest(this._world, from, to, closeHitCB);

          if (bt.RayCallback_hasHit(closeHitCB)) {
            bullet2CocosVec3(v3_0$3, bt.ccClosestRayCallback_getHitPointWorld(closeHitCB));
            bullet2CocosVec3(v3_1$6, bt.ccClosestRayCallback_getHitNormalWorld(closeHitCB));
            var shape = BulletCache.getWrapper(bt.ccClosestRayCallback_getCollisionShapePtr(closeHitCB), BulletShape.TYPE);

            result._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$6);

            return true;
          }

          return false;
        };

        _proto.getSharedBody = function getSharedBody(node, wrappedBody) {
          return BulletSharedBody.getSharedBody(node, this, wrappedBody);
        };

        _proto.addSharedBody = function addSharedBody(sharedBody) {
          var i = this.bodies.indexOf(sharedBody);

          if (i < 0) {
            this.bodies.push(sharedBody);
            bt.DynamicsWorld_addRigidBody(this._world, sharedBody.body, sharedBody.collisionFilterGroup, sharedBody.collisionFilterMask);
          }
        };

        _proto.removeSharedBody = function removeSharedBody(sharedBody) {
          var i = this.bodies.indexOf(sharedBody);

          if (i >= 0) {
            fastRemoveAt(this.bodies, i);
            bt.DynamicsWorld_removeRigidBody(this._world, sharedBody.body);
          }
        };

        _proto.addGhostObject = function addGhostObject(sharedBody) {
          var i = this.ghosts.indexOf(sharedBody);

          if (i < 0) {
            this.ghosts.push(sharedBody);
            bt.CollisionWorld_addCollisionObject(this._world, sharedBody.ghost, sharedBody.collisionFilterGroup, sharedBody.collisionFilterMask);
          }
        };

        _proto.removeGhostObject = function removeGhostObject(sharedBody) {
          var i = this.ghosts.indexOf(sharedBody);

          if (i >= 0) {
            fastRemoveAt(this.ghosts, i);
            bt.CollisionWorld_removeCollisionObject(this._world, sharedBody.ghost);
          }
        };

        _proto.addConstraint = function addConstraint(constraint) {
          var i = this.constraints.indexOf(constraint);

          if (i < 0) {
            this.constraints.push(constraint);
            bt.DynamicsWorld_addConstraint(this.impl, constraint.impl, !constraint.constraint.enableCollision);
            constraint.index = i;
          }
        };

        _proto.removeConstraint = function removeConstraint(constraint) {
          var i = this.constraints.indexOf(constraint);

          if (i >= 0) {
            this.constraints.splice(i, 1);
            bt.DynamicsWorld_removeConstraint(this.impl, constraint.impl);
            constraint.index = -1;
          }
        };

        _proto.emitEvents = function emitEvents() {
          this._needSyncAfterEvents = false;
          if (!this._needEmitEvents) return;
          this.gatherConatactData();
          var dicL = this.contactsDic.getLength();

          while (dicL--) {
            contactsPool.push.apply(contactsPool, CollisionEventObject.contacts);
            CollisionEventObject.contacts.length = 0;
            var key = this.contactsDic.getKeyByIndex(dicL);
            var data = this.contactsDic.getDataByKey(key);
            var shape0 = data.shape0;
            var shape1 = data.shape1;
            this.oldContactsDic.set(shape0.id, shape1.id, data);
            var collider0 = shape0.collider;
            var collider1 = shape1.collider;

            if (collider0 && collider1) {
              var isTrigger = collider0.isTrigger || collider1.isTrigger;

              if (isTrigger) {
                if (this.triggerArrayMat.get(shape0.id, shape1.id)) {
                  TriggerEventObject.type = 'onTriggerStay';
                } else {
                  TriggerEventObject.type = 'onTriggerEnter';
                  this.triggerArrayMat.set(shape0.id, shape1.id, true);
                }

                TriggerEventObject.impl = data.impl;
                TriggerEventObject.selfCollider = collider0;
                TriggerEventObject.otherCollider = collider1;
                collider0.emit(TriggerEventObject.type, TriggerEventObject);
                TriggerEventObject.selfCollider = collider1;
                TriggerEventObject.otherCollider = collider0;
                collider1.emit(TriggerEventObject.type, TriggerEventObject);
                this._needSyncAfterEvents = true;
              } else {
                var body0 = collider0.attachedRigidBody;
                var body1 = collider1.attachedRigidBody;

                if (body0 && body1) {
                  if (body0.isSleeping && body1.isSleeping) continue;
                } else if (!body0 && body1) {
                  if (body1.isSleeping) continue;
                } else if (!body1 && body0) {
                  if (body0.isSleeping) continue;
                }

                if (this.collisionArrayMat.get(shape0.id, shape1.id)) {
                  CollisionEventObject.type = 'onCollisionStay';
                } else {
                  CollisionEventObject.type = 'onCollisionEnter';
                  this.collisionArrayMat.set(shape0.id, shape1.id, true);
                }

                for (var i = 0; i < data.contacts.length; i++) {
                  var cq = data.contacts[i];

                  if (contactsPool.length > 0) {
                    var c = contactsPool.pop();
                    c.impl = cq;
                    CollisionEventObject.contacts.push(c);
                  } else {
                    var _c = new BulletContactData(CollisionEventObject);

                    _c.impl = cq;
                    CollisionEventObject.contacts.push(_c);
                  }
                }

                CollisionEventObject.impl = data.impl;
                CollisionEventObject.selfCollider = collider0;
                CollisionEventObject.otherCollider = collider1;
                collider0.emit(CollisionEventObject.type, CollisionEventObject);
                CollisionEventObject.selfCollider = collider1;
                CollisionEventObject.otherCollider = collider0;
                collider1.emit(CollisionEventObject.type, CollisionEventObject);
                this._needSyncAfterEvents = true;
              }

              if (this.oldContactsDic.get(shape0.id, shape1.id) == null) {
                this.oldContactsDic.set(shape0.id, shape1.id, data);
              }
            }
          }

          var oldDicL = this.oldContactsDic.getLength();

          while (oldDicL--) {
            var _key = this.oldContactsDic.getKeyByIndex(oldDicL);

            var _data = this.oldContactsDic.getDataByKey(_key);

            var _shape = _data.shape0;
            var _shape2 = _data.shape1;
            var _collider2 = _shape.collider;
            var _collider3 = _shape2.collider;

            if (_collider2 && _collider3) {
              var _isTrigger = _collider2.isTrigger || _collider3.isTrigger;

              if (this.contactsDic.getDataByKey(_key) == null) {
                if (_isTrigger) {
                  if (this.triggerArrayMat.get(_shape.id, _shape2.id)) {
                    TriggerEventObject.type = 'onTriggerExit';
                    TriggerEventObject.selfCollider = _collider2;
                    TriggerEventObject.otherCollider = _collider3;

                    _collider2.emit(TriggerEventObject.type, TriggerEventObject);

                    TriggerEventObject.selfCollider = _collider3;
                    TriggerEventObject.otherCollider = _collider2;

                    _collider3.emit(TriggerEventObject.type, TriggerEventObject);

                    this.triggerArrayMat.set(_shape.id, _shape2.id, false);
                    this.oldContactsDic.set(_shape.id, _shape2.id, null);
                    this._needSyncAfterEvents = true;
                  }
                } else if (this.collisionArrayMat.get(_shape.id, _shape2.id)) {
                  contactsPool.push.apply(contactsPool, CollisionEventObject.contacts);
                  CollisionEventObject.contacts.length = 0;
                  CollisionEventObject.type = 'onCollisionExit';
                  CollisionEventObject.selfCollider = _collider2;
                  CollisionEventObject.otherCollider = _collider3;

                  _collider2.emit(CollisionEventObject.type, CollisionEventObject);

                  CollisionEventObject.selfCollider = _collider3;
                  CollisionEventObject.otherCollider = _collider2;

                  _collider3.emit(CollisionEventObject.type, CollisionEventObject);

                  this.collisionArrayMat.set(_shape.id, _shape2.id, false);
                  this.oldContactsDic.set(_shape.id, _shape2.id, null);
                  this._needSyncAfterEvents = true;
                }
              }
            }
          }

          this.contactsDic.reset();
        };

        _proto.gatherConatactData = function gatherConatactData() {
          var numManifolds = bt.Dispatcher_getNumManifolds(this._dispatcher);

          for (var i = 0; i < numManifolds; i++) {
            var manifold = bt.Dispatcher_getManifoldByIndexInternal(this._dispatcher, i);
            var numContacts = bt.PersistentManifold_getNumContacts(manifold);

            for (var j = 0; j < numContacts; j++) {
              var manifoldPoint = bt.PersistentManifold_getContactPoint(manifold, j);
              var s0 = bt.ManifoldPoint_getShape0(manifoldPoint);
              var s1 = bt.ManifoldPoint_getShape1(manifoldPoint);
              var shape0 = BulletCache.getWrapper(s0, BulletShape.TYPE);
              var shape1 = BulletCache.getWrapper(s1, BulletShape.TYPE);

              if (shape0.collider.needTriggerEvent || shape1.collider.needTriggerEvent || shape0.collider.needCollisionEvent || shape1.collider.needCollisionEvent) {
                var item = this.contactsDic.get(shape0.id, shape1.id);

                if (!item) {
                  item = this.contactsDic.set(shape0.id, shape1.id, {
                    shape0: shape0,
                    shape1: shape1,
                    contacts: [],
                    impl: manifold
                  });
                }

                item.contacts.push(manifoldPoint);
              }
            }
          }
        };

        _createClass(BulletWorld, [{
          key: "impl",
          get: function get() {
            return this._world;
          }
        }]);

        return BulletWorld;
      }();

      var BulletBoxShape = function (_BulletShape) {
        _inheritsLoose(BulletBoxShape, _BulletShape);

        function BulletBoxShape() {
          return _BulletShape.apply(this, arguments) || this;
        }

        var _proto = BulletBoxShape.prototype;

        _proto.updateSize = function updateSize() {
          var hf = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(hf, this.getMinUnscaledHalfExtents(VEC3_0));
          bt.BoxShape_setUnscaledHalfExtents(this.impl, hf);
          this.updateCompoundTransform();
        };

        _proto.onComponentSet = function onComponentSet() {
          var hf = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(hf, this.getMinUnscaledHalfExtents(VEC3_0));
          this._impl = bt.BoxShape_new(hf);
          this.updateScale();
        };

        _proto.updateScale = function updateScale() {
          _BulletShape.prototype.updateScale.call(this);

          var bt_v3 = BulletCache.instance.BT_V3_0;
          bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this.getMinScale(VEC3_0)));
          this.updateCompoundTransform();
        };

        _proto.getMinUnscaledHalfExtents = function getMinUnscaledHalfExtents(out) {
          var size = this.collider.size;
          var ws = absolute(VEC3_0.set(this._collider.node.worldScale));
          var minVolumeSize = PhysicsSystem.instance.minVolumeSize;
          var halfSizeX = size.x / 2;
          var halfSizeY = size.y / 2;
          var halfSizeZ = size.z / 2;
          var halfX = halfSizeX * ws.x < minVolumeSize ? minVolumeSize / ws.x : halfSizeX;
          var halfY = halfSizeY * ws.y < minVolumeSize ? minVolumeSize / ws.y : halfSizeY;
          var halfZ = halfSizeZ * ws.z < minVolumeSize ? minVolumeSize / ws.z : halfSizeZ;
          out.set(halfX, halfY, halfZ);
          return out;
        };

        _proto.getMinScale = function getMinScale(out) {
          var size = this.collider.size;
          var ws = absolute(VEC3_0.set(this._collider.node.worldScale));
          var minVolumeSize = PhysicsSystem.instance.minVolumeSize;
          var halfSizeX = size.x / 2;
          var halfSizeY = size.y / 2;
          var halfSizeZ = size.z / 2;
          var scaleX = halfSizeX * ws.x < minVolumeSize ? minVolumeSize / halfSizeX : ws.x;
          var scaleY = halfSizeY * ws.y < minVolumeSize ? minVolumeSize / halfSizeY : ws.y;
          var scaleZ = halfSizeZ * ws.z < minVolumeSize ? minVolumeSize / halfSizeZ : ws.z;
          out.set(scaleX, scaleY, scaleZ);
          return out;
        };

        _createClass(BulletBoxShape, [{
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletBoxShape;
      }(BulletShape);

      var BulletSphereShape = function (_BulletShape) {
        _inheritsLoose(BulletSphereShape, _BulletShape);

        function BulletSphereShape() {
          return _BulletShape.apply(this, arguments) || this;
        }

        var _proto = BulletSphereShape.prototype;

        _proto.updateRadius = function updateRadius() {
          bt.SphereShape_setUnscaledRadius(this.impl, this.getMinUnscaledRadius());
          this.updateCompoundTransform();
        };

        _proto.onComponentSet = function onComponentSet() {
          this._impl = bt.SphereShape_new(this.getMinUnscaledRadius());
          this.updateScale();
        };

        _proto.updateScale = function updateScale() {
          _BulletShape.prototype.updateScale.call(this);

          var scale = this.getMinScale();
          CC_V3_0.set(scale, scale, scale);
          var bt_v3 = BulletCache.instance.BT_V3_0;
          bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, CC_V3_0));
          this.updateCompoundTransform();
        };

        _proto.getMinUnscaledRadius = function getMinUnscaledRadius() {
          var radius = this.collider.radius;
          var ws = Math.abs(absMaxComponent(this._collider.node.worldScale));
          var minVolumeSize = PhysicsSystem.instance.minVolumeSize;
          return ws * radius < minVolumeSize ? minVolumeSize / ws : radius;
        };

        _proto.getMinScale = function getMinScale() {
          var radius = this.collider.radius;
          var ws = Math.abs(absMaxComponent(this._collider.node.worldScale));
          var minVolumeSize = PhysicsSystem.instance.minVolumeSize;
          return ws * radius < minVolumeSize ? minVolumeSize / radius : ws;
        };

        _createClass(BulletSphereShape, [{
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletSphereShape;
      }(BulletShape);

      var BulletCapsuleShape = function (_BulletShape) {
        _inheritsLoose(BulletCapsuleShape, _BulletShape);

        function BulletCapsuleShape() {
          return _BulletShape.apply(this, arguments) || this;
        }

        var _proto = BulletCapsuleShape.prototype;

        _proto.setCylinderHeight = function setCylinderHeight(v) {
          this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.setDirection = function setDirection(v) {
          this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.setRadius = function setRadius(v) {
          this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.onComponentSet = function onComponentSet() {
          this._impl = bt.CapsuleShape_new(0.5, 1);
          this.setRadius(this.collider.radius);
        };

        _proto.updateScale = function updateScale() {
          _BulletShape.prototype.updateScale.call(this);

          this.setRadius(this.collider.radius);
        };

        _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
          var ws = scale;
          var upAxis = direction;
          var wr;
          var halfH;

          if (upAxis === 1) {
            wr = radius * Math.abs(absMax(ws.x, ws.z));
            halfH = height / 2 * Math.abs(ws.y);
          } else if (upAxis === 0) {
            wr = radius * Math.abs(absMax(ws.y, ws.z));
            halfH = height / 2 * Math.abs(ws.x);
          } else {
            wr = radius * Math.abs(absMax(ws.x, ws.y));
            halfH = height / 2 * Math.abs(ws.z);
          }

          bt.CapsuleShape_updateProp(this._impl, wr, halfH, upAxis);
          this.updateCompoundTransform();
        };

        _createClass(BulletCapsuleShape, [{
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletCapsuleShape;
      }(BulletShape);

      var BulletTrimeshShape = function (_BulletShape) {
        _inheritsLoose(BulletTrimeshShape, _BulletShape);

        function BulletTrimeshShape() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _BulletShape.call.apply(_BulletShape, [this].concat(args)) || this;
          _this.refBtTriangleMesh = 0;
          return _this;
        }

        var _proto = BulletTrimeshShape.prototype;

        _proto.setMesh = function setMesh(v) {
          if (!this._isInitialized) return;

          if (this._impl && BulletCache.isNotEmptyShape(this._impl)) {
            warnID(9620);
          } else {
            var mesh = v;

            if (mesh && mesh.renderingSubMeshes.length > 0) {
              var btTriangleMesh = this._getBtTriangleMesh(mesh);

              if (this.collider.convex) {
                this._impl = bt.ConvexTriangleMeshShape_new(btTriangleMesh);
              } else {
                this._impl = bt.BvhTriangleMeshShape_new(btTriangleMesh, true, true);
              }

              var bt_v3 = BulletCache.instance.BT_V3_0;
              cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
              bt.CollisionShape_setMargin(this._impl, 0.01);
              bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
              this.setCompound(this._compound);
              this.updateByReAdd();
              this.setWrapper();
            } else {
              this._impl = bt.EmptyShape_static();
            }
          }
        };

        _proto.onComponentSet = function onComponentSet() {
          this.setMesh(this.collider.mesh);
        };

        _proto.onDestroy = function onDestroy() {
          if (this.refBtTriangleMesh) {
            bt.TriangleMesh_del(this.refBtTriangleMesh);
          }

          _BulletShape.prototype.onDestroy.call(this);
        };

        _proto.updateScale = function updateScale() {
          _BulletShape.prototype.updateScale.call(this);

          var bt_v3 = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
          bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
          this.updateCompoundTransform();
        };

        _proto._getBtTriangleMesh = function _getBtTriangleMesh(mesh) {
          this.refBtTriangleMesh = bt.TriangleMesh_new();
          cocos2BulletTriMesh(this.refBtTriangleMesh, mesh);
          return this.refBtTriangleMesh;
        };

        _createClass(BulletTrimeshShape, [{
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletTrimeshShape;
      }(BulletShape);

      var BulletCylinderShape = function (_BulletShape) {
        _inheritsLoose(BulletCylinderShape, _BulletShape);

        function BulletCylinderShape() {
          return _BulletShape.apply(this, arguments) || this;
        }

        var _proto = BulletCylinderShape.prototype;

        _proto.setHeight = function setHeight(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.setDirection = function setDirection(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.setRadius = function setRadius(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.onComponentSet = function onComponentSet() {
          var bt_v3 = BulletCache.instance.BT_V3_0;
          bt.Vec3_set(bt_v3, 0.5, 1, 0.5);
          this._impl = bt.CylinderShape_new(bt_v3);
          this.setRadius(this.collider.radius);
        };

        _proto.updateScale = function updateScale() {
          _BulletShape.prototype.updateScale.call(this);

          this.setRadius(this.collider.radius);
        };

        _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
          var ws = scale;
          var upAxis = direction;
          var wr;
          var wh;

          if (upAxis === 1) {
            wh = height * Math.abs(ws.y);
            wr = radius * Math.abs(absMax(ws.x, ws.z));
          } else if (upAxis === 0) {
            wh = height * Math.abs(ws.x);
            wr = radius * Math.abs(absMax(ws.y, ws.z));
          } else {
            wh = height * Math.abs(ws.z);
            wr = radius * Math.abs(absMax(ws.x, ws.y));
          }

          bt.CylinderShape_updateProp(this._impl, wr, wh / 2, upAxis);
          this.updateCompoundTransform();
        };

        _createClass(BulletCylinderShape, [{
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletCylinderShape;
      }(BulletShape);

      var BulletConeShape = function (_BulletShape) {
        _inheritsLoose(BulletConeShape, _BulletShape);

        function BulletConeShape() {
          return _BulletShape.apply(this, arguments) || this;
        }

        var _proto = BulletConeShape.prototype;

        _proto.setHeight = function setHeight(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.setDirection = function setDirection(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.setRadius = function setRadius(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        };

        _proto.onComponentSet = function onComponentSet() {
          this._impl = bt.ConeShape_new(0.5, 1);
          this.setRadius(this.collider.radius);
        };

        _proto.updateScale = function updateScale() {
          _BulletShape.prototype.updateScale.call(this);

          this.setRadius(this.collider.radius);
        };

        _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
          var ws = scale;
          var upAxis = direction;
          var wr;
          var wh;

          if (upAxis === 1) {
            wh = height * Math.abs(ws.y);
            wr = radius * Math.abs(absMax(ws.x, ws.z));
          } else if (upAxis === 0) {
            wh = height * Math.abs(ws.x);
            wr = radius * Math.abs(absMax(ws.y, ws.z));
          } else {
            wh = height * Math.abs(ws.z);
            wr = radius * Math.abs(absMax(ws.x, ws.y));
          }

          bt.ConeShape_setRadius(this._impl, wr);
          bt.ConeShape_setHeight(this._impl, wh);
          bt.ConeShape_setConeUpIndex(this._impl, upAxis);
          var bt_v3 = BulletCache.instance.BT_V3_0;
          bt.Vec3_set(bt_v3, 1, 1, 1);
          bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
          this.updateCompoundTransform();
        };

        _createClass(BulletConeShape, [{
          key: "impl",
          get: function get() {
            return this._impl;
          }
        }, {
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletConeShape;
      }(BulletShape);

      var BulletTerrainShape = function (_BulletShape) {
        _inheritsLoose(BulletTerrainShape, _BulletShape);

        function BulletTerrainShape() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _BulletShape.call.apply(_BulletShape, [this].concat(args)) || this;
          _this._bufPtr = 0;
          _this._tileSize = 0;
          _this._localOffset = new Vec3();
          return _this;
        }

        var _proto = BulletTerrainShape.prototype;

        _proto.setTerrain = function setTerrain(v) {
          if (!this._isInitialized) return;

          if (this._impl && BulletCache.isNotEmptyShape(this._impl)) {
            warn('[Physics][Bullet]: change the terrain asset after initialization is not support.');
          } else {
            var terrain = v;

            if (terrain) {
              this._tileSize = terrain.tileSize;
              var sizeI = terrain.getVertexCountI();
              var sizeJ = terrain.getVertexCountJ();
              this._bufPtr = bt._malloc(4 * sizeI * sizeJ);
              var offset = 0;
              var min = Number.MAX_SAFE_INTEGER;
              var max = Number.MIN_SAFE_INTEGER;

              for (var j = 0; j < sizeJ; j++) {
                for (var i = 0; i < sizeI; i++) {
                  var _v = terrain.getHeight(i, j);

                  bt._write_f32(this._bufPtr + offset, _v);

                  if (min > _v) min = _v;
                  if (_v > max) max = _v;
                  offset += 4;
                }
              }

              max += 0.01;
              min -= 0.01;

              this._localOffset.set((sizeI - 1) / 2 * this._tileSize, (max + min) / 2, (sizeJ - 1) / 2 * this._tileSize);

              this._impl = bt.TerrainShape_new(sizeI, sizeJ, this._bufPtr, 1, min, max);
              var bt_v3 = BulletCache.instance.BT_V3_0;
              bt.Vec3_set(bt_v3, this._tileSize, 1, this._tileSize);
              bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
              this.setCompound(this._compound);
              this.updateByReAdd();
              this.setWrapper();
            } else {
              this._impl = bt.EmptyShape_static();
            }
          }
        };

        _proto.onComponentSet = function onComponentSet() {
          this.setTerrain(this.collider.terrain);
        };

        _proto.onDestroy = function onDestroy() {
          if (this._bufPtr) bt._free(this._bufPtr);

          _BulletShape.prototype.onDestroy.call(this);
        };

        _proto.setCenter = function setCenter(v) {
          Vec3.copy(CC_V3_0, v);
          CC_V3_0.add(this._localOffset);
          cocos2BulletVec3(bt.Transform_getOrigin(this.transform), CC_V3_0);
          this.updateCompoundTransform();
        };

        _createClass(BulletTerrainShape, [{
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletTerrainShape;
      }(BulletShape);

      var BulletSimplexShape = function (_BulletShape) {
        _inheritsLoose(BulletSimplexShape, _BulletShape);

        function BulletSimplexShape() {
          return _BulletShape.apply(this, arguments) || this;
        }

        var _proto = BulletSimplexShape.prototype;

        _proto.setShapeType = function setShapeType(v) {};

        _proto.setVertices = function setVertices(v) {};

        _proto.onComponentSet = function onComponentSet() {
          this._impl = bt.SimplexShape_new();
          var length = this.collider.shapeType;
          var vertices = this.collider.vertices;
          var bt_v3 = BulletCache.instance.BT_V3_0;

          for (var i = 0; i < length; i++) {
            bt.SimplexShape_addVertex(this._impl, cocos2BulletVec3(bt_v3, vertices[i]));
          }

          bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this._collider.node.worldScale));
        };

        _proto.onLoad = function onLoad() {
          _BulletShape.prototype.onLoad.call(this);

          this.collider.updateVertices();
        };

        _proto.updateScale = function updateScale() {
          _BulletShape.prototype.updateScale.call(this);

          var bt_v3 = BulletCache.instance.BT_V3_0;
          bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this._collider.node.worldScale));
        };

        _createClass(BulletSimplexShape, [{
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletSimplexShape;
      }(BulletShape);

      var BulletPlaneShape = function (_BulletShape) {
        _inheritsLoose(BulletPlaneShape, _BulletShape);

        function BulletPlaneShape() {
          return _BulletShape.apply(this, arguments) || this;
        }

        var _proto = BulletPlaneShape.prototype;

        _proto.setNormal = function setNormal(v) {
          cocos2BulletVec3(bt.StaticPlaneShape_getPlaneNormal(this.impl), v);
          this.updateCompoundTransform();
        };

        _proto.setConstant = function setConstant(v) {
          bt.StaticPlaneShape_setPlaneConstant(this.impl, v);
          this.updateCompoundTransform();
        };

        _proto.updateScale = function updateScale() {
          _BulletShape.prototype.updateScale.call(this);

          var bt_v3 = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
          bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
          this.updateCompoundTransform();
        };

        _proto.onComponentSet = function onComponentSet() {
          var normal = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(normal, this.collider.normal);
          this._impl = bt.StaticPlaneShape_new(normal, this.collider.constant);
          this.updateScale();
        };

        _createClass(BulletPlaneShape, [{
          key: "collider",
          get: function get() {
            return this._collider;
          }
        }]);

        return BulletPlaneShape;
      }(BulletShape);

      var BulletConstraint = function () {
        function BulletConstraint() {
          this.dirty = 0;
          this.index = -1;
          this._impl = 0;
          this._collided = false;
        }

        var _proto = BulletConstraint.prototype;

        _proto.setConnectedBody = function setConnectedBody(v) {};

        _proto.setEnableCollision = function setEnableCollision(v) {
          if (this._collided !== v) {
            this._collided = v;
            this.updateByReAdd();
          }
        };

        _proto.updateByReAdd = function updateByReAdd() {
          if (this._rigidBody && this.index >= 0) {
            var sb = this._rigidBody.body.sharedBody;
            sb.wrappedWorld.removeConstraint(this);
            sb.wrappedWorld.addConstraint(this);
          }
        };

        _proto.initialize = function initialize(v) {
          this._com = v;
          this._rigidBody = v.attachedBody;
          this._collided = v.enableCollision;
          this.onComponentSet();
        };

        _proto.onEnable = function onEnable() {
          var sb = this._rigidBody.body.sharedBody;
          sb.wrappedWorld.addConstraint(this);
          sb.addJoint(this, 0);
          var connect = this.constraint.connectedBody;

          if (connect) {
            var sb2 = connect.body.sharedBody;
            sb2.addJoint(this, 1);
          }
        };

        _proto.onDisable = function onDisable() {
          var sb = this._rigidBody.body.sharedBody;
          sb.wrappedWorld.removeConstraint(this);
          sb.removeJoint(this, 0);
          var connect = this.constraint.connectedBody;

          if (connect) {
            var sb2 = connect.body.sharedBody;
            sb2.removeJoint(this, 1);
          }
        };

        _proto.onDestroy = function onDestroy() {
          bt.TypedConstraint_del(this._impl);
          this._com = null;
          this._rigidBody = null;
        };

        _createClass(BulletConstraint, [{
          key: "impl",
          get: function get() {
            return this._impl;
          }
        }, {
          key: "constraint",
          get: function get() {
            return this._com;
          }
        }]);

        return BulletConstraint;
      }();

      var BulletP2PConstraint = function (_BulletConstraint) {
        _inheritsLoose(BulletP2PConstraint, _BulletConstraint);

        function BulletP2PConstraint() {
          return _BulletConstraint.apply(this, arguments) || this;
        }

        var _proto = BulletP2PConstraint.prototype;

        _proto.setPivotA = function setPivotA(v) {
          var cs = this.constraint;
          var pivotA = BulletCache.instance.BT_V3_0;
          Vec3.multiply(CC_V3_0, cs.node.worldScale, cs.pivotA);
          cocos2BulletVec3(pivotA, CC_V3_0);
          bt.P2PConstraint_setPivotA(this._impl, pivotA);
          if (!cs.connectedBody) this.setPivotB(cs.pivotB);
        };

        _proto.setPivotB = function setPivotB(v) {
          var cs = this.constraint;
          var node = this._rigidBody.node;
          var pivotB = BulletCache.instance.BT_V3_0;
          var cb = cs.connectedBody;

          if (cb) {
            Vec3.multiply(CC_V3_0, cb.node.worldScale, cs.pivotB);
            cocos2BulletVec3(pivotB, CC_V3_0);
          } else {
            Vec3.multiply(CC_V3_0, node.worldScale, cs.pivotA);
            Vec3.add(CC_V3_0, CC_V3_0, node.worldPosition);
            Vec3.add(CC_V3_0, CC_V3_0, cs.pivotB);
            cocos2BulletVec3(pivotB, CC_V3_0);
          }

          bt.P2PConstraint_setPivotB(this._impl, pivotB);
        };

        _proto.onComponentSet = function onComponentSet() {
          var cb = this.constraint.connectedBody;
          var bodyA = this._rigidBody.body.impl;
          var bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
          var pivotA = BulletCache.instance.BT_V3_0;
          var pivotB = BulletCache.instance.BT_V3_1;
          this._impl = bt.P2PConstraint_new(bodyA, bodyB, pivotA, pivotB);
          this.setPivotA(this.constraint.pivotA);
          this.setPivotB(this.constraint.pivotB);
        };

        _proto.updateScale0 = function updateScale0() {
          this.setPivotA(this.constraint.pivotA);
        };

        _proto.updateScale1 = function updateScale1() {
          this.setPivotB(this.constraint.pivotB);
        };

        _createClass(BulletP2PConstraint, [{
          key: "constraint",
          get: function get() {
            return this._com;
          }
        }]);

        return BulletP2PConstraint;
      }(BulletConstraint);

      var BulletHingeConstraint = function (_BulletConstraint) {
        _inheritsLoose(BulletHingeConstraint, _BulletConstraint);

        function BulletHingeConstraint() {
          return _BulletConstraint.apply(this, arguments) || this;
        }

        var _proto = BulletHingeConstraint.prototype;

        _proto.setPivotA = function setPivotA(v) {
          this.updateFrames();
        };

        _proto.setPivotB = function setPivotB(v) {
          this.updateFrames();
        };

        _proto.setAxis = function setAxis(v) {
          this.updateFrames();
        };

        _proto.onComponentSet = function onComponentSet() {
          var cb = this.constraint.connectedBody;
          var bodyA = this._rigidBody.body.impl;
          var bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
          var trans0 = BulletCache.instance.BT_TRANSFORM_0;
          var trans1 = BulletCache.instance.BT_TRANSFORM_1;
          this._impl = bt.HingeConstraint_new(bodyA, bodyB, trans0, trans1);
          this.updateFrames();
        };

        _proto.updateFrames = function updateFrames() {
          var cs = this.constraint;
          var node = cs.node;
          var v3_0 = CC_V3_0;
          var rot_0 = CC_QUAT_0;
          var trans0 = BulletCache.instance.BT_TRANSFORM_0;
          Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
          cocos2BulletVec3(bt.Transform_getOrigin(trans0), v3_0);
          var quat = BulletCache.instance.BT_QUAT_0;
          Quat.rotationTo(rot_0, Vec3.UNIT_Z, cs.axis);
          cocos2BulletQuat(quat, rot_0);
          bt.Transform_setRotation(trans0, quat);
          var trans1 = BulletCache.instance.BT_TRANSFORM_1;
          var cb = this.constraint.connectedBody;

          if (cb) {
            Vec3.multiply(v3_0, cb.node.worldScale, cs.pivotB);
          } else {
            Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
            Vec3.add(v3_0, v3_0, node.worldPosition);
            Vec3.add(v3_0, v3_0, cs.pivotB);
            Quat.multiply(rot_0, rot_0, node.worldRotation);
          }

          cocos2BulletVec3(bt.Transform_getOrigin(trans1), v3_0);
          cocos2BulletQuat(quat, rot_0);
          bt.Transform_setRotation(trans1, quat);
          bt.HingeConstraint_setFrames(this._impl, trans0, trans1);
        };

        _proto.updateScale0 = function updateScale0() {
          this.updateFrames();
        };

        _proto.updateScale1 = function updateScale1() {
          this.updateFrames();
        };

        _createClass(BulletHingeConstraint, [{
          key: "constraint",
          get: function get() {
            return this._com;
          }
        }]);

        return BulletHingeConstraint;
      }(BulletConstraint);

      game.once(Game.EVENT_PRE_SUBSYSTEM_INIT, function () {
        selector.register('bullet', {
          PhysicsWorld: BulletWorld,
          RigidBody: BulletRigidBody,
          BoxShape: BulletBoxShape,
          SphereShape: BulletSphereShape,
          CapsuleShape: BulletCapsuleShape,
          TrimeshShape: BulletTrimeshShape,
          CylinderShape: BulletCylinderShape,
          ConeShape: BulletConeShape,
          TerrainShape: BulletTerrainShape,
          SimplexShape: BulletSimplexShape,
          PlaneShape: BulletPlaneShape,
          PointToPointConstraint: BulletP2PConstraint,
          HingeConstraint: BulletHingeConstraint
        });
      });

      var Counter = function () {
        function Counter(id, opts, now) {
          this._id = void 0;
          this._opts = void 0;
          this._accumStart = void 0;
          this._total = 0;
          this._value = 0;
          this._averageValue = 0;
          this._accumValue = 0;
          this._accumSamples = 0;
          this._id = id;
          this._opts = opts;
          this._accumStart = now;
        }

        var _proto = Counter.prototype;

        _proto.sample = function sample(now) {
          this._average(this._value, now);
        };

        _proto.human = function human() {
          var _this$_opts = this._opts,
              average = _this$_opts.average,
              isInteger = _this$_opts.isInteger;
          var v = average ? this._averageValue : this._value;
          return isInteger ? Math.round(v) : Math.round(v * 100) / 100;
        };

        _proto.alarm = function alarm() {
          return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
        };

        _proto._average = function _average(v, now) {
          if (now === void 0) {
            now = 0;
          }

          if (this._opts.average) {
            this._accumValue += v;
            ++this._accumSamples;
            var t = now;

            if (t - this._accumStart >= this._opts.average) {
              this._averageValue = this._accumValue / this._accumSamples;
              this._accumValue = 0;
              this._accumStart = t;
              this._accumSamples = 0;
            }
          }
        };

        _createClass(Counter, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(val) {
            this._value = val;
          }
        }]);

        return Counter;
      }();

      var _dec$1j, _class$1k, _temp$1e;
      var PerfCounter = (_dec$1j = ccclass('cc.PerfCounter'), _dec$1j(_class$1k = (_temp$1e = function (_Counter) {
        _inheritsLoose(PerfCounter, _Counter);

        function PerfCounter(id, opts, now) {
          var _this;

          _this = _Counter.call(this, id, opts, now) || this;
          _this._time = void 0;
          _this._time = now;
          return _this;
        }

        var _proto = PerfCounter.prototype;

        _proto.start = function start(now) {
          if (now === void 0) {
            now = 0;
          }

          this._time = now;
        };

        _proto.end = function end(now) {
          if (now === void 0) {
            now = 0;
          }

          this._value = now - this._time;

          this._average(this._value);
        };

        _proto.tick = function tick() {
          this.end();
          this.start();
        };

        _proto.frame = function frame(now) {
          var t = now;
          var e = t - this._time;
          this._total++;
          var avg = this._opts.average || 1000;

          if (e > avg) {
            this._value = this._total * 1000 / e;
            this._total = 0;
            this._time = t;

            this._average(this._value);
          }
        };

        return PerfCounter;
      }(Counter), _temp$1e)) || _class$1k);

      var _characters = '0123456789. ';
      var _average = 500;
      var _string2offset = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        '.': 10
      };
      var _profileInfo = {
        fps: {
          desc: "Framerate (FPS)",
          below: 30,
          average: _average,
          isInteger: true
        },
        draws: {
          desc: 'Draw call',
          isInteger: true
        },
        frame: {
          desc: 'Frame time (ms)',
          min: 0,
          max: 50,
          average: _average
        },
        instances: {
          desc: 'Instance Count',
          isInteger: true
        },
        tricount: {
          desc: 'Triangle',
          isInteger: true
        },
        logic: {
          desc: 'Game Logic (ms)',
          min: 0,
          max: 50,
          average: _average,
          color: '#080'
        },
        physics: {
          desc: 'Physics (ms)',
          min: 0,
          max: 50,
          average: _average
        },
        render: {
          desc: 'Renderer (ms)',
          min: 0,
          max: 50,
          average: _average,
          color: '#f90'
        },
        textureMemory: {
          desc: 'GFX Texture Mem(M)'
        },
        bufferMemory: {
          desc: 'GFX Buffer Mem(M)'
        }
      };
      var _constants = {
        fontSize: 23,
        quadHeight: 0.4,
        segmentsPerLine: 8,
        textureWidth: 256,
        textureHeight: 256
      };
      var Profiler = exports('Profiler', function (_System) {
        _inheritsLoose(Profiler, _System);

        function Profiler() {
          var _this;

          _this = _System.call(this) || this;
          _this._stats = null;
          _this._showFPS = false;
          _this._rootNode = null;
          _this._device = null;
          _this._swapchain = null;
          _this._pipeline = null;
          _this._meshRenderer = null;
          _this._canvas = null;
          _this._ctx = null;
          _this._texture = null;
          _this._region = new BufferTextureCopy();
          _this._canvasArr = [];
          _this._regionArr = [_this._region];
          _this.digitsData = null;
          _this.offsetData = null;
          _this.pass = null;
          _this._canvasDone = false;
          _this._statsDone = false;
          _this._inited = false;
          _this._lineHeight = _constants.textureHeight / (Object.keys(_profileInfo).length + 1);
          _this._wordHeight = 0;
          _this._eachNumWidth = 0;
          _this._totalLines = 0;
          _this.lastTime = 0;

          {
            _this._canvas = document.createElement('canvas');
            _this._ctx = _this._canvas.getContext('2d');

            _this._canvasArr.push(_this._canvas);
          }

          return _this;
        }

        var _proto = Profiler.prototype;

        _proto.init = function init() {
          var showFPS = !!settings.querySettings(Settings.Category.PROFILING, 'showFPS');

          if (showFPS) {
            this.showStats();
          } else {
            this.hideStats();
          }
        };

        _proto.isShowingStats = function isShowingStats() {
          return this._showFPS;
        };

        _proto.hideStats = function hideStats() {
          if (this._showFPS) {
            if (this._rootNode) {
              this._rootNode.active = false;
            }

            legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
            legacyCC.director.off(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
            legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
            legacyCC.director.off(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
            legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
            legacyCC.director.off(legacyCC.Director.EVENT_AFTER_DRAW, this.afterDraw, this);
            this._showFPS = false;
            director.root.pipeline.profiler = null;
            legacyCC.game.config.showFPS = false;
          }
        };

        _proto.showStats = function showStats() {
          if (!this._showFPS) {
            if (!this._device) {
              var root = legacyCC.director.root;
              this._device = deviceManager.gfxDevice;
              this._swapchain = root.mainWindow.swapchain;
              this._pipeline = root.pipeline;
            }

            {
              this.generateCanvas();
            }

            this.generateStats();

            {
              legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this.generateNode, this);
              legacyCC.game.on(legacyCC.Game.EVENT_RESTART, this.generateNode, this);
            }

            if (this._rootNode) {
              this._rootNode.active = true;
            }

            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
            legacyCC.director.on(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
            legacyCC.director.on(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
            legacyCC.director.on(legacyCC.Director.EVENT_AFTER_DRAW, this.afterDraw, this);
            this._showFPS = true;
            this._canvasDone = true;
            this._statsDone = true;
            legacyCC.game.config.showFPS = true;
          }
        };

        _proto.generateCanvas = function generateCanvas() {
          if (this._canvasDone) {
            return;
          }

          var textureWidth = _constants.textureWidth,
              textureHeight = _constants.textureHeight;

          if (!this._ctx || !this._canvas) {
            return;
          }

          this._canvas.width = textureWidth;
          this._canvas.height = textureHeight;
          this._canvas.style.width = "" + this._canvas.width;
          this._canvas.style.height = "" + this._canvas.height;
          this._ctx.font = _constants.fontSize + "px Arial";
          this._ctx.textBaseline = 'top';
          this._ctx.fillStyle = '#fff';
          this._texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, textureWidth, textureHeight));
          this._region.texExtent.width = textureWidth;
          this._region.texExtent.height = textureHeight;
        };

        _proto.generateStats = function generateStats() {
          if (this._statsDone || !this._ctx || !this._canvas) {
            return;
          }

          this._stats = null;
          var now = performance.now();
          this._ctx.textAlign = 'left';
          var i = 0;

          for (var id in _profileInfo) {
            var element = _profileInfo[id];
            this._ctx.fillText(element.desc, 0, i * this._lineHeight);
            element.counter = new PerfCounter(id, element, now);
            i++;
          }

          this._totalLines = i;
          this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;

          {
            for (var j = 0; j < _characters.length; ++j) {
              var offset = this._ctx.measureText(_characters[j]).width;

              this._eachNumWidth = Math.max(this._eachNumWidth, offset);
            }

            for (var _j = 0; _j < _characters.length; ++_j) {
              this._ctx.fillText(_characters[_j], _j * this._eachNumWidth, this._totalLines * this._lineHeight);
            }
          }

          this._eachNumWidth /= this._canvas.width;
          this._stats = _profileInfo;
          this._canvasArr[0] = this._canvas;
          this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
        };

        _proto.generateNode = function generateNode() {
          if (this._rootNode && this._rootNode.isValid) {
            return;
          }

          this._rootNode = new Node('PROFILER_NODE');
          this._rootNode._objFlags = legacyCC.Object.Flags.DontSave | legacyCC.Object.Flags.HideInHierarchy;
          legacyCC.game.addPersistRootNode(this._rootNode);
          var managerNode = new Node('Profiler_Root');
          managerNode.parent = this._rootNode;
          var height = _constants.quadHeight;
          var rowHeight = height / this._totalLines;
          var lWidth = height / this._wordHeight;
          var scale = rowHeight / _constants.fontSize;
          var columnWidth = this._eachNumWidth * this._canvas.width * scale;
          var vertexPos = [0, height, 0, lWidth, height, 0, lWidth, 0, 0, 0, 0, 0];
          var vertexindices = [0, 2, 1, 0, 3, 2];
          var vertexUV = [0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0];
          var offset = 0;

          for (var i = 0; i < this._totalLines; i++) {
            for (var j = 0; j < _constants.segmentsPerLine; j++) {
              vertexPos.push(lWidth + j * columnWidth, height - i * rowHeight, 0);
              vertexPos.push(lWidth + (j + 1) * columnWidth, height - i * rowHeight, 0);
              vertexPos.push(lWidth + (j + 1) * columnWidth, height - (i + 1) * rowHeight, 0);
              vertexPos.push(lWidth + j * columnWidth, height - (i + 1) * rowHeight, 0);
              offset = (i * _constants.segmentsPerLine + j + 1) * 4;
              vertexindices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
              var idx = i * _constants.segmentsPerLine + j;
              var z = Math.floor(idx / 4);
              var w = idx - z * 4;
              vertexUV.push(0, this._wordHeight, z, w);
              vertexUV.push(this._eachNumWidth, this._wordHeight, z, w);
              vertexUV.push(this._eachNumWidth, 1, z, w);
              vertexUV.push(0, 1, z, w);
            }
          }

          this._meshRenderer = managerNode.addComponent(MeshRenderer);
          this._meshRenderer.mesh = _createMesh({
            positions: vertexPos,
            indices: vertexindices,
            colors: vertexUV
          });

          var _material = new Material();

          _material.initialize({
            effectName: 'util/profiler'
          });

          var pass = this.pass = _material.passes[0];
          var hTexture = pass.getBinding('mainTexture');
          var bDigits = pass.getBinding('digits');
          var bOffset = pass.getBinding('offset');
          pass.bindTexture(hTexture, this._texture);
          this.digitsData = pass.blocks[bDigits];
          this.offsetData = pass.blocks[bOffset];
          this.offsetData[3] = -1;
          this._meshRenderer.material = _material;
          this._meshRenderer.node.layer = Layers.Enum.PROFILER;
          this._inited = true;
        };

        _proto.beforeUpdate = function beforeUpdate() {
          if (!this._stats) {
            return;
          }

          var now = performance.now();

          this._stats.frame.counter.start(now);

          this._stats.logic.counter.start(now);
        };

        _proto.afterUpdate = function afterUpdate() {
          if (!this._stats) {
            return;
          }

          var now = performance.now();

          if (legacyCC.director.isPaused()) {
            this._stats.frame.counter.start(now);
          } else {
            this._stats.logic.counter.end(now);
          }
        };

        _proto.beforePhysics = function beforePhysics() {
          if (!this._stats) {
            return;
          }

          var now = performance.now();

          this._stats.physics.counter.start(now);
        };

        _proto.afterPhysics = function afterPhysics() {
          if (!this._stats) {
            return;
          }

          var now = performance.now();

          this._stats.physics.counter.end(now);
        };

        _proto.beforeDraw = function beforeDraw() {
          if (!this._stats || !this._inited) {
            return;
          }

          {
            var surfaceTransform = this._swapchain.surfaceTransform;
            var clipSpaceSignY = this._device.capabilities.clipSpaceSignY;

            if (surfaceTransform !== this.offsetData[3]) {
              var preTransform = preTransforms[surfaceTransform];
              var x = -0.9;
              var y = -0.9 * clipSpaceSignY;

              if (sys.isXR) {
                x = -0.5;
                y = -0.5 * clipSpaceSignY;
              }

              this.offsetData[0] = x * preTransform[0] + y * preTransform[2];
              this.offsetData[1] = x * preTransform[1] + y * preTransform[3];
              this.offsetData[2] = this._eachNumWidth;
              this.offsetData[3] = surfaceTransform;
            }

            this.pass._rootBufferDirty = true;
          }

          if (this._meshRenderer.model) {
            director.root.pipeline.profiler = this._meshRenderer.model;
          } else {
            director.root.pipeline.profiler = null;
          }

          var now = performance.now();

          this._stats.render.counter.start(now);
        };

        _proto.afterDraw = function afterDraw() {
          if (!this._stats || !this._inited) {
            return;
          }

          var now = performance.now();

          this._stats.frame.counter.end(now);

          this._stats.fps.counter.frame(now);

          this._stats.render.counter.end(now);

          if (now - this.lastTime < _average) {
            return;
          }

          this.lastTime = now;
          var device = this._device;
          this._stats.draws.counter.value = device.numDrawCalls;
          this._stats.instances.counter.value = device.numInstances;
          this._stats.bufferMemory.counter.value = device.memoryStatus.bufferSize / (1024 * 1024);
          this._stats.textureMemory.counter.value = device.memoryStatus.textureSize / (1024 * 1024);
          this._stats.tricount.counter.value = device.numTris;
          var i = 0;

          {
            var view = this.digitsData;

            for (var id in this._stats) {
              var stat = this._stats[id];
              stat.counter.sample(now);
              var result = stat.counter.human().toString();

              for (var j = _constants.segmentsPerLine - 1; j >= 0; j--) {
                var index = i * _constants.segmentsPerLine + j;
                var character = result[result.length - (_constants.segmentsPerLine - j)];
                var offset = _string2offset[character];

                if (offset === undefined) {
                  offset = 11;
                }

                view[index] = offset;
              }

              i++;
            }
          }
        };

        return Profiler;
      }(System));
      var profiler = exports('profiler', new Profiler());
      director.registerSystem('profiler', profiler, 0);
      legacyCC.profiler = profiler;

      var DeviceType;

      (function (DeviceType) {
        DeviceType[DeviceType["Other"] = 0] = "Other";
        DeviceType[DeviceType["Left"] = 1] = "Left";
        DeviceType[DeviceType["Right"] = 2] = "Right";
      })(DeviceType || (DeviceType = {}));

      var XrUIPressEventType;

      (function (XrUIPressEventType) {
        XrUIPressEventType["XRUI_HOVER_ENTERED"] = "xrui-hover-entered";
        XrUIPressEventType["XRUI_HOVER_EXITED"] = "xrui-hover-exited";
        XrUIPressEventType["XRUI_HOVER_STAY"] = "xrui-hover-stay";
        XrUIPressEventType["XRUI_CLICK"] = "xrui-click";
        XrUIPressEventType["XRUI_UNCLICK"] = "xrui-unclick";
      })(XrUIPressEventType || (XrUIPressEventType = {}));

      var XrKeyboardEventType;

      (function (XrKeyboardEventType) {
        XrKeyboardEventType["XR_CAPS_LOCK"] = "xr-caps-lock";
        XrKeyboardEventType["XR_KEYBOARD_INIT"] = "xr-keyboard-init";
        XrKeyboardEventType["XR_KEYBOARD_INPUT"] = "xr-keyboard-input";
        XrKeyboardEventType["TO_LATIN"] = "to-latin";
        XrKeyboardEventType["TO_SYMBOL"] = "to-symbol";
        XrKeyboardEventType["TO_MATH_SYMBOL"] = "to-math-symbol";
      })(XrKeyboardEventType || (XrKeyboardEventType = {}));

      var XrUIPressEvent = function (_Event) {
        _inheritsLoose(XrUIPressEvent, _Event);

        function XrUIPressEvent() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Event.call.apply(_Event, [this].concat(args)) || this;
          _this.deviceType = DeviceType.Other;
          _this.hitPoint = new Vec3();
          return _this;
        }

        return XrUIPressEvent;
      }(Event);

      var _dec$1k, _dec2$10, _dec3$Y, _dec4$T, _dec5$P, _dec6$J, _dec7$F, _dec8$A, _dec9$v, _dec10$s, _dec11$q, _dec12$p, _dec13$n, _dec14$l, _dec15$l, _dec16$k, _dec17$j, _dec18$i, _dec19$h, _dec20$h, _dec21$h, _dec22$f, _dec23$e, _dec24$e, _dec25$d, _dec26$d, _dec27$d, _dec28$c, _dec29$c, _dec30$a, _dec31$a, _dec32$7, _dec33$5, _dec34$5, _dec35$5, _dec36$5, _dec37$5, _dec38$5, _dec39$5, _dec40$5, _dec41$5, _dec42$5, _class$1l, _class2$1c, _descriptor$18, _descriptor2$_, _descriptor3$M, _descriptor4$C, _descriptor5$v, _descriptor6$r, _descriptor7$l, _descriptor8$j, _descriptor9$g, _descriptor10$d, _descriptor11$a, _descriptor12$a, _descriptor13$a, _descriptor14$5, _class3$h, _temp$1f;

      var _tempColor = new Color();

      var Transition;

      (function (Transition) {
        Transition[Transition["NONE"] = 0] = "NONE";
        Transition[Transition["COLOR"] = 1] = "COLOR";
        Transition[Transition["SPRITE"] = 2] = "SPRITE";
        Transition[Transition["SCALE"] = 3] = "SCALE";
      })(Transition || (Transition = {}));

      ccenum(Transition);
      var State;

      (function (State) {
        State["NORMAL"] = "normal";
        State["HOVER"] = "hover";
        State["PRESSED"] = "pressed";
        State["DISABLED"] = "disabled";
      })(State || (State = {}));

      var EventType$2;

      (function (EventType) {
        EventType["CLICK"] = "click";
      })(EventType$2 || (EventType$2 = {}));

      var Button = function (v) { return exports({ Button: v, ButtonComponent: v }), v; }((_dec$1k = ccclass('cc.Button'), _dec2$10 = help(), _dec3$Y = executionOrder(110), _dec4$T = menu(), _dec5$P = requireComponent(UITransform), _dec6$J = type(Node), _dec7$F = displayOrder(), _dec8$A = tooltip(), _dec9$v = displayOrder(), _dec10$s = tooltip(), _dec11$q = type(Transition), _dec12$p = displayOrder(), _dec13$n = tooltip(), _dec14$l = displayOrder(), _dec15$l = tooltip(), _dec16$k = displayOrder(), _dec17$j = tooltip(), _dec18$i = displayOrder(), _dec19$h = tooltip(), _dec20$h = displayOrder(), _dec21$h = tooltip(), _dec22$f = rangeMin(), _dec23$e = rangeMax(), _dec24$e = displayOrder(), _dec25$d = tooltip(), _dec26$d = displayOrder(), _dec27$d = tooltip(), _dec28$c = type(SpriteFrame), _dec29$c = displayOrder(), _dec30$a = tooltip(), _dec31$a = type(SpriteFrame), _dec32$7 = displayOrder(), _dec33$5 = tooltip(), _dec34$5 = type(SpriteFrame), _dec35$5 = displayOrder(), _dec36$5 = tooltip(), _dec37$5 = type(SpriteFrame), _dec38$5 = displayOrder(), _dec39$5 = tooltip(), _dec40$5 = type([EventHandler]), _dec41$5 = displayOrder(), _dec42$5 = tooltip(), _dec$1k(_class$1l = _dec2$10(_class$1l = _dec3$Y(_class$1l = _dec4$T(_class$1l = _dec5$P(_class$1l = executeInEditMode(_class$1l = (_class2$1c = (_temp$1f = _class3$h = function (_Component) {
        _inheritsLoose(Button, _Component);

        function Button() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "clickEvents", _descriptor$18, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_interactable", _descriptor2$_, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_transition", _descriptor3$M, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_normalColor", _descriptor4$C, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_hoverColor", _descriptor5$v, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pressedColor", _descriptor6$r, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_disabledColor", _descriptor7$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_normalSprite", _descriptor8$j, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_hoverSprite", _descriptor9$g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pressedSprite", _descriptor10$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_disabledSprite", _descriptor11$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_duration", _descriptor12$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_zoomScale", _descriptor13$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_target", _descriptor14$5, _assertThisInitialized(_this));

          _this._pressed = false;
          _this._hovered = false;
          _this._fromColor = new Color();
          _this._toColor = new Color();
          _this._time = 0;
          _this._transitionFinished = true;
          _this._fromScale = new Vec3();
          _this._toScale = new Vec3();
          _this._originalScale = null;
          _this._sprite = null;
          _this._targetScale = new Vec3();
          return _this;
        }

        var _proto = Button.prototype;

        _proto.__preload = function __preload() {
          if (!this.target) {
            this.target = this.node;
          }

          var sprite = this.node.getComponent(Sprite);

          if (sprite) {
            this._normalSprite = sprite.spriteFrame;
          }

          this._applyTarget();

          this._resetState();
        };

        _proto.onEnable = function onEnable() {

          {
            this._registerNodeEvent();
          }
        };

        _proto.onDisable = function onDisable() {
          this._resetState();

          {
            this._unregisterNodeEvent();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this.target.isValid) {
            this._unregisterTargetEvent(this.target);
          }
        };

        _proto.update = function update(dt) {
          var target = this.target;

          if (this._transitionFinished || !target) {
            return;
          }

          if (this._transition !== Transition.COLOR && this._transition !== Transition.SCALE) {
            return;
          }

          this._time += dt;
          var ratio = 1.0;

          if (this._duration > 0) {
            ratio = this._time / this._duration;
          }

          if (ratio >= 1) {
            ratio = 1;
          }

          if (this._transition === Transition.COLOR) {
            var renderComp = target._uiProps.uiComp;
            Color.lerp(_tempColor, this._fromColor, this._toColor, ratio);

            if (renderComp) {
              renderComp.color = _tempColor;
            }
          } else if (this.transition === Transition.SCALE) {
            target.getScale(this._targetScale);
            this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio);
            this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio);
            target.setScale(this._targetScale);
          }

          if (ratio === 1) {
            this._transitionFinished = true;
          }
        };

        _proto._resizeNodeToTargetNode = function _resizeNodeToTargetNode() {
          if (!this.target) {
            return;
          }

          var targetTrans = this.target._uiProps.uiTransformComp;
        };

        _proto._resetState = function _resetState() {
          this._pressed = false;
          this._hovered = false;
          var target = this.target;

          if (!target) {
            return;
          }

          var transition = this._transition;

          if (transition === Transition.COLOR && this._interactable) {
            var renderComp = target.getComponent(UIRenderer);

            if (renderComp) {
              renderComp.color = this._normalColor;
            }
          } else if (transition === Transition.SCALE && this._originalScale) {
            target.setScale(this._originalScale);
          }

          this._transitionFinished = true;
        };

        _proto._registerNodeEvent = function _registerNodeEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
          this.node.on(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
          this.node.on(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          this.node.on(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
        };

        _proto._registerTargetEvent = function _registerTargetEvent(target) {

          target.on(NodeEventType.TRANSFORM_CHANGED, this._onTargetTransformChanged, this);
        };

        _proto._unregisterNodeEvent = function _unregisterNodeEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
          this.node.off(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
          this.node.off(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          this.node.off(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
        };

        _proto._unregisterTargetEvent = function _unregisterTargetEvent(target) {

          target.off(NodeEventType.TRANSFORM_CHANGED);
        };

        _proto._getTargetSprite = function _getTargetSprite(target) {
          var sprite = null;

          if (target) {
            sprite = target.getComponent(Sprite);
          }

          return sprite;
        };

        _proto._applyTarget = function _applyTarget() {
          if (this.target) {
            this._sprite = this._getTargetSprite(this.target);

            if (!this._originalScale) {
              this._originalScale = new Vec3();
            }

            Vec3.copy(this._originalScale, this.target.getScale());

            this._registerTargetEvent(this.target);
          }
        };

        _proto._onTargetSpriteFrameChanged = function _onTargetSpriteFrameChanged(comp) {
          if (this._transition === Transition.SPRITE) {
            this._setCurrentStateSpriteFrame(comp.spriteFrame);
          }
        };

        _proto._setCurrentStateSpriteFrame = function _setCurrentStateSpriteFrame(spriteFrame) {
          if (!spriteFrame) {
            return;
          }

          switch (this._getButtonState()) {
            case State.NORMAL:
              this._normalSprite = spriteFrame;
              break;

            case State.HOVER:
              this._hoverSprite = spriteFrame;
              break;

            case State.PRESSED:
              this._pressedSprite = spriteFrame;
              break;

            case State.DISABLED:
              this._disabledSprite = spriteFrame;
              break;
          }
        };

        _proto._onTargetColorChanged = function _onTargetColorChanged(color) {
          if (this._transition === Transition.COLOR) {
            this._setCurrentStateColor(color);
          }
        };

        _proto._setCurrentStateColor = function _setCurrentStateColor(color) {
          switch (this._getButtonState()) {
            case State.NORMAL:
              this._normalColor = color;
              break;

            case State.HOVER:
              this._hoverColor = color;
              break;

            case State.PRESSED:
              this._pressedColor = color;
              break;

            case State.DISABLED:
              this._disabledColor = color;
              break;
          }
        };

        _proto._onTargetTransformChanged = function _onTargetTransformChanged(transformBit) {
          if (transformBit & TransformBit.SCALE && this._originalScale && this._transition === Transition.SCALE && this._transitionFinished) {
            Vec3.copy(this._originalScale, this.target.getScale());
          }
        };

        _proto._onTouchBegan = function _onTouchBegan(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }

          this._pressed = true;

          this._updateState();

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._onTouchMove = function _onTouchMove(event) {
          if (!this._interactable || !this.enabledInHierarchy || !this._pressed) {
            return;
          }

          if (!event) {
            return;
          }

          var touch = event.touch;

          if (!touch) {
            return;
          }

          var hit = this.node._uiProps.uiTransformComp.hitTest(touch.getLocation());

          if (this._transition === Transition.SCALE && this.target && this._originalScale) {
            if (hit) {
              Vec3.copy(this._fromScale, this._originalScale);
              Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
              this._transitionFinished = false;
            } else {
              this._time = 0;
              this._transitionFinished = true;
              this.target.setScale(this._originalScale);
            }
          } else {
            var state;

            if (hit) {
              state = State.PRESSED;
            } else {
              state = State.NORMAL;
            }

            this._applyTransition(state);
          }

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._onTouchEnded = function _onTouchEnded(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }

          if (this._pressed) {
            EventHandler.emitEvents(this.clickEvents, event);
            this.node.emit(EventType$2.CLICK, this);
          }

          this._pressed = false;

          this._updateState();

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._onTouchCancel = function _onTouchCancel(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }

          this._pressed = false;

          this._updateState();
        };

        _proto._onMouseMoveIn = function _onMouseMoveIn(event) {
          if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
            return;
          }

          if (this._transition === Transition.SPRITE && !this._hoverSprite) {
            return;
          }

          if (!this._hovered) {
            this._hovered = true;

            this._updateState();
          }
        };

        _proto._onMouseMoveOut = function _onMouseMoveOut(event) {
          if (this._hovered) {
            this._hovered = false;

            this._updateState();
          }
        };

        _proto._updateState = function _updateState() {
          var state = this._getButtonState();

          this._applyTransition(state);
        };

        _proto._getButtonState = function _getButtonState() {
          var state = State.NORMAL;

          if (!this._interactable) {
            state = State.DISABLED;
          } else if (this._pressed) {
            state = State.PRESSED;
          } else if (this._hovered) {
            state = State.HOVER;
          }

          return state.toString();
        };

        _proto._updateColorTransition = function _updateColorTransition(state) {
          var _this$target;

          var color = this[state + "Color"];
          var renderComp = (_this$target = this.target) === null || _this$target === void 0 ? void 0 : _this$target.getComponent(UIRenderer);

          if (!renderComp) {
            return;
          }

          if ( state === State.DISABLED) {
            renderComp.color = color;
          } else {
            this._fromColor = renderComp.color.clone();
            this._toColor = color;
            this._time = 0;
            this._transitionFinished = false;
          }
        };

        _proto._updateSpriteTransition = function _updateSpriteTransition(state) {
          var sprite = this[state + "Sprite"];

          if (this._sprite && sprite) {
            this._sprite.spriteFrame = sprite;
          }
        };

        _proto._updateScaleTransition = function _updateScaleTransition(state) {
          if (!this._interactable) {
            return;
          }

          if (state === State.PRESSED) {
            this._zoomUp();
          } else {
            this._zoomBack();
          }
        };

        _proto._zoomUp = function _zoomUp() {
          if (!this._originalScale) {
            return;
          }

          Vec3.copy(this._fromScale, this._originalScale);
          Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
          this._time = 0;
          this._transitionFinished = false;
        };

        _proto._zoomBack = function _zoomBack() {
          if (!this.target || !this._originalScale) {
            return;
          }

          Vec3.copy(this._fromScale, this.target.getScale());
          Vec3.copy(this._toScale, this._originalScale);
          this._time = 0;
          this._transitionFinished = false;
        };

        _proto._applyTransition = function _applyTransition(state) {
          var transition = this._transition;

          if (transition === Transition.COLOR) {
            this._updateColorTransition(state);
          } else if (transition === Transition.SPRITE) {
            this._updateSpriteTransition(state);
          } else if (transition === Transition.SCALE) {
            this._updateScaleTransition(state);
          }
        };

        _proto._xrHoverEnter = function _xrHoverEnter() {
          this._onMouseMoveIn();

          this._updateState();
        };

        _proto._xrHoverExit = function _xrHoverExit() {
          this._onMouseMoveOut();

          if (this._pressed) {
            this._pressed = false;

            this._updateState();
          }
        };

        _proto._xrClick = function _xrClick() {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }

          this._pressed = true;

          this._updateState();
        };

        _proto._xrUnClick = function _xrUnClick() {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }

          if (this._pressed) {
            EventHandler.emitEvents(this.clickEvents, this);
            this.node.emit(EventType$2.CLICK, this);
          }

          this._pressed = false;

          this._updateState();
        };

        _createClass(Button, [{
          key: "target",
          get: function get() {
            return this._target || this.node;
          },
          set: function set(value) {
            if (this._target === value) {
              return;
            }

            if (this._target) {
              this._unregisterTargetEvent(this._target);
            }

            this._target = value;

            this._applyTarget();
          }
        }, {
          key: "interactable",
          get: function get() {
            return this._interactable;
          },
          set: function set(value) {
            if (this._interactable === value) {
              return;
            }

            this._interactable = value;

            this._updateState();

            if (!this._interactable) {
              this._resetState();
            }
          }
        }, {
          key: "_resizeToTarget",
          set: function set(value) {
            if (value) {
              this._resizeNodeToTargetNode();
            }
          }
        }, {
          key: "transition",
          get: function get() {
            return this._transition;
          },
          set: function set(value) {
            if (this._transition === value) {
              return;
            }

            if (this._transition === Transition.COLOR) {
              this._updateColorTransition(State.NORMAL);
            } else if (this._transition === Transition.SPRITE) {
              this._updateSpriteTransition(State.NORMAL);
            }

            this._transition = value;

            this._updateState();
          }
        }, {
          key: "normalColor",
          get: function get() {
            return this._normalColor;
          },
          set: function set(value) {
            if (this._normalColor === value) {
              return;
            }

            this._normalColor.set(value);

            this._updateState();
          }
        }, {
          key: "pressedColor",
          get: function get() {
            return this._pressedColor;
          },
          set: function set(value) {
            if (this._pressedColor === value) {
              return;
            }

            this._pressedColor.set(value);
          }
        }, {
          key: "hoverColor",
          get: function get() {
            return this._hoverColor;
          },
          set: function set(value) {
            if (this._hoverColor === value) {
              return;
            }

            this._hoverColor.set(value);
          }
        }, {
          key: "disabledColor",
          get: function get() {
            return this._disabledColor;
          },
          set: function set(value) {
            if (this._disabledColor === value) {
              return;
            }

            this._disabledColor.set(value);

            this._updateState();
          }
        }, {
          key: "duration",
          get: function get() {
            return this._duration;
          },
          set: function set(value) {
            if (this._duration === value) {
              return;
            }

            this._duration = value;
          }
        }, {
          key: "zoomScale",
          get: function get() {
            return this._zoomScale;
          },
          set: function set(value) {
            if (this._zoomScale === value) {
              return;
            }

            this._zoomScale = value;
          }
        }, {
          key: "normalSprite",
          get: function get() {
            return this._normalSprite;
          },
          set: function set(value) {
            if (this._normalSprite === value) {
              return;
            }

            this._normalSprite = value;
            var sprite = this.node.getComponent(Sprite);

            if (sprite) {
              sprite.spriteFrame = value;
            }

            this._updateState();
          }
        }, {
          key: "pressedSprite",
          get: function get() {
            return this._pressedSprite;
          },
          set: function set(value) {
            if (this._pressedSprite === value) {
              return;
            }

            this._pressedSprite = value;

            this._updateState();
          }
        }, {
          key: "hoverSprite",
          get: function get() {
            return this._hoverSprite;
          },
          set: function set(value) {
            if (this._hoverSprite === value) {
              return;
            }

            this._hoverSprite = value;

            this._updateState();
          }
        }, {
          key: "disabledSprite",
          get: function get() {
            return this._disabledSprite;
          },
          set: function set(value) {
            if (this._disabledSprite === value) {
              return;
            }

            this._disabledSprite = value;

            this._updateState();
          }
        }]);

        return Button;
      }(Component), _class3$h.Transition = Transition, _class3$h.EventType = EventType$2, _temp$1f), (_applyDecoratedDescriptor(_class2$1c.prototype, "target", [_dec6$J, _dec7$F, _dec8$A], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "target"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "interactable", [_dec9$v, _dec10$s], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "interactable"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "transition", [_dec11$q, _dec12$p, _dec13$n], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "transition"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "normalColor", [_dec14$l, _dec15$l], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "normalColor"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "pressedColor", [_dec16$k, _dec17$j], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "pressedColor"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "hoverColor", [_dec18$i, _dec19$h], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "hoverColor"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "disabledColor", [_dec20$h, _dec21$h], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "disabledColor"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "duration", [_dec22$f, _dec23$e, _dec24$e, _dec25$d], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "duration"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "zoomScale", [_dec26$d, _dec27$d], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "zoomScale"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "normalSprite", [_dec28$c, _dec29$c, _dec30$a], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "normalSprite"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "pressedSprite", [_dec31$a, _dec32$7, _dec33$5], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "pressedSprite"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "hoverSprite", [_dec34$5, _dec35$5, _dec36$5], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "hoverSprite"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "disabledSprite", [_dec37$5, _dec38$5, _dec39$5], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "disabledSprite"), _class2$1c.prototype), _descriptor$18 = _applyDecoratedDescriptor(_class2$1c.prototype, "clickEvents", [_dec40$5, serializable, _dec41$5, _dec42$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$_ = _applyDecoratedDescriptor(_class2$1c.prototype, "_interactable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor3$M = _applyDecoratedDescriptor(_class2$1c.prototype, "_transition", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Transition.NONE;
        }
      }), _descriptor4$C = _applyDecoratedDescriptor(_class2$1c.prototype, "_normalColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor5$v = _applyDecoratedDescriptor(_class2$1c.prototype, "_hoverColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(211, 211, 211, 255);
        }
      }), _descriptor6$r = _applyDecoratedDescriptor(_class2$1c.prototype, "_pressedColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor7$l = _applyDecoratedDescriptor(_class2$1c.prototype, "_disabledColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(124, 124, 124, 255);
        }
      }), _descriptor8$j = _applyDecoratedDescriptor(_class2$1c.prototype, "_normalSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9$g = _applyDecoratedDescriptor(_class2$1c.prototype, "_hoverSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10$d = _applyDecoratedDescriptor(_class2$1c.prototype, "_pressedSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$a = _applyDecoratedDescriptor(_class2$1c.prototype, "_disabledSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12$a = _applyDecoratedDescriptor(_class2$1c.prototype, "_duration", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor13$a = _applyDecoratedDescriptor(_class2$1c.prototype, "_zoomScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.2;
        }
      }), _descriptor14$5 = _applyDecoratedDescriptor(_class2$1c.prototype, "_target", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$1c)) || _class$1l) || _class$1l) || _class$1l) || _class$1l) || _class$1l) || _class$1l));
      legacyCC.Button = Button;

      var tabIndexUtil = function () {
        function tabIndexUtil() {}

        tabIndexUtil.add = function add(editBoxImpl) {
          var list = this._tabIndexList;
          var index = list.indexOf(editBoxImpl);

          if (index === -1) {
            list.push(editBoxImpl);
          }
        };

        tabIndexUtil.remove = function remove(editBoxImpl) {
          var list = this._tabIndexList;
          var index = list.indexOf(editBoxImpl);

          if (index !== -1) {
            list.splice(index, 1);
          }
        };

        tabIndexUtil.resort = function resort() {
          this._tabIndexList.sort(function (a, b) {
            return a._delegate.tabIndex - b._delegate.tabIndex;
          });
        };

        tabIndexUtil.next = function next(editBoxImpl) {
          var list = this._tabIndexList;
          var index = list.indexOf(editBoxImpl);
          editBoxImpl.setFocus(false);

          if (index !== -1) {
            var nextImpl = list[index + 1];

            if (nextImpl && nextImpl._delegate.tabIndex >= 0) {
              nextImpl.setFocus(true);
            }
          }
        };

        return tabIndexUtil;
      }();
      tabIndexUtil._tabIndexList = [];

      var KeyboardReturnType;

      (function (KeyboardReturnType) {
        KeyboardReturnType[KeyboardReturnType["DEFAULT"] = 0] = "DEFAULT";
        KeyboardReturnType[KeyboardReturnType["DONE"] = 1] = "DONE";
        KeyboardReturnType[KeyboardReturnType["SEND"] = 2] = "SEND";
        KeyboardReturnType[KeyboardReturnType["SEARCH"] = 3] = "SEARCH";
        KeyboardReturnType[KeyboardReturnType["GO"] = 4] = "GO";
        KeyboardReturnType[KeyboardReturnType["NEXT"] = 5] = "NEXT";
      })(KeyboardReturnType || (KeyboardReturnType = {}));

      Enum(KeyboardReturnType);
      var InputMode;

      (function (InputMode) {
        InputMode[InputMode["ANY"] = 0] = "ANY";
        InputMode[InputMode["EMAIL_ADDR"] = 1] = "EMAIL_ADDR";
        InputMode[InputMode["NUMERIC"] = 2] = "NUMERIC";
        InputMode[InputMode["PHONE_NUMBER"] = 3] = "PHONE_NUMBER";
        InputMode[InputMode["URL"] = 4] = "URL";
        InputMode[InputMode["DECIMAL"] = 5] = "DECIMAL";
        InputMode[InputMode["SINGLE_LINE"] = 6] = "SINGLE_LINE";
      })(InputMode || (InputMode = {}));

      Enum(InputMode);
      var InputFlag;

      (function (InputFlag) {
        InputFlag[InputFlag["PASSWORD"] = 0] = "PASSWORD";
        InputFlag[InputFlag["SENSITIVE"] = 1] = "SENSITIVE";
        InputFlag[InputFlag["INITIAL_CAPS_WORD"] = 2] = "INITIAL_CAPS_WORD";
        InputFlag[InputFlag["INITIAL_CAPS_SENTENCE"] = 3] = "INITIAL_CAPS_SENTENCE";
        InputFlag[InputFlag["INITIAL_CAPS_ALL_CHARACTERS"] = 4] = "INITIAL_CAPS_ALL_CHARACTERS";
        InputFlag[InputFlag["DEFAULT"] = 5] = "DEFAULT";
      })(InputFlag || (InputFlag = {}));

      Enum(InputFlag);

      var EditBoxImplBase = function () {
        function EditBoxImplBase() {
          this._editing = false;
          this._delegate = null;
        }

        var _proto = EditBoxImplBase.prototype;

        _proto.init = function init(delegate) {};

        _proto.onEnable = function onEnable() {};

        _proto.update = function update() {};

        _proto.onDisable = function onDisable() {
          if (this._editing) {
            this.endEditing();
          }
        };

        _proto.clear = function clear() {
          this._delegate = null;
        };

        _proto.setTabIndex = function setTabIndex(index) {};

        _proto.setSize = function setSize(width, height) {};

        _proto.setFocus = function setFocus(value) {
          if (value) {
            this.beginEditing();
          } else {
            this.endEditing();
          }
        };

        _proto.isFocused = function isFocused() {
          return this._editing;
        };

        _proto.beginEditing = function beginEditing() {};

        _proto.endEditing = function endEditing() {};

        return EditBoxImplBase;
      }();

      var SCROLLY = 40;
      var LEFT_PADDING = 2;
      var DELAY_TIME = 400;

      var _matrix$1 = new Mat4();

      var _matrix_temp = new Mat4();

      var _vec3 = new Vec3();

      var _currentEditBoxImpl = null;
      var _domCount = 0;
      var EditBoxImpl = function (_EditBoxImplBase) {
        _inheritsLoose(EditBoxImpl, _EditBoxImplBase);

        function EditBoxImpl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _EditBoxImplBase.call.apply(_EditBoxImplBase, [this].concat(args)) || this;
          _this._delegate = null;
          _this._inputMode = -1;
          _this._inputFlag = -1;
          _this._returnType = -1;
          _this.__eventListeners = {};
          _this.__autoResize = false;
          _this.__orientationChanged = void 0;
          _this._edTxt = null;
          _this._isTextArea = false;
          _this._textLabelFont = null;
          _this._textLabelFontSize = null;
          _this._textLabelFontColor = null;
          _this._textLabelAlign = null;
          _this._placeholderLabelFont = null;
          _this._placeholderLabelFontSize = null;
          _this._placeholderLabelFontColor = null;
          _this._placeholderLabelAlign = null;
          _this._placeholderLineHeight = null;
          _this._placeholderStyleSheet = null;
          _this._domId = "EditBoxId_" + ++_domCount;
          return _this;
        }

        var _proto = EditBoxImpl.prototype;

        _proto.init = function init(delegate) {
          if (!delegate) {
            return;
          }

          this._delegate = delegate;

          if (delegate.inputMode === InputMode.ANY) {
            this._createTextArea();
          } else {
            this._createInput();
          }

          tabIndexUtil.add(this);
          this.setTabIndex(delegate.tabIndex);

          this._initStyleSheet();

          this._registerEventListeners();

          this._addDomToGameContainer();
        };

        _proto.clear = function clear() {
          this._removeEventListeners();

          this._removeDomFromGameContainer();

          tabIndexUtil.remove(this);

          if (_currentEditBoxImpl === this) {
            _currentEditBoxImpl = null;
          }

          this._delegate = null;
        };

        _proto.update = function update() {
          this._updateMatrix();
        };

        _proto.setTabIndex = function setTabIndex(index) {
          this._edTxt.tabIndex = index;
          tabIndexUtil.resort();
        };

        _proto.setSize = function setSize(width, height) {
          var elem = this._edTxt;

          if (elem) {
            elem.style.width = width + "px";
            elem.style.height = height + "px";
          }
        };

        _proto.beginEditing = function beginEditing() {
          if (_currentEditBoxImpl && _currentEditBoxImpl !== this) {
            _currentEditBoxImpl.setFocus(false);
          }

          this._editing = true;
          _currentEditBoxImpl = this;

          this._delegate._editBoxEditingDidBegan();

          this._showDom();

          this._edTxt.focus();
        };

        _proto.endEditing = function endEditing() {
          this._edTxt.blur();
        };

        _proto._createInput = function _createInput() {
          this._isTextArea = false;
          this._edTxt = document.createElement('input');
        };

        _proto._createTextArea = function _createTextArea() {
          this._isTextArea = true;
          this._edTxt = document.createElement('textarea');
        };

        _proto._addDomToGameContainer = function _addDomToGameContainer() {
          if (game.container && this._edTxt) {
            game.container.appendChild(this._edTxt);
            document.head.appendChild(this._placeholderStyleSheet);
          }
        };

        _proto._removeDomFromGameContainer = function _removeDomFromGameContainer() {
          var hasElem = contains$2(game.container, this._edTxt);

          if (hasElem && this._edTxt) {
            game.container.removeChild(this._edTxt);
          }

          var hasStyleSheet = contains$2(document.head, this._placeholderStyleSheet);

          if (hasStyleSheet) {
            document.head.removeChild(this._placeholderStyleSheet);
          }

          this._edTxt = null;
          this._placeholderStyleSheet = null;
        };

        _proto._showDom = function _showDom() {
          this._updateMaxLength();

          this._updateInputType();

          this._updateStyleSheet();

          if (this._edTxt && this._delegate) {
            this._edTxt.style.display = '';

            this._delegate._hideLabels();
          }

          if (sys.isMobile) {
            this._showDomOnMobile();
          }
        };

        _proto._hideDom = function _hideDom() {
          var elem = this._edTxt;

          if (elem && this._delegate) {
            elem.style.display = 'none';

            this._delegate._showLabels();
          }

          if (sys.isMobile) {
            this._hideDomOnMobile();
          }
        };

        _proto._showDomOnMobile = function _showDomOnMobile() {
          if (sys.os !== OS.ANDROID && sys.os !== OS.OHOS) {
            return;
          }

          screenAdapter.handleResizeEvent = false;

          this._adjustWindowScroll();
        };

        _proto._hideDomOnMobile = function _hideDomOnMobile() {
          if (sys.os === OS.ANDROID || sys.os === OS.OHOS) {
            screenAdapter.handleResizeEvent = true;
          }

          this._scrollBackWindow();
        };

        _proto._adjustWindowScroll = function _adjustWindowScroll() {
          var _this2 = this;

          setTimeout(function () {
            if (window.scrollY < SCROLLY) {
              _this2._edTxt.scrollIntoView({
                block: 'start',
                inline: 'nearest',
                behavior: 'smooth'
              });
            }
          }, DELAY_TIME);
        };

        _proto._scrollBackWindow = function _scrollBackWindow() {
          setTimeout(function () {
            if (sys.browserType === BrowserType.WECHAT && sys.os === OS.IOS) {
              if (window.top) {
                window.top.scrollTo(0, 0);
              }

              return;
            }

            window.scrollTo(0, 0);
          }, DELAY_TIME);
        };

        _proto._updateMatrix = function _updateMatrix() {
          if (!this._edTxt) {
            return;
          }

          var node = this._delegate.node;
          var scaleX = view.getScaleX();
          var scaleY = view.getScaleY();
          var viewport = view.getViewportRect();
          var dpr = screenAdapter.devicePixelRatio;
          node.getWorldMatrix(_matrix$1);
          var transform = node._uiProps.uiTransformComp;

          if (transform) {
            Vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z);
          }

          Mat4.transform(_matrix$1, _matrix$1, _vec3);

          if (!node._uiProps.uiTransformComp) {
            return;
          }

          var camera = director.root.batcher2D.getFirstRenderCamera(node);
          if (!camera) return;
          camera.node.getWorldRT(_matrix_temp);
          var m12 = _matrix_temp.m12;
          var m13 = _matrix_temp.m13;
          var center = visibleRect.center;
          _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13);
          _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13);
          Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1);
          scaleX /= dpr;
          scaleY /= dpr;
          var container = game.container;
          var a = _matrix_temp.m00 * scaleX;
          var b = _matrix$1.m01;
          var c = _matrix$1.m04;
          var d = _matrix_temp.m05 * scaleY;
          var offsetX = parseInt(container && container.style.paddingLeft || '0');
          offsetX += viewport.x / dpr;
          var offsetY = parseInt(container && container.style.paddingBottom || '0');
          offsetY += viewport.y / dpr;
          var tx = _matrix_temp.m12 * scaleX + offsetX;
          var ty = _matrix_temp.m13 * scaleY + offsetY;
          var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
          this._edTxt.style.transform = matrix;
          this._edTxt.style['-webkit-transform'] = matrix;
          this._edTxt.style['transform-origin'] = '0px 100% 0px';
          this._edTxt.style['-webkit-transform-origin'] = '0px 100% 0px';
        };

        _proto._updateInputType = function _updateInputType() {
          var delegate = this._delegate;
          var inputMode = delegate.inputMode;
          var inputFlag = delegate.inputFlag;
          var returnType = delegate.returnType;
          var elem = this._edTxt;

          if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) {
            return;
          }

          this._inputMode = inputMode;
          this._inputFlag = inputFlag;
          this._returnType = returnType;

          if (this._isTextArea) {
            var transform = 'none';

            if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
              transform = 'uppercase';
            } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
              transform = 'capitalize';
            }

            elem.style.textTransform = transform;
            return;
          }

          elem = elem;

          if (inputFlag === InputFlag.PASSWORD) {
            elem.type = 'password';
            elem.style.textTransform = 'none';
            return;
          }

          var type = elem.type;

          if (inputMode === InputMode.EMAIL_ADDR) {
            type = 'email';
          } else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) {
            type = 'number';
          } else if (inputMode === InputMode.PHONE_NUMBER) {
            type = 'number';
            elem.pattern = '[0-9]*';
            elem.addEventListener('wheel', function () {
              return false;
            });
          } else if (inputMode === InputMode.URL) {
            type = 'url';
          } else {
            type = 'text';

            if (returnType === KeyboardReturnType.SEARCH) {
              type = 'search';
            }
          }

          elem.type = type;
          var textTransform = 'none';

          if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
            textTransform = 'uppercase';
          } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
            textTransform = 'capitalize';
          }

          elem.style.textTransform = textTransform;
        };

        _proto._updateMaxLength = function _updateMaxLength() {
          var maxLength = this._delegate.maxLength;

          if (maxLength < 0) {
            maxLength = 65535;
          }

          this._edTxt.maxLength = maxLength;
        };

        _proto._initStyleSheet = function _initStyleSheet() {
          if (!this._edTxt) {
            return;
          }

          var elem = this._edTxt;
          elem.style.color = '#000000';
          elem.style.border = '0px';
          elem.style.background = 'transparent';
          elem.style.width = '100%';
          elem.style.height = '100%';
          elem.style.outline = 'medium';
          elem.style.padding = '0';
          elem.style.textTransform = 'none';
          elem.style.display = 'none';
          elem.style.position = 'absolute';
          elem.style.bottom = '0px';
          elem.style.left = LEFT_PADDING + "px";
          elem.className = 'cocosEditBox';
          elem.style.fontFamily = 'Arial';
          elem.id = this._domId;

          if (!this._isTextArea) {
            elem = elem;
            elem.type = 'text';
            elem.style['-moz-appearance'] = 'textfield';
          } else {
            elem.style.resize = 'none';
            elem.style.overflowY = 'scroll';
          }

          this._placeholderStyleSheet = document.createElement('style');
        };

        _proto._updateStyleSheet = function _updateStyleSheet() {
          var delegate = this._delegate;
          var elem = this._edTxt;

          if (elem && delegate) {
            elem.value = delegate.string;

            this._updateTextLabel(delegate.textLabel);
          }
        };

        _proto._updateTextLabel = function _updateTextLabel(textLabel) {
          if (!textLabel) {
            return;
          }

          var font = textLabel.font;

          if (font && !(font instanceof BitmapFont)) {
            font = font._fontFamily;
          } else {
            font = textLabel.fontFamily;
          }

          var fontSize = textLabel.fontSize * textLabel.node.scale.y;

          if (this._textLabelFont === font && this._textLabelFontSize === fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) {
            return;
          }

          this._textLabelFont = font;
          this._textLabelFontSize = fontSize;
          this._textLabelFontColor = textLabel.fontColor;
          this._textLabelAlign = textLabel.horizontalAlign;

          if (!this._edTxt) {
            return;
          }

          var elem = this._edTxt;
          elem.style.fontSize = fontSize + "px";
          elem.style.color = textLabel.color.toCSS();
          elem.style.fontFamily = font;

          switch (textLabel.horizontalAlign) {
            case Label.HorizontalAlign.LEFT:
              elem.style.textAlign = 'left';
              break;

            case Label.HorizontalAlign.CENTER:
              elem.style.textAlign = 'center';
              break;

            case Label.HorizontalAlign.RIGHT:
              elem.style.textAlign = 'right';
              break;
          }
        };

        _proto._updatePlaceholderLabel = function _updatePlaceholderLabel(placeholderLabel) {
          if (!placeholderLabel) {
            return;
          }

          var font = placeholderLabel.font;

          if (font && !(font instanceof BitmapFont)) {
            font = placeholderLabel.font._fontFamily;
          } else {
            font = placeholderLabel.fontFamily;
          }

          var fontSize = placeholderLabel.fontSize * placeholderLabel.node.scale.y;

          if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) {
            return;
          }

          this._placeholderLabelFont = font;
          this._placeholderLabelFontSize = fontSize;
          this._placeholderLabelFontColor = placeholderLabel.fontColor;
          this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
          this._placeholderLineHeight = placeholderLabel.fontSize;
          var styleEl = this._placeholderStyleSheet;
          var fontColor = placeholderLabel.color.toCSS();
          var lineHeight = placeholderLabel.fontSize;
          var horizontalAlign = '';

          switch (placeholderLabel.horizontalAlign) {
            case Label.HorizontalAlign.LEFT:
              horizontalAlign = 'left';
              break;

            case Label.HorizontalAlign.CENTER:
              horizontalAlign = 'center';
              break;

            case Label.HorizontalAlign.RIGHT:
              horizontalAlign = 'right';
              break;
          }

          styleEl.innerHTML = "#" + this._domId + "::-webkit-input-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}" + ("#" + this._domId + "::-moz-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}") + ("#" + this._domId + "::-ms-input-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}");

          if (sys.browserType === BrowserType.EDGE) {
            styleEl.innerHTML += "#" + this._domId + "::-ms-clear{display: none;}";
          }
        };

        _proto._registerEventListeners = function _registerEventListeners() {
          var _this3 = this;

          if (!this._edTxt) {
            return;
          }

          var elem = this._edTxt;
          var inputLock = false;
          var cbs = this.__eventListeners;

          cbs.compositionStart = function () {
            inputLock = true;
          };

          cbs.compositionEnd = function () {
            inputLock = false;

            _this3._delegate._editBoxTextChanged(elem.value);
          };

          cbs.onInput = function () {
            if (inputLock) {
              return;
            }

            var delegate = _this3._delegate;
            var maxLength = delegate.maxLength;

            if (maxLength >= 0) {
              elem.value = elem.value.slice(0, maxLength);
            }

            delegate._editBoxTextChanged(elem.value);
          };

          cbs.onClick = function () {
            if (_this3._editing) {
              if (sys.isMobile) {
                _this3._adjustWindowScroll();
              }
            }
          };

          cbs.onKeydown = function (e) {
            if (e.keyCode === KeyCode.ENTER) {
              e.propagationStopped = true;

              _this3._delegate._editBoxEditingReturn();

              if (!_this3._isTextArea) {
                elem.blur();
              }
            } else if (e.keyCode === KeyCode.TAB) {
              e.propagationStopped = true;
              e.preventDefault();
              tabIndexUtil.next(_this3);
            }
          };

          cbs.onBlur = function () {
            if (sys.isMobile && inputLock) {
              cbs.compositionEnd();
            }

            _this3._editing = false;
            _currentEditBoxImpl = null;

            _this3._hideDom();

            _this3._delegate._editBoxEditingDidEnded();
          };

          elem.addEventListener('compositionstart', cbs.compositionStart);
          elem.addEventListener('compositionend', cbs.compositionEnd);
          elem.addEventListener('input', cbs.onInput);
          elem.addEventListener('keydown', cbs.onKeydown);
          elem.addEventListener('blur', cbs.onBlur);
          elem.addEventListener('touchstart', cbs.onClick);
        };

        _proto._removeEventListeners = function _removeEventListeners() {
          if (!this._edTxt) {
            return;
          }

          var elem = this._edTxt;
          var cbs = this.__eventListeners;
          elem.removeEventListener('compositionstart', cbs.compositionStart);
          elem.removeEventListener('compositionend', cbs.compositionEnd);
          elem.removeEventListener('input', cbs.onInput);
          elem.removeEventListener('keydown', cbs.onKeydown);
          elem.removeEventListener('blur', cbs.onBlur);
          elem.removeEventListener('touchstart', cbs.onClick);
          cbs.compositionStart = null;
          cbs.compositionEnd = null;
          cbs.onInput = null;
          cbs.onKeydown = null;
          cbs.onBlur = null;
          cbs.onClick = null;
        };

        return EditBoxImpl;
      }(EditBoxImplBase);

      var _dec$1l, _dec2$11, _dec3$Z, _dec4$U, _dec5$Q, _dec6$K, _dec7$G, _dec8$B, _dec9$w, _dec10$t, _dec11$r, _dec12$q, _dec13$o, _dec14$m, _dec15$m, _dec16$l, _dec17$k, _dec18$j, _dec19$i, _dec20$i, _dec21$i, _dec22$g, _dec23$f, _dec24$f, _dec25$e, _dec26$e, _dec27$e, _dec28$d, _dec29$d, _dec30$b, _dec31$b, _dec32$8, _dec33$6, _dec34$6, _dec35$6, _dec36$6, _dec37$6, _dec38$6, _dec39$6, _dec40$6, _dec41$6, _dec42$6, _dec43$5, _class$1m, _class2$1d, _descriptor$19, _descriptor2$$, _descriptor3$N, _descriptor4$D, _descriptor5$w, _descriptor6$s, _descriptor7$m, _descriptor8$k, _descriptor9$h, _descriptor10$e, _descriptor11$b, _descriptor12$b, _descriptor13$b, _class3$i, _temp$1g;
      var LEFT_PADDING$1 = 2;

      function capitalize(str) {
        return str.replace(/(?:^|\s)\S/g, function (a) {
          return a.toUpperCase();
        });
      }

      function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }

      var EventType$3;

      (function (EventType) {
        EventType["EDITING_DID_BEGAN"] = "editing-did-began";
        EventType["EDITING_DID_ENDED"] = "editing-did-ended";
        EventType["TEXT_CHANGED"] = "text-changed";
        EventType["EDITING_RETURN"] = "editing-return";
        EventType["XR_EDITING_DID_BEGAN"] = "xr-editing-did-began";
        EventType["XR_EDITING_DID_ENDED"] = "xr-editing-did-ended";
      })(EventType$3 || (EventType$3 = {}));

      var EditBox = function (v) { return exports({ EditBox: v, EditBoxComponent: v }), v; }((_dec$1l = ccclass('cc.EditBox'), _dec2$11 = help(), _dec3$Z = executionOrder(110), _dec4$U = menu(), _dec5$Q = requireComponent(UITransform), _dec6$K = displayOrder(), _dec7$G = tooltip(), _dec8$B = displayOrder(), _dec9$w = tooltip(), _dec10$t = type(Label), _dec11$r = displayOrder(), _dec12$q = tooltip(), _dec13$o = type(Label), _dec14$m = displayOrder(), _dec15$m = tooltip(), _dec16$l = type(SpriteFrame), _dec17$k = displayOrder(), _dec18$j = tooltip(), _dec19$i = type(InputFlag), _dec20$i = displayOrder(), _dec21$i = tooltip(), _dec22$g = type(InputMode), _dec23$f = displayOrder(), _dec24$f = tooltip(), _dec25$e = type(KeyboardReturnType), _dec26$e = displayOrder(), _dec27$e = tooltip(), _dec28$d = displayOrder(), _dec29$d = tooltip(), _dec30$b = displayOrder(), _dec31$b = tooltip(), _dec32$8 = type([EventHandler]), _dec33$6 = displayOrder(), _dec34$6 = tooltip(), _dec35$6 = type([EventHandler]), _dec36$6 = displayOrder(), _dec37$6 = tooltip(), _dec38$6 = type([EventHandler]), _dec39$6 = displayOrder(), _dec40$6 = tooltip(), _dec41$6 = type([EventHandler]), _dec42$6 = displayOrder(), _dec43$5 = tooltip(), _dec$1l(_class$1m = _dec2$11(_class$1m = _dec3$Z(_class$1m = _dec4$U(_class$1m = _dec5$Q(_class$1m = executeInEditMode(_class$1m = (_class2$1d = (_temp$1g = _class3$i = function (_Component) {
        _inheritsLoose(EditBox, _Component);

        function EditBox() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "editingDidBegan", _descriptor$19, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "textChanged", _descriptor2$$, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "editingDidEnded", _descriptor3$N, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "editingReturn", _descriptor4$D, _assertThisInitialized(_this));

          _this._impl = null;
          _this._background = null;

          _initializerDefineProperty(_this, "_textLabel", _descriptor5$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_placeholderLabel", _descriptor6$s, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_returnType", _descriptor7$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_string", _descriptor8$k, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_tabIndex", _descriptor9$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_backgroundImage", _descriptor10$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_inputFlag", _descriptor11$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_inputMode", _descriptor12$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_maxLength", _descriptor13$b, _assertThisInitialized(_this));

          _this._isLabelVisible = false;
          return _this;
        }

        var _proto = EditBox.prototype;

        _proto.__preload = function __preload() {
          this._init();
        };

        _proto.onEnable = function onEnable() {
          {
            this._registerEvent();
          }

          this._ensureBackgroundSprite();

          if (this._impl) {
            this._impl.onEnable();
          }
        };

        _proto.update = function update() {
          if (this._impl) {
            this._impl.update();
          }
        };

        _proto.onDisable = function onDisable() {
          {
            this._unregisterEvent();
          }

          this._unregisterBackgroundEvent();

          if (this._impl) {
            this._impl.onDisable();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this._impl) {
            this._impl.clear();
          }
        };

        _proto.setFocus = function setFocus() {
          if (this._impl) {
            this._impl.setFocus(true);
          }
        };

        _proto.focus = function focus() {
          if (this._impl) {
            this._impl.setFocus(true);
          }
        };

        _proto.blur = function blur() {
          if (this._impl) {
            this._impl.setFocus(false);
          }
        };

        _proto.isFocused = function isFocused() {
          if (this._impl) {
            return this._impl.isFocused();
          }

          return false;
        };

        _proto._editBoxEditingDidBegan = function _editBoxEditingDidBegan() {
          EventHandler.emitEvents(this.editingDidBegan, this);
          this.node.emit(EventType$3.EDITING_DID_BEGAN, this);
        };

        _proto._editBoxEditingDidEnded = function _editBoxEditingDidEnded() {
          EventHandler.emitEvents(this.editingDidEnded, this);
          this.node.emit(EventType$3.EDITING_DID_ENDED, this);
        };

        _proto._editBoxTextChanged = function _editBoxTextChanged(text) {
          text = this._updateLabelStringStyle(text, true);
          this.string = text;
          EventHandler.emitEvents(this.textChanged, text, this);
          this.node.emit(EventType$3.TEXT_CHANGED, this);
        };

        _proto._editBoxEditingReturn = function _editBoxEditingReturn() {
          EventHandler.emitEvents(this.editingReturn, this);
          this.node.emit(EventType$3.EDITING_RETURN, this);
        };

        _proto._showLabels = function _showLabels() {
          this._isLabelVisible = true;

          this._updateLabels();
        };

        _proto._hideLabels = function _hideLabels() {
          this._isLabelVisible = false;

          if (this._textLabel) {
            this._textLabel.node.active = false;
          }

          if (this._placeholderLabel) {
            this._placeholderLabel.node.active = false;
          }
        };

        _proto._onTouchBegan = function _onTouchBegan(event) {
          event.propagationStopped = true;
        };

        _proto._onTouchCancel = function _onTouchCancel(event) {
          event.propagationStopped = true;
        };

        _proto._onTouchEnded = function _onTouchEnded(event) {
          if (this._impl) {
            this._impl.beginEditing();
          }

          event.propagationStopped = true;
        };

        _proto._init = function _init() {
          this._updatePlaceholderLabel();

          this._updateTextLabel();

          this._isLabelVisible = true;
          this.node.on(NodeEventType.SIZE_CHANGED, this._resizeChildNodes, this);
          var impl = this._impl = new EditBox._EditBoxImpl();
          impl.init(this);

          this._updateString(this._string);

          this._syncSize();
        };

        _proto._ensureBackgroundSprite = function _ensureBackgroundSprite() {
          if (!this._background) {
            var background = this.node.getComponent(Sprite);

            if (!background) {
              background = this.node.addComponent(Sprite);
            }

            if (background !== this._background) {
              background.type = Sprite.Type.SLICED;
              background.spriteFrame = this._backgroundImage;
              this._background = background;

              this._registerBackgroundEvent();
            }
          }
        };

        _proto._updateTextLabel = function _updateTextLabel() {
          var textLabel = this._textLabel;

          if (!textLabel) {
            var node = this.node.getChildByName('TEXT_LABEL');

            if (!node) {
              node = new Node('TEXT_LABEL');
              node.layer = this.node.layer;
            }

            textLabel = node.getComponent(Label);

            if (!textLabel) {
              textLabel = node.addComponent(Label);
            }

            node.parent = this.node;
            this._textLabel = textLabel;
          }

          var transformComp = this._textLabel.node._uiProps.uiTransformComp;
          transformComp.setAnchorPoint(0, 1);
          textLabel.overflow = Label.Overflow.CLAMP;

          if (this._inputMode === InputMode.ANY) {
            textLabel.verticalAlign = VerticalTextAlignment.TOP;
            textLabel.enableWrapText = true;
          } else {
            textLabel.enableWrapText = false;
          }

          textLabel.string = this._updateLabelStringStyle(this._string);
        };

        _proto._updatePlaceholderLabel = function _updatePlaceholderLabel() {
          var placeholderLabel = this._placeholderLabel;

          if (!placeholderLabel) {
            var node = this.node.getChildByName('PLACEHOLDER_LABEL');

            if (!node) {
              node = new Node('PLACEHOLDER_LABEL');
              node.layer = this.node.layer;
            }

            placeholderLabel = node.getComponent(Label);

            if (!placeholderLabel) {
              placeholderLabel = node.addComponent(Label);
            }

            node.parent = this.node;
            this._placeholderLabel = placeholderLabel;
          }

          var transform = this._placeholderLabel.node._uiProps.uiTransformComp;
          transform.setAnchorPoint(0, 1);

          if (this._inputMode === InputMode.ANY) {
            placeholderLabel.enableWrapText = true;
          } else {
            placeholderLabel.enableWrapText = false;
          }

          placeholderLabel.string = this.placeholder;
        };

        _proto._syncSize = function _syncSize() {
          var trans = this.node._uiProps.uiTransformComp;
          var size = trans.contentSize;

          if (this._background) {
            var bgTrans = this._background.node._uiProps.uiTransformComp;
            bgTrans.anchorPoint = trans.anchorPoint;
            bgTrans.setContentSize(size);
          }

          this._updateLabelPosition(size);

          if (this._impl) {
            this._impl.setSize(size.width, size.height);
          }
        };

        _proto._updateLabels = function _updateLabels() {
          if (this._isLabelVisible) {
            var content = this._string;

            if (this._textLabel) {
              this._textLabel.node.active = content !== '';
            }

            if (this._placeholderLabel) {
              this._placeholderLabel.node.active = content === '';
            }
          }
        };

        _proto._updateString = function _updateString(text) {
          var textLabel = this._textLabel;

          if (!textLabel) {
            return;
          }

          var displayText = text;

          if (displayText) {
            displayText = this._updateLabelStringStyle(displayText);
          }

          textLabel.string = displayText;

          this._updateLabels();
        };

        _proto._updateLabelStringStyle = function _updateLabelStringStyle(text, ignorePassword) {
          if (ignorePassword === void 0) {
            ignorePassword = false;
          }

          var inputFlag = this._inputFlag;

          if (!ignorePassword && inputFlag === InputFlag.PASSWORD) {
            var passwordString = '';
            var len = text.length;

            for (var i = 0; i < len; ++i) {
              passwordString += "\u25CF";
            }

            text = passwordString;
          } else if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
            text = text.toUpperCase();
          } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
            text = capitalize(text);
          } else if (inputFlag === InputFlag.INITIAL_CAPS_SENTENCE) {
            text = capitalizeFirstLetter(text);
          }

          return text;
        };

        _proto._registerEvent = function _registerEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          this.node.on(XrKeyboardEventType.XR_KEYBOARD_INPUT, this._xrKeyBoardInput, this);
        };

        _proto._unregisterEvent = function _unregisterEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          this.node.off(XrKeyboardEventType.XR_KEYBOARD_INPUT, this._xrKeyBoardInput, this);
        };

        _proto._onBackgroundSpriteFrameChanged = function _onBackgroundSpriteFrameChanged() {
          if (!this._background) {
            return;
          }

          this.backgroundImage = this._background.spriteFrame;
        };

        _proto._registerBackgroundEvent = function _registerBackgroundEvent() {
          var node = this._background && this._background.node;
          node === null || node === void 0 ? void 0 : node.on(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        };

        _proto._unregisterBackgroundEvent = function _unregisterBackgroundEvent() {
          var node = this._background && this._background.node;
          node === null || node === void 0 ? void 0 : node.off(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        };

        _proto._updateLabelPosition = function _updateLabelPosition(size) {
          var trans = this.node._uiProps.uiTransformComp;
          var offX = -trans.anchorX * trans.width;
          var offY = -trans.anchorY * trans.height;
          var placeholderLabel = this._placeholderLabel;
          var textLabel = this._textLabel;

          if (textLabel) {
            textLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

            textLabel.node.setPosition(offX + LEFT_PADDING$1, offY + size.height, textLabel.node.position.z);

            if (this._inputMode === InputMode.ANY) {
              textLabel.verticalAlign = VerticalTextAlignment.TOP;
            }

            textLabel.enableWrapText = this._inputMode === InputMode.ANY;
          }

          if (placeholderLabel) {
            placeholderLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

            placeholderLabel.lineHeight = size.height;
            placeholderLabel.node.setPosition(offX + LEFT_PADDING$1, offY + size.height, placeholderLabel.node.position.z);
            placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY;
          }
        };

        _proto._resizeChildNodes = function _resizeChildNodes() {
          var trans = this.node._uiProps.uiTransformComp;
          var textLabelNode = this._textLabel && this._textLabel.node;

          if (textLabelNode) {
            textLabelNode.setPosition(-trans.width / 2, trans.height / 2, textLabelNode.position.z);

            textLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }

          var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;

          if (placeholderLabelNode) {
            placeholderLabelNode.setPosition(-trans.width / 2, trans.height / 2, placeholderLabelNode.position.z);

            placeholderLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }

          var backgroundNode = this._background && this._background.node;

          if (backgroundNode) {
            backgroundNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }

          this._syncSize();
        };

        _proto._xrUnClick = function _xrUnClick() {
          this.node.emit(EventType$3.XR_EDITING_DID_BEGAN, this._maxLength, this.string);
        };

        _proto._xrKeyBoardInput = function _xrKeyBoardInput(str) {
          this.string = str;
        };

        _createClass(EditBox, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            if (this._maxLength >= 0 && value.length >= this._maxLength) {
              value = value.slice(0, this._maxLength);
            }

            if (this._string === value) {
              return;
            }

            this._string = value;

            this._updateString(value);
          }
        }, {
          key: "placeholder",
          get: function get() {
            if (!this._placeholderLabel) {
              return '';
            }

            return this._placeholderLabel.string;
          },
          set: function set(value) {
            if (this._placeholderLabel) {
              this._placeholderLabel.string = value;
            }
          }
        }, {
          key: "textLabel",
          get: function get() {
            return this._textLabel;
          },
          set: function set(oldValue) {
            if (this._textLabel !== oldValue) {
              this._textLabel = oldValue;

              if (this._textLabel) {
                this._updateTextLabel();

                this._updateLabels();
              }
            }
          }
        }, {
          key: "placeholderLabel",
          get: function get() {
            return this._placeholderLabel;
          },
          set: function set(oldValue) {
            if (this._placeholderLabel !== oldValue) {
              this._placeholderLabel = oldValue;

              if (this._placeholderLabel) {
                this._updatePlaceholderLabel();

                this._updateLabels();
              }
            }
          }
        }, {
          key: "backgroundImage",
          get: function get() {
            return this._backgroundImage;
          },
          set: function set(value) {
            if (this._backgroundImage === value) {
              return;
            }

            this._backgroundImage = value;

            this._ensureBackgroundSprite();

            this._background.spriteFrame = value;
          }
        }, {
          key: "inputFlag",
          get: function get() {
            return this._inputFlag;
          },
          set: function set(value) {
            if (this._inputFlag === value) {
              return;
            }

            this._inputFlag = value;

            this._updateString(this._string);
          }
        }, {
          key: "inputMode",
          get: function get() {
            return this._inputMode;
          },
          set: function set(oldValue) {
            if (this._inputMode !== oldValue) {
              this._inputMode = oldValue;

              this._updateTextLabel();

              this._updatePlaceholderLabel();
            }
          }
        }, {
          key: "returnType",
          get: function get() {
            return this._returnType;
          },
          set: function set(value) {
            this._returnType = value;
          }
        }, {
          key: "maxLength",
          get: function get() {
            return this._maxLength;
          },
          set: function set(value) {
            this._maxLength = value;
          }
        }, {
          key: "tabIndex",
          get: function get() {
            return this._tabIndex;
          },
          set: function set(value) {
            if (this._tabIndex !== value) {
              this._tabIndex = value;

              if (this._impl) {
                this._impl.setTabIndex(value);
              }
            }
          }
        }]);

        return EditBox;
      }(Component), _class3$i._EditBoxImpl = EditBoxImplBase, _class3$i.KeyboardReturnType = KeyboardReturnType, _class3$i.InputFlag = InputFlag, _class3$i.InputMode = InputMode, _class3$i.EventType = EventType$3, _temp$1g), (_applyDecoratedDescriptor(_class2$1d.prototype, "string", [_dec6$K, _dec7$G], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "string"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "placeholder", [_dec8$B, _dec9$w], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "placeholder"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "textLabel", [_dec10$t, _dec11$r, _dec12$q], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "textLabel"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "placeholderLabel", [_dec13$o, _dec14$m, _dec15$m], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "placeholderLabel"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "backgroundImage", [_dec16$l, _dec17$k, _dec18$j], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "backgroundImage"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "inputFlag", [_dec19$i, _dec20$i, _dec21$i], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "inputFlag"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "inputMode", [_dec22$g, _dec23$f, _dec24$f], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "inputMode"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "returnType", [_dec25$e, _dec26$e, _dec27$e], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "returnType"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "maxLength", [_dec28$d, _dec29$d], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "maxLength"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "tabIndex", [_dec30$b, _dec31$b], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "tabIndex"), _class2$1d.prototype), _descriptor$19 = _applyDecoratedDescriptor(_class2$1d.prototype, "editingDidBegan", [_dec32$8, serializable, _dec33$6, _dec34$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$$ = _applyDecoratedDescriptor(_class2$1d.prototype, "textChanged", [_dec35$6, serializable, _dec36$6, _dec37$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3$N = _applyDecoratedDescriptor(_class2$1d.prototype, "editingDidEnded", [_dec38$6, serializable, _dec39$6, _dec40$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor4$D = _applyDecoratedDescriptor(_class2$1d.prototype, "editingReturn", [_dec41$6, serializable, _dec42$6, _dec43$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor5$w = _applyDecoratedDescriptor(_class2$1d.prototype, "_textLabel", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6$s = _applyDecoratedDescriptor(_class2$1d.prototype, "_placeholderLabel", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7$m = _applyDecoratedDescriptor(_class2$1d.prototype, "_returnType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return KeyboardReturnType.DEFAULT;
        }
      }), _descriptor8$k = _applyDecoratedDescriptor(_class2$1d.prototype, "_string", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor9$h = _applyDecoratedDescriptor(_class2$1d.prototype, "_tabIndex", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor10$e = _applyDecoratedDescriptor(_class2$1d.prototype, "_backgroundImage", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$b = _applyDecoratedDescriptor(_class2$1d.prototype, "_inputFlag", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return InputFlag.DEFAULT;
        }
      }), _descriptor12$b = _applyDecoratedDescriptor(_class2$1d.prototype, "_inputMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return InputMode.ANY;
        }
      }), _descriptor13$b = _applyDecoratedDescriptor(_class2$1d.prototype, "_maxLength", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 20;
        }
      })), _class2$1d)) || _class$1m) || _class$1m) || _class$1m) || _class$1m) || _class$1m) || _class$1m));

      if (typeof window === 'object' && typeof document === 'object' && !MINIGAME && !JSB && !RUNTIME_BASED) {
        EditBox._EditBoxImpl = EditBoxImpl;
      }

      legacyCC.internal.EditBox = EditBox;

      var _dec$1m, _dec2$12, _dec3$_, _dec4$V, _dec5$R, _dec6$L, _dec7$H, _dec8$C, _dec9$x, _dec10$u, _dec11$s, _dec12$r, _dec13$p, _dec14$n, _dec15$n, _dec16$m, _dec17$l, _dec18$k, _dec19$j, _dec20$j, _dec21$j, _dec22$h, _dec23$g, _dec24$g, _dec25$f, _dec26$f, _dec27$f, _dec28$e, _dec29$e, _dec30$c, _dec31$c, _dec32$9, _dec33$7, _dec34$7, _dec35$7, _class$1n, _class2$1e, _descriptor$1a, _descriptor2$10, _descriptor3$O, _descriptor4$E, _descriptor5$x, _descriptor6$t, _descriptor7$n, _descriptor8$l, _descriptor9$i, _descriptor10$f, _descriptor11$c, _descriptor12$c, _descriptor13$c, _descriptor14$6, _descriptor15$4, _descriptor16$4, _class3$j, _temp$1h;
      var Type;

      (function (Type) {
        Type[Type["NONE"] = 0] = "NONE";
        Type[Type["HORIZONTAL"] = 1] = "HORIZONTAL";
        Type[Type["VERTICAL"] = 2] = "VERTICAL";
        Type[Type["GRID"] = 3] = "GRID";
      })(Type || (Type = {}));

      ccenum(Type);
      var ResizeMode;

      (function (ResizeMode) {
        ResizeMode[ResizeMode["NONE"] = 0] = "NONE";
        ResizeMode[ResizeMode["CONTAINER"] = 1] = "CONTAINER";
        ResizeMode[ResizeMode["CHILDREN"] = 2] = "CHILDREN";
      })(ResizeMode || (ResizeMode = {}));

      ccenum(ResizeMode);
      var AxisDirection;

      (function (AxisDirection) {
        AxisDirection[AxisDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
        AxisDirection[AxisDirection["VERTICAL"] = 1] = "VERTICAL";
      })(AxisDirection || (AxisDirection = {}));

      ccenum(AxisDirection);
      var VerticalDirection;

      (function (VerticalDirection) {
        VerticalDirection[VerticalDirection["BOTTOM_TO_TOP"] = 0] = "BOTTOM_TO_TOP";
        VerticalDirection[VerticalDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
      })(VerticalDirection || (VerticalDirection = {}));

      ccenum(VerticalDirection);
      var HorizontalDirection;

      (function (HorizontalDirection) {
        HorizontalDirection[HorizontalDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
        HorizontalDirection[HorizontalDirection["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
      })(HorizontalDirection || (HorizontalDirection = {}));

      ccenum(HorizontalDirection);
      var Constraint$1;

      (function (Constraint) {
        Constraint[Constraint["NONE"] = 0] = "NONE";
        Constraint[Constraint["FIXED_ROW"] = 1] = "FIXED_ROW";
        Constraint[Constraint["FIXED_COL"] = 2] = "FIXED_COL";
      })(Constraint$1 || (Constraint$1 = {}));

      ccenum(Constraint$1);

      var _tempVec3 = new Vec3();

      var Layout = function (v) { return exports({ Layout: v, LayoutComponent: v }), v; }((_dec$1m = ccclass('cc.Layout'), _dec2$12 = help(), _dec3$_ = executionOrder(110), _dec4$V = menu(), _dec5$R = requireComponent(UITransform), _dec6$L = visible(), _dec7$H = tooltip(), _dec8$C = visible(), _dec9$x = tooltip(), _dec10$u = type(Type), _dec11$s = displayOrder(), _dec12$r = tooltip(), _dec13$p = type(ResizeMode), _dec14$n = visible(), _dec15$n = tooltip(), _dec16$m = visible(), _dec17$l = tooltip(), _dec18$k = type(AxisDirection), _dec19$j = tooltip(), _dec20$j = tooltip(), _dec21$j = tooltip(), _dec22$h = tooltip(), _dec23$g = tooltip(), _dec24$g = tooltip(), _dec25$f = tooltip(), _dec26$f = type(VerticalDirection), _dec27$f = tooltip(), _dec28$e = type(HorizontalDirection), _dec29$e = tooltip(), _dec30$c = type(Constraint$1), _dec31$c = visible(), _dec32$9 = tooltip(), _dec33$7 = visible(), _dec34$7 = tooltip(), _dec35$7 = tooltip(), _dec$1m(_class$1n = _dec2$12(_class$1n = _dec3$_(_class$1n = _dec4$V(_class$1n = _dec5$R(_class$1n = executeInEditMode(_class$1n = (_class2$1e = (_temp$1h = _class3$j = function (_Component) {
        _inheritsLoose(Layout, _Component);

        function Layout() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_resizeMode", _descriptor$1a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_layoutType", _descriptor2$10, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cellSize", _descriptor3$O, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_startAxis", _descriptor4$E, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_paddingLeft", _descriptor5$x, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_paddingRight", _descriptor6$t, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_paddingTop", _descriptor7$n, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_paddingBottom", _descriptor8$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spacingX", _descriptor9$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spacingY", _descriptor10$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalDirection", _descriptor11$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalDirection", _descriptor12$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_constraint", _descriptor13$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_constraintNum", _descriptor14$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_affectedByScale", _descriptor15$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAlign", _descriptor16$4, _assertThisInitialized(_this));

          _this._layoutSize = new Size(300, 200);
          _this._layoutDirty = true;
          _this._childrenDirty = false;
          _this._usefulLayoutObj = [];
          _this._init = false;
          return _this;
        }

        var _proto = Layout.prototype;

        _proto.updateLayout = function updateLayout(force) {
          if (force === void 0) {
            force = false;
          }

          if ((this._layoutDirty || force) && this.node.children.length > 0) {
            this._doLayout();

            this._layoutDirty = false;
          }
        };

        _proto.onEnable = function onEnable() {
          this._addEventListeners();

          var trans = this.node._uiProps.uiTransformComp;

          if (trans.contentSize.equals(Size.ZERO)) {
            trans.setContentSize(this._layoutSize);
          }

          this._childrenChanged();
        };

        _proto.onDisable = function onDisable() {
          this._usefulLayoutObj.length = 0;

          this._removeEventListeners();
        };

        _proto._checkUsefulObj = function _checkUsefulObj() {
          this._usefulLayoutObj.length = 0;
          var children = this.node.children;

          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            var uiTrans = child._uiProps.uiTransformComp;

            if (child.activeInHierarchy && uiTrans) {
              this._usefulLayoutObj.push(uiTrans);
            }
          }
        };

        _proto._addEventListeners = function _addEventListeners() {
          director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._resized, this);
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          this.node.on(NodeEventType.CHILD_ADDED, this._childAdded, this);
          this.node.on(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
          this.node.on(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
          this.node.on('childrenSiblingOrderChanged', this.updateLayout, this);

          this._addChildrenEventListeners();
        };

        _proto._removeEventListeners = function _removeEventListeners() {
          director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._resized, this);
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          this.node.off(NodeEventType.CHILD_ADDED, this._childAdded, this);
          this.node.off(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
          this.node.off(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
          this.node.off('childrenSiblingOrderChanged', this.updateLayout, this);

          this._removeChildrenEventListeners();
        };

        _proto._addChildrenEventListeners = function _addChildrenEventListeners() {
          var children = this.node.children;

          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
            child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
            child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
            child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        };

        _proto._removeChildrenEventListeners = function _removeChildrenEventListeners() {
          var children = this.node.children;

          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
            child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
            child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
            child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        };

        _proto._childAdded = function _childAdded(child) {
          child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
          child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);

          this._childrenChanged();
        };

        _proto._childRemoved = function _childRemoved(child) {
          child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
          child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);

          this._childrenChanged();
        };

        _proto._resized = function _resized() {
          this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize);

          this._doLayoutDirty();
        };

        _proto._doLayoutHorizontally = function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
          var trans = this.node._uiProps.uiTransformComp;
          var layoutAnchor = trans.anchorPoint;

          var limit = this._getFixedBreakingNum();

          var sign = 1;
          var paddingX = this._paddingLeft;

          if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            paddingX = this._paddingRight;
          }

          var startPos = (this._horizontalDirection - layoutAnchor.x) * baseWidth + sign * paddingX;
          var nextX = startPos - sign * this._spacingX;
          var totalHeight = 0;
          var rowMaxHeight = 0;
          var tempMaxHeight = 0;
          var maxHeight = 0;
          var isBreak = false;
          var activeChildCount = this._usefulLayoutObj.length;
          var newChildWidth = this._cellSize.width;

          var paddingH = this._getPaddingH();

          if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
            newChildWidth = (baseWidth - paddingH - (activeChildCount - 1) * this._spacingX) / activeChildCount;
          }

          var children = this._usefulLayoutObj;

          for (var i = 0; i < children.length; ++i) {
            var childTrans = children[i];
            var child = childTrans.node;
            var scale = child.scale;

            var childScaleX = this._getUsedScaleValue(scale.x);

            var childScaleY = this._getUsedScaleValue(scale.y);

            if (this._resizeMode === ResizeMode.CHILDREN) {
              childTrans.width = newChildWidth / childScaleX;

              if (this._layoutType === Type.GRID) {
                childTrans.height = this._cellSize.height / childScaleY;
              }
            }

            var anchorX = Math.abs(this._horizontalDirection - childTrans.anchorX);
            var childBoundingBoxWidth = childTrans.width * childScaleX;
            var childBoundingBoxHeight = childTrans.height * childScaleY;

            if (childBoundingBoxHeight > tempMaxHeight) {
              maxHeight = Math.max(tempMaxHeight, maxHeight);
              rowMaxHeight = tempMaxHeight || childBoundingBoxHeight;
              tempMaxHeight = childBoundingBoxHeight;
            }

            nextX += sign * (anchorX * childBoundingBoxWidth + this._spacingX);
            var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;

            if (rowBreak) {
              if (limit > 0) {
                isBreak = i / limit > 0 && i % limit === 0;

                if (isBreak) {
                  rowMaxHeight = tempMaxHeight > childBoundingBoxHeight ? tempMaxHeight : rowMaxHeight;
                }
              } else if (childBoundingBoxWidth > baseWidth - paddingH) {
                if (nextX > startPos + sign * (anchorX * childBoundingBoxWidth)) {
                  isBreak = true;
                }
              } else {
                var boundary = (1 - this._horizontalDirection - layoutAnchor.x) * baseWidth;
                var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft);
                isBreak = Math.abs(rowBreakBoundary) > Math.abs(boundary);
              }

              if (isBreak) {
                nextX = startPos + sign * (anchorX * childBoundingBoxWidth);

                if (childBoundingBoxHeight !== tempMaxHeight) {
                  rowMaxHeight = tempMaxHeight;
                }

                totalHeight += rowMaxHeight + this._spacingY;
                rowMaxHeight = tempMaxHeight = childBoundingBoxHeight;
              }
            }

            var finalPositionY = fnPositionY(child, childTrans, totalHeight);

            if (applyChildren) {
              child.setPosition(nextX, finalPositionY);
            }

            nextX += rightBoundaryOfChild;
          }

          rowMaxHeight = Math.max(rowMaxHeight, tempMaxHeight);

          var containerResizeBoundary = Math.max(maxHeight, totalHeight + rowMaxHeight) + this._getPaddingV();

          return containerResizeBoundary;
        };

        _proto._doLayoutVertically = function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
          var trans = this.node._uiProps.uiTransformComp;
          var layoutAnchor = trans.anchorPoint;

          var limit = this._getFixedBreakingNum();

          var sign = 1;
          var paddingY = this._paddingBottom;

          if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            paddingY = this._paddingTop;
          }

          var startPos = (this._verticalDirection - layoutAnchor.y) * baseHeight + sign * paddingY;
          var nextY = startPos - sign * this._spacingY;
          var tempMaxWidth = 0;
          var maxWidth = 0;
          var colMaxWidth = 0;
          var totalWidth = 0;
          var isBreak = false;
          var activeChildCount = this._usefulLayoutObj.length;
          var newChildHeight = this._cellSize.height;

          var paddingV = this._getPaddingV();

          if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
            newChildHeight = (baseHeight - paddingV - (activeChildCount - 1) * this._spacingY) / activeChildCount;
          }

          var children = this._usefulLayoutObj;

          for (var i = 0; i < children.length; ++i) {
            var childTrans = children[i];
            var child = childTrans.node;
            var scale = child.scale;

            var childScaleX = this._getUsedScaleValue(scale.x);

            var childScaleY = this._getUsedScaleValue(scale.y);

            if (this._resizeMode === ResizeMode.CHILDREN) {
              childTrans.height = newChildHeight / childScaleY;

              if (this._layoutType === Type.GRID) {
                childTrans.width = this._cellSize.width / childScaleX;
              }
            }

            var anchorY = Math.abs(this._verticalDirection - childTrans.anchorY);
            var childBoundingBoxWidth = childTrans.width * childScaleX;
            var childBoundingBoxHeight = childTrans.height * childScaleY;

            if (childBoundingBoxWidth > tempMaxWidth) {
              maxWidth = Math.max(tempMaxWidth, maxWidth);
              colMaxWidth = tempMaxWidth || childBoundingBoxWidth;
              tempMaxWidth = childBoundingBoxWidth;
            }

            nextY += sign * (anchorY * childBoundingBoxHeight + this._spacingY);
            var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;

            if (columnBreak) {
              if (limit > 0) {
                isBreak = i / limit > 0 && i % limit === 0;

                if (isBreak) {
                  colMaxWidth = tempMaxWidth > childBoundingBoxHeight ? tempMaxWidth : colMaxWidth;
                }
              } else if (childBoundingBoxHeight > baseHeight - paddingV) {
                if (nextY > startPos + sign * (anchorY * childBoundingBoxHeight)) {
                  isBreak = true;
                }
              } else {
                var boundary = (1 - this._verticalDirection - layoutAnchor.y) * baseHeight;
                var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom);
                isBreak = Math.abs(columnBreakBoundary) > Math.abs(boundary);
              }

              if (isBreak) {
                nextY = startPos + sign * (anchorY * childBoundingBoxHeight);

                if (childBoundingBoxWidth !== tempMaxWidth) {
                  colMaxWidth = tempMaxWidth;
                }

                totalWidth += colMaxWidth + this._spacingX;
                colMaxWidth = tempMaxWidth = childBoundingBoxWidth;
              }
            }

            var finalPositionX = fnPositionX(child, childTrans, totalWidth);

            if (applyChildren) {
              child.getPosition(_tempVec3);
              child.setPosition(finalPositionX, nextY, _tempVec3.z);
            }

            nextY += topBoundaryOfChild;
          }

          colMaxWidth = Math.max(colMaxWidth, tempMaxWidth);

          var containerResizeBoundary = Math.max(maxWidth, totalWidth + colMaxWidth) + this._getPaddingH();

          return containerResizeBoundary;
        };

        _proto._doLayoutGridAxisHorizontal = function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
          var _this2 = this;

          var baseWidth = layoutSize.width;
          var sign = 1;
          var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
          var paddingY = this._paddingBottom;

          if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
            paddingY = this._paddingTop;
          }

          var fnPositionY = function fnPositionY(child, childTrans, topOffset) {
            return bottomBoundaryOfLayout + sign * (topOffset + (1 - childTrans.anchorY) * childTrans.height * _this2._getUsedScaleValue(child.scale.y) + paddingY);
          };

          var newHeight = 0;

          if (this._resizeMode === ResizeMode.CONTAINER) {
            newHeight = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
            bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;

            if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
              sign = -1;
              bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
            }
          }

          this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);

          if (this._resizeMode === ResizeMode.CONTAINER) {
            this.node._uiProps.uiTransformComp.setContentSize(baseWidth, newHeight);
          }
        };

        _proto._doLayoutGridAxisVertical = function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
          var _this3 = this;

          var baseHeight = layoutSize.height;
          var sign = 1;
          var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
          var paddingX = this._paddingLeft;

          if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
            paddingX = this._paddingRight;
          }

          var fnPositionX = function fnPositionX(child, childTrans, leftOffset) {
            return leftBoundaryOfLayout + sign * (leftOffset + (1 - childTrans.anchorX) * childTrans.width * _this3._getUsedScaleValue(child.scale.x) + paddingX);
          };

          var newWidth = 0;

          if (this._resizeMode === ResizeMode.CONTAINER) {
            newWidth = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
            leftBoundaryOfLayout = -layoutAnchor.x * newWidth;

            if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
              sign = -1;
              leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
            }
          }

          this._doLayoutVertically(baseHeight, true, fnPositionX, true);

          if (this._resizeMode === ResizeMode.CONTAINER) {
            this.node._uiProps.uiTransformComp.setContentSize(newWidth, baseHeight);
          }
        };

        _proto._doLayoutGrid = function _doLayoutGrid() {
          var trans = this.node._uiProps.uiTransformComp;
          var layoutAnchor = trans.anchorPoint;
          var layoutSize = trans.contentSize;

          if (this.startAxis === AxisDirection.HORIZONTAL) {
            this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize);
          } else if (this.startAxis === AxisDirection.VERTICAL) {
            this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
          }
        };

        _proto._getHorizontalBaseWidth = function _getHorizontalBaseWidth(horizontal) {

          var children = this._usefulLayoutObj;
          var baseSize = 0;
          var activeChildCount = children.length;

          if (this._resizeMode === ResizeMode.CONTAINER) {
            for (var i = 0; i < children.length; ++i) {
              var childTrans = children[i];
              var child = childTrans.node;
              var scale = child.scale;
              baseSize += childTrans.width * this._getUsedScaleValue(scale.x);
            }

            baseSize += (activeChildCount - 1) * this._spacingX + this._getPaddingH();
          } else {
            baseSize = this.node._uiProps.uiTransformComp.width;
          }

          return baseSize;
        };

        _proto._getVerticalBaseHeight = function _getVerticalBaseHeight() {
          var children = this._usefulLayoutObj;
          var baseSize = 0;
          var activeChildCount = children.length;

          if (this._resizeMode === ResizeMode.CONTAINER) {
            for (var i = 0; i < children.length; ++i) {
              var childTrans = children[i];
              var child = childTrans.node;
              var scale = child.scale;
              baseSize += childTrans.height * this._getUsedScaleValue(scale.y);
            }

            baseSize += (activeChildCount - 1) * this._spacingY + this._getPaddingV();
          } else {
            baseSize = this.node._uiProps.uiTransformComp.height;
          }

          return baseSize;
        };

        _proto._doLayout = function _doLayout() {
          var _this4 = this;

          if (!this._init || this._childrenDirty) {
            this._checkUsefulObj();

            this._init = true;
            this._childrenDirty = false;
          }

          if (this._layoutType === Type.HORIZONTAL) {
            var newWidth = this._getHorizontalBaseWidth();

            var fnPositionY = function fnPositionY(child) {
              var pos = _this4._isAlign ? Vec3.ZERO : child.position;
              return pos.y;
            };

            this._doLayoutHorizontally(newWidth, false, fnPositionY, true);

            this.node._uiProps.uiTransformComp.width = newWidth;
          } else if (this._layoutType === Type.VERTICAL) {
            var newHeight = this._getVerticalBaseHeight();

            var fnPositionX = function fnPositionX(child) {
              var pos = _this4._isAlign ? Vec3.ZERO : child.position;
              return pos.x;
            };

            this._doLayoutVertically(newHeight, false, fnPositionX, true);

            this.node._uiProps.uiTransformComp.height = newHeight;
          } else if (this._layoutType === Type.GRID) {
            this._doLayoutGrid();
          }
        };

        _proto._getUsedScaleValue = function _getUsedScaleValue(value) {
          return this._affectedByScale ? Math.abs(value) : 1;
        };

        _proto._transformDirty = function _transformDirty(type) {
          if (!(type & TransformBit.SCALE) || !(type & TransformBit.POSITION) || !this._affectedByScale) {
            return;
          }

          this._doLayoutDirty();
        };

        _proto._doLayoutDirty = function _doLayoutDirty() {
          this._layoutDirty = true;
        };

        _proto._childrenChanged = function _childrenChanged() {
          this._childrenDirty = true;

          this._doLayoutDirty();
        };

        _proto._getPaddingH = function _getPaddingH() {
          return this._paddingLeft + this._paddingRight;
        };

        _proto._getPaddingV = function _getPaddingV() {
          return this._paddingTop + this._paddingBottom;
        };

        _proto._getFixedBreakingNum = function _getFixedBreakingNum() {
          if (this._layoutType !== Type.GRID || this._constraint === Constraint$1.NONE || this._constraintNum <= 0) {
            return 0;
          }

          var num = this._constraint === Constraint$1.FIXED_ROW ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;

          if (this._startAxis === AxisDirection.VERTICAL) {
            num = this._constraint === Constraint$1.FIXED_COL ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
          }

          return num;
        };

        _createClass(Layout, [{
          key: "alignHorizontal",
          get: function get() {
            return this._isAlign;
          },
          set: function set(value) {
            if (this._layoutType !== Type.HORIZONTAL) {
              return;
            }

            this._isAlign = value;

            this._doLayoutDirty();
          }
        }, {
          key: "alignVertical",
          get: function get() {
            return this._isAlign;
          },
          set: function set(value) {
            if (this._layoutType !== Type.VERTICAL) {
              return;
            }

            this._isAlign = value;

            this._doLayoutDirty();
          }
        }, {
          key: "type",
          get: function get() {
            return this._layoutType;
          },
          set: function set(value) {
            this._layoutType = value;

            this._doLayoutDirty();
          }
        }, {
          key: "resizeMode",
          get: function get() {
            return this._resizeMode;
          },
          set: function set(value) {
            if (this._layoutType === Type.NONE) {
              return;
            }

            this._resizeMode = value;

            this._doLayoutDirty();
          }
        }, {
          key: "cellSize",
          get: function get() {
            return this._cellSize;
          },
          set: function set(value) {
            if (this._cellSize === value) {
              return;
            }

            this._cellSize.set(value);

            this._doLayoutDirty();
          }
        }, {
          key: "startAxis",
          get: function get() {
            return this._startAxis;
          },
          set: function set(value) {
            if (this._startAxis === value) {
              return;
            }

            this._startAxis = value;

            this._doLayoutDirty();
          }
        }, {
          key: "paddingLeft",
          get: function get() {
            return this._paddingLeft;
          },
          set: function set(value) {
            if (this._paddingLeft === value) {
              return;
            }

            this._paddingLeft = value;

            this._doLayoutDirty();
          }
        }, {
          key: "paddingRight",
          get: function get() {
            return this._paddingRight;
          },
          set: function set(value) {
            if (this._paddingRight === value) {
              return;
            }

            this._paddingRight = value;

            this._doLayoutDirty();
          }
        }, {
          key: "paddingTop",
          get: function get() {
            return this._paddingTop;
          },
          set: function set(value) {
            if (this._paddingTop === value) {
              return;
            }

            this._paddingTop = value;

            this._doLayoutDirty();
          }
        }, {
          key: "paddingBottom",
          get: function get() {
            return this._paddingBottom;
          },
          set: function set(value) {
            if (this._paddingBottom === value) {
              return;
            }

            this._paddingBottom = value;

            this._doLayoutDirty();
          }
        }, {
          key: "spacingX",
          get: function get() {
            return this._spacingX;
          },
          set: function set(value) {
            if (this._spacingX === value) {
              return;
            }

            this._spacingX = value;

            this._doLayoutDirty();
          }
        }, {
          key: "spacingY",
          get: function get() {
            return this._spacingY;
          },
          set: function set(value) {
            if (this._spacingY === value) {
              return;
            }

            this._spacingY = value;

            this._doLayoutDirty();
          }
        }, {
          key: "verticalDirection",
          get: function get() {
            return this._verticalDirection;
          },
          set: function set(value) {
            if (this._verticalDirection === value) {
              return;
            }

            this._verticalDirection = value;

            this._doLayoutDirty();
          }
        }, {
          key: "horizontalDirection",
          get: function get() {
            return this._horizontalDirection;
          },
          set: function set(value) {
            if (this._horizontalDirection === value) {
              return;
            }

            this._horizontalDirection = value;

            this._doLayoutDirty();
          }
        }, {
          key: "padding",
          get: function get() {
            return this._paddingLeft;
          },
          set: function set(value) {
            if (this.paddingLeft !== value || this._paddingRight !== value || this._paddingTop !== value || this._paddingBottom !== value) {
              this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = value;

              this._doLayoutDirty();
            }
          }
        }, {
          key: "constraint",
          get: function get() {
            return this._constraint;
          },
          set: function set(value) {
            if (this._layoutType === Type.NONE || this._constraint === value) {
              return;
            }

            this._constraint = value;

            this._doLayoutDirty();
          }
        }, {
          key: "constraintNum",
          get: function get() {
            return this._constraintNum;
          },
          set: function set(value) {
            if (this._constraint === Constraint$1.NONE || this._constraintNum === value) {
              return;
            }

            if (value <= 0) {
              warn('Limit values to be greater than 0');
            }

            this._constraintNum = value;

            this._doLayoutDirty();
          }
        }, {
          key: "affectedByScale",
          get: function get() {
            return this._affectedByScale;
          },
          set: function set(value) {
            this._affectedByScale = value;

            this._doLayoutDirty();
          }
        }]);

        return Layout;
      }(Component), _class3$j.Type = Type, _class3$j.VerticalDirection = VerticalDirection, _class3$j.HorizontalDirection = HorizontalDirection, _class3$j.ResizeMode = ResizeMode, _class3$j.AxisDirection = AxisDirection, _class3$j.Constraint = Constraint$1, _temp$1h), (_applyDecoratedDescriptor(_class2$1e.prototype, "alignHorizontal", [_dec6$L, _dec7$H], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "alignHorizontal"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "alignVertical", [_dec8$C, _dec9$x], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "alignVertical"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "type", [_dec10$u, _dec11$s, _dec12$r], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "type"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "resizeMode", [_dec13$p, _dec14$n, _dec15$n], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "resizeMode"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "cellSize", [_dec16$m, _dec17$l], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "cellSize"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "startAxis", [_dec18$k, _dec19$j], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "startAxis"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "paddingLeft", [_dec20$j], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "paddingLeft"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "paddingRight", [_dec21$j], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "paddingRight"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "paddingTop", [_dec22$h], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "paddingTop"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "paddingBottom", [_dec23$g], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "paddingBottom"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "spacingX", [_dec24$g], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "spacingX"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "spacingY", [_dec25$f], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "spacingY"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "verticalDirection", [_dec26$f, _dec27$f], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "verticalDirection"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "horizontalDirection", [_dec28$e, _dec29$e], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "horizontalDirection"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "constraint", [_dec30$c, _dec31$c, _dec32$9], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "constraint"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "constraintNum", [_dec33$7, _dec34$7], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "constraintNum"), _class2$1e.prototype), _applyDecoratedDescriptor(_class2$1e.prototype, "affectedByScale", [_dec35$7], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "affectedByScale"), _class2$1e.prototype), _descriptor$1a = _applyDecoratedDescriptor(_class2$1e.prototype, "_resizeMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ResizeMode.NONE;
        }
      }), _descriptor2$10 = _applyDecoratedDescriptor(_class2$1e.prototype, "_layoutType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Type.NONE;
        }
      }), _descriptor3$O = _applyDecoratedDescriptor(_class2$1e.prototype, "_cellSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(40, 40);
        }
      }), _descriptor4$E = _applyDecoratedDescriptor(_class2$1e.prototype, "_startAxis", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AxisDirection.HORIZONTAL;
        }
      }), _descriptor5$x = _applyDecoratedDescriptor(_class2$1e.prototype, "_paddingLeft", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor6$t = _applyDecoratedDescriptor(_class2$1e.prototype, "_paddingRight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$n = _applyDecoratedDescriptor(_class2$1e.prototype, "_paddingTop", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8$l = _applyDecoratedDescriptor(_class2$1e.prototype, "_paddingBottom", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor9$i = _applyDecoratedDescriptor(_class2$1e.prototype, "_spacingX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor10$f = _applyDecoratedDescriptor(_class2$1e.prototype, "_spacingY", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor11$c = _applyDecoratedDescriptor(_class2$1e.prototype, "_verticalDirection", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return VerticalDirection.TOP_TO_BOTTOM;
        }
      }), _descriptor12$c = _applyDecoratedDescriptor(_class2$1e.prototype, "_horizontalDirection", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return HorizontalDirection.LEFT_TO_RIGHT;
        }
      }), _descriptor13$c = _applyDecoratedDescriptor(_class2$1e.prototype, "_constraint", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Constraint$1.NONE;
        }
      }), _descriptor14$6 = _applyDecoratedDescriptor(_class2$1e.prototype, "_constraintNum", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _descriptor15$4 = _applyDecoratedDescriptor(_class2$1e.prototype, "_affectedByScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor16$4 = _applyDecoratedDescriptor(_class2$1e.prototype, "_isAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2$1e)) || _class$1n) || _class$1n) || _class$1n) || _class$1n) || _class$1n) || _class$1n));
      legacyCC.Layout = Layout;

      var _dec$1n, _dec2$13, _dec3$$, _dec4$W, _dec5$S, _dec6$M, _dec7$I, _dec8$D, _dec9$y, _dec10$v, _dec11$t, _dec12$s, _dec13$q, _class$1o, _class2$1f, _descriptor$1b, _descriptor2$11, _descriptor3$P, _descriptor4$F, _descriptor5$y, _class3$k, _temp$1i;
      var Mode$4;

      (function (Mode) {
        Mode[Mode["HORIZONTAL"] = 0] = "HORIZONTAL";
        Mode[Mode["VERTICAL"] = 1] = "VERTICAL";
        Mode[Mode["FILLED"] = 2] = "FILLED";
      })(Mode$4 || (Mode$4 = {}));

      Enum(Mode$4);
      var ProgressBar = function (v) { return exports({ ProgressBar: v, ProgressBarComponent: v }), v; }((_dec$1n = ccclass('cc.ProgressBar'), _dec2$13 = help(), _dec3$$ = executionOrder(110), _dec4$W = menu(), _dec5$S = requireComponent(UITransform), _dec6$M = type(Sprite), _dec7$I = tooltip(), _dec8$D = type(Mode$4), _dec9$y = tooltip(), _dec10$v = tooltip(), _dec11$t = range(), _dec12$s = tooltip(), _dec13$q = tooltip(), _dec$1n(_class$1o = _dec2$13(_class$1o = _dec3$$(_class$1o = _dec4$W(_class$1o = _dec5$S(_class$1o = (_class2$1f = (_temp$1i = _class3$k = function (_Component) {
        _inheritsLoose(ProgressBar, _Component);

        function ProgressBar() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_barSprite", _descriptor$1b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mode", _descriptor2$11, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_totalLength", _descriptor3$P, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_progress", _descriptor4$F, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_reverse", _descriptor5$y, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = ProgressBar.prototype;

        _proto._initBarSprite = function _initBarSprite() {
          if (this._barSprite) {
            var entity = this._barSprite.node;

            if (!entity) {
              return;
            }

            var trans = this.node._uiProps.uiTransformComp;
            var nodeSize = trans.contentSize;
            var nodeAnchor = trans.anchorPoint;
            var barSpriteSize = entity._uiProps.uiTransformComp.contentSize;

            if (this._barSprite.fillType === Sprite.FillType.RADIAL) {
              this._mode = Mode$4.FILLED;
            }

            if (this._mode === Mode$4.HORIZONTAL) {
              this.totalLength = barSpriteSize.width;
            } else if (this._mode === Mode$4.VERTICAL) {
              this.totalLength = barSpriteSize.height;
            } else {
              this.totalLength = this._barSprite.fillRange;
            }

            if (entity.parent === this.node) {
              var x = -nodeSize.width * nodeAnchor.x;
              entity.setPosition(x, 0, 0);
            }
          }
        };

        _proto._updateBarStatus = function _updateBarStatus() {
          if (this._barSprite) {
            var entity = this._barSprite.node;

            if (!entity) {
              return;
            }

            var entTrans = entity._uiProps.uiTransformComp;
            var entityAnchorPoint = entTrans.anchorPoint;
            var entitySize = entTrans.contentSize;
            var entityPosition = entity.getPosition();
            var anchorPoint = new Vec2(0, 0.5);
            var progress = clamp01(this._progress);
            var actualLenth = this._totalLength * progress;
            var finalContentSize = entitySize;
            var totalWidth = 0;
            var totalHeight = 0;

            switch (this._mode) {
              case Mode$4.HORIZONTAL:
                if (this._reverse) {
                  anchorPoint = new Vec2(1, 0.5);
                }

                finalContentSize = new Size(actualLenth, entitySize.height);
                totalWidth = this._totalLength;
                totalHeight = entitySize.height;
                break;

              case Mode$4.VERTICAL:
                if (this._reverse) {
                  anchorPoint = new Vec2(0.5, 1);
                } else {
                  anchorPoint = new Vec2(0.5, 0);
                }

                finalContentSize = new Size(entitySize.width, actualLenth);
                totalWidth = entitySize.width;
                totalHeight = this._totalLength;
                break;
            }

            if (this._mode === Mode$4.FILLED) {
              if (this._barSprite.type !== Sprite.Type.FILLED) {
                warn('ProgressBar FILLED mode only works when barSprite\'s Type is FILLED!');
              } else {
                if (this._reverse) {
                  actualLenth *= -1;
                }

                this._barSprite.fillRange = actualLenth;
              }
            } else if (this._barSprite.type !== Sprite.Type.FILLED) {
              var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
              var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
              var finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
              entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z);
              entTrans.setAnchorPoint(anchorPoint);
              entTrans.setContentSize(finalContentSize);
            } else {
              warn('ProgressBar non-FILLED mode only works when barSprite\'s Type is non-FILLED!');
            }
          }
        };

        _createClass(ProgressBar, [{
          key: "barSprite",
          get: function get() {
            return this._barSprite;
          },
          set: function set(value) {
            if (this._barSprite === value) {
              return;
            }

            this._barSprite = value;

            this._initBarSprite();
          }
        }, {
          key: "mode",
          get: function get() {
            return this._mode;
          },
          set: function set(value) {
            if (this._mode === value) {
              return;
            }

            this._mode = value;

            if (this._barSprite) {
              var entity = this._barSprite.node;

              if (!entity) {
                return;
              }

              var entitySize = entity._uiProps.uiTransformComp.contentSize;

              if (this._mode === Mode$4.HORIZONTAL) {
                this.totalLength = entitySize.width;
              } else if (this._mode === Mode$4.VERTICAL) {
                this.totalLength = entitySize.height;
              } else if (this._mode === Mode$4.FILLED) {
                this.totalLength = this._barSprite.fillRange;
              }
            }
          }
        }, {
          key: "totalLength",
          get: function get() {
            return this._totalLength;
          },
          set: function set(value) {
            if (this._mode === Mode$4.FILLED) {
              value = clamp01(value);
            }

            if (this._totalLength === value) {
              return;
            }

            this._totalLength = value;

            this._updateBarStatus();
          }
        }, {
          key: "progress",
          get: function get() {
            return this._progress;
          },
          set: function set(value) {
            if (this._progress === value) {
              return;
            }

            this._progress = value;

            this._updateBarStatus();
          }
        }, {
          key: "reverse",
          get: function get() {
            return this._reverse;
          },
          set: function set(value) {
            if (this._reverse === value) {
              return;
            }

            this._reverse = value;

            if (this._barSprite) {
              this._barSprite.fillStart = 1 - this._barSprite.fillStart;
            }

            this._updateBarStatus();
          }
        }]);

        return ProgressBar;
      }(Component), _class3$k.Mode = Mode$4, _temp$1i), (_applyDecoratedDescriptor(_class2$1f.prototype, "barSprite", [_dec6$M, _dec7$I], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "barSprite"), _class2$1f.prototype), _applyDecoratedDescriptor(_class2$1f.prototype, "mode", [_dec8$D, _dec9$y], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "mode"), _class2$1f.prototype), _applyDecoratedDescriptor(_class2$1f.prototype, "totalLength", [_dec10$v], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "totalLength"), _class2$1f.prototype), _applyDecoratedDescriptor(_class2$1f.prototype, "progress", [_dec11$t, slide, _dec12$s], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "progress"), _class2$1f.prototype), _applyDecoratedDescriptor(_class2$1f.prototype, "reverse", [_dec13$q], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "reverse"), _class2$1f.prototype), _descriptor$1b = _applyDecoratedDescriptor(_class2$1f.prototype, "_barSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$11 = _applyDecoratedDescriptor(_class2$1f.prototype, "_mode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Mode$4.HORIZONTAL;
        }
      }), _descriptor3$P = _applyDecoratedDescriptor(_class2$1f.prototype, "_totalLength", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor4$F = _applyDecoratedDescriptor(_class2$1f.prototype, "_progress", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor5$y = _applyDecoratedDescriptor(_class2$1f.prototype, "_reverse", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2$1f)) || _class$1o) || _class$1o) || _class$1o) || _class$1o) || _class$1o));
      legacyCC.ProgressBar = ProgressBar;

      var _dec$1o, _dec2$14, _dec3$10, _dec4$X, _dec5$T, _dec6$N, _dec7$J, _dec8$E, _dec9$z, _dec10$w, _dec11$u, _dec12$t, _dec13$r, _dec14$o, _dec15$o, _class$1p, _class2$1g, _descriptor$1c, _descriptor2$12, _descriptor3$Q, _descriptor4$G, _descriptor5$z, _class3$l, _temp$1j;
      var GETTING_SHORTER_FACTOR = 20;

      var _tempPos_1 = new Vec3();

      var _tempPos_2 = new Vec3();

      var _tempVec3$1 = new Vec3();

      var defaultAnchor = new Vec2();

      var _tempColor$1 = new Color();

      var _tempVec2 = new Vec2();

      var Direction;

      (function (Direction) {
        Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
        Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
      })(Direction || (Direction = {}));

      ccenum(Direction);
      var ScrollBar = function (v) { return exports({ ScrollBar: v, ScrollBarComponent: v }), v; }((_dec$1o = ccclass('cc.ScrollBar'), _dec2$14 = help(), _dec3$10 = executionOrder(110), _dec4$X = menu(), _dec5$T = requireComponent(UITransform), _dec6$N = type(Sprite), _dec7$J = displayOrder(), _dec8$E = tooltip(), _dec9$z = type(Direction), _dec10$w = displayOrder(), _dec11$u = tooltip(), _dec12$t = displayOrder(), _dec13$r = tooltip(), _dec14$o = displayOrder(), _dec15$o = tooltip(), _dec$1o(_class$1p = _dec2$14(_class$1p = _dec3$10(_class$1p = _dec4$X(_class$1p = _dec5$T(_class$1p = (_class2$1g = (_temp$1j = _class3$l = function (_Component) {
        _inheritsLoose(ScrollBar, _Component);

        function ScrollBar() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_scrollView", _descriptor$1c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_handle", _descriptor2$12, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$Q, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_enableAutoHide", _descriptor4$G, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_autoHideTime", _descriptor5$z, _assertThisInitialized(_this));

          _this._touching = false;
          _this._opacity = 255;
          _this._autoHideRemainingTime = 0;
          return _this;
        }

        var _proto = ScrollBar.prototype;

        _proto.hide = function hide() {
          this._autoHideRemainingTime = 0;

          this._setOpacity(0);
        };

        _proto.show = function show() {
          this._autoHideRemainingTime = this._autoHideTime;

          this._setOpacity(this._opacity);
        };

        _proto.onScroll = function onScroll(outOfBoundary) {
          if (!this._scrollView) {
            return;
          }

          var content = this._scrollView.content;

          if (!content) {
            return;
          }

          var contentSize = content._uiProps.uiTransformComp.contentSize;
          var scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
          var barSize = this.node._uiProps.uiTransformComp.contentSize;

          if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
            return;
          }

          if (this._enableAutoHide) {
            this._autoHideRemainingTime = this._autoHideTime;

            this._setOpacity(this._opacity);
          }

          var contentMeasure = 0;
          var scrollViewMeasure = 0;
          var outOfBoundaryValue = 0;
          var contentPosition = 0;
          var handleNodeMeasure = 0;
          var outOfContentPosition = _tempVec2;
          outOfContentPosition.set(0, 0);

          if (this._direction === Direction.HORIZONTAL) {
            contentMeasure = contentSize.width;
            scrollViewMeasure = scrollViewSize.width;
            handleNodeMeasure = barSize.width;
            outOfBoundaryValue = outOfBoundary.x;

            this._convertToScrollViewSpace(outOfContentPosition, content);

            contentPosition = -outOfContentPosition.x;
          } else if (this._direction === Direction.VERTICAL) {
            contentMeasure = contentSize.height;
            scrollViewMeasure = scrollViewSize.height;
            handleNodeMeasure = barSize.height;
            outOfBoundaryValue = outOfBoundary.y;

            this._convertToScrollViewSpace(outOfContentPosition, content);

            contentPosition = -outOfContentPosition.y;
          }

          var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);

          var position = _tempVec2;

          this._calculatePosition(position, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);

          this._updateLength(length);

          this._updateHandlerPosition(position);
        };

        _proto.setScrollView = function setScrollView(scrollView) {
          this._scrollView = scrollView;
        };

        _proto.onTouchBegan = function onTouchBegan() {
          if (!this._enableAutoHide) {
            return;
          }

          this._touching = true;
        };

        _proto.onTouchEnded = function onTouchEnded() {
          if (!this._enableAutoHide) {
            return;
          }

          this._touching = false;

          if (this._autoHideTime <= 0) {
            return;
          }

          if (this._scrollView) {
            var content = this._scrollView.content;

            if (content) {
              var contentSize = content._uiProps.uiTransformComp.contentSize;
              var scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;

              if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                return;
              }
            }
          }

          this._autoHideRemainingTime = this._autoHideTime;
        };

        _proto.onEnable = function onEnable() {
          var renderComp = this.node.getComponent(Sprite);

          if (renderComp) {
            this._opacity = renderComp.color.a;
          }
        };

        _proto.start = function start() {
          if (this._enableAutoHide) {
            this._setOpacity(0);
          }
        };

        _proto.update = function update(dt) {
          this._processAutoHide(dt);
        };

        _proto._convertToScrollViewSpace = function _convertToScrollViewSpace(out, content) {
          var scrollTrans = this._scrollView && this._scrollView.node._uiProps.uiTransformComp;
          var contentTrans = content._uiProps.uiTransformComp;

          if (!scrollTrans || !contentTrans) {
            out.set(Vec2.ZERO);
          } else {
            _tempPos_1.set(-contentTrans.anchorX * contentTrans.width, -contentTrans.anchorY * contentTrans.height, 0);

            contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
            var scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
            scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width;
            scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height;
            out.set(scrollViewSpacePos.x, scrollViewSpacePos.y);
          }
        };

        _proto._setOpacity = function _setOpacity(opacity) {
          if (this._handle) {
            var renderComp = this.node.getComponent(Sprite);

            if (renderComp) {
              _tempColor$1.set(renderComp.color);

              _tempColor$1.a = opacity;
              renderComp.color = _tempColor$1;
            }

            renderComp = this._handle.getComponent(Sprite);

            if (renderComp) {
              _tempColor$1.set(renderComp.color);

              _tempColor$1.a = opacity;
              renderComp.color = _tempColor$1;
            }
          }
        };

        _proto._updateHandlerPosition = function _updateHandlerPosition(position) {
          if (this._handle) {
            var oldPosition = _tempVec3$1;

            this._fixupHandlerPosition(oldPosition);

            this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
          }
        };

        _proto._fixupHandlerPosition = function _fixupHandlerPosition(out) {
          var uiTrans = this.node._uiProps.uiTransformComp;
          var barSize = uiTrans.contentSize;
          var barAnchor = uiTrans.anchorPoint;
          var handleSize = this.handle.node._uiProps.uiTransformComp.contentSize;
          var handleParent = this.handle.node.parent;
          Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);

          var leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);

          var fixupPosition = out;
          fixupPosition.set(0, 0, 0);

          handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition);

          if (this.direction === Direction.HORIZONTAL) {
            fixupPosition.set(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, fixupPosition.z);
          } else if (this.direction === Direction.VERTICAL) {
            fixupPosition.set(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, fixupPosition.z);
          }

          this.handle.node.setPosition(fixupPosition);
        };

        _proto._conditionalDisableScrollBar = function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
          if (contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL) {
            return true;
          }

          if (contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL) {
            return true;
          }

          return false;
        };

        _proto._calculateLength = function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
          var denominatorValue = contentMeasure;

          if (outOfBoundary) {
            denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTING_SHORTER_FACTOR;
          }

          var lengthRation = scrollViewMeasure / denominatorValue;
          return handleNodeMeasure * lengthRation;
        };

        _proto._calculatePosition = function _calculatePosition(out, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
          var denominatorValue = contentMeasure - scrollViewMeasure;

          if (outOfBoundary) {
            denominatorValue += Math.abs(outOfBoundary);
          }

          var positionRatio = 0;

          if (denominatorValue) {
            positionRatio = contentPosition / denominatorValue;
            positionRatio = clamp01(positionRatio);
          }

          var position = (handleNodeMeasure - actualLenth) * positionRatio;

          if (this._direction === Direction.VERTICAL) {
            out.set(0, position);
          } else {
            out.set(position, 0);
          }
        };

        _proto._updateLength = function _updateLength(length) {
          if (this._handle) {
            var handleNode = this._handle.node;
            var handleTrans = handleNode._uiProps.uiTransformComp;
            var handleNodeSize = handleTrans.contentSize;
            var anchor = handleTrans.anchorPoint;

            if (anchor.x !== defaultAnchor.x || anchor.y !== defaultAnchor.y) {
              handleTrans.setAnchorPoint(defaultAnchor);
            }

            if (this._direction === Direction.HORIZONTAL) {
              handleTrans.setContentSize(length, handleNodeSize.height);
            } else {
              handleTrans.setContentSize(handleNodeSize.width, length);
            }
          }
        };

        _proto._processAutoHide = function _processAutoHide(deltaTime) {
          if (!this._enableAutoHide || this._autoHideRemainingTime <= 0) {
            return;
          } else if (this._touching) {
            return;
          }

          this._autoHideRemainingTime -= deltaTime;

          if (this._autoHideRemainingTime <= this._autoHideTime) {
            this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
            var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);

            this._setOpacity(opacity);
          }
        };

        _createClass(ScrollBar, [{
          key: "handle",
          get: function get() {
            return this._handle;
          },
          set: function set(value) {
            if (this._handle === value) {
              return;
            }

            this._handle = value;
            this.onScroll(Vec2.ZERO);
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) {
              return;
            }

            this._direction = value;
            this.onScroll(Vec2.ZERO);
          }
        }, {
          key: "enableAutoHide",
          get: function get() {
            return this._enableAutoHide;
          },
          set: function set(value) {
            if (this._enableAutoHide === value) {
              return;
            }

            this._enableAutoHide = value;

            if (this._enableAutoHide) {
              this._setOpacity(0);
            }
          }
        }, {
          key: "autoHideTime",
          get: function get() {
            return this._autoHideTime;
          },
          set: function set(value) {
            if (this._autoHideTime === value) {
              return;
            }

            this._autoHideTime = value;
          }
        }]);

        return ScrollBar;
      }(Component), _class3$l.Direction = Direction, _temp$1j), (_applyDecoratedDescriptor(_class2$1g.prototype, "handle", [_dec6$N, _dec7$J, _dec8$E], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "handle"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "direction", [_dec9$z, _dec10$w, _dec11$u], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "direction"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "enableAutoHide", [_dec12$t, _dec13$r], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "enableAutoHide"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "autoHideTime", [_dec14$o, _dec15$o], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "autoHideTime"), _class2$1g.prototype), _descriptor$1c = _applyDecoratedDescriptor(_class2$1g.prototype, "_scrollView", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$12 = _applyDecoratedDescriptor(_class2$1g.prototype, "_handle", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$Q = _applyDecoratedDescriptor(_class2$1g.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Direction.HORIZONTAL;
        }
      }), _descriptor4$G = _applyDecoratedDescriptor(_class2$1g.prototype, "_enableAutoHide", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor5$z = _applyDecoratedDescriptor(_class2$1g.prototype, "_autoHideTime", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      })), _class2$1g)) || _class$1p) || _class$1p) || _class$1p) || _class$1p) || _class$1p));
      legacyCC.ScrollBar = ScrollBar;

      var _dec$1p, _dec2$15, _class$1q;
      var ViewGroup = exports('ViewGroup', (_dec$1p = ccclass('cc.ViewGroup'), _dec2$15 = executionOrder(110), _dec$1p(_class$1q = _dec2$15(_class$1q = function (_Component) {
        _inheritsLoose(ViewGroup, _Component);

        function ViewGroup() {
          return _Component.apply(this, arguments) || this;
        }

        return ViewGroup;
      }(Component)) || _class$1q) || _class$1q));
      legacyCC.ViewGroup = ViewGroup;

      var _dec$1q, _dec2$16, _dec3$11, _dec4$Y, _dec5$U, _dec6$O, _dec7$K, _dec8$F, _dec9$A, _dec10$x, _dec11$v, _dec12$u, _dec13$s, _dec14$p, _dec15$p, _dec16$n, _dec17$m, _dec18$l, _dec19$k, _dec20$k, _dec21$k, _dec22$i, _dec23$h, _dec24$h, _dec25$g, _dec26$g, _dec27$g, _dec28$f, _dec29$f, _dec30$d, _dec31$d, _dec32$a, _dec33$8, _class$1r, _class2$1h, _descriptor$1d, _descriptor2$13, _descriptor3$R, _descriptor4$H, _descriptor5$A, _descriptor6$u, _descriptor7$o, _descriptor8$m, _descriptor9$j, _descriptor10$g, _descriptor11$d, _class3$m, _temp$1k;
      var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
      var OUT_OF_BOUNDARY_BREAKING_FACTOR = 0.05;
      var EPSILON$1 = 1e-4;
      var TOLERANCE = 1e4;
      var MOVEMENT_FACTOR = 0.7;

      var _tempVec3$2 = new Vec3();

      var _tempVec3_1 = new Vec3();

      var _tempVec2$1 = new Vec2();

      var _tempVec2_1 = new Vec2();

      var quintEaseOut = function quintEaseOut(time) {
        time -= 1;
        return time * time * time * time * time + 1;
      };

      var getTimeInMilliseconds = function getTimeInMilliseconds() {
        var currentTime = new Date();
        return currentTime.getMilliseconds();
      };

      var eventMap = {
        'scroll-to-top': 0,
        'scroll-to-bottom': 1,
        'scroll-to-left': 2,
        'scroll-to-right': 3,
        scrolling: 4,
        'bounce-bottom': 6,
        'bounce-left': 7,
        'bounce-right': 8,
        'bounce-top': 5,
        'scroll-ended': 9,
        'touch-up': 10,
        'scroll-ended-with-threshold': 11,
        'scroll-began': 12
      };
      var EventType$4;

      (function (EventType) {
        EventType["SCROLL_TO_TOP"] = "scroll-to-top";
        EventType["SCROLL_TO_BOTTOM"] = "scroll-to-bottom";
        EventType["SCROLL_TO_LEFT"] = "scroll-to-left";
        EventType["SCROLL_TO_RIGHT"] = "scroll-to-right";
        EventType["SCROLL_BEGAN"] = "scroll-began";
        EventType["SCROLL_ENDED"] = "scroll-ended";
        EventType["BOUNCE_TOP"] = "bounce-top";
        EventType["BOUNCE_BOTTOM"] = "bounce-bottom";
        EventType["BOUNCE_LEFT"] = "bounce-left";
        EventType["BOUNCE_RIGHT"] = "bounce-right";
        EventType["SCROLLING"] = "scrolling";
        EventType["SCROLL_ENG_WITH_THRESHOLD"] = "scroll-ended-with-threshold";
        EventType["TOUCH_UP"] = "touch-up";
      })(EventType$4 || (EventType$4 = {}));

      var XrhoverType;

      (function (XrhoverType) {
        XrhoverType[XrhoverType["NONE"] = 0] = "NONE";
        XrhoverType[XrhoverType["LEFT"] = 1] = "LEFT";
        XrhoverType[XrhoverType["RIGHT"] = 2] = "RIGHT";
      })(XrhoverType || (XrhoverType = {}));

      var ScrollView = function (v) { return exports({ ScrollView: v, ScrollViewComponent: v }), v; }((_dec$1q = ccclass('cc.ScrollView'), _dec2$16 = help(), _dec3$11 = executionOrder(110), _dec4$Y = menu(), _dec5$U = requireComponent(UITransform), _dec6$O = range(), _dec7$K = displayOrder(), _dec8$F = tooltip(), _dec9$A = range(), _dec10$x = displayOrder(), _dec11$v = tooltip(), _dec12$u = displayOrder(), _dec13$s = tooltip(), _dec14$p = displayOrder(), _dec15$p = tooltip(), _dec16$n = type(Node), _dec17$m = displayOrder(), _dec18$l = tooltip(), _dec19$k = displayOrder(), _dec20$k = tooltip(), _dec21$k = type(ScrollBar), _dec22$i = displayOrder(), _dec23$h = tooltip(), _dec24$h = displayOrder(), _dec25$g = tooltip(), _dec26$g = type(ScrollBar), _dec27$g = displayOrder(), _dec28$f = tooltip(), _dec29$f = displayOrder(), _dec30$d = tooltip(), _dec31$d = type([EventHandler]), _dec32$a = displayOrder(), _dec33$8 = tooltip(), _dec$1q(_class$1r = _dec2$16(_class$1r = _dec3$11(_class$1r = _dec4$Y(_class$1r = _dec5$U(_class$1r = (_class2$1h = (_temp$1k = _class3$m = function (_ViewGroup) {
        _inheritsLoose(ScrollView, _ViewGroup);

        function ScrollView() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ViewGroup.call.apply(_ViewGroup, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "bounceDuration", _descriptor$1d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "brake", _descriptor2$13, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "elastic", _descriptor3$R, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "inertia", _descriptor4$H, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "horizontal", _descriptor5$A, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "vertical", _descriptor6$u, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor7$o, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "scrollEvents", _descriptor8$m, _assertThisInitialized(_this));

          _this._autoScrolling = false;
          _this._scrolling = false;

          _initializerDefineProperty(_this, "_content", _descriptor9$j, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalScrollBar", _descriptor10$g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalScrollBar", _descriptor11$d, _assertThisInitialized(_this));

          _this._topBoundary = 0;
          _this._bottomBoundary = 0;
          _this._leftBoundary = 0;
          _this._rightBoundary = 0;
          _this._touchMoveDisplacements = [];
          _this._touchMoveTimeDeltas = [];
          _this._touchMovePreviousTimestamp = 0;
          _this._touchMoved = false;
          _this._autoScrollAttenuate = false;
          _this._autoScrollStartPosition = new Vec3();
          _this._autoScrollTargetDelta = new Vec3();
          _this._autoScrollTotalTime = 0;
          _this._autoScrollAccumulatedTime = 0;
          _this._autoScrollCurrentlyOutOfBoundary = false;
          _this._autoScrollBraking = false;
          _this._autoScrollBrakingStartPosition = new Vec3();
          _this._outOfBoundaryAmount = new Vec3();
          _this._outOfBoundaryAmountDirty = true;
          _this._stopMouseWheel = false;
          _this._mouseWheelEventElapsedTime = 0.0;
          _this._isScrollEndedWithThresholdEventFired = false;
          _this._scrollEventEmitMask = 0;
          _this._isBouncing = false;
          _this._contentPos = new Vec3();
          _this._deltaPos = new Vec3();
          _this._hoverIn = XrhoverType.NONE;
          _this._scrollState = new Vec2(0, 0);
          return _this;
        }

        var _proto = ScrollView.prototype;

        _proto.scrollToBottom = function scrollToBottom(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: false,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta, true);
          }
        };

        _proto.scrollToTop = function scrollToTop(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 1),
            applyToHorizontal: false,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToLeft = function scrollToLeft(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToRight = function scrollToRight(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToTopLeft = function scrollToTopLeft(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 1),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToTopRight = function scrollToTopRight(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 1),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToBottomLeft = function scrollToBottomLeft(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToBottomRight = function scrollToBottomRight(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 0),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToOffset = function scrollToOffset(offset, timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var maxScrollOffset = this.getMaxScrollOffset();
          var anchor = new Vec2(0, 0);

          if (maxScrollOffset.x === 0) {
            anchor.x = 0;
          } else {
            anchor.x = offset.x / maxScrollOffset.x;
          }

          if (maxScrollOffset.y === 0) {
            anchor.y = 1;
          } else {
            anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
          }

          this.scrollTo(anchor, timeInSecond, attenuated);
        };

        _proto.getScrollOffset = function getScrollOffset() {
          var topDelta = this._getContentTopBoundary() - this._topBoundary;

          var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

          return new Vec2(leftDelta, topDelta);
        };

        _proto.getMaxScrollOffset = function getMaxScrollOffset() {
          if (!this._content || !this.view) {
            return Vec2.ZERO;
          }

          var contentSize = this._content._uiProps.uiTransformComp.contentSize;
          var horizontalMaximizeOffset = contentSize.width - this.view.width;
          var verticalMaximizeOffset = contentSize.height - this.view.height;
          horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
          verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
          return new Vec2(horizontalMaximizeOffset, verticalMaximizeOffset);
        };

        _proto.scrollToPercentHorizontal = function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(percent, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollTo = function scrollTo(anchor, timeInSecond, attenuated) {
          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(anchor),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToPercentVertical = function scrollToPercentVertical(percent, timeInSecond, attenuated) {
          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, percent),
            applyToHorizontal: false,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.stopAutoScroll = function stopAutoScroll() {
          this._autoScrolling = false;
          this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
        };

        _proto.setContentPosition = function setContentPosition(position) {
          this._setContentPosition(position);
        };

        _proto._setContentPosition = function _setContentPosition(position) {
          if (!this._content) {
            return;
          }

          var contentPos = this._getContentPosition();

          if (Math.abs(position.x - contentPos.x) < EPSILON$1 && Math.abs(position.y - contentPos.y) < EPSILON$1) {
            return;
          }

          this._content.setPosition(position);

          this._outOfBoundaryAmountDirty = true;
        };

        _proto.getContentPosition = function getContentPosition() {
          return this._getContentPosition();
        };

        _proto._getContentPosition = function _getContentPosition() {
          if (!this._content) {
            return Vec3.ZERO.clone();
          }

          this._contentPos.set(this._content.position);

          return this._contentPos;
        };

        _proto.isScrolling = function isScrolling() {
          return this._scrolling;
        };

        _proto.isAutoScrolling = function isAutoScrolling() {
          return this._autoScrolling;
        };

        _proto.getScrollEndedEventTiming = function getScrollEndedEventTiming() {
          return EPSILON$1;
        };

        _proto.start = function start() {
          this._calculateBoundary();

          if (this._content) {
            director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
          }
        };

        _proto.onEnable = function onEnable() {
          {
            this._registerEvent();

            if (this._content) {
              this._content.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);

              this._content.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);

              if (this.view) {
                this.view.node.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                this.view.node.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              }
            }

            this._calculateBoundary();
          }

          this._updateScrollBarState();
        };

        _proto.update = function update(dt) {
          if (this._autoScrolling) {
            this._processAutoScrolling(dt);
          }
        };

        _proto.onDisable = function onDisable() {
          {
            this._unregisterEvent();

            if (this._content) {
              this._content.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);

              this._content.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);

              if (this.view) {
                this.view.node.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                this.view.node.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              }
            }
          }

          this._hideScrollBar();

          this.stopAutoScroll();
        };

        _proto._registerEvent = function _registerEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
          this.node.on(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
          this.node.on(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          input.on(Input.EventType.HANDLE_INPUT, this._dispatchEventHandleInput, this);
          input.on(Input.EventType.GAMEPAD_INPUT, this._dispatchEventHandleInput, this);
        };

        _proto._unregisterEvent = function _unregisterEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
          this.node.off(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
          this.node.off(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          input.off(Input.EventType.HANDLE_INPUT, this._dispatchEventHandleInput, this);
          input.off(Input.EventType.GAMEPAD_INPUT, this._dispatchEventHandleInput, this);
        };

        _proto._onMouseWheel = function _onMouseWheel(event, captureListeners) {
          if (!this.enabledInHierarchy) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          var deltaMove = new Vec3();
          var wheelPrecision = -0.1;
          var scrollY = event.getScrollY();

          if (this.vertical) {
            deltaMove.set(0, scrollY * wheelPrecision, 0);
          } else if (this.horizontal) {
            deltaMove.set(scrollY * wheelPrecision, 0, 0);
          }

          this._mouseWheelEventElapsedTime = 0;

          this._processDeltaMove(deltaMove);

          if (!this._stopMouseWheel) {
            this._handlePressLogic();

            this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
            this._stopMouseWheel = true;
          }

          this._stopPropagationIfTargetIsMe(event);
        };

        _proto._onTouchBegan = function _onTouchBegan(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          this._handlePressLogic();

          this._touchMoved = false;

          this._stopPropagationIfTargetIsMe(event);
        };

        _proto._onTouchMoved = function _onTouchMoved(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          var touch = event.touch;

          this._handleMoveLogic(touch);

          if (!this.cancelInnerEvents) {
            return;
          }

          var deltaMove = touch.getUILocation(_tempVec2$1);
          deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1));

          if (deltaMove.length() > 7) {
            if (!this._touchMoved && event.target !== this.node) {
              var cancelEvent = new EventTouch(event.getTouches(), event.bubbles, SystemEventType.TOUCH_CANCEL);
              cancelEvent.touch = event.touch;
              cancelEvent.simulate = true;
              event.target.dispatchEvent(cancelEvent);
              this._touchMoved = true;
            }
          }

          this._stopPropagationIfTargetIsMe(event);
        };

        _proto._onTouchEnded = function _onTouchEnded(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content || !event) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          this._dispatchEvent(EventType$4.TOUCH_UP);

          var touch = event.touch;

          this._handleReleaseLogic(touch);

          if (this._touchMoved) {
            event.propagationStopped = true;
          } else {
            this._stopPropagationIfTargetIsMe(event);
          }
        };

        _proto._onTouchCancelled = function _onTouchCancelled(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          if (event && !event.simulate) {
            var touch = event.touch;

            this._handleReleaseLogic(touch);
          }

          this._stopPropagationIfTargetIsMe(event);
        };

        _proto._calculateBoundary = function _calculateBoundary() {
          if (this._content && this.view) {
            var layout = this._content.getComponent(Layout);

            if (layout && layout.enabledInHierarchy) {
              layout.updateLayout();
            }

            var viewTrans = this.view;
            var anchorX = viewTrans.width * viewTrans.anchorX;
            var anchorY = viewTrans.height * viewTrans.anchorY;
            this._leftBoundary = -anchorX;
            this._bottomBoundary = -anchorY;
            this._rightBoundary = this._leftBoundary + viewTrans.width;
            this._topBoundary = this._bottomBoundary + viewTrans.height;

            this._moveContentToTopLeft(viewTrans.contentSize);
          }
        };

        _proto._hasNestedViewGroup = function _hasNestedViewGroup(event, captureListeners) {
          if (!event || event.eventPhase !== Event.CAPTURING_PHASE) {
            return false;
          }

          if (captureListeners) {
            for (var _iterator = _createForOfIteratorHelperLoose(captureListeners), _step; !(_step = _iterator()).done;) {
              var listener = _step.value;
              var item = listener;

              if (this.node === item) {
                if (event.target && event.target.getComponent(ViewGroup)) {
                  return true;
                }

                return false;
              }

              if (item.getComponent(ViewGroup)) {
                return true;
              }
            }
          }

          return false;
        };

        _proto._startInertiaScroll = function _startInertiaScroll(touchMoveVelocity) {
          var inertiaTotalMovement = new Vec3(touchMoveVelocity);
          inertiaTotalMovement.multiplyScalar(MOVEMENT_FACTOR);

          this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
        };

        _proto._calculateAttenuatedFactor = function _calculateAttenuatedFactor(distance) {
          if (this.brake <= 0) {
            return 1 - this.brake;
          }

          return (1 - this.brake) * (1 / (1 + distance * 0.000014 + distance * distance * 0.000000008));
        };

        _proto._startAttenuatingAutoScroll = function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
          var targetDelta = deltaMove.clone();
          targetDelta.normalize();

          if (this._content && this.view) {
            var contentSize = this._content._uiProps.uiTransformComp.contentSize;
            var scrollViewSize = this.view.contentSize;
            var totalMoveWidth = contentSize.width - scrollViewSize.width;
            var totalMoveHeight = contentSize.height - scrollViewSize.height;

            var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);

            var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);

            targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX;
            targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake);
            targetDelta.z = 0;
          }

          var originalMoveLength = deltaMove.length();
          var factor = targetDelta.length() / originalMoveLength;
          targetDelta.add(deltaMove);

          if (this.brake > 0 && factor > 7) {
            factor = Math.sqrt(factor);
            var clonedDeltaMove = deltaMove.clone();
            clonedDeltaMove.multiplyScalar(factor);
            targetDelta.set(clonedDeltaMove);
            targetDelta.add(deltaMove);
          }

          var time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length());

          if (this.brake > 0 && factor > 3) {
            factor = 3;
            time *= factor;
          }

          if (this.brake === 0 && factor > 1) {
            time *= factor;
          }

          this._startAutoScroll(targetDelta, time, true);
        };

        _proto._calculateAutoScrollTimeByInitialSpeed = function _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
          return Math.sqrt(Math.sqrt(initialSpeed / 5));
        };

        _proto._startAutoScroll = function _startAutoScroll(deltaMove, timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = false;
          }

          var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);

          this._autoScrolling = true;
          this._autoScrollTargetDelta = adjustedDeltaMove;
          this._autoScrollAttenuate = attenuated;
          Vec3.copy(this._autoScrollStartPosition, this._getContentPosition());
          this._autoScrollTotalTime = timeInSecond;
          this._autoScrollAccumulatedTime = 0;
          this._autoScrollBraking = false;
          this._isScrollEndedWithThresholdEventFired = false;

          this._autoScrollBrakingStartPosition.set(0, 0, 0);

          var currentOutOfBoundary = this._getHowMuchOutOfBoundary();

          if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
            this._autoScrollCurrentlyOutOfBoundary = true;
          }
        };

        _proto._calculateTouchMoveVelocity = function _calculateTouchMoveVelocity() {
          var out = new Vec3();
          var totalTime = 0;
          totalTime = this._touchMoveTimeDeltas.reduce(function (a, b) {
            return a + b;
          }, totalTime);

          if (totalTime <= 0 || totalTime >= 0.5) {
            out.set(Vec3.ZERO);
          } else {
            var totalMovement = new Vec3();
            totalMovement = this._touchMoveDisplacements.reduce(function (a, b) {
              a.add(b);
              return a;
            }, totalMovement);
            out.set(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, totalMovement.z);
          }

          return out;
        };

        _proto._flattenVectorByDirection = function _flattenVectorByDirection(vector) {
          var result = vector;
          result.x = this.horizontal ? result.x : 0;
          result.y = this.vertical ? result.y : 0;
          return result;
        };

        _proto._moveContent = function _moveContent(deltaMove, canStartBounceBack) {
          var adjustedMove = this._flattenVectorByDirection(deltaMove);

          _tempVec3$2.set(this._getContentPosition());

          _tempVec3$2.add(adjustedMove);

          _tempVec3$2.set(Math.round(_tempVec3$2.x * TOLERANCE) * EPSILON$1, Math.round(_tempVec3$2.y * TOLERANCE) * EPSILON$1, _tempVec3$2.z);

          this._setContentPosition(_tempVec3$2);

          var outOfBoundary = this._getHowMuchOutOfBoundary();

          _tempVec2$1.set(outOfBoundary.x, outOfBoundary.y);

          this._updateScrollBar(_tempVec2$1);

          if (this.elastic && canStartBounceBack) {
            this._startBounceBackIfNeeded();
          }
        };

        _proto._getContentLeftBoundary = function _getContentLeftBoundary() {
          if (!this._content) {
            return -1;
          }

          var contentPos = this._getContentPosition();

          var uiTrans = this._content._uiProps.uiTransformComp;
          return contentPos.x - uiTrans.anchorX * uiTrans.width;
        };

        _proto._getContentRightBoundary = function _getContentRightBoundary() {
          if (!this._content) {
            return -1;
          }

          var uiTrans = this._content._uiProps.uiTransformComp;
          return this._getContentLeftBoundary() + uiTrans.width;
        };

        _proto._getContentTopBoundary = function _getContentTopBoundary() {
          if (!this._content) {
            return -1;
          }

          var uiTrans = this._content._uiProps.uiTransformComp;
          return this._getContentBottomBoundary() + uiTrans.height;
        };

        _proto._getContentBottomBoundary = function _getContentBottomBoundary() {
          if (!this._content) {
            return -1;
          }

          var contentPos = this._getContentPosition();

          var uiTrans = this._content._uiProps.uiTransformComp;
          return contentPos.y - uiTrans.anchorY * uiTrans.height;
        };

        _proto._getHowMuchOutOfBoundary = function _getHowMuchOutOfBoundary(addition) {
          addition = addition || new Vec3();

          if (addition.equals(Vec3.ZERO, EPSILON$1) && !this._outOfBoundaryAmountDirty) {
            return this._outOfBoundaryAmount;
          }

          var outOfBoundaryAmount = new Vec3();

          var tempLeftBoundary = this._getContentLeftBoundary();

          var tempRightBoundary = this._getContentRightBoundary();

          if (tempLeftBoundary + addition.x > this._leftBoundary) {
            outOfBoundaryAmount.x = this._leftBoundary - (tempLeftBoundary + addition.x);
          } else if (tempRightBoundary + addition.x < this._rightBoundary) {
            outOfBoundaryAmount.x = this._rightBoundary - (tempRightBoundary + addition.x);
          }

          var tempTopBoundary = this._getContentTopBoundary();

          var tempBottomBoundary = this._getContentBottomBoundary();

          if (tempTopBoundary + addition.y < this._topBoundary) {
            outOfBoundaryAmount.y = this._topBoundary - (tempTopBoundary + addition.y);
          } else if (tempBottomBoundary + addition.y > this._bottomBoundary) {
            outOfBoundaryAmount.y = this._bottomBoundary - (tempBottomBoundary + addition.y);
          }

          if (addition.equals(Vec3.ZERO, EPSILON$1)) {
            this._outOfBoundaryAmount = outOfBoundaryAmount;
            this._outOfBoundaryAmountDirty = false;
          }

          this._clampDelta(outOfBoundaryAmount);

          return outOfBoundaryAmount;
        };

        _proto._updateScrollBar = function _updateScrollBar(outOfBoundary) {
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.onScroll(outOfBoundary);
          }

          if (this.verticalScrollBar) {
            this.verticalScrollBar.onScroll(outOfBoundary);
          }
        };

        _proto._onScrollBarTouchBegan = function _onScrollBarTouchBegan() {
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.onTouchBegan();
          }

          if (this.verticalScrollBar) {
            this.verticalScrollBar.onTouchBegan();
          }
        };

        _proto._onScrollBarTouchEnded = function _onScrollBarTouchEnded() {
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.onTouchEnded();
          }

          if (this.verticalScrollBar) {
            this.verticalScrollBar.onTouchEnded();
          }
        };

        _proto._dispatchEvent = function _dispatchEvent(event) {
          if (event === EventType$4.SCROLL_ENDED) {
            this._scrollEventEmitMask = 0;
          } else if (event === EventType$4.SCROLL_TO_TOP || event === EventType$4.SCROLL_TO_BOTTOM || event === EventType$4.SCROLL_TO_LEFT || event === EventType$4.SCROLL_TO_RIGHT) {
            var flag = 1 << eventMap[event];

            if (this._scrollEventEmitMask & flag) {
              return;
            } else {
              this._scrollEventEmitMask |= flag;
            }
          }

          EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
          this.node.emit(event, this);
        };

        _proto._adjustContentOutOfBoundary = function _adjustContentOutOfBoundary() {
          if (!this._content) {
            return;
          }

          this._outOfBoundaryAmountDirty = true;

          if (this._isOutOfBoundary()) {
            var outOfBoundary = this._getHowMuchOutOfBoundary();

            _tempVec3$2.set(this._getContentPosition());

            _tempVec3$2.add(outOfBoundary);

            this._content.setPosition(_tempVec3$2);

            this._updateScrollBar(Vec2.ZERO);
          }
        };

        _proto._hideScrollBar = function _hideScrollBar() {
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.hide();
          }

          if (this._verticalScrollBar) {
            this._verticalScrollBar.hide();
          }
        };

        _proto._updateScrollBarState = function _updateScrollBarState() {
          if (!this._content || !this.view) {
            return;
          }

          var viewTrans = this.view;
          var uiTrans = this._content._uiProps.uiTransformComp;

          if (this.verticalScrollBar) {
            if (uiTrans.height < viewTrans.height) {
              this.verticalScrollBar.hide();
            } else {
              this.verticalScrollBar.show();
            }
          }

          if (this.horizontalScrollBar) {
            if (uiTrans.width < viewTrans.width) {
              this.horizontalScrollBar.hide();
            } else {
              this.horizontalScrollBar.show();
            }
          }
        };

        _proto._stopPropagationIfTargetIsMe = function _stopPropagationIfTargetIsMe(event) {
          if (event.eventPhase === Event.AT_TARGET && event.target === this.node) {
            event.propagationStopped = true;
          }
        };

        _proto._processDeltaMove = function _processDeltaMove(deltaMove) {
          this._scrollChildren(deltaMove);

          this._gatherTouchMove(deltaMove);
        };

        _proto._handleMoveLogic = function _handleMoveLogic(touch) {
          this._getLocalAxisAlignDelta(this._deltaPos, touch);

          this._processDeltaMove(this._deltaPos);
        };

        _proto._handleReleaseLogic = function _handleReleaseLogic(touch) {
          this._getLocalAxisAlignDelta(this._deltaPos, touch);

          this._gatherTouchMove(this._deltaPos);

          this._processInertiaScroll();

          if (this._scrolling) {
            this._scrolling = false;

            if (!this._autoScrolling) {
              this._dispatchEvent(EventType$4.SCROLL_ENDED);
            }
          }
        };

        _proto._getLocalAxisAlignDelta = function _getLocalAxisAlignDelta(out, touch) {
          var uiTransformComp = this.node._uiProps.uiTransformComp;
          var vec = new Vec3();

          if (uiTransformComp) {
            touch.getUILocation(_tempVec2$1);
            touch.getUIPreviousLocation(_tempVec2_1);

            _tempVec3$2.set(_tempVec2$1.x, _tempVec2$1.y, 0);

            _tempVec3_1.set(_tempVec2_1.x, _tempVec2_1.y, 0);

            uiTransformComp.convertToNodeSpaceAR(_tempVec3$2, _tempVec3$2);
            uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1);
            Vec3.subtract(vec, _tempVec3$2, _tempVec3_1);
          }

          out.set(vec);
        };

        _proto._scrollChildren = function _scrollChildren(deltaMove) {
          this._clampDelta(deltaMove);

          var realMove = deltaMove;
          var outOfBoundary;

          if (this.elastic) {
            outOfBoundary = this._getHowMuchOutOfBoundary();
            realMove.x *= outOfBoundary.x === 0 ? 1 : 0.5;
            realMove.y *= outOfBoundary.y === 0 ? 1 : 0.5;
          }

          if (!this.elastic) {
            outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
            realMove.add(outOfBoundary);
          }

          var verticalScrollEventType = '';
          var horizontalScrollEventType = '';

          if (this._content) {
            var _ref = this._content._uiProps.uiTransformComp,
                anchorX = _ref.anchorX,
                anchorY = _ref.anchorY,
                width = _ref.width,
                height = _ref.height;
            var pos = this._content.position || Vec3.ZERO;

            if (this.vertical) {
              if (realMove.y > 0) {
                var icBottomPos = pos.y - anchorY * height;

                if (icBottomPos + realMove.y >= this._bottomBoundary) {
                  verticalScrollEventType = EventType$4.SCROLL_TO_BOTTOM;
                }
              } else if (realMove.y < 0) {
                var icTopPos = pos.y - anchorY * height + height;

                if (icTopPos + realMove.y <= this._topBoundary) {
                  verticalScrollEventType = EventType$4.SCROLL_TO_TOP;
                }
              }
            }

            if (this.horizontal) {
              if (realMove.x < 0) {
                var icRightPos = pos.x - anchorX * width + width;

                if (icRightPos + realMove.x <= this._rightBoundary) {
                  horizontalScrollEventType = EventType$4.SCROLL_TO_RIGHT;
                }
              } else if (realMove.x > 0) {
                var icLeftPos = pos.x - anchorX * width;

                if (icLeftPos + realMove.x >= this._leftBoundary) {
                  horizontalScrollEventType = EventType$4.SCROLL_TO_LEFT;
                }
              }
            }
          }

          this._moveContent(realMove, false);

          if (this.horizontal && realMove.x !== 0 || this.vertical && realMove.y !== 0) {
            if (!this._scrolling) {
              this._scrolling = true;

              this._dispatchEvent(EventType$4.SCROLL_BEGAN);
            }

            this._dispatchEvent(EventType$4.SCROLLING);
          }

          if (verticalScrollEventType !== '') {
            this._dispatchEvent(verticalScrollEventType);
          }

          if (horizontalScrollEventType !== '') {
            this._dispatchEvent(horizontalScrollEventType);
          }
        };

        _proto._handlePressLogic = function _handlePressLogic() {
          if (this._autoScrolling) {
            this._dispatchEvent(EventType$4.SCROLL_ENDED);
          }

          this._autoScrolling = false;
          this._isBouncing = false;
          this._touchMovePreviousTimestamp = getTimeInMilliseconds();
          this._touchMoveDisplacements.length = 0;
          this._touchMoveTimeDeltas.length = 0;

          this._onScrollBarTouchBegan();
        };

        _proto._clampDelta = function _clampDelta(out) {
          if (this._content && this.view) {
            var scrollViewSize = this.view.contentSize;
            var uiTrans = this._content._uiProps.uiTransformComp;

            if (uiTrans.width < scrollViewSize.width) {
              out.x = 0;
            }

            if (uiTrans.height < scrollViewSize.height) {
              out.y = 0;
            }
          }
        };

        _proto._gatherTouchMove = function _gatherTouchMove(delta) {
          var clampDt = delta.clone();

          this._clampDelta(clampDt);

          while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
            this._touchMoveDisplacements.shift();

            this._touchMoveTimeDeltas.shift();
          }

          this._touchMoveDisplacements.push(clampDt);

          var timeStamp = getTimeInMilliseconds();

          this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1000);

          this._touchMovePreviousTimestamp = timeStamp;
        };

        _proto._startBounceBackIfNeeded = function _startBounceBackIfNeeded() {
          if (!this.elastic) {
            return false;
          }

          var bounceBackAmount = this._getHowMuchOutOfBoundary();

          this._clampDelta(bounceBackAmount);

          if (bounceBackAmount.equals(Vec3.ZERO, EPSILON$1)) {
            return false;
          }

          var bounceBackTime = Math.max(this.bounceDuration, 0);

          this._startAutoScroll(bounceBackAmount, bounceBackTime, true);

          if (!this._isBouncing) {
            if (bounceBackAmount.y > 0) {
              this._dispatchEvent(EventType$4.BOUNCE_TOP);
            }

            if (bounceBackAmount.y < 0) {
              this._dispatchEvent(EventType$4.BOUNCE_BOTTOM);
            }

            if (bounceBackAmount.x > 0) {
              this._dispatchEvent(EventType$4.BOUNCE_RIGHT);
            }

            if (bounceBackAmount.x < 0) {
              this._dispatchEvent(EventType$4.BOUNCE_LEFT);
            }

            this._isBouncing = true;
          }

          return true;
        };

        _proto._processInertiaScroll = function _processInertiaScroll() {
          var bounceBackStarted = this._startBounceBackIfNeeded();

          if (!bounceBackStarted && this.inertia) {
            var touchMoveVelocity = this._calculateTouchMoveVelocity();

            if (!touchMoveVelocity.equals(_tempVec3$2, EPSILON$1) && this.brake < 1) {
              this._startInertiaScroll(touchMoveVelocity);
            }
          }

          this._onScrollBarTouchEnded();
        };

        _proto._isOutOfBoundary = function _isOutOfBoundary() {
          var outOfBoundary = this._getHowMuchOutOfBoundary();

          return !outOfBoundary.equals(Vec3.ZERO, EPSILON$1);
        };

        _proto._isNecessaryAutoScrollBrake = function _isNecessaryAutoScrollBrake() {
          if (this._autoScrollBraking) {
            return true;
          }

          if (this._isOutOfBoundary()) {
            if (!this._autoScrollCurrentlyOutOfBoundary) {
              this._autoScrollCurrentlyOutOfBoundary = true;
              this._autoScrollBraking = true;
              Vec3.copy(this._autoScrollBrakingStartPosition, this._getContentPosition());
              return true;
            }
          } else {
            this._autoScrollCurrentlyOutOfBoundary = false;
          }

          return false;
        };

        _proto._processAutoScrolling = function _processAutoScrolling(dt) {
          var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();

          var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
          this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
          var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);

          if (this._autoScrollAttenuate) {
            percentage = quintEaseOut(percentage);
          }

          var clonedAutoScrollTargetDelta = this._autoScrollTargetDelta.clone();

          clonedAutoScrollTargetDelta.multiplyScalar(percentage);

          var clonedAutoScrollStartPosition = this._autoScrollStartPosition.clone();

          clonedAutoScrollStartPosition.add(clonedAutoScrollTargetDelta);
          var reachedEnd = Math.abs(percentage - 1) <= EPSILON$1;
          var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();

          if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
            this._dispatchEvent(EventType$4.SCROLL_ENG_WITH_THRESHOLD);

            this._isScrollEndedWithThresholdEventFired = true;
          }

          if (this.elastic) {
            var brakeOffsetPosition = clonedAutoScrollStartPosition.clone();
            brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition);

            if (isAutoScrollBrake) {
              brakeOffsetPosition.multiplyScalar(brakingFactor);
            }

            clonedAutoScrollStartPosition.set(this._autoScrollBrakingStartPosition);
            clonedAutoScrollStartPosition.add(brakeOffsetPosition);
          } else {
            var moveDelta = clonedAutoScrollStartPosition.clone();
            moveDelta.subtract(this.getContentPosition());

            var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);

            if (!outOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
              clonedAutoScrollStartPosition.add(outOfBoundary);
              reachedEnd = true;
            }
          }

          if (reachedEnd) {
            this._autoScrolling = false;
          }

          var deltaMove = clonedAutoScrollStartPosition.clone();
          deltaMove.subtract(this._getContentPosition());

          this._clampDelta(deltaMove);

          this._moveContent(deltaMove, reachedEnd);

          this._dispatchEvent(EventType$4.SCROLLING);

          if (!this._autoScrolling) {
            this._isBouncing = false;
            this._scrolling = false;

            this._dispatchEvent(EventType$4.SCROLL_ENDED);
          }
        };

        _proto._checkMouseWheel = function _checkMouseWheel(dt) {
          var currentOutOfBoundary = this._getHowMuchOutOfBoundary();

          var maxElapsedTime = 0.1;

          if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
            this._processInertiaScroll();

            this.unschedule(this._checkMouseWheel);

            this._dispatchEvent(EventType$4.SCROLL_ENDED);

            this._stopMouseWheel = false;
            return;
          }

          this._mouseWheelEventElapsedTime += dt;

          if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
            this._onScrollBarTouchEnded();

            this.unschedule(this._checkMouseWheel);

            this._dispatchEvent(EventType$4.SCROLL_ENDED);

            this._stopMouseWheel = false;
          }
        };

        _proto._calculateMovePercentDelta = function _calculateMovePercentDelta(options) {
          var anchor = options.anchor;
          var applyToHorizontal = options.applyToHorizontal;
          var applyToVertical = options.applyToVertical;

          this._calculateBoundary();

          anchor.clampf(Vec2.ZERO, Vec2.ONE);

          var bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

          bottomDelta = -bottomDelta;

          var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

          leftDelta = -leftDelta;
          var moveDelta = new Vec3();

          if (this._content && this.view) {
            var totalScrollDelta = 0;
            var uiTrans = this._content._uiProps.uiTransformComp;
            var contentSize = uiTrans.contentSize;
            var scrollSize = this.view.contentSize;

            if (applyToHorizontal) {
              totalScrollDelta = contentSize.width - scrollSize.width;
              moveDelta.x = leftDelta - totalScrollDelta * anchor.x;
            }

            if (applyToVertical) {
              totalScrollDelta = contentSize.height - scrollSize.height;
              moveDelta.y = bottomDelta - totalScrollDelta * anchor.y;
            }
          }

          return moveDelta;
        };

        _proto._moveContentToTopLeft = function _moveContentToTopLeft(scrollViewSize) {
          var bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

          bottomDelta = -bottomDelta;
          var moveDelta = new Vec3();
          var totalScrollDelta = 0;

          var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

          leftDelta = -leftDelta;

          if (this._content) {
            var uiTrans = this._content._uiProps.uiTransformComp;
            var contentSize = uiTrans.contentSize;

            if (contentSize.height < scrollViewSize.height) {
              totalScrollDelta = contentSize.height - scrollViewSize.height;
              moveDelta.y = bottomDelta - totalScrollDelta;
            }

            if (contentSize.width < scrollViewSize.width) {
              totalScrollDelta = contentSize.width - scrollViewSize.width;
              moveDelta.x = leftDelta;
            }
          }

          this._updateScrollBarState();

          this._moveContent(moveDelta);

          this._adjustContentOutOfBoundary();
        };

        _proto._scaleChanged = function _scaleChanged(value) {
          if (value === TransformBit.SCALE) {
            this._calculateBoundary();
          }
        };

        _proto._xrHoverEnter = function _xrHoverEnter(event) {
          if (event.deviceType === DeviceType.Left) {
            this._hoverIn = XrhoverType.LEFT;
          } else if (event.deviceType === DeviceType.Right) {
            this._hoverIn = XrhoverType.RIGHT;
          }

          this._autoScrolling = false;

          this._dispatchEvent(EventType$4.SCROLL_BEGAN);
        };

        _proto._xrHoverExit = function _xrHoverExit() {
          this._hoverIn = XrhoverType.NONE;
          this._autoScrolling = true;

          this._dispatchEvent(EventType$4.SCROLL_ENDED);
        };

        _proto._dispatchEventHandleInput = function _dispatchEventHandleInput(event) {
          var handleInputDevice;

          if (event instanceof EventGamepad) {
            handleInputDevice = event.gamepad;
          } else if (event instanceof EventHandle) {
            handleInputDevice = event.handleInputDevice;
          }

          var value;

          if (!this.enabledInHierarchy) {
            return;
          }

          if (this._hoverIn === XrhoverType.NONE) {
            return;
          } else if (this._hoverIn === XrhoverType.LEFT) {
            value = handleInputDevice.leftStick.getValue();

            if (!value.equals(Vec2.ZERO)) {
              this._xrThumbStickMove(value);
            }
          } else if (this._hoverIn === XrhoverType.RIGHT) {
            value = handleInputDevice.rightStick.getValue();

            if (!value.equals(Vec2.ZERO)) {
              this._xrThumbStickMove(value);
            }
          }

          if (!value && this._scrollState.equals(Vec2.ZERO)) {
            this._xrThumbStickMoveEnd();

            this._scrollState.set(value);
          }
        };

        _proto._xrThumbStickMove = function _xrThumbStickMove(event) {
          var deltaMove = new Vec3();
          var wheelPrecision = -62.5;
          var scrollY = event.y;

          if (this.vertical) {
            deltaMove.set(0, scrollY * wheelPrecision, 0);
          } else if (this.horizontal) {
            deltaMove.set(scrollY * wheelPrecision, 0, 0);
          }

          this._mouseWheelEventElapsedTime = 0;

          this._processDeltaMove(deltaMove);

          this._dispatchEvent(EventType$4.SCROLLING);
        };

        _proto._xrThumbStickMoveEnd = function _xrThumbStickMoveEnd() {
          this._autoScrolling = true;

          this._dispatchEvent(EventType$4.TOUCH_UP);
        };

        _createClass(ScrollView, [{
          key: "content",
          get: function get() {
            return this._content;
          },
          set: function set(value) {
            if (this._content === value) {
              return;
            }

            var viewTrans = value && value.parent && value.parent._uiProps.uiTransformComp;

            if (value && (!value || !viewTrans)) {
              logID(4302);
              return;
            }

            this._content = value;

            this._calculateBoundary();
          }
        }, {
          key: "horizontalScrollBar",
          get: function get() {
            return this._horizontalScrollBar;
          },
          set: function set(value) {
            if (this._horizontalScrollBar === value) {
              return;
            }

            this._horizontalScrollBar = value;

            if (this._horizontalScrollBar) {
              this._horizontalScrollBar.setScrollView(this);

              this._updateScrollBar(Vec2.ZERO);
            }
          }
        }, {
          key: "verticalScrollBar",
          get: function get() {
            return this._verticalScrollBar;
          },
          set: function set(value) {
            if (this._verticalScrollBar === value) {
              return;
            }

            this._verticalScrollBar = value;

            if (this._verticalScrollBar) {
              this._verticalScrollBar.setScrollView(this);

              this._updateScrollBar(Vec2.ZERO);
            }
          }
        }, {
          key: "view",
          get: function get() {
            var parent = this._content && this._content.parent;

            if (!parent) {
              return null;
            }

            return parent._uiProps.uiTransformComp;
          }
        }]);

        return ScrollView;
      }(ViewGroup), _class3$m.EventType = EventType$4, _temp$1k), (_descriptor$1d = _applyDecoratedDescriptor(_class2$1h.prototype, "bounceDuration", [serializable, _dec6$O, _dec7$K, _dec8$F], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor2$13 = _applyDecoratedDescriptor(_class2$1h.prototype, "brake", [serializable, _dec9$A, _dec10$x, _dec11$v], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor3$R = _applyDecoratedDescriptor(_class2$1h.prototype, "elastic", [serializable, _dec12$u, _dec13$s], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor4$H = _applyDecoratedDescriptor(_class2$1h.prototype, "inertia", [serializable, _dec14$p, _dec15$p], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2$1h.prototype, "content", [_dec16$n, _dec17$m, _dec18$l], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "content"), _class2$1h.prototype), _descriptor5$A = _applyDecoratedDescriptor(_class2$1h.prototype, "horizontal", [serializable, _dec19$k, _dec20$k], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2$1h.prototype, "horizontalScrollBar", [_dec21$k, _dec22$i, _dec23$h], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "horizontalScrollBar"), _class2$1h.prototype), _descriptor6$u = _applyDecoratedDescriptor(_class2$1h.prototype, "vertical", [serializable, _dec24$h, _dec25$g], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2$1h.prototype, "verticalScrollBar", [_dec26$g, _dec27$g, _dec28$f], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "verticalScrollBar"), _class2$1h.prototype), _descriptor7$o = _applyDecoratedDescriptor(_class2$1h.prototype, "cancelInnerEvents", [serializable, _dec29$f, _dec30$d], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor8$m = _applyDecoratedDescriptor(_class2$1h.prototype, "scrollEvents", [_dec31$d, serializable, _dec32$a, _dec33$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor9$j = _applyDecoratedDescriptor(_class2$1h.prototype, "_content", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10$g = _applyDecoratedDescriptor(_class2$1h.prototype, "_horizontalScrollBar", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$d = _applyDecoratedDescriptor(_class2$1h.prototype, "_verticalScrollBar", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$1h)) || _class$1r) || _class$1r) || _class$1r) || _class$1r) || _class$1r));
      legacyCC.ScrollView = ScrollView;

      var _dec$1r, _dec2$17, _dec3$12, _dec4$Z, _dec5$V, _dec6$P, _dec7$L, _dec8$G, _dec9$B, _dec10$y, _dec11$w, _dec12$v, _dec13$t, _class$1s, _class2$1i, _descriptor$1e, _descriptor2$14, _descriptor3$S, _descriptor4$I, _class3$n, _temp$1l;

      var _tempPos = new Vec3();

      var Direction$1;

      (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
      })(Direction$1 || (Direction$1 = {}));

      ccenum(Direction$1);
      var Slider = function (v) { return exports({ Slider: v, SliderComponent: v }), v; }((_dec$1r = ccclass('cc.Slider'), _dec2$17 = help(), _dec3$12 = executionOrder(110), _dec4$Z = menu(), _dec5$V = requireComponent(UITransform), _dec6$P = type(Sprite), _dec7$L = tooltip(), _dec8$G = type(Direction$1), _dec9$B = tooltip(), _dec10$y = range(), _dec11$w = tooltip(), _dec12$v = type([EventHandler]), _dec13$t = tooltip(), _dec$1r(_class$1s = _dec2$17(_class$1s = _dec3$12(_class$1s = _dec4$Z(_class$1s = _dec5$V(_class$1s = (_class2$1i = (_temp$1l = _class3$n = function (_Component) {
        _inheritsLoose(Slider, _Component);

        function Slider() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "slideEvents", _descriptor$1e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_handle", _descriptor2$14, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$S, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_progress", _descriptor4$I, _assertThisInitialized(_this));

          _this._offset = new Vec3();
          _this._dragging = false;
          _this._touchHandle = false;
          _this._handleLocalPos = new Vec3();
          _this._touchPos = new Vec3();
          return _this;
        }

        var _proto = Slider.prototype;

        _proto.__preload = function __preload() {
          this._updateHandlePosition();
        };

        _proto.onEnable = function onEnable() {
          this._updateHandlePosition();

          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_STAY, this._xrHoverStay, this);
          this.node.on(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);

          if (this._handle && this._handle.isValid) {
            this._handle.node.on(NodeEventType.TOUCH_START, this._onHandleDragStart, this);

            this._handle.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);

            this._handle.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          }
        };

        _proto.onDisable = function onDisable() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_STAY, this._xrHoverStay, this);
          this.node.off(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);

          if (this._handle && this._handle.isValid) {
            this._handle.node.off(NodeEventType.TOUCH_START, this._onHandleDragStart, this);

            this._handle.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);

            this._handle.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          }
        };

        _proto._onHandleDragStart = function _onHandleDragStart(event) {
          if (!event || !this._handle || !this._handle.node._uiProps.uiTransformComp) {
            return;
          }

          this._dragging = true;
          this._touchHandle = true;
          var touhPos = event.touch.getUILocation();
          Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0);

          this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset);

          event.propagationStopped = true;
        };

        _proto._onTouchBegan = function _onTouchBegan(event) {
          if (!this._handle || !event) {
            return;
          }

          this._dragging = true;

          if (!this._touchHandle) {
            this._handleSliderLogic(event.touch);
          }

          event.propagationStopped = true;
        };

        _proto._onTouchMoved = function _onTouchMoved(event) {
          if (!this._dragging || !event) {
            return;
          }

          this._handleSliderLogic(event.touch);

          event.propagationStopped = true;
        };

        _proto._onTouchEnded = function _onTouchEnded(event) {
          this._dragging = false;
          this._touchHandle = false;
          this._offset = new Vec3();

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._onTouchCancelled = function _onTouchCancelled(event) {
          this._dragging = false;

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._handleSliderLogic = function _handleSliderLogic(touch) {
          this._updateProgress(touch);

          this._emitSlideEvent();
        };

        _proto._emitSlideEvent = function _emitSlideEvent() {
          EventHandler.emitEvents(this.slideEvents, this);
          this.node.emit('slide', this);
        };

        _proto._updateProgress = function _updateProgress(touch) {
          if (!this._handle || !touch) {
            return;
          }

          var touchPos = touch.getUILocation();
          Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
          var uiTrans = this.node._uiProps.uiTransformComp;
          var localTouchPos = uiTrans.convertToNodeSpaceAR(this._touchPos, _tempPos);

          if (this.direction === Direction$1.Horizontal) {
            this.progress = clamp01(0.5 + (localTouchPos.x - this._offset.x) / uiTrans.width);
          } else {
            this.progress = clamp01(0.5 + (localTouchPos.y - this._offset.y) / uiTrans.height);
          }
        };

        _proto._updateHandlePosition = function _updateHandlePosition() {
          if (!this._handle) {
            return;
          }

          this._handleLocalPos.set(this._handle.node.getPosition());

          var uiTrans = this.node._uiProps.uiTransformComp;

          if (this._direction === Direction$1.Horizontal) {
            this._handleLocalPos.x = -uiTrans.width * uiTrans.anchorX + this.progress * uiTrans.width;
          } else {
            this._handleLocalPos.y = -uiTrans.height * uiTrans.anchorY + this.progress * uiTrans.height;
          }

          this._handle.node.setPosition(this._handleLocalPos);
        };

        _proto._changeLayout = function _changeLayout() {
          var uiTrans = this.node._uiProps.uiTransformComp;
          var contentSize = uiTrans.contentSize;
          uiTrans.setContentSize(contentSize.height, contentSize.width);

          if (this._handle) {
            var pos = this._handle.node.position;

            if (this._direction === Direction$1.Horizontal) {
              this._handle.node.setPosition(pos.x, 0, pos.z);
            } else {
              this._handle.node.setPosition(0, pos.y, pos.z);
            }

            this._updateHandlePosition();
          }
        };

        _proto._xrHandleProgress = function _xrHandleProgress(point) {
          if (!this._touchHandle) {
            var uiTrans = this.node._uiProps.uiTransformComp;
            uiTrans.convertToNodeSpaceAR(point, _tempPos);

            if (this.direction === Direction$1.Horizontal) {
              this.progress = clamp01(0.5 + (_tempPos.x - this.node.position.x) / uiTrans.width);
            } else {
              this.progress = clamp01(0.5 + (_tempPos.y - this.node.position.y) / uiTrans.height);
            }
          }
        };

        _proto._xrClick = function _xrClick(event) {
          if (!this._handle) {
            return;
          }

          this._dragging = true;

          this._xrHandleProgress(event.hitPoint);

          this._emitSlideEvent();
        };

        _proto._xrUnClick = function _xrUnClick() {
          this._dragging = false;
          this._touchHandle = false;
        };

        _proto._xrHoverStay = function _xrHoverStay(event) {
          if (!this._dragging) {
            return;
          }

          this._xrHandleProgress(event.hitPoint);

          this._emitSlideEvent();
        };

        _createClass(Slider, [{
          key: "handle",
          get: function get() {
            return this._handle;
          },
          set: function set(value) {
            if (this._handle === value) {
              return;
            }

            this._handle = value;
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) {
              return;
            }

            this._direction = value;

            this._changeLayout();
          }
        }, {
          key: "progress",
          get: function get() {
            return this._progress;
          },
          set: function set(value) {
            if (this._progress === value) {
              return;
            }

            this._progress = value;

            this._updateHandlePosition();
          }
        }]);

        return Slider;
      }(Component), _class3$n.Direction = Direction$1, _temp$1l), (_applyDecoratedDescriptor(_class2$1i.prototype, "handle", [_dec6$P, _dec7$L], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "handle"), _class2$1i.prototype), _applyDecoratedDescriptor(_class2$1i.prototype, "direction", [_dec8$G, _dec9$B], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "direction"), _class2$1i.prototype), _applyDecoratedDescriptor(_class2$1i.prototype, "progress", [slide, _dec10$y, _dec11$w], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "progress"), _class2$1i.prototype), _descriptor$1e = _applyDecoratedDescriptor(_class2$1i.prototype, "slideEvents", [_dec12$v, serializable, _dec13$t], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$14 = _applyDecoratedDescriptor(_class2$1i.prototype, "_handle", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$S = _applyDecoratedDescriptor(_class2$1i.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Direction$1.Horizontal;
        }
      }), _descriptor4$I = _applyDecoratedDescriptor(_class2$1i.prototype, "_progress", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      })), _class2$1i)) || _class$1s) || _class$1s) || _class$1s) || _class$1s) || _class$1s));
      legacyCC.Slider = Slider;

      function extendsEnum() {
        for (var _len = arguments.length, enums = new Array(_len), _key = 0; _key < _len; _key++) {
          enums[_key] = arguments[_key];
        }

        return Object.assign.apply(Object, [{}].concat(enums));
      }

      var _dec$1s, _dec2$18, _dec3$13, _dec4$_, _dec5$W, _dec6$Q, _dec7$M, _dec8$H, _dec9$C, _dec10$z, _dec11$x, _dec12$w, _class$1t, _class2$1j, _descriptor$1f, _descriptor2$15, _descriptor3$T, _class3$o, _temp$1m;
      var EventType$5;

      (function (EventType) {
        EventType["TOGGLE"] = "toggle";
      })(EventType$5 || (EventType$5 = {}));

      var Toggle = function (v) { return exports({ Toggle: v, ToggleComponent: v }), v; }((_dec$1s = ccclass('cc.Toggle'), _dec2$18 = help(), _dec3$13 = executionOrder(110), _dec4$_ = menu(), _dec5$W = requireComponent(UITransform), _dec6$Q = displayOrder(), _dec7$M = tooltip(), _dec8$H = type(Sprite), _dec9$C = displayOrder(), _dec10$z = tooltip(), _dec11$x = type([EventHandler]), _dec12$w = tooltip(), _dec$1s(_class$1t = _dec2$18(_class$1t = _dec3$13(_class$1t = _dec4$_(_class$1t = _dec5$W(_class$1t = (_class2$1j = (_temp$1m = _class3$o = function (_Button) {
        _inheritsLoose(Toggle, _Button);

        function Toggle() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Button.call.apply(_Button, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "checkEvents", _descriptor$1f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isChecked", _descriptor2$15, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_checkMark", _descriptor3$T, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = Toggle.prototype;

        _proto._internalToggle = function _internalToggle() {
          this.isChecked = !this.isChecked;
        };

        _proto._set = function _set(value, emitEvent) {
          if (emitEvent === void 0) {
            emitEvent = true;
          }

          if (this._isChecked == value) return;
          this._isChecked = value;
          var group = this._toggleContainer;

          if (group && group.enabled && this.enabled) {
            if (value || !group.anyTogglesChecked() && !group.allowSwitchOff) {
              this._isChecked = true;
              group.notifyToggleCheck(this, emitEvent);
            }
          }

          this.playEffect();

          if (emitEvent) {
            this._emitToggleEvents();
          }
        };

        _proto.playEffect = function playEffect() {
          if (this._checkMark) {
            this._checkMark.node.active = this._isChecked;
          }
        };

        _proto.setIsCheckedWithoutNotify = function setIsCheckedWithoutNotify(value) {
          this._set(value, false);
        };

        _proto.onEnable = function onEnable() {
          _Button.prototype.onEnable.call(this);

          this.playEffect();

          {
            this.node.on(Toggle.EventType.CLICK, this._internalToggle, this);
          }
        };

        _proto.onDisable = function onDisable() {
          _Button.prototype.onDisable.call(this);

          {
            this.node.off(Toggle.EventType.CLICK, this._internalToggle, this);
          }
        };

        _proto.OnDestroy = function OnDestroy() {
          var group = this._toggleContainer;

          if (group) {
            group.ensureValidState();
          }
        };

        _proto._emitToggleEvents = function _emitToggleEvents() {
          this.node.emit(Toggle.EventType.TOGGLE, this);

          if (this.checkEvents) {
            EventHandler.emitEvents(this.checkEvents, this);
          }
        };

        _createClass(Toggle, [{
          key: "isChecked",
          get: function get() {
            return this._isChecked;
          },
          set: function set(value) {
            this._set(value);
          }
        }, {
          key: "checkMark",
          get: function get() {
            return this._checkMark;
          },
          set: function set(value) {
            if (this._checkMark === value) {
              return;
            }

            this._checkMark = value;
          }
        }, {
          key: "_resizeToTarget",
          set: function set(value) {
            if (value) {
              this._resizeNodeToTargetNode();
            }
          }
        }, {
          key: "_toggleContainer",
          get: function get() {
            var parent = this.node.parent;

            if (legacyCC.Node.isNode(parent)) {
              return parent.getComponent('cc.ToggleContainer');
            }

            return null;
          }
        }]);

        return Toggle;
      }(Button), _class3$o.EventType = extendsEnum(EventType$5, EventType$2), _temp$1m), (_applyDecoratedDescriptor(_class2$1j.prototype, "isChecked", [_dec6$Q, _dec7$M], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "isChecked"), _class2$1j.prototype), _applyDecoratedDescriptor(_class2$1j.prototype, "checkMark", [_dec8$H, _dec9$C, _dec10$z], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "checkMark"), _class2$1j.prototype), _descriptor$1f = _applyDecoratedDescriptor(_class2$1j.prototype, "checkEvents", [_dec11$x, serializable, _dec12$w], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$15 = _applyDecoratedDescriptor(_class2$1j.prototype, "_isChecked", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor3$T = _applyDecoratedDescriptor(_class2$1j.prototype, "_checkMark", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$1j)) || _class$1t) || _class$1t) || _class$1t) || _class$1t) || _class$1t));
      legacyCC.Toggle = Toggle;

      var _dec$1t, _dec2$19, _dec3$14, _dec4$$, _dec5$X, _dec6$R, _dec7$N, _class$1u, _class2$1k, _descriptor$1g, _descriptor2$16, _temp$1n;
      var ToggleContainer = function (v) { return exports({ ToggleContainer: v, ToggleContainerComponent: v }), v; }((_dec$1t = ccclass('cc.ToggleContainer'), _dec2$19 = help(), _dec3$14 = executionOrder(110), _dec4$$ = menu(), _dec5$X = tooltip(), _dec6$R = type([EventHandler]), _dec7$N = tooltip(), _dec$1t(_class$1u = _dec2$19(_class$1u = _dec3$14(_class$1u = _dec4$$(_class$1u = executeInEditMode(_class$1u = (_class2$1k = (_temp$1n = function (_Component) {
        _inheritsLoose(ToggleContainer, _Component);

        function ToggleContainer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_allowSwitchOff", _descriptor$1g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "checkEvents", _descriptor2$16, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = ToggleContainer.prototype;

        _proto.onEnable = function onEnable() {
          this.ensureValidState();
          this.node.on(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
          this.node.on(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
        };

        _proto.onDisable = function onDisable() {
          this.node.off(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
          this.node.off(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
        };

        _proto.activeToggles = function activeToggles() {
          return this.toggleItems.filter(function (x) {
            return x.isChecked;
          });
        };

        _proto.anyTogglesChecked = function anyTogglesChecked() {
          return !!this.toggleItems.find(function (x) {
            return x.isChecked;
          });
        };

        _proto.notifyToggleCheck = function notifyToggleCheck(toggle, emitEvent) {
          if (emitEvent === void 0) {
            emitEvent = true;
          }

          if (!this.enabledInHierarchy) {
            return;
          }

          for (var i = 0; i < this.toggleItems.length; i++) {
            var item = this.toggleItems[i];

            if (item === toggle) {
              continue;
            }

            if (emitEvent) {
              item.isChecked = false;
            } else {
              item.setIsCheckedWithoutNotify(false);
            }
          }

          if (this.checkEvents) {
            legacyCC.Component.EventHandler.emitEvents(this.checkEvents, toggle);
          }
        };

        _proto.ensureValidState = function ensureValidState() {
          var toggles = this.toggleItems;

          if (!this._allowSwitchOff && !this.anyTogglesChecked() && toggles.length !== 0) {
            var toggle = toggles[0];
            toggle.isChecked = true;
            this.notifyToggleCheck(toggle);
          }

          var activeToggles = this.activeToggles();

          if (activeToggles.length > 1) {
            var firstToggle = activeToggles[0];

            for (var i = 0; i < activeToggles.length; ++i) {
              var _toggle = activeToggles[i];

              if (_toggle === firstToggle) {
                continue;
              }

              _toggle.isChecked = false;
            }
          }
        };

        _createClass(ToggleContainer, [{
          key: "allowSwitchOff",
          get: function get() {
            return this._allowSwitchOff;
          },
          set: function set(value) {
            this._allowSwitchOff = value;
          }
        }, {
          key: "toggleItems",
          get: function get() {
            return this.node.children.map(function (item) {
              var toggle = item.getComponent('cc.Toggle');

              if (toggle && toggle.enabled) {
                return toggle;
              }

              return null;
            }).filter(Boolean);
          }
        }]);

        return ToggleContainer;
      }(Component), _temp$1n), (_descriptor$1g = _applyDecoratedDescriptor(_class2$1k.prototype, "_allowSwitchOff", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$1k.prototype, "allowSwitchOff", [_dec5$X], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "allowSwitchOff"), _class2$1k.prototype), _descriptor2$16 = _applyDecoratedDescriptor(_class2$1k.prototype, "checkEvents", [_dec6$R, serializable, _dec7$N], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$1k)) || _class$1u) || _class$1u) || _class$1u) || _class$1u) || _class$1u));
      legacyCC.ToggleContainer = ToggleContainer;

      var _dec$1u, _dec2$1a, _dec3$15, _dec4$10, _dec5$Y, _dec6$S, _dec7$O, _dec8$I, _dec9$D, _dec10$A, _dec11$y, _dec12$x, _dec13$u, _dec14$q, _dec15$q, _dec16$o, _dec17$n, _dec18$m, _dec19$l, _dec20$l, _dec21$l, _dec22$j, _dec23$i, _class$1v, _class2$1l, _descriptor$1h, _descriptor2$17, _descriptor3$U, _descriptor4$J, _descriptor5$B, _descriptor6$v, _descriptor7$p, _descriptor8$n, _descriptor9$k, _descriptor10$h, _descriptor11$e, _descriptor12$d, _descriptor13$d, _descriptor14$7, _descriptor15$5, _descriptor16$5, _descriptor17$3, _descriptor18$2, _class3$p, _temp$1o;

      var _tempScale = new Vec2();

      function getReadonlyNodeSize(parent) {
        if (parent instanceof Scene) {

          return visibleRect;
        } else if (parent._uiProps.uiTransformComp) {
          return parent._uiProps.uiTransformComp.contentSize;
        } else {
          return Size.ZERO;
        }
      }
      function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
        if (widgetNode.parent) {
          _tempScale.set(widgetNode.parent.getScale().x, widgetNode.parent.getScale().y);
        } else {
          _tempScale.set(0, 0);
        }

        var scaleX = _tempScale.x;
        var scaleY = _tempScale.y;
        var translateX = 0;
        var translateY = 0;

        for (var node = widgetNode.parent;;) {
          if (!node) {
            out_inverseTranslate.x = out_inverseTranslate.y = 0;
            out_inverseScale.x = out_inverseScale.y = 1;
            return;
          }

          var pos = node.getPosition();
          translateX += pos.x;
          translateY += pos.y;
          node = node.parent;

          if (node !== target) {
            if (node) {
              _tempScale.set(node.getScale().x, node.getScale().y);
            } else {
              _tempScale.set(0, 0);
            }

            var sx = _tempScale.x;
            var sy = _tempScale.y;
            translateX *= sx;
            translateY *= sy;
            scaleX *= sx;
            scaleY *= sy;
          } else {
            break;
          }
        }

        out_inverseScale.x = scaleX !== 0 ? 1 / scaleX : 1;
        out_inverseScale.y = scaleY !== 0 ? 1 / scaleY : 1;
        out_inverseTranslate.x = -translateX;
        out_inverseTranslate.y = -translateY;
      }
      var AlignMode;

      (function (AlignMode) {
        AlignMode[AlignMode["ONCE"] = 0] = "ONCE";
        AlignMode[AlignMode["ALWAYS"] = 1] = "ALWAYS";
        AlignMode[AlignMode["ON_WINDOW_RESIZE"] = 2] = "ON_WINDOW_RESIZE";
      })(AlignMode || (AlignMode = {}));

      ccenum(AlignMode);
      var AlignFlags;

      (function (AlignFlags) {
        AlignFlags[AlignFlags["TOP"] = 1] = "TOP";
        AlignFlags[AlignFlags["MID"] = 2] = "MID";
        AlignFlags[AlignFlags["BOT"] = 4] = "BOT";
        AlignFlags[AlignFlags["LEFT"] = 8] = "LEFT";
        AlignFlags[AlignFlags["CENTER"] = 16] = "CENTER";
        AlignFlags[AlignFlags["RIGHT"] = 32] = "RIGHT";
        AlignFlags[AlignFlags["HORIZONTAL"] = 56] = "HORIZONTAL";
        AlignFlags[AlignFlags["VERTICAL"] = 7] = "VERTICAL";
      })(AlignFlags || (AlignFlags = {}));

      var TOP_BOT = AlignFlags.TOP | AlignFlags.BOT;
      var LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT;
      var Widget = function (v) { return exports({ Widget: v, WidgetComponent: v }), v; }((_dec$1u = ccclass('cc.Widget'), _dec2$1a = help(), _dec3$15 = executionOrder(110), _dec4$10 = menu(), _dec5$Y = requireComponent(UITransform), _dec6$S = type(Node), _dec7$O = tooltip(), _dec8$I = tooltip(), _dec9$D = tooltip(), _dec10$A = tooltip(), _dec11$y = tooltip(), _dec12$x = tooltip(), _dec13$u = tooltip(), _dec14$q = visible(), _dec15$q = visible(), _dec16$o = tooltip(), _dec17$n = tooltip(), _dec18$m = tooltip(), _dec19$l = tooltip(), _dec20$l = tooltip(), _dec21$l = tooltip(), _dec22$j = type(AlignMode), _dec23$i = tooltip(), _dec$1u(_class$1v = _dec2$1a(_class$1v = _dec3$15(_class$1v = _dec4$10(_class$1v = _dec5$Y(_class$1v = executeInEditMode(_class$1v = (_class2$1l = (_temp$1o = _class3$p = function (_Component) {
        _inheritsLoose(Widget, _Component);

        function Widget() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._lastPos = new Vec3();
          _this._lastSize = new Size();
          _this._dirty = true;
          _this._hadAlignOnce = false;

          _initializerDefineProperty(_this, "_alignFlags", _descriptor$1h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_target", _descriptor2$17, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_left", _descriptor3$U, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_right", _descriptor4$J, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_top", _descriptor5$B, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_bottom", _descriptor6$v, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalCenter", _descriptor7$p, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalCenter", _descriptor8$n, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsLeft", _descriptor9$k, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsRight", _descriptor10$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsTop", _descriptor11$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsBottom", _descriptor12$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsHorizontalCenter", _descriptor13$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsVerticalCenter", _descriptor14$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_originalWidth", _descriptor15$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_originalHeight", _descriptor16$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_alignMode", _descriptor17$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lockFlags", _descriptor18$2, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = Widget.prototype;

        _proto.updateAlignment = function updateAlignment() {
          legacyCC._widgetManager.updateAlignment(this.node);
        };

        _proto._validateTargetInDEV = function _validateTargetInDEV() {
          {
            return;
          }
        };

        _proto.setDirty = function setDirty() {
          this._recursiveDirty();
        };

        _proto.onEnable = function onEnable() {
          this.node.getPosition(this._lastPos);

          this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize);

          legacyCC._widgetManager.add(this);

          this._hadAlignOnce = false;

          this._registerEvent();

          this._registerTargetEvents();
        };

        _proto.onDisable = function onDisable() {
          legacyCC._widgetManager.remove(this);

          this._unregisterEvent();

          this._unregisterTargetEvents();
        };

        _proto.onDestroy = function onDestroy() {
          this._removeParentEvent();
        };

        _proto._adjustWidgetToAllowMovingInEditor = function _adjustWidgetToAllowMovingInEditor(eventType) {};

        _proto._adjustWidgetToAllowResizingInEditor = function _adjustWidgetToAllowResizingInEditor() {};

        _proto._adjustWidgetToAnchorChanged = function _adjustWidgetToAnchorChanged() {
          this.setDirty();
        };

        _proto._adjustTargetToParentChanged = function _adjustTargetToParentChanged(oldParent) {
          if (oldParent) {
            this._unregisterOldParentEvents(oldParent);
          }

          if (this.node.getParent()) {
            this._registerTargetEvents();
          }

          this._setDirtyByMode();
        };

        _proto._registerEvent = function _registerEvent() {
          {
            this.node.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            this.node.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }

          this.node.on(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
          this.node.on(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        };

        _proto._unregisterEvent = function _unregisterEvent() {
          {
            this.node.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            this.node.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }

          this.node.off(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
        };

        _proto._removeParentEvent = function _removeParentEvent() {
          this.node.off(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        };

        _proto._autoChangedValue = function _autoChangedValue(flag, isAbs) {
          var current = (this._alignFlags & flag) > 0;

          if (!current) {
            return;
          }

          var parentUiProps = this.node.parent && this.node.parent._uiProps;
          var parentTrans = parentUiProps && parentUiProps.uiTransformComp;
          var size = parentTrans ? parentTrans.contentSize : visibleRect;

          if (this.isAlignLeft && flag === AlignFlags.LEFT) {
            this._left = isAbs ? this._left * size.width : this._left / size.width;
          } else if (this.isAlignRight && flag === AlignFlags.RIGHT) {
            this._right = isAbs ? this._right * size.width : this._right / size.width;
          } else if (this.isAlignHorizontalCenter && flag === AlignFlags.CENTER) {
            this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width;
          } else if (this.isAlignTop && flag === AlignFlags.TOP) {
            this._top = isAbs ? this._top * size.height : this._top / size.height;
          } else if (this.isAlignBottom && flag === AlignFlags.BOT) {
            this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height;
          } else if (this.isAbsoluteVerticalCenter && flag === AlignFlags.MID) {
            this._verticalCenter = isAbs ? this._verticalCenter / size.height : this._verticalCenter / size.height;
          }

          this._recursiveDirty();
        };

        _proto._registerTargetEvents = function _registerTargetEvents() {
          var target = this._target || this.node.parent;

          if (target) {
            if (target.getComponent(UITransform)) {
              target.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
              target.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
              target.on(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
            }
          }
        };

        _proto._unregisterTargetEvents = function _unregisterTargetEvents() {
          var target = this._target || this.node.parent;

          if (target) {
            target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
          }
        };

        _proto._unregisterOldParentEvents = function _unregisterOldParentEvents(oldParent) {
          var target = this._target || oldParent;

          if (target) {
            target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }
        };

        _proto._setDirtyByMode = function _setDirtyByMode() {
          if (this.alignMode === AlignMode.ALWAYS || EDITOR ) {
            this._recursiveDirty();
          }
        };

        _proto._setAlign = function _setAlign(flag, isAlign) {
          var current = (this._alignFlags & flag) > 0;

          if (isAlign === current) {
            return;
          }

          var isHorizontal = (flag & LEFT_RIGHT) > 0;
          var trans = this.node._uiProps.uiTransformComp;

          if (isAlign) {
            this._alignFlags |= flag;

            if (isHorizontal) {
              this.isAlignHorizontalCenter = false;

              if (this.isStretchWidth) {
                this._originalWidth = trans.width;
              }
            } else {
              this.isAlignVerticalCenter = false;

              if (this.isStretchHeight) {
                this._originalHeight = trans.height;
              }
            }
          } else {
            if (isHorizontal) {
              if (this.isStretchWidth) {
                trans.width = this._originalWidth;
              }
            } else if (this.isStretchHeight) {
              trans.height = this._originalHeight;
            }

            this._alignFlags &= ~flag;
          }
        };

        _proto._recursiveDirty = function _recursiveDirty() {
          if (this._dirty) {
            return;
          }

          this._dirty = true;
        };

        _createClass(Widget, [{
          key: "target",
          get: function get() {
            return this._target;
          },
          set: function set(value) {
            if (this._target === value) {
              return;
            }

            this._unregisterTargetEvents();

            this._target = value;

            this._registerTargetEvents();

            this._validateTargetInDEV();

            this._recursiveDirty();
          }
        }, {
          key: "isAlignTop",
          get: function get() {
            return (this._alignFlags & AlignFlags.TOP) > 0;
          },
          set: function set(value) {
            this._setAlign(AlignFlags.TOP, value);

            this._recursiveDirty();
          }
        }, {
          key: "isAlignBottom",
          get: function get() {
            return (this._alignFlags & AlignFlags.BOT) > 0;
          },
          set: function set(value) {
            this._setAlign(AlignFlags.BOT, value);

            this._recursiveDirty();
          }
        }, {
          key: "isAlignLeft",
          get: function get() {
            return (this._alignFlags & AlignFlags.LEFT) > 0;
          },
          set: function set(value) {
            this._setAlign(AlignFlags.LEFT, value);

            this._recursiveDirty();
          }
        }, {
          key: "isAlignRight",
          get: function get() {
            return (this._alignFlags & AlignFlags.RIGHT) > 0;
          },
          set: function set(value) {
            this._setAlign(AlignFlags.RIGHT, value);

            this._recursiveDirty();
          }
        }, {
          key: "isAlignVerticalCenter",
          get: function get() {
            return (this._alignFlags & AlignFlags.MID) > 0;
          },
          set: function set(value) {
            if (value) {
              this.isAlignTop = false;
              this.isAlignBottom = false;
              this._alignFlags |= AlignFlags.MID;
            } else {
              this._alignFlags &= ~AlignFlags.MID;
            }

            this._recursiveDirty();
          }
        }, {
          key: "isAlignHorizontalCenter",
          get: function get() {
            return (this._alignFlags & AlignFlags.CENTER) > 0;
          },
          set: function set(value) {
            if (value) {
              this.isAlignLeft = false;
              this.isAlignRight = false;
              this._alignFlags |= AlignFlags.CENTER;
            } else {
              this._alignFlags &= ~AlignFlags.CENTER;
            }

            this._recursiveDirty();
          }
        }, {
          key: "isStretchWidth",
          get: function get() {
            return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
          }
        }, {
          key: "isStretchHeight",
          get: function get() {
            return (this._alignFlags & TOP_BOT) === TOP_BOT;
          }
        }, {
          key: "top",
          get: function get() {
            return this._top;
          },
          set: function set(value) {
            this._top = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorTop",
          get: function get() {
            return this._isAbsTop ? this._top : this._top * 100;
          },
          set: function set(value) {
            this._top = this._isAbsTop ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "bottom",
          get: function get() {
            return this._bottom;
          },
          set: function set(value) {
            this._bottom = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorBottom",
          get: function get() {
            return this._isAbsBottom ? this._bottom : this._bottom * 100;
          },
          set: function set(value) {
            this._bottom = this._isAbsBottom ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "left",
          get: function get() {
            return this._left;
          },
          set: function set(value) {
            this._left = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorLeft",
          get: function get() {
            return this._isAbsLeft ? this._left : this._left * 100;
          },
          set: function set(value) {
            this._left = this._isAbsLeft ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "right",
          get: function get() {
            return this._right;
          },
          set: function set(value) {
            this._right = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorRight",
          get: function get() {
            return this._isAbsRight ? this._right : this._right * 100;
          },
          set: function set(value) {
            this._right = this._isAbsRight ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "horizontalCenter",
          get: function get() {
            return this._horizontalCenter;
          },
          set: function set(value) {
            this._horizontalCenter = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorHorizontalCenter",
          get: function get() {
            return this._isAbsHorizontalCenter ? this._horizontalCenter : this._horizontalCenter * 100;
          },
          set: function set(value) {
            this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "verticalCenter",
          get: function get() {
            return this._verticalCenter;
          },
          set: function set(value) {
            this._verticalCenter = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorVerticalCenter",
          get: function get() {
            return this._isAbsVerticalCenter ? this._verticalCenter : this._verticalCenter * 100;
          },
          set: function set(value) {
            this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "isAbsoluteTop",
          get: function get() {
            return this._isAbsTop;
          },
          set: function set(value) {
            if (this._isAbsTop === value) {
              return;
            }

            this._isAbsTop = value;

            this._autoChangedValue(AlignFlags.TOP, this._isAbsTop);
          }
        }, {
          key: "isAbsoluteBottom",
          get: function get() {
            return this._isAbsBottom;
          },
          set: function set(value) {
            if (this._isAbsBottom === value) {
              return;
            }

            this._isAbsBottom = value;

            this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom);
          }
        }, {
          key: "isAbsoluteLeft",
          get: function get() {
            return this._isAbsLeft;
          },
          set: function set(value) {
            if (this._isAbsLeft === value) {
              return;
            }

            this._isAbsLeft = value;

            this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft);
          }
        }, {
          key: "isAbsoluteRight",
          get: function get() {
            return this._isAbsRight;
          },
          set: function set(value) {
            if (this._isAbsRight === value) {
              return;
            }

            this._isAbsRight = value;

            this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight);
          }
        }, {
          key: "isAbsoluteHorizontalCenter",
          get: function get() {
            return this._isAbsHorizontalCenter;
          },
          set: function set(value) {
            if (this._isAbsHorizontalCenter === value) {
              return;
            }

            this._isAbsHorizontalCenter = value;

            this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter);
          }
        }, {
          key: "isAbsoluteVerticalCenter",
          get: function get() {
            return this._isAbsVerticalCenter;
          },
          set: function set(value) {
            if (this._isAbsVerticalCenter === value) {
              return;
            }

            this._isAbsVerticalCenter = value;

            this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter);
          }
        }, {
          key: "alignMode",
          get: function get() {
            return this._alignMode;
          },
          set: function set(value) {
            this._alignMode = value;

            this._recursiveDirty();
          }
        }, {
          key: "alignFlags",
          get: function get() {
            return this._alignFlags;
          },
          set: function set(value) {
            if (this._alignFlags === value) {
              return;
            }

            this._alignFlags = value;

            this._recursiveDirty();
          }
        }]);

        return Widget;
      }(Component), _class3$p.AlignMode = AlignMode, _temp$1o), (_applyDecoratedDescriptor(_class2$1l.prototype, "target", [_dec6$S, _dec7$O], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "target"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAlignTop", [_dec8$I], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAlignTop"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAlignBottom", [_dec9$D], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAlignBottom"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAlignLeft", [_dec10$A], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAlignLeft"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAlignRight", [_dec11$y], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAlignRight"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAlignVerticalCenter", [_dec12$x], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAlignVerticalCenter"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAlignHorizontalCenter", [_dec13$u], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAlignHorizontalCenter"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isStretchWidth", [_dec14$q], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isStretchWidth"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isStretchHeight", [_dec15$q], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isStretchHeight"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "top", [_dec16$o], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "top"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "editorTop", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "editorTop"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "bottom", [_dec17$n], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "bottom"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "editorBottom", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "editorBottom"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "left", [_dec18$m], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "left"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "editorLeft", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "editorLeft"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "right", [_dec19$l], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "right"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "editorRight", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "editorRight"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "horizontalCenter", [_dec20$l], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "horizontalCenter"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "editorHorizontalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "editorHorizontalCenter"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "verticalCenter", [_dec21$l], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "verticalCenter"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "editorVerticalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "editorVerticalCenter"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAbsoluteTop", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAbsoluteTop"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAbsoluteBottom", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAbsoluteBottom"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAbsoluteLeft", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAbsoluteLeft"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAbsoluteRight", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAbsoluteRight"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAbsoluteHorizontalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAbsoluteHorizontalCenter"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "isAbsoluteVerticalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isAbsoluteVerticalCenter"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "alignMode", [_dec22$j, _dec23$i], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "alignMode"), _class2$1l.prototype), _applyDecoratedDescriptor(_class2$1l.prototype, "alignFlags", [editable], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "alignFlags"), _class2$1l.prototype), _descriptor$1h = _applyDecoratedDescriptor(_class2$1l.prototype, "_alignFlags", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$17 = _applyDecoratedDescriptor(_class2$1l.prototype, "_target", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$U = _applyDecoratedDescriptor(_class2$1l.prototype, "_left", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor4$J = _applyDecoratedDescriptor(_class2$1l.prototype, "_right", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor5$B = _applyDecoratedDescriptor(_class2$1l.prototype, "_top", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor6$v = _applyDecoratedDescriptor(_class2$1l.prototype, "_bottom", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$p = _applyDecoratedDescriptor(_class2$1l.prototype, "_horizontalCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8$n = _applyDecoratedDescriptor(_class2$1l.prototype, "_verticalCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor9$k = _applyDecoratedDescriptor(_class2$1l.prototype, "_isAbsLeft", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor10$h = _applyDecoratedDescriptor(_class2$1l.prototype, "_isAbsRight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor11$e = _applyDecoratedDescriptor(_class2$1l.prototype, "_isAbsTop", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor12$d = _applyDecoratedDescriptor(_class2$1l.prototype, "_isAbsBottom", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor13$d = _applyDecoratedDescriptor(_class2$1l.prototype, "_isAbsHorizontalCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor14$7 = _applyDecoratedDescriptor(_class2$1l.prototype, "_isAbsVerticalCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor15$5 = _applyDecoratedDescriptor(_class2$1l.prototype, "_originalWidth", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor16$5 = _applyDecoratedDescriptor(_class2$1l.prototype, "_originalHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor17$3 = _applyDecoratedDescriptor(_class2$1l.prototype, "_alignMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AlignMode.ON_WINDOW_RESIZE;
        }
      }), _descriptor18$2 = _applyDecoratedDescriptor(_class2$1l.prototype, "_lockFlags", [serializable, editorOnly], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$1l)) || _class$1v) || _class$1v) || _class$1v) || _class$1v) || _class$1v) || _class$1v));
      legacyCC.internal.computeInverseTransForTarget = computeInverseTransForTarget;
      legacyCC.internal.getReadonlyNodeSize = getReadonlyNodeSize;
      legacyCC.Widget = Widget;

      var _dec$1v, _dec2$1b, _dec3$16, _dec4$11, _dec5$Z, _dec6$T, _dec7$P, _dec8$J, _dec9$E, _dec10$B, _dec11$z, _class$1w, _class2$1m, _descriptor$1i, _descriptor2$18, _descriptor3$V, _descriptor4$K, _class3$q, _temp$1p;

      var _color$1 = new Color();

      var Direction$2;

      (function (Direction) {
        Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
        Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
      })(Direction$2 || (Direction$2 = {}));

      ccenum(Direction$2);
      var PageViewIndicator = function (v) { return exports({ PageViewIndicator: v, PageViewIndicatorComponent: v }), v; }((_dec$1v = ccclass('cc.PageViewIndicator'), _dec2$1b = help(), _dec3$16 = executionOrder(110), _dec4$11 = menu(), _dec5$Z = type(SpriteFrame), _dec6$T = tooltip(), _dec7$P = type(Direction$2), _dec8$J = tooltip(), _dec9$E = type(Size), _dec10$B = tooltip(), _dec11$z = tooltip(), _dec$1v(_class$1w = _dec2$1b(_class$1w = _dec3$16(_class$1w = _dec4$11(_class$1w = (_class2$1m = (_temp$1p = _class3$q = function (_Component) {
        _inheritsLoose(PageViewIndicator, _Component);

        function PageViewIndicator() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "spacing", _descriptor$1i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spriteFrame", _descriptor2$18, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$V, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cellSize", _descriptor4$K, _assertThisInitialized(_this));

          _this._layout = null;
          _this._pageView = null;
          _this._indicators = [];
          return _this;
        }

        var _proto = PageViewIndicator.prototype;

        _proto.onLoad = function onLoad() {
          this._updateLayout();
        };

        _proto.setPageView = function setPageView(target) {
          this._pageView = target;

          this._refresh();
        };

        _proto._updateLayout = function _updateLayout() {
          this._layout = this.getComponent(Layout);

          if (!this._layout) {
            this._layout = this.addComponent(Layout);
          }

          var layout = this._layout;

          if (this.direction === Direction$2.HORIZONTAL) {
            layout.type = Layout.Type.HORIZONTAL;
            layout.spacingX = this.spacing;
          } else if (this.direction === Direction$2.VERTICAL) {
            layout.type = Layout.Type.VERTICAL;
            layout.spacingY = this.spacing;
          }

          layout.resizeMode = Layout.ResizeMode.CONTAINER;
        };

        _proto._createIndicator = function _createIndicator() {
          var node = new Node();
          node.layer = this.node.layer;
          var sprite = node.addComponent(Sprite);
          sprite.spriteFrame = this.spriteFrame;
          sprite.sizeMode = Sprite.SizeMode.CUSTOM;
          node.parent = this.node;

          node._uiProps.uiTransformComp.setContentSize(this._cellSize);

          return node;
        };

        _proto._changedState = function _changedState() {
          var indicators = this._indicators;

          if (indicators.length === 0 || !this._pageView) {
            return;
          }

          var idx = this._pageView.curPageIdx;

          if (idx >= indicators.length) {
            return;
          }

          for (var i = 0; i < indicators.length; ++i) {
            var node = indicators[i];

            if (!node._uiProps.uiComp) {
              continue;
            }

            var uiComp = node._uiProps.uiComp;

            _color$1.set(uiComp.color);

            _color$1.a = 255 / 2;
            uiComp.color = _color$1;
          }

          if (indicators[idx]._uiProps.uiComp) {
            var comp = indicators[idx]._uiProps.uiComp;

            _color$1.set(comp.color);

            _color$1.a = 255;
            comp.color = _color$1;
          }
        };

        _proto._refresh = function _refresh() {
          if (!this._pageView) {
            return;
          }

          var indicators = this._indicators;

          var pages = this._pageView.getPages();

          if (pages.length === indicators.length) {
            return;
          }

          var i = 0;

          if (pages.length > indicators.length) {
            for (i = 0; i < pages.length; ++i) {
              if (!indicators[i]) {
                indicators[i] = this._createIndicator();
              }
            }
          } else {
            var count = indicators.length - pages.length;

            for (i = count; i > 0; --i) {
              var node = indicators[i - 1];
              this.node.removeChild(node);
              indicators.splice(i - 1, 1);
            }
          }

          if (this._layout && this._layout.enabledInHierarchy) {
            this._layout.updateLayout();
          }

          this._changedState();
        };

        _createClass(PageViewIndicator, [{
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value) {
            if (this._spriteFrame === value) {
              return;
            }

            this._spriteFrame = value;
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) {
              return;
            }

            this._direction = value;
          }
        }, {
          key: "cellSize",
          get: function get() {
            return this._cellSize;
          },
          set: function set(value) {
            if (this._cellSize === value) {
              return;
            }

            this._cellSize = value;
          }
        }]);

        return PageViewIndicator;
      }(Component), _class3$q.Direction = Direction$2, _temp$1p), (_applyDecoratedDescriptor(_class2$1m.prototype, "spriteFrame", [_dec5$Z, _dec6$T], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "spriteFrame"), _class2$1m.prototype), _applyDecoratedDescriptor(_class2$1m.prototype, "direction", [_dec7$P, _dec8$J], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "direction"), _class2$1m.prototype), _applyDecoratedDescriptor(_class2$1m.prototype, "cellSize", [_dec9$E, _dec10$B], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "cellSize"), _class2$1m.prototype), _descriptor$1i = _applyDecoratedDescriptor(_class2$1m.prototype, "spacing", [serializable, _dec11$z], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$18 = _applyDecoratedDescriptor(_class2$1m.prototype, "_spriteFrame", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$V = _applyDecoratedDescriptor(_class2$1m.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Direction$2.HORIZONTAL;
        }
      }), _descriptor4$K = _applyDecoratedDescriptor(_class2$1m.prototype, "_cellSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(20, 20);
        }
      })), _class2$1m)) || _class$1w) || _class$1w) || _class$1w) || _class$1w));
      legacyCC.PageViewIndicator = PageViewIndicator;

      var _dec$1w, _dec2$1c, _dec3$17, _dec4$12, _dec5$_, _dec6$U, _dec7$Q, _dec8$K, _dec9$F, _dec10$C, _dec11$A, _dec12$y, _dec13$v, _dec14$r, _dec15$r, _dec16$p, _dec17$o, _dec18$n, _dec19$m, _dec20$m, _dec21$m, _dec22$k, _dec23$j, _dec24$i, _dec25$h, _dec26$h, _dec27$h, _class$1x, _class2$1n, _descriptor$1j, _descriptor2$19, _descriptor3$W, _descriptor4$L, _descriptor5$C, _descriptor6$w, _descriptor7$q, _descriptor8$o, _descriptor9$l, _descriptor10$i, _descriptor11$f, _descriptor12$e, _class3$r, _temp$1q;

      var _tempVec2$2 = new Vec2();

      var SizeMode$1;

      (function (SizeMode) {
        SizeMode[SizeMode["Unified"] = 0] = "Unified";
        SizeMode[SizeMode["Free"] = 1] = "Free";
      })(SizeMode$1 || (SizeMode$1 = {}));

      ccenum(SizeMode$1);
      var Direction$3;

      (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
      })(Direction$3 || (Direction$3 = {}));

      ccenum(Direction$3);
      var EventType$6;

      (function (EventType) {
        EventType["PAGE_TURNING"] = "page-turning";
      })(EventType$6 || (EventType$6 = {}));

      var PageView = function (v) { return exports({ PageView: v, PageViewComponent: v }), v; }((_dec$1w = ccclass('cc.PageView'), _dec2$1c = help(), _dec3$17 = executionOrder(110), _dec4$12 = menu(), _dec5$_ = type(SizeMode$1), _dec6$U = tooltip(), _dec7$Q = type(Direction$3), _dec8$K = tooltip(), _dec9$F = range(), _dec10$C = tooltip(), _dec11$A = range(), _dec12$y = tooltip(), _dec13$v = type(PageViewIndicator), _dec14$r = tooltip(), _dec15$r = tooltip(), _dec16$p = type(ScrollBar), _dec17$o = visible(), _dec18$n = type(ScrollBar), _dec19$m = visible(), _dec20$m = visible(), _dec21$m = visible(), _dec22$k = visible(), _dec23$j = type([EventHandler]), _dec24$i = visible(), _dec25$h = tooltip(), _dec26$h = type([EventHandler]), _dec27$h = tooltip(), _dec$1w(_class$1x = _dec2$1c(_class$1x = _dec3$17(_class$1x = _dec4$12(_class$1x = (_class2$1n = (_temp$1q = _class3$r = function (_ScrollView) {
        _inheritsLoose(PageView, _ScrollView);

        function PageView() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ScrollView.call.apply(_ScrollView, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "autoPageTurningThreshold", _descriptor$1j, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "horizontal", _descriptor2$19, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "vertical", _descriptor3$W, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor4$L, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "scrollEvents", _descriptor5$C, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "pageTurningSpeed", _descriptor6$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "pageEvents", _descriptor7$q, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_sizeMode", _descriptor8$o, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor9$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_scrollThreshold", _descriptor10$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pageTurningEventTiming", _descriptor11$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_indicator", _descriptor12$e, _assertThisInitialized(_this));

          _this._curPageIdx = 0;
          _this._lastPageIdx = 0;
          _this._pages = [];
          _this._initContentPos = new Vec3();
          _this._scrollCenterOffsetX = [];
          _this._scrollCenterOffsetY = [];
          _this._touchBeganPosition = new Vec2();
          _this._touchEndPosition = new Vec2();
          return _this;
        }

        var _proto = PageView.prototype;

        _proto.onEnable = function onEnable() {
          _ScrollView.prototype.onEnable.call(this);

          this.node.on(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

          {
            this.node.on(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
          }
        };

        _proto.onDisable = function onDisable() {
          _ScrollView.prototype.onDisable.call(this);

          this.node.off(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

          {
            this.node.off(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
          }
        };

        _proto.onLoad = function onLoad() {
          this._initPages();

          if (this.indicator) {
            this.indicator.setPageView(this);
          }
        };

        _proto.getCurrentPageIndex = function getCurrentPageIndex() {
          return this._curPageIdx;
        };

        _proto.setCurrentPageIndex = function setCurrentPageIndex(index) {
          this.scrollToPage(index, 1);
        };

        _proto.getPages = function getPages() {
          return this._pages;
        };

        _proto.addPage = function addPage(page) {
          if (!page || this._pages.indexOf(page) !== -1 || !this.content) {
            return;
          }

          if (!page._uiProps.uiTransformComp) {
            logID(4301);
            return;
          }

          this.content.addChild(page);

          this._pages.push(page);

          this._updatePageView();
        };

        _proto.insertPage = function insertPage(page, index) {
          if (index < 0 || !page || this._pages.indexOf(page) !== -1 || !this.content) {
            return;
          }

          var pageCount = this._pages.length;

          if (index >= pageCount) {
            this.addPage(page);
          } else {
            if (!page._uiProps.uiTransformComp) {
              logID(4301);
              return;
            }

            this._pages.splice(index, 0, page);

            this.content.insertChild(page, index);

            this._updatePageView();
          }
        };

        _proto.removePage = function removePage(page) {
          if (!page || !this.content) {
            return;
          }

          var index = this._pages.indexOf(page);

          if (index === -1) {
            warnID(4300, page.name);
            return;
          }

          this.removePageAtIndex(index);
        };

        _proto.removePageAtIndex = function removePageAtIndex(index) {
          var pageList = this._pages;

          if (index < 0 || index >= pageList.length) {
            return;
          }

          var page = pageList[index];

          if (!page || !this.content) {
            return;
          }

          this.content.removeChild(page);
          pageList.splice(index, 1);

          this._updatePageView();
        };

        _proto.removeAllPages = function removeAllPages() {
          if (!this.content) {
            return;
          }

          var locPages = this._pages;

          for (var i = 0, len = locPages.length; i < len; i++) {
            this.content.removeChild(locPages[i]);
          }

          this._pages.length = 0;

          this._updatePageView();
        };

        _proto.scrollToPage = function scrollToPage(idx, timeInSecond) {
          if (timeInSecond === void 0) {
            timeInSecond = 0.3;
          }

          if (idx < 0 || idx >= this._pages.length) {
            return;
          }

          this._curPageIdx = idx;
          this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);

          if (this.indicator) {
            this.indicator._changedState();
          }
        };

        _proto.getScrollEndedEventTiming = function getScrollEndedEventTiming() {
          return this.pageTurningEventTiming;
        };

        _proto._updatePageView = function _updatePageView() {
          if (!this.content) {
            return;
          }

          var layout = this.content.getComponent(Layout);

          if (layout && layout.enabled) {
            layout.updateLayout();
          }

          var pageCount = this._pages.length;

          if (this._curPageIdx >= pageCount) {
            this._curPageIdx = pageCount === 0 ? 0 : pageCount - 1;
            this._lastPageIdx = this._curPageIdx;
          }

          var contentPos = this._initContentPos;

          for (var i = 0; i < pageCount; ++i) {
            var page = this._pages[i];
            var pos = page.position;

            if (this.direction === Direction$3.Horizontal) {
              this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x);
            } else {
              this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
            }
          }

          if (this.indicator) {
            this.indicator._refresh();
          }
        };

        _proto._updateAllPagesSize = function _updateAllPagesSize() {
          var viewTrans = this.view;

          if (!this.content || !viewTrans) {
            return;
          }

          if (this._sizeMode !== SizeMode$1.Unified) {
            return;
          }

          var locPages =  this._pages;
          var selfSize = viewTrans.contentSize;

          for (var i = 0, len = locPages.length; i < len; i++) {
            locPages[i]._uiProps.uiTransformComp.setContentSize(selfSize);
          }
        };

        _proto._handleReleaseLogic = function _handleReleaseLogic() {
          this._autoScrollToPage();

          if (this._scrolling) {
            this._scrolling = false;

            if (!this._autoScrolling) {
              this._dispatchEvent(PageView.EventType.SCROLL_ENDED);
            }
          }
        };

        _proto._onTouchBegan = function _onTouchBegan(event, captureListeners) {
          event.touch.getUILocation(_tempVec2$2);
          Vec2.set(this._touchBeganPosition, _tempVec2$2.x, _tempVec2$2.y);

          _ScrollView.prototype._onTouchBegan.call(this, event, captureListeners);
        };

        _proto._onTouchMoved = function _onTouchMoved(event, captureListeners) {
          _ScrollView.prototype._onTouchMoved.call(this, event, captureListeners);
        };

        _proto._onTouchEnded = function _onTouchEnded(event, captureListeners) {
          event.touch.getUILocation(_tempVec2$2);
          Vec2.set(this._touchEndPosition, _tempVec2$2.x, _tempVec2$2.y);

          _ScrollView.prototype._onTouchEnded.call(this, event, captureListeners);
        };

        _proto._onTouchCancelled = function _onTouchCancelled(event, captureListeners) {
          event.touch.getUILocation(_tempVec2$2);
          Vec2.set(this._touchEndPosition, _tempVec2$2.x, _tempVec2$2.y);

          _ScrollView.prototype._onTouchCancelled.call(this, event, captureListeners);
        };

        _proto._onMouseWheel = function _onMouseWheel() {};

        _proto._syncScrollDirection = function _syncScrollDirection() {
          this.horizontal = this.direction === Direction$3.Horizontal;
          this.vertical = this.direction === Direction$3.Vertical;
        };

        _proto._syncSizeMode = function _syncSizeMode() {
          var viewTrans = this.view;

          if (!this.content || !viewTrans) {
            return;
          }

          var layout = this.content.getComponent(Layout);

          if (layout) {
            if (this._sizeMode === SizeMode$1.Free && this._pages.length > 0) {
              var firstPageTrans = this._pages[0]._uiProps.uiTransformComp;
              var lastPageTrans = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;

              if (this.direction === Direction$3.Horizontal) {
                layout.paddingLeft = (viewTrans.width - firstPageTrans.width) / 2;
                layout.paddingRight = (viewTrans.width - lastPageTrans.width) / 2;
              } else if (this.direction === Direction$3.Vertical) {
                layout.paddingTop = (viewTrans.height - firstPageTrans.height) / 2;
                layout.paddingBottom = (viewTrans.height - lastPageTrans.height) / 2;
              }
            }

            layout.updateLayout();
          }
        };

        _proto._initPages = function _initPages() {
          if (!this.content) {
            return;
          }

          this._initContentPos = this.content.position;
          var children = this.content.children;

          for (var i = 0; i < children.length; ++i) {
            var page = children[i];

            if (this._pages.indexOf(page) >= 0) {
              continue;
            }

            this._pages.push(page);
          }

          this._syncScrollDirection();

          this._syncSizeMode();

          this._updatePageView();
        };

        _proto._dispatchPageTurningEvent = function _dispatchPageTurningEvent() {
          if (this._lastPageIdx === this._curPageIdx) {
            return;
          }

          this._lastPageIdx = this._curPageIdx;
          EventHandler.emitEvents(this.pageEvents, this, EventType$6.PAGE_TURNING);
          this.node.emit(EventType$6.PAGE_TURNING, this);
        };

        _proto._isQuicklyScrollable = function _isQuicklyScrollable(touchMoveVelocity) {
          if (this.direction === Direction$3.Horizontal) {
            if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) {
              return true;
            }
          } else if (this.direction === Direction$3.Vertical) {
            if (Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) {
              return true;
            }
          }

          return false;
        };

        _proto._moveOffsetValue = function _moveOffsetValue(idx) {
          var offset = new Vec2();

          if (this._sizeMode === SizeMode$1.Free) {
            if (this.direction === Direction$3.Horizontal) {
              offset.x = this._scrollCenterOffsetX[idx];
            } else if (this.direction === Direction$3.Vertical) {
              offset.y = this._scrollCenterOffsetY[idx];
            }
          } else {
            var viewTrans = this.view;

            if (!viewTrans) {
              return offset;
            }

            if (this.direction === Direction$3.Horizontal) {
              offset.x = idx * viewTrans.width;
            } else if (this.direction === Direction$3.Vertical) {
              offset.y = idx * viewTrans.height;
            }
          }

          return offset;
        };

        _proto._getDragDirection = function _getDragDirection(moveOffset) {
          if (this._direction === Direction$3.Horizontal) {
            if (moveOffset.x === 0) {
              return 0;
            }

            return moveOffset.x > 0 ? 1 : -1;
          } else {
            if (moveOffset.y === 0) {
              return 0;
            }

            return moveOffset.y < 0 ? 1 : -1;
          }
        };

        _proto._isScrollable = function _isScrollable(offset, index, nextIndex) {
          if (this._sizeMode === SizeMode$1.Free) {
            var curPageCenter = 0;
            var nextPageCenter = 0;

            if (this.direction === Direction$3.Horizontal) {
              curPageCenter = this._scrollCenterOffsetX[index];
              nextPageCenter = this._scrollCenterOffsetX[nextIndex];
              return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            } else if (this.direction === Direction$3.Vertical) {
              curPageCenter = this._scrollCenterOffsetY[index];
              nextPageCenter = this._scrollCenterOffsetY[nextIndex];
              return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            }
          } else {
            var viewTrans = this.view;

            if (!viewTrans) {
              return false;
            }

            if (this.direction === Direction$3.Horizontal) {
              return Math.abs(offset.x) >= viewTrans.width * this.scrollThreshold;
            } else if (this.direction === Direction$3.Vertical) {
              return Math.abs(offset.y) >= viewTrans.height * this.scrollThreshold;
            }
          }

          return false;
        };

        _proto._autoScrollToPage = function _autoScrollToPage() {
          var bounceBackStarted = this._startBounceBackIfNeeded();

          if (bounceBackStarted) {
            var bounceBackAmount = this._getHowMuchOutOfBoundary();

            this._clampDelta(bounceBackAmount);

            if (bounceBackAmount.x > 0 || bounceBackAmount.y < 0) {
              this._curPageIdx = this._pages.length === 0 ? 0 : this._pages.length - 1;
            }

            if (bounceBackAmount.x < 0 || bounceBackAmount.y > 0) {
              this._curPageIdx = 0;
            }

            if (this.indicator) {
              this.indicator._changedState();
            }
          } else {
            var moveOffset = new Vec2();
            Vec2.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition);
            var index = this._curPageIdx;

            var nextIndex = index + this._getDragDirection(moveOffset);

            var timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);

            if (nextIndex < this._pages.length) {
              if (this._isScrollable(moveOffset, index, nextIndex)) {
                this.scrollToPage(nextIndex, timeInSecond);
                return;
              } else {
                var touchMoveVelocity = this._calculateTouchMoveVelocity();

                if (this._isQuicklyScrollable(touchMoveVelocity)) {
                  this.scrollToPage(nextIndex, timeInSecond);
                  return;
                }
              }
            }

            this.scrollToPage(index, timeInSecond);
          }
        };

        _createClass(PageView, [{
          key: "sizeMode",
          get: function get() {
            return this._sizeMode;
          },
          set: function set(value) {
            if (this._sizeMode === value) {
              return;
            }

            this._sizeMode = value;

            this._syncSizeMode();
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) {
              return;
            }

            this._direction = value;

            this._syncScrollDirection();
          }
        }, {
          key: "scrollThreshold",
          get: function get() {
            return this._scrollThreshold;
          },
          set: function set(value) {
            if (this._scrollThreshold === value) {
              return;
            }

            this._scrollThreshold = value;
          }
        }, {
          key: "pageTurningEventTiming",
          get: function get() {
            return this._pageTurningEventTiming;
          },
          set: function set(value) {
            if (this._pageTurningEventTiming === value) {
              return;
            }

            this._pageTurningEventTiming = value;
          }
        }, {
          key: "indicator",
          get: function get() {
            return this._indicator;
          },
          set: function set(value) {
            if (this._indicator === value) {
              return;
            }

            this._indicator = value;

            if (this.indicator) {
              this.indicator.setPageView(this);
            }
          }
        }, {
          key: "curPageIdx",
          get: function get() {
            return this._curPageIdx;
          }
        }, {
          key: "verticalScrollBar",
          get: function get() {
            return _ScrollView.prototype.verticalScrollBar;
          },
          set: function set(value) {
            this.verticalScrollBar = value;
          }
        }, {
          key: "horizontalScrollBar",
          get: function get() {
            return _ScrollView.prototype.horizontalScrollBar;
          },
          set: function set(value) {
            this.horizontalScrollBar = value;
          }
        }]);

        return PageView;
      }(ScrollView), _class3$r.SizeMode = SizeMode$1, _class3$r.Direction = Direction$3, _class3$r.EventType = extendsEnum(EventType$6, EventType$4), _temp$1q), (_applyDecoratedDescriptor(_class2$1n.prototype, "sizeMode", [_dec5$_, _dec6$U], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "sizeMode"), _class2$1n.prototype), _applyDecoratedDescriptor(_class2$1n.prototype, "direction", [_dec7$Q, _dec8$K], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "direction"), _class2$1n.prototype), _applyDecoratedDescriptor(_class2$1n.prototype, "scrollThreshold", [slide, _dec9$F, _dec10$C], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "scrollThreshold"), _class2$1n.prototype), _applyDecoratedDescriptor(_class2$1n.prototype, "pageTurningEventTiming", [slide, _dec11$A, _dec12$y], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "pageTurningEventTiming"), _class2$1n.prototype), _applyDecoratedDescriptor(_class2$1n.prototype, "indicator", [_dec13$v, _dec14$r], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "indicator"), _class2$1n.prototype), _descriptor$1j = _applyDecoratedDescriptor(_class2$1n.prototype, "autoPageTurningThreshold", [serializable, _dec15$r], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _applyDecoratedDescriptor(_class2$1n.prototype, "verticalScrollBar", [_dec16$p, override, _dec17$o], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "verticalScrollBar"), _class2$1n.prototype), _applyDecoratedDescriptor(_class2$1n.prototype, "horizontalScrollBar", [_dec18$n, override, _dec19$m], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "horizontalScrollBar"), _class2$1n.prototype), _descriptor2$19 = _applyDecoratedDescriptor(_class2$1n.prototype, "horizontal", [override, serializable, _dec20$m], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor3$W = _applyDecoratedDescriptor(_class2$1n.prototype, "vertical", [override, serializable, _dec21$m], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor4$L = _applyDecoratedDescriptor(_class2$1n.prototype, "cancelInnerEvents", [override, serializable, _dec22$k], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor5$C = _applyDecoratedDescriptor(_class2$1n.prototype, "scrollEvents", [_dec23$j, serializable, override, _dec24$i], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor6$w = _applyDecoratedDescriptor(_class2$1n.prototype, "pageTurningSpeed", [serializable, editable, _dec25$h], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.3;
        }
      }), _descriptor7$q = _applyDecoratedDescriptor(_class2$1n.prototype, "pageEvents", [_dec26$h, serializable, _dec27$h], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor8$o = _applyDecoratedDescriptor(_class2$1n.prototype, "_sizeMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return SizeMode$1.Unified;
        }
      }), _descriptor9$l = _applyDecoratedDescriptor(_class2$1n.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Direction$3.Horizontal;
        }
      }), _descriptor10$i = _applyDecoratedDescriptor(_class2$1n.prototype, "_scrollThreshold", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor11$f = _applyDecoratedDescriptor(_class2$1n.prototype, "_pageTurningEventTiming", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor12$e = _applyDecoratedDescriptor(_class2$1n.prototype, "_indicator", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$1n)) || _class$1x) || _class$1x) || _class$1x) || _class$1x));
      legacyCC.PageView = PageView;

      var _tempPos$1 = new Vec3();

      var _defaultAnchor = new Vec2();

      var tInverseTranslate = new Vec2();
      var tInverseScale = new Vec2(1, 1);

      var _tempVec2_1$1 = new Vec2();

      var _tempVec2_2 = new Vec2();

      function align(node, widget) {
        if (widget._hadAlignOnce) return;

        if ( widget.alignMode === AlignMode.ONCE) {
          widget._hadAlignOnce = true;
        }

        var hasTarget = widget.target;
        var target;
        var inverseTranslate = tInverseTranslate;
        var inverseScale = tInverseScale;

        if (hasTarget) {
          target = hasTarget;
          computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
        } else {
          target = node.parent;
        }

        var targetSize = getReadonlyNodeSize(target);
        var useGlobal = target instanceof Scene || !target.getComponent(UITransform);
        var targetAnchor = useGlobal ? _defaultAnchor : target.getComponent(UITransform).anchorPoint;
        var isRoot = useGlobal;
        node.getPosition(_tempPos$1);
        var uiTrans = node._uiProps.uiTransformComp;
        var x = _tempPos$1.x;
        var y = _tempPos$1.y;
        var anchor = uiTrans.anchorPoint;
        var scale = node.getScale();

        if (widget.alignFlags & AlignFlags.HORIZONTAL) {
          var localLeft = 0;
          var localRight = 0;
          var targetWidth = targetSize.width;

          if (isRoot) {
            localLeft = visibleRect.left.x;
            localRight = visibleRect.right.x;
          } else {
            localLeft = -targetAnchor.x * targetWidth;
            localRight = localLeft + targetWidth;
          }

          localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth;
          localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth;

          if (hasTarget) {
            localLeft += inverseTranslate.x;
            localLeft *= inverseScale.x;
            localRight += inverseTranslate.x;
            localRight *= inverseScale.x;
          }

          var width = 0;
          var anchorX = anchor.x;
          var scaleX = scale.x;

          if (scaleX < 0) {
            anchorX = 1.0 - anchorX;
            scaleX = -scaleX;
          }

          if (widget.isStretchWidth) {
            width = localRight - localLeft;

            if (scaleX !== 0) {
              uiTrans.width = width / scaleX;
            }

            x = localLeft + anchorX * width;
          } else {
            width = uiTrans.width * scaleX;

            if (widget.isAlignHorizontalCenter) {
              var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth;
              var targetCenter = (0.5 - targetAnchor.x) * targetSize.width;

              if (hasTarget) {
                localHorizontalCenter *= inverseScale.x;
                targetCenter += inverseTranslate.x;
                targetCenter *= inverseScale.x;
              }

              x = targetCenter + (anchorX - 0.5) * width + localHorizontalCenter;
            } else if (widget.isAlignLeft) {
              x = localLeft + anchorX * width;
            } else {
              x = localRight + (anchorX - 1) * width;
            }
          }

          widget._lastSize.width = width;
        }

        if (widget.alignFlags & AlignFlags.VERTICAL) {
          var localTop = 0;
          var localBottom = 0;
          var targetHeight = targetSize.height;

          if (isRoot) {
            localBottom = visibleRect.bottom.y;
            localTop = visibleRect.top.y;
          } else {
            localBottom = -targetAnchor.y * targetHeight;
            localTop = localBottom + targetHeight;
          }

          localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight;
          localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight;

          if (hasTarget) {
            localBottom += inverseTranslate.y;
            localBottom *= inverseScale.y;
            localTop += inverseTranslate.y;
            localTop *= inverseScale.y;
          }

          var height = 0;
          var anchorY = anchor.y;
          var scaleY = scale.y;

          if (scaleY < 0) {
            anchorY = 1.0 - anchorY;
            scaleY = -scaleY;
          }

          if (widget.isStretchHeight) {
            height = localTop - localBottom;

            if (scaleY !== 0) {
              uiTrans.height = height / scaleY;
            }

            y = localBottom + anchorY * height;
          } else {
            height = uiTrans.height * scaleY;

            if (widget.isAlignVerticalCenter) {
              var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight;
              var targetMiddle = (0.5 - targetAnchor.y) * targetSize.height;

              if (hasTarget) {
                localVerticalCenter *= inverseScale.y;
                targetMiddle += inverseTranslate.y;
                targetMiddle *= inverseScale.y;
              }

              y = targetMiddle + (anchorY - 0.5) * height + localVerticalCenter;
            } else if (widget.isAlignBottom) {
              y = localBottom + anchorY * height;
            } else {
              y = localTop + (anchorY - 1) * height;
            }
          }

          widget._lastSize.height = height;
        }

        node.setPosition(x, y, _tempPos$1.z);
        Vec3.set(widget._lastPos, x, y, _tempPos$1.z);
      }

      function visitNode(node) {
        var widget = node.getComponent(Widget);

        if (widget && widget.enabled) {

          if (!legacyCC.isValid(node, true)) {
            return;
          }

          activeWidgets.push(widget);
        }

        var children = node.children;

        for (var _iterator = _createForOfIteratorHelperLoose(children), _step; !(_step = _iterator()).done;) {
          var child = _step.value;

          if (child.active) {
            visitNode(child);
          }
        }
      }

      function refreshScene() {
        var scene = director.getScene();

        if (scene) {
          widgetManager.isAligning = true;

          if (widgetManager._nodesOrderDirty) {
            activeWidgets.length = 0;
            visitNode(scene);
            widgetManager._nodesOrderDirty = false;
          }
          var widget = null;
          var iterator = widgetManager._activeWidgetsIterator;

          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];

            if (widget._dirty) {
              align(widget.node, widget);
              widget._dirty = false;
            }
          }

          widgetManager.isAligning = false;
        }
      }

      var activeWidgets = [];

      function updateAlignment(node) {
        var parent = node.parent;

        if (parent && Node.isNode(parent)) {
          updateAlignment(parent);
        }

        var widget = node.getComponent(Widget);

        if (widget && parent) {
          align(node, widget);
        }
      }

      var widgetManager = exports('widgetManager', legacyCC._widgetManager = {
        isAligning: false,
        _nodesOrderDirty: false,
        _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
        animationState:  null,
        init: function init() {
          director.on(Director.EVENT_AFTER_SCENE_LAUNCH, refreshScene);
          director.on(Director.EVENT_AFTER_UPDATE, refreshScene);
          View.instance.on('design-resolution-changed', this.onResized, this);

          {
            var thisOnResized = this.onResized.bind(this);
            View.instance.on('canvas-resize', thisOnResized);
            screenAdapter.on('orientation-change', thisOnResized);
          }
        },
        add: function add(widget) {
          this._nodesOrderDirty = true;
        },
        remove: function remove(widget) {
          this._activeWidgetsIterator.remove(widget);
        },
        onResized: function onResized() {
          var scene = director.getScene();

          if (scene) {
            this.refreshWidgetOnResized(scene);
          }
        },
        refreshWidgetOnResized: function refreshWidgetOnResized(node) {
          var widget = Node.isNode(node) && node.getComponent(Widget);

          if (widget && widget.enabled && (widget.alignMode === AlignMode.ON_WINDOW_RESIZE || widget.alignMode === AlignMode.ALWAYS)) {
            widget.setDirty();
          }

          var children = node.children;

          for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {
            var child = _step2.value;
            this.refreshWidgetOnResized(child);
          }
        },
        updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
          function i(t, c) {
            return Math.abs(t - c) > 1e-10 ? c : t;
          }

          var widgetNode = widget.node;
          var widgetParent = widgetNode.parent;

          if (widgetParent) {
            var zero = _tempVec2_1$1;
            zero.set(0, 0);
            var one = _tempVec2_2;
            one.set(1, 1);

            if (widget.target) {
              widgetParent = widget.target;
              computeInverseTransForTarget(widgetNode, widgetParent, zero, one);
            }

            if (!e) {
              return;
            }

            var parentTrans = widgetParent._uiProps && widgetParent._uiProps.uiTransformComp;
            var parentAP = parentTrans ? parentTrans.anchorPoint : _defaultAnchor;
            var trans = widgetNode._uiProps.uiTransformComp;
            var matchSize = getReadonlyNodeSize(widgetParent);
            var myAP = trans.anchorPoint;
            var pos = widgetNode.getPosition();
            var alignFlags = AlignFlags;
            var widgetNodeScale = widgetNode.getScale();
            var temp = 0;

            if (e & alignFlags.LEFT) {
              var l = -parentAP.x * matchSize.width;
              l += zero.x;
              l *= one.x;
              temp = pos.x - myAP.x * trans.width * Math.abs(widgetNodeScale.x) - l;

              if (!widget.isAbsoluteLeft) {
                temp /= matchSize.width;
              }

              temp /= one.x;
              widget.left = i(widget.left, temp);
            }

            if (e & alignFlags.RIGHT) {
              var r = (1 - parentAP.x) * matchSize.width;
              r += zero.x;
              temp = (r *= one.x) - (pos.x + (1 - myAP.x) * trans.width * Math.abs(widgetNodeScale.x));

              if (!widget.isAbsoluteRight) {
                temp /= matchSize.width;
              }

              temp /= one.x;
              widget.right = i(widget.right, temp);
            }

            if (e & alignFlags.TOP) {
              var t = (1 - parentAP.y) * matchSize.height;
              t += zero.y;
              temp = (t *= one.y) - (pos.y + (1 - myAP.y) * trans.height * Math.abs(widgetNodeScale.y));

              if (!widget.isAbsoluteTop) {
                temp /= matchSize.height;
              }

              temp /= one.y;
              widget.top = i(widget.top, temp);
            }

            if (e & alignFlags.BOT) {
              var b = -parentAP.y * matchSize.height;
              b += zero.y;
              b *= one.y;
              temp = pos.y - myAP.y * trans.height * Math.abs(widgetNodeScale.y) - b;

              if (!widget.isAbsoluteBottom) {
                temp /= matchSize.height;
              }

              temp /= one.y;
              widget.bottom = i(widget.bottom, temp);
            }
          }
        },
        updateAlignment: updateAlignment,
        AlignMode: AlignMode,
        AlignFlags: AlignFlags
      });
      director.on(Director.EVENT_INIT, function () {
        widgetManager.init();
      });

      var _dec$1x, _dec2$1d, _dec3$18, _dec4$13, _dec5$$, _class$1y;
      var SafeArea = function (v) { return exports({ SafeArea: v, SafeAreaComponent: v }), v; }((_dec$1x = ccclass('cc.SafeArea'), _dec2$1d = help(), _dec3$18 = executionOrder(110), _dec4$13 = menu(), _dec5$$ = requireComponent(Widget), _dec$1x(_class$1y = _dec2$1d(_class$1y = _dec3$18(_class$1y = executeInEditMode(_class$1y = _dec4$13(_class$1y = _dec5$$(_class$1y = function (_Component) {
        _inheritsLoose(SafeArea, _Component);

        function SafeArea() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = SafeArea.prototype;

        _proto.onEnable = function onEnable() {
          this.updateArea();
          screenAdapter.on('window-resize', this.updateArea, this);
          screenAdapter.on('orientation-change', this.updateArea, this);
        };

        _proto.onDisable = function onDisable() {
          screenAdapter.off('window-resize', this.updateArea, this);
          screenAdapter.off('orientation-change', this.updateArea, this);
        };

        _proto.updateArea = function updateArea() {
          var widget = this.node.getComponent(Widget);
          var uiTransComp = this.node.getComponent(UITransform);

          if (!widget || !uiTransComp) {
            return;
          }

          widget.updateAlignment();
          var lastPos = this.node.position.clone();
          var lastAnchorPoint = uiTransComp.anchorPoint.clone();
          widget.isAlignTop = widget.isAlignBottom = widget.isAlignLeft = widget.isAlignRight = true;
          var visibleSize = view.getVisibleSize();
          var screenWidth = visibleSize.width;
          var screenHeight = visibleSize.height;
          var safeArea = sys.getSafeAreaRect();
          widget.top = screenHeight - safeArea.y - safeArea.height;
          widget.bottom = safeArea.y;
          widget.left = safeArea.x;
          widget.right = screenWidth - safeArea.x - safeArea.width;
          widget.updateAlignment();
          var curPos = this.node.position.clone();
          var anchorX = lastAnchorPoint.x - (curPos.x - lastPos.x) / uiTransComp.width;
          var anchorY = lastAnchorPoint.y - (curPos.y - lastPos.y) / uiTransComp.height;
          uiTransComp.setAnchorPoint(anchorX, anchorY);
          widgetManager.add(widget);
        };

        return SafeArea;
      }(Component)) || _class$1y) || _class$1y) || _class$1y) || _class$1y) || _class$1y) || _class$1y));
      legacyCC.SafeArea = SafeArea;

      var _dec$1y, _dec2$1e, _dec3$19, _dec4$14, _dec5$10, _dec6$V, _dec7$R, _dec8$L, _dec9$G, _dec10$D, _dec11$B, _dec12$z, _class$1z, _class2$1o, _descriptor$1k, _descriptor2$1a, _descriptor3$X, _descriptor4$M, _descriptor5$D, _temp$1r;
      var UICoordinateTracker = function (v) { return exports({ UICoordinateTracker: v, UICoordinateTrackerComponent: v }), v; }((_dec$1y = ccclass('cc.UICoordinateTracker'), _dec2$1e = help(), _dec3$19 = menu(), _dec4$14 = executionOrder(110), _dec5$10 = type(Node), _dec6$V = tooltip(), _dec7$R = type(Camera$1), _dec8$L = tooltip(), _dec9$G = tooltip(), _dec10$D = tooltip(), _dec11$B = type([EventHandler]), _dec12$z = tooltip(), _dec$1y(_class$1z = _dec2$1e(_class$1z = _dec3$19(_class$1z = _dec4$14(_class$1z = (_class2$1o = (_temp$1r = function (_Component) {
        _inheritsLoose(UICoordinateTracker, _Component);

        function UICoordinateTracker() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "syncEvents", _descriptor$1k, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_target", _descriptor2$1a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_camera", _descriptor3$X, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_useScale", _descriptor4$M, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_distance", _descriptor5$D, _assertThisInitialized(_this));

          _this._transformPos = new Vec3();
          _this._viewPos = new Vec3();
          _this._canMove = true;
          _this._lastWPos = new Vec3();
          _this._lastCameraPos = new Vec3();
          return _this;
        }

        var _proto = UICoordinateTracker.prototype;

        _proto.onEnable = function onEnable() {
          this._checkCanMove();
        };

        _proto.update = function update() {
          var wPos = this.node.worldPosition;
          var camera = this._camera;

          if (!this._canMove || !camera || !camera.camera || this._lastWPos.equals(wPos) && this._lastCameraPos.equals(camera.node.worldPosition)) {
            return;
          }

          this._lastWPos.set(wPos);

          this._lastCameraPos.set(camera.node.worldPosition);

          camera.camera.update();
          camera.convertToUINode(wPos, this._target, this._transformPos);

          if (this._useScale) {
            Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera.camera.matView);
          }

          if (this.syncEvents.length > 0) {
            var data = this._distance / Math.abs(this._viewPos.z);
            EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
          }
        };

        _proto._checkCanMove = function _checkCanMove() {
          this._canMove = !!(this._camera && this._target);
        };

        _createClass(UICoordinateTracker, [{
          key: "target",
          get: function get() {
            return this._target;
          },
          set: function set(value) {
            if (this._target === value) {
              return;
            }

            this._target = value;

            this._checkCanMove();
          }
        }, {
          key: "camera",
          get: function get() {
            return this._camera;
          },
          set: function set(value) {
            if (this._camera === value) {
              return;
            }

            this._camera = value;

            this._checkCanMove();
          }
        }, {
          key: "useScale",
          get: function get() {
            return this._useScale;
          },
          set: function set(value) {
            if (this._useScale === value) {
              return;
            }

            this._useScale = value;
          }
        }, {
          key: "distance",
          get: function get() {
            return this._distance;
          },
          set: function set(value) {
            if (this._distance === value) {
              return;
            }

            this._distance = value;
          }
        }]);

        return UICoordinateTracker;
      }(Component), _temp$1r), (_applyDecoratedDescriptor(_class2$1o.prototype, "target", [_dec5$10, _dec6$V], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "target"), _class2$1o.prototype), _applyDecoratedDescriptor(_class2$1o.prototype, "camera", [_dec7$R, _dec8$L], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "camera"), _class2$1o.prototype), _applyDecoratedDescriptor(_class2$1o.prototype, "useScale", [_dec9$G], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "useScale"), _class2$1o.prototype), _applyDecoratedDescriptor(_class2$1o.prototype, "distance", [_dec10$D], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "distance"), _class2$1o.prototype), _descriptor$1k = _applyDecoratedDescriptor(_class2$1o.prototype, "syncEvents", [_dec11$B, serializable, _dec12$z], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$1a = _applyDecoratedDescriptor(_class2$1o.prototype, "_target", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$X = _applyDecoratedDescriptor(_class2$1o.prototype, "_camera", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4$M = _applyDecoratedDescriptor(_class2$1o.prototype, "_useScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor5$D = _applyDecoratedDescriptor(_class2$1o.prototype, "_distance", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      })), _class2$1o)) || _class$1z) || _class$1z) || _class$1z) || _class$1z));

      var _dec$1z, _dec2$1f, _dec3$1a, _class$1A;
      var BlockEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_END, NodeEventType.TOUCH_MOVE, NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_WHEEL];

      function stopPropagation(event) {
        event.propagationStopped = true;
      }

      var BlockInputEvents = function (v) { return exports({ BlockInputEvents: v, BlockInputEventsComponent: v }), v; }((_dec$1z = ccclass('cc.BlockInputEvents'), _dec2$1f = help(), _dec3$1a = menu(), _dec$1z(_class$1A = _dec2$1f(_class$1A = _dec3$1a(_class$1A = function (_Component) {
        _inheritsLoose(BlockInputEvents, _Component);

        function BlockInputEvents() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = BlockInputEvents.prototype;

        _proto.onEnable = function onEnable() {
          for (var i = 0; i < BlockEvents.length; i++) {
            this.node.on(BlockEvents[i], stopPropagation, this);
          }
        };

        _proto.onDisable = function onDisable() {
          for (var i = 0; i < BlockEvents.length; i++) {
            this.node.off(BlockEvents[i], stopPropagation, this);
          }
        };

        return BlockInputEvents;
      }(Component)) || _class$1A) || _class$1A) || _class$1A));

      var _dec$1A, _dec2$1g, _dec3$1b, _dec4$15, _dec5$11, _dec6$W, _dec7$S, _class$1B, _class2$1p, _descriptor$1l, _descriptor2$1b, _temp$1s;
      var SubContextView = exports('SubContextView', (_dec$1A = ccclass('cc.SubContextView'), _dec2$1g = help(), _dec3$1b = executionOrder(110), _dec4$15 = requireComponent(UITransform), _dec5$11 = menu(), _dec6$W = tooltip(), _dec7$S = tooltip(), _dec$1A(_class$1B = _dec2$1g(_class$1B = _dec3$1b(_class$1B = _dec4$15(_class$1B = _dec5$11(_class$1B = (_class2$1p = (_temp$1s = function (_Component) {
        _inheritsLoose(SubContextView, _Component);

        function SubContextView() {
          var _this;

          _this = _Component.call(this) || this;

          _initializerDefineProperty(_this, "_fps", _descriptor$1l, _assertThisInitialized(_this));

          _this._sprite = void 0;
          _this._imageAsset = void 0;
          _this._texture = void 0;
          _this._updatedTime = 0;
          _this._updateInterval = 0;
          _this._openDataContext = void 0;
          _this._content = void 0;

          _initializerDefineProperty(_this, "_designResolutionSize", _descriptor2$1b, _assertThisInitialized(_this));

          _this._content = new Node('content');
          _this._content.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
          _this._sprite = null;
          _this._imageAsset = new ImageAsset();
          _this._openDataContext = null;
          _this._updatedTime = performance.now();
          _this._texture = new Texture2D();
          return _this;
        }

        var _proto = SubContextView.prototype;

        _proto.onLoad = function onLoad() {
          if (minigame.getOpenDataContext) {
            this._updateInterval = 1000 / this._fps;
            this._openDataContext = minigame.getOpenDataContext();

            this._initSharedCanvas();

            this._initContentNode();

            this._updateSubContextView();

            this._updateContentLayer();
          } else {
            this.enabled = false;
          }
        };

        _proto.onEnable = function onEnable() {
          this._registerNodeEvent();
        };

        _proto.onDisable = function onDisable() {
          this._unregisterNodeEvent();
        };

        _proto._initSharedCanvas = function _initSharedCanvas() {
          if (this._openDataContext) {
            var sharedCanvas = this._openDataContext.canvas;
            var designWidth = this._designResolutionSize.width;
            var designHeight = this._designResolutionSize.height;

            sharedCanvas.width = designWidth;
            sharedCanvas.height = designHeight;
          }
        };

        _proto._initContentNode = function _initContentNode() {
          if (this._openDataContext) {
            var sharedCanvas = this._openDataContext.canvas;
            var image = this._imageAsset;
            image.reset(sharedCanvas);
            this._texture.image = image;

            this._texture.create(sharedCanvas.width, sharedCanvas.height);

            this._sprite = this._content.getComponent(Sprite);

            if (!this._sprite) {
              this._sprite = this._content.addComponent(Sprite);
            }

            if (this._sprite.spriteFrame) {
              this._sprite.spriteFrame.texture = this._texture;
            } else {
              var sp = new SpriteFrame();
              sp.texture = this._texture;
              this._sprite.spriteFrame = sp;
            }

            this._content.parent = this.node;
          }
        };

        _proto._updateSubContextView = function _updateSubContextView() {
          if (!this._openDataContext) {
            return;
          }

          var nodeTrans = this.node.getComponent(UITransform);

          var contentTrans = this._content.getComponent(UITransform);

          var scaleX = nodeTrans.width / contentTrans.width;
          var scaleY = nodeTrans.height / contentTrans.height;
          var scale = scaleX > scaleY ? scaleY : scaleX;
          contentTrans.width *= scale;
          contentTrans.height *= scale;
          var viewportRect = view.getViewportRect();
          var box = contentTrans.getBoundingBoxToWorld();
          var visibleSize = view.getVisibleSize();
          var dpr = screenAdapter.devicePixelRatio;
          var x = (viewportRect.width * (box.x / visibleSize.width) + viewportRect.x) / dpr;
          var y = (viewportRect.height * (box.y / visibleSize.height) + viewportRect.y) / dpr;
          var width = viewportRect.width * (box.width / visibleSize.width) / dpr;
          var height = viewportRect.height * (box.height / visibleSize.height) / dpr;

          this._openDataContext.postMessage({
            fromEngine: true,
            type: 'engine',
            event: 'viewport',
            x: x,
            y: y,
            width: width,
            height: height
          });
        };

        _proto._updateSubContextTexture = function _updateSubContextTexture() {
          var img = this._imageAsset;

          if (!img || !this._openDataContext) {
            return;
          }

          if (img.width <= 0 || img.height <= 0) {
            return;
          }

          var sharedCanvas = this._openDataContext.canvas;
          img.reset(sharedCanvas);

          if (sharedCanvas.width > img.width || sharedCanvas.height > img.height) {
            this._texture.create(sharedCanvas.width, sharedCanvas.height);
          }

          this._texture.uploadData(sharedCanvas);
        };

        _proto._registerNodeEvent = function _registerNodeEvent() {
          this.node.on(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
          this.node.on(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
        };

        _proto._unregisterNodeEvent = function _unregisterNodeEvent() {
          this.node.off(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
          this.node.off(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
        };

        _proto._updateContentLayer = function _updateContentLayer() {
          this._content.layer = this.node.layer;
        };

        _proto.update = function update(dt) {
          var calledUpdateManually = dt === undefined;

          if (calledUpdateManually) {
            this._updateSubContextTexture();

            return;
          }

          var now = performance.now();
          var deltaTime = now - this._updatedTime;

          if (deltaTime >= this._updateInterval) {
            this._updatedTime += this._updateInterval;

            this._updateSubContextTexture();
          }
        };

        _proto.onDestroy = function onDestroy() {
          this._content.destroy();

          this._texture.destroy();

          if (this._sprite) {
            this._sprite.destroy();
          }

          this._imageAsset.destroy();

          this._openDataContext = null;
        };

        _createClass(SubContextView, [{
          key: "designResolutionSize",
          get: function get() {
            return this._designResolutionSize;
          },
          set: function set(value) {
            {
              return;
            }
          }
        }, {
          key: "fps",
          get: function get() {
            return this._fps;
          },
          set: function set(value) {
            if (this._fps === value) {
              return;
            }

            this._fps = value;
            this._updateInterval = 1000 / value;
          }
        }]);

        return SubContextView;
      }(Component), _temp$1s), (_applyDecoratedDescriptor(_class2$1p.prototype, "designResolutionSize", [_dec6$W], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "designResolutionSize"), _class2$1p.prototype), _applyDecoratedDescriptor(_class2$1p.prototype, "fps", [_dec7$S], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "fps"), _class2$1p.prototype), _descriptor$1l = _applyDecoratedDescriptor(_class2$1p.prototype, "_fps", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 60;
        }
      }), _descriptor2$1b = _applyDecoratedDescriptor(_class2$1p.prototype, "_designResolutionSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(640, 960);
        }
      })), _class2$1p)) || _class$1B) || _class$1B) || _class$1B) || _class$1B) || _class$1B));
      legacyCC.SubContextView = SubContextView;

      deprecateModuleExportedName({
        ButtonComponent: {
          newName: 'Button',
          since: '1.2.0',
          removed: false
        },
        EditBoxComponent: {
          newName: 'EditBox',
          since: '1.2.0',
          removed: false
        },
        LayoutComponent: {
          newName: 'Layout',
          since: '1.2.0',
          removed: false
        },
        ProgressBarComponent: {
          newName: 'ProgressBar',
          since: '1.2.0',
          removed: false
        },
        ScrollViewComponent: {
          newName: 'ScrollView',
          since: '1.2.0',
          removed: false
        },
        ScrollBarComponent: {
          newName: 'ScrollBar',
          since: '1.2.0',
          removed: false
        },
        SliderComponent: {
          newName: 'Slider',
          since: '1.2.0',
          removed: false
        },
        ToggleComponent: {
          newName: 'Toggle',
          since: '1.2.0',
          removed: false
        },
        ToggleContainerComponent: {
          newName: 'ToggleContainer',
          since: '1.2.0',
          removed: false
        },
        WidgetComponent: {
          newName: 'Widget',
          since: '1.2.0',
          removed: false
        },
        PageViewComponent: {
          newName: 'PageView',
          since: '1.2.0',
          removed: false
        },
        PageViewIndicatorComponent: {
          newName: 'PageViewIndicator',
          since: '1.2.0',
          removed: false
        },
        SafeAreaComponent: {
          newName: 'SafeArea',
          since: '1.2.0',
          removed: false
        },
        UICoordinateTrackerComponent: {
          newName: 'UICoordinateTracker',
          since: '1.2.0',
          removed: false
        },
        BlockInputEventsComponent: {
          newName: 'BlockInputEvents',
          since: '1.2.0',
          removed: false
        }
      });

      var _dec$1B, _class$1C;
      var UIReorderComponent = exports('UIReorderComponent', (_dec$1B = ccclass('cc.UIReorderComponent'), _dec$1B(_class$1C = function UIReorderComponent() {
        warnID(1408, 'UIReorderComponent');
      }) || _class$1C));
      legacyCC.UIReorderComponent = UIReorderComponent;
      legacyCC.ButtonComponent = Button;
      js.setClassAlias(Button, 'cc.ButtonComponent');
      legacyCC.EditBoxComponent = EditBox;
      js.setClassAlias(EditBox, 'cc.EditBoxComponent');
      legacyCC.LayoutComponent = Layout;
      js.setClassAlias(Layout, 'cc.LayoutComponent');
      legacyCC.ProgressBarComponent = ProgressBar;
      js.setClassAlias(ProgressBar, 'cc.ProgressBarComponent');
      legacyCC.ScrollViewComponent = ScrollView;
      js.setClassAlias(ScrollView, 'cc.ScrollViewComponent');
      legacyCC.ScrollBarComponent = ScrollBar;
      js.setClassAlias(ScrollBar, 'cc.ScrollBarComponent');
      legacyCC.SliderComponent = Slider;
      js.setClassAlias(Slider, 'cc.SliderComponent');
      legacyCC.ToggleComponent = Toggle;
      js.setClassAlias(Toggle, 'cc.ToggleComponent');
      legacyCC.ToggleContainerComponent = ToggleContainer;
      js.setClassAlias(ToggleContainer, 'cc.ToggleContainerComponent');
      legacyCC.WidgetComponent = Widget;
      js.setClassAlias(Widget, 'cc.WidgetComponent');
      legacyCC.PageViewComponent = PageView;
      js.setClassAlias(PageView, 'cc.PageViewComponent');
      legacyCC.PageViewIndicatorComponent = PageViewIndicator;
      js.setClassAlias(PageViewIndicator, 'cc.PageViewIndicatorComponent');
      legacyCC.SafeAreaComponent = SafeArea;
      js.setClassAlias(SafeArea, 'cc.SafeAreaComponent');
      js.setClassAlias(UICoordinateTracker, 'cc.UICoordinateTrackerComponent');
      legacyCC.BlockInputEventsComponent = BlockInputEvents;
      js.setClassAlias(BlockInputEvents, 'cc.BlockInputEventsComponent');

    }
  };
});
//# sourceMappingURL=cc.js.map
